; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?g_nSizeList@@3QBHB				; g_nSizeList
CONST	SEGMENT
$SG44510 DB	'new m_nFlagArray', 00H
	ORG $+7
$SG44511 DB	'CBufPool::alloc', 00H
$SG44513 DB	'm_pChunk alloc', 00H
	ORG $+1
$SG44514 DB	'CBufPool::alloc', 00H
$SG44606 DB	'm_nFlagArray alloc', 00H
	ORG $+5
$SG44607 DB	'CSBufPool::alloc', 00H
	ORG $+7
$SG44609 DB	'm_pChunk alloc', 00H
	ORG $+1
$SG44610 DB	'CSBufPool::alloc', 00H
	ORG $+7
$SG44611 DB	'mem allock list m_nAllocCount[%d]', 00H
	ORG $+14
?g_nSizeList@@3QBHB DD 01H				; g_nSizeList
	DD	02H
	DD	04H
	DD	08H
	DD	010H
	DD	020H
	DD	040H
	DD	080H
	DD	0100H
	DD	0200H
	DD	0400H
	DD	0800H
	DD	01000H
	DD	02000H
	DD	03fdcH
	DD	08000H
	DD	010000H
	DD	020000H
	DD	040000H
	DD	080000H
	DD	0100000H
	DD	0200000H
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	sprintf
PUBLIC	??0win64_atomic@win32@common@@QEAA@XZ		; common::win32::win64_atomic::win64_atomic
PUBLIC	??1win64_atomic@win32@common@@QEAA@XZ		; common::win32::win64_atomic::~win64_atomic
PUBLIC	?getCount@win64_atomic@win32@common@@QEAAHXZ	; common::win32::win64_atomic::getCount
PUBLIC	?init@win64_atomic@win32@common@@QEAAXXZ	; common::win32::win64_atomic::init
PUBLIC	?atomic_increment@win64_atomic@win32@common@@QEAA_JXZ ; common::win32::win64_atomic::atomic_increment
PUBLIC	?atomic_decrement@win64_atomic@win32@common@@QEAA_JXZ ; common::win32::win64_atomic::atomic_decrement
PUBLIC	?atomic_compare_exchange@win64_atomic@win32@common@@QEAA_J_J0@Z ; common::win32::win64_atomic::atomic_compare_exchange
PUBLIC	??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z	; common::win32::win64_atomic::`vector deleting destructor'
PUBLIC	?isBitSet_flag@@YA_NHPEAD@Z			; isBitSet_flag
PUBLIC	?bitClear_flag@@YAXHPEAD@Z			; bitClear_flag
PUBLIC	?bitSet_flag@@YAXHPEAD@Z			; bitSet_flag
PUBLIC	?ISINCLUDE@@YA_NHH@Z				; ISINCLUDE
PUBLIC	?getSizeByIndex@@YAHH@Z				; getSizeByIndex
PUBLIC	??0CBufPool@@QEAA@XZ				; CBufPool::CBufPool
PUBLIC	??1CBufPool@@QEAA@XZ				; CBufPool::~CBufPool
PUBLIC	?clear@CBufPool@@QEAAXXZ			; CBufPool::clear
PUBLIC	?alloc@CBufPool@@QEAA_NHH@Z			; CBufPool::alloc
PUBLIC	?newMem@CBufPool@@QEAAPEADXZ			; CBufPool::newMem
PUBLIC	?delMem@CBufPool@@QEAAXPEAD@Z			; CBufPool::delMem
PUBLIC	?newMemList@CBufPool@@QEAA_NH@Z			; CBufPool::newMemList
PUBLIC	?delMem@CBufPool@@QEAAXPEADH@Z			; CBufPool::delMem
PUBLIC	?ISINCLUDE_ADDRESS@CBufPool@@QEAA_NPEAD@Z	; CBufPool::ISINCLUDE_ADDRESS
PUBLIC	??0CSBufPool@@QEAA@XZ				; CSBufPool::CSBufPool
PUBLIC	??1CSBufPool@@QEAA@XZ				; CSBufPool::~CSBufPool
PUBLIC	?clear@CSBufPool@@QEAAXXZ			; CSBufPool::clear
PUBLIC	?alloc@CSBufPool@@QEAA_NHH@Z			; CSBufPool::alloc
PUBLIC	?destroy@CSBufPool@@QEAAXXZ			; CSBufPool::destroy
PUBLIC	?newMem@CSBufPool@@QEAAPEADPEAH@Z		; CSBufPool::newMem
PUBLIC	?delMem@CSBufPool@@QEAA_NPEAD@Z			; CSBufPool::delMem
PUBLIC	?delMemByIdx@CSBufPool@@QEAA_NPEADH@Z		; CSBufPool::delMemByIdx
PUBLIC	?newMemList@CSBufPool@@QEAA_NH@Z		; CSBufPool::newMemList
PUBLIC	?delMem@CSBufPool@@QEAA_NPEADH@Z		; CSBufPool::delMem
PUBLIC	?ISINCLUDE_ADDRESS@CSBufPool@@QEAA_NPEAD@Z	; CSBufPool::ISINCLUDE_ADDRESS
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
EXTRN	??_L@YAXPEAX_K1P6AX0@Z2@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YAXPEAX_K1P6AX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	??_V@YAXPEAX_K@Z:PROC				; operator delete[]
EXTRN	memset:PROC
EXTRN	__imp___stdio_common_vsprintf:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	??_U@YAPEAX_KAEBUnothrow_t@std@@@Z:PROC		; operator new[]
EXTRN	??_V@YAXPEAXAEBUnothrow_t@std@@@Z:PROC		; operator delete[]
EXTRN	?__debugLog@CLogger@@QEAAXHPEBDH0ZZ:PROC	; CLogger::__debugLog
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__CxxFrameHandler3:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	?nothrow@std@@3Unothrow_t@1@B:BYTE		; std::nothrow
EXTRN	?g_szMessage@@3PADA:BYTE			; g_szMessage
EXTRN	?gs_cLogger@@3VCLogger@@A:BYTE			; gs_cLogger
EXTRN	__security_cookie:QWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$__local_stdio_printf_options DD imagerel $LN3
	DD	imagerel $LN3+11
	DD	imagerel $unwind$__local_stdio_printf_options
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+4
	DD	imagerel $unwind$??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+140
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+156
	DD	imagerel $unwind$sprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0win64_atomic@win32@common@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$??0win64_atomic@win32@common@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1win64_atomic@win32@common@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+8
	DD	imagerel $unwind$??1win64_atomic@win32@common@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getCount@win64_atomic@win32@common@@QEAAHXZ DD imagerel $LN3
	DD	imagerel $LN3+16
	DD	imagerel $unwind$?getCount@win64_atomic@win32@common@@QEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?init@win64_atomic@win32@common@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+20
	DD	imagerel $unwind$?init@win64_atomic@win32@common@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?atomic_increment@win64_atomic@win32@common@@QEAA_JXZ DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$?atomic_increment@win64_atomic@win32@common@@QEAA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?atomic_decrement@win64_atomic@win32@common@@QEAA_JXZ DD imagerel $LN3
	DD	imagerel $LN3+31
	DD	imagerel $unwind$?atomic_decrement@win64_atomic@win32@common@@QEAA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?atomic_compare_exchange@win64_atomic@win32@common@@QEAA_J_J0@Z DD imagerel $LN3
	DD	imagerel $LN3+78
	DD	imagerel $unwind$?atomic_compare_exchange@win64_atomic@win32@common@@QEAA_J_J0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z DD imagerel $LN6
	DD	imagerel $LN6+192
	DD	imagerel $unwind$??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isBitSet_flag@@YA_NHPEAD@Z DD imagerel $LN5
	DD	imagerel $LN5+84
	DD	imagerel $unwind$?isBitSet_flag@@YA_NHPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?bitClear_flag@@YAXHPEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+59
	DD	imagerel $unwind$?bitClear_flag@@YAXHPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?bitSet_flag@@YAXHPEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$?bitSet_flag@@YAXHPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ISINCLUDE@@YA_NHH@Z DD imagerel $LN4
	DD	imagerel $LN4+34
	DD	imagerel $unwind$?ISINCLUDE@@YA_NHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getSizeByIndex@@YAHH@Z DD imagerel $LN3
	DD	imagerel $LN3+22
	DD	imagerel $unwind$?getSizeByIndex@@YAHH@Z
pdata	ENDS
pdata	SEGMENT
$pdata$??0CBufPool@@QEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+179
	DD	imagerel $unwind$??0CBufPool@@QEAA@XZ
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0???0CBufPool@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0CBufPool@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0CBufPool@@QEAA@XZ@4HA+39
	DD	imagerel $unwind$?dtor$0@?0???0CBufPool@@QEAA@XZ@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$??1CBufPool@@QEAA@XZ DD imagerel $LN7
	DD	imagerel $LN7+195
	DD	imagerel $unwind$??1CBufPool@@QEAA@XZ
$pdata$?clear@CBufPool@@QEAAXXZ DD imagerel $LN6
	DD	imagerel $LN6+169
	DD	imagerel $unwind$?clear@CBufPool@@QEAAXXZ
$pdata$?alloc@CBufPool@@QEAA_NHH@Z DD imagerel $LN13
	DD	imagerel $LN13+727
	DD	imagerel $unwind$?alloc@CBufPool@@QEAA_NHH@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??alloc@CBufPool@@QEAA_NHH@Z@4HA DD imagerel ?dtor$0@?0??alloc@CBufPool@@QEAA_NHH@Z@4HA
	DD	imagerel ?dtor$0@?0??alloc@CBufPool@@QEAA_NHH@Z@4HA+42
	DD	imagerel $unwind$?dtor$0@?0??alloc@CBufPool@@QEAA_NHH@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?newMem@CBufPool@@QEAAPEADXZ DD imagerel $LN11
	DD	imagerel $LN11+408
	DD	imagerel $unwind$?newMem@CBufPool@@QEAAPEADXZ
$pdata$?delMem@CBufPool@@QEAAXPEAD@Z DD imagerel $LN5
	DD	imagerel $LN5+202
	DD	imagerel $unwind$?delMem@CBufPool@@QEAAXPEAD@Z
$pdata$?newMemList@CBufPool@@QEAA_NH@Z DD imagerel $LN17
	DD	imagerel $LN17+400
	DD	imagerel $unwind$?newMemList@CBufPool@@QEAA_NH@Z
$pdata$?delMem@CBufPool@@QEAAXPEADH@Z DD imagerel $LN9
	DD	imagerel $LN9+272
	DD	imagerel $unwind$?delMem@CBufPool@@QEAAXPEADH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ISINCLUDE_ADDRESS@CBufPool@@QEAA_NPEAD@Z DD imagerel $LN4
	DD	imagerel $LN4+51
	DD	imagerel $unwind$?ISINCLUDE_ADDRESS@CBufPool@@QEAA_NPEAD@Z
pdata	ENDS
pdata	SEGMENT
$pdata$??0CSBufPool@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+135
	DD	imagerel $unwind$??0CSBufPool@@QEAA@XZ
$pdata$??1CSBufPool@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$??1CSBufPool@@QEAA@XZ
$pdata$?clear@CSBufPool@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+132
	DD	imagerel $unwind$?clear@CSBufPool@@QEAAXXZ
$pdata$?alloc@CSBufPool@@QEAA_NHH@Z DD imagerel $LN5
	DD	imagerel $LN5+371
	DD	imagerel $unwind$?alloc@CSBufPool@@QEAA_NHH@Z
$pdata$?destroy@CSBufPool@@QEAAXXZ DD imagerel $LN5
	DD	imagerel $LN5+116
	DD	imagerel $unwind$?destroy@CSBufPool@@QEAAXXZ
$pdata$?newMem@CSBufPool@@QEAAPEADPEAH@Z DD imagerel $LN12
	DD	imagerel $LN12+379
	DD	imagerel $unwind$?newMem@CSBufPool@@QEAAPEADPEAH@Z
$pdata$?delMem@CSBufPool@@QEAA_NPEAD@Z DD imagerel $LN5
	DD	imagerel $LN5+184
	DD	imagerel $unwind$?delMem@CSBufPool@@QEAA_NPEAD@Z
$pdata$?delMemByIdx@CSBufPool@@QEAA_NPEADH@Z DD imagerel $LN5
	DD	imagerel $LN5+166
	DD	imagerel $unwind$?delMemByIdx@CSBufPool@@QEAA_NPEADH@Z
$pdata$?newMemList@CSBufPool@@QEAA_NH@Z DD imagerel $LN15
	DD	imagerel $LN15+292
	DD	imagerel $unwind$?newMemList@CSBufPool@@QEAA_NH@Z
$pdata$?delMem@CSBufPool@@QEAA_NPEADH@Z DD imagerel $LN9
	DD	imagerel $LN9+243
	DD	imagerel $unwind$?delMem@CSBufPool@@QEAA_NPEADH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ISINCLUDE_ADDRESS@CSBufPool@@QEAA_NPEAD@Z DD imagerel $LN4
	DD	imagerel $LN4+51
	DD	imagerel $unwind$?ISINCLUDE_ADDRESS@CSBufPool@@QEAA_NPEAD@Z
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ISINCLUDE_ADDRESS@CSBufPool@@QEAA_NPEAD@Z DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ISINCLUDE_ADDRESS@CBufPool@@QEAA_NPEAD@Z DD 010b01H
	DD	0700bH
xdata	ENDS
CONST	SEGMENT
$cppxdata$??0CBufPool@@QEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0CBufPool@@QEAA@XZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??0CBufPool@@QEAA@XZ
	DD	020H
	DD	00H
	DD	01H
$cppxdata$?alloc@CBufPool@@QEAA_NHH@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?alloc@CBufPool@@QEAA_NHH@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?alloc@CBufPool@@QEAA_NHH@Z
	DD	058H
	DD	00H
	DD	01H
$cppxdata$??1CSBufPool@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1CSBufPool@@QEAA@XZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
xdata	SEGMENT
$unwind$??0CBufPool@@QEAA@XZ DD 022711H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0CBufPool@@QEAA@XZ
$stateUnwindMap$??0CBufPool@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0CBufPool@@QEAA@XZ@4HA
$ip2state$??0CBufPool@@QEAA@XZ DD imagerel ??0CBufPool@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??0CBufPool@@QEAA@XZ+57
	DD	00H
	DD	imagerel ??0CBufPool@@QEAA@XZ+168
	DD	0ffffffffH
$unwind$?dtor$0@?0???0CBufPool@@QEAA@XZ@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
$unwind$??1CBufPool@@QEAA@XZ DD 021e01H
	DD	07006720aH
$unwind$?clear@CBufPool@@QEAAXXZ DD 021e01H
	DD	07006520aH
$unwind$?alloc@CBufPool@@QEAA_NHH@Z DD 023311H
	DD	0700fd213H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?alloc@CBufPool@@QEAA_NHH@Z
$stateUnwindMap$?alloc@CBufPool@@QEAA_NHH@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??alloc@CBufPool@@QEAA_NHH@Z@4HA
$ip2state$?alloc@CBufPool@@QEAA_NHH@Z DD imagerel ?alloc@CBufPool@@QEAA_NHH@Z
	DD	0ffffffffH
	DD	imagerel ?alloc@CBufPool@@QEAA_NHH@Z+120
	DD	00H
	DD	imagerel ?alloc@CBufPool@@QEAA_NHH@Z+222
	DD	0ffffffffH
$unwind$?dtor$0@?0??alloc@CBufPool@@QEAA_NHH@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
$unwind$?newMem@CBufPool@@QEAAPEADXZ DD 021e01H
	DD	07006520aH
$unwind$?delMem@CBufPool@@QEAAXPEAD@Z DD 022301H
	DD	0700b520fH
$unwind$?newMemList@CBufPool@@QEAA_NH@Z DD 022201H
	DD	0700a520eH
$unwind$?delMem@CBufPool@@QEAAXPEADH@Z DD 022801H
	DD	070105214H
$unwind$??0CSBufPool@@QEAA@XZ DD 021e01H
	DD	07006320aH
$unwind$??1CSBufPool@@QEAA@XZ DD 022719H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1CSBufPool@@QEAA@XZ
$ip2state$??1CSBufPool@@QEAA@XZ DD imagerel ??1CSBufPool@@QEAA@XZ
	DD	0ffffffffH
$unwind$?clear@CSBufPool@@QEAAXXZ DD 021e01H
	DD	07006320aH
$unwind$?alloc@CSBufPool@@QEAA_NHH@Z DD 022701H
	DD	0700f7213H
$unwind$?destroy@CSBufPool@@QEAAXXZ DD 021e01H
	DD	07006320aH
$unwind$?newMem@CSBufPool@@QEAAPEADPEAH@Z DD 022301H
	DD	0700b520fH
$unwind$?delMem@CSBufPool@@QEAA_NPEAD@Z DD 022301H
	DD	0700b520fH
$unwind$?delMemByIdx@CSBufPool@@QEAA_NPEADH@Z DD 022801H
	DD	070103214H
$unwind$?newMemList@CSBufPool@@QEAA_NH@Z DD 022201H
	DD	0700a520eH
$unwind$?delMem@CSBufPool@@QEAA_NPEADH@Z DD 022801H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getSizeByIndex@@YAHH@Z DD 010501H
	DD	07005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ISINCLUDE@@YA_NHH@Z DD 010901H
	DD	07009H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?bitSet_flag@@YAXHPEAD@Z DD 010a01H
	DD	0700aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?bitClear_flag@@YAXHPEAD@Z DD 010a01H
	DD	0700aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isBitSet_flag@@YA_NHPEAD@Z DD 022101H
	DD	0700a120eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z DD imagerel ??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z DD 022b19H
	DD	0700a520eH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?atomic_compare_exchange@win64_atomic@win32@common@@QEAA_J_J0@Z DD 022801H
	DD	070101214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?atomic_decrement@win64_atomic@win32@common@@QEAA_JXZ DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?atomic_increment@win64_atomic@win32@common@@QEAA_JXZ DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?init@win64_atomic@win32@common@@QEAAXXZ DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getCount@win64_atomic@win32@common@@QEAAHXZ DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1win64_atomic@win32@common@@QEAA@XZ DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0win64_atomic@win32@common@@QEAA@XZ DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 023c19H
	DD	07015b219H
	DD	imagerel __GSHandlerCheck
	DD	050H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
sprintf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
sprintf$rtcVarDesc DD 038H
	DD	08H
	DQ	FLAT:sprintf$rtcName$0
	ORG $+48
sprintf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:sprintf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 022d01H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 022d01H
	DD	070157219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ DD 010201H
	DD	07002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$__local_stdio_printf_options DD 010201H
	DD	07002H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\combufpool.h
;	COMDAT ?ISINCLUDE_ADDRESS@CSBufPool@@QEAA_NPEAD@Z
_TEXT	SEGMENT
this$ = 16
p$ = 24
?ISINCLUDE_ADDRESS@CSBufPool@@QEAA_NPEAD@Z PROC		; CSBufPool::ISINCLUDE_ADDRESS, COMDAT

; 131  : 	inline bool ISINCLUDE_ADDRESS(char *p) { if (m_pChunk <= p && p <= m_pEnd) return true; return false; }

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  00010	48 8b 4c 24 18	 mov	 rcx, QWORD PTR p$[rsp]
  00015	48 39 48 18	 cmp	 QWORD PTR [rax+24], rcx
  00019	77 14		 ja	 SHORT $LN2@ISINCLUDE_
  0001b	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  00020	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00024	48 39 44 24 18	 cmp	 QWORD PTR p$[rsp], rax
  00029	77 04		 ja	 SHORT $LN2@ISINCLUDE_
  0002b	b0 01		 mov	 al, 1
  0002d	eb 02		 jmp	 SHORT $LN1@ISINCLUDE_
$LN2@ISINCLUDE_:
  0002f	32 c0		 xor	 al, al
$LN1@ISINCLUDE_:
  00031	5f		 pop	 rdi
  00032	c3		 ret	 0
?ISINCLUDE_ADDRESS@CSBufPool@@QEAA_NPEAD@Z ENDP		; CSBufPool::ISINCLUDE_ADDRESS
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\combufpool.cpp
_TEXT	SEGMENT
nPos$ = 32
nIdx$ = 36
i$ = 40
this$ = 64
pUsedMem$ = 72
nCount$ = 80
?delMem@CSBufPool@@QEAA_NPEADH@Z PROC			; CSBufPool::delMem

; 365  : {

$LN9:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 0c 00 00 00	 mov	 ecx, 12
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 366  : 	int nPos = (int)(pUsedMem - m_pChunk);

  00028	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0002d	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00031	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pUsedMem$[rsp]
  00036	48 2b c8	 sub	 rcx, rax
  00039	48 8b c1	 mov	 rax, rcx
  0003c	89 44 24 20	 mov	 DWORD PTR nPos$[rsp], eax

; 367  : 	int nIdx = nPos >> m_nShift;

  00040	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00045	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00048	0f b6 c8	 movzx	 ecx, al
  0004b	8b 44 24 20	 mov	 eax, DWORD PTR nPos$[rsp]
  0004f	d3 f8		 sar	 eax, cl
  00051	89 44 24 24	 mov	 DWORD PTR nIdx$[rsp], eax

; 368  : 	int i;
; 369  : 
; 370  : 	if (pUsedMem != &m_pChunk[nPos]) return false;

  00055	48 63 44 24 20	 movsxd	 rax, DWORD PTR nPos$[rsp]
  0005a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0005f	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00063	48 03 c8	 add	 rcx, rax
  00066	48 8b c1	 mov	 rax, rcx
  00069	48 39 44 24 48	 cmp	 QWORD PTR pUsedMem$[rsp], rax
  0006e	74 04		 je	 SHORT $LN5@delMem
  00070	32 c0		 xor	 al, al
  00072	eb 79		 jmp	 SHORT $LN1@delMem
$LN5@delMem:

; 371  : 	for (i = 0; i < nCount; i++)

  00074	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0007c	eb 0a		 jmp	 SHORT $LN4@delMem
$LN2@delMem:
  0007e	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00082	ff c0		 inc	 eax
  00084	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN4@delMem:
  00088	8b 44 24 50	 mov	 eax, DWORD PTR nCount$[rsp]
  0008c	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  00090	7d 59		 jge	 SHORT $LN3@delMem

; 372  : 	{
; 373  : 		if (nIdx >= m_nAllocCount) return false;

  00092	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00097	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0009a	39 44 24 24	 cmp	 DWORD PTR nIdx$[rsp], eax
  0009e	7c 04		 jl	 SHORT $LN6@delMem
  000a0	32 c0		 xor	 al, al
  000a2	eb 49		 jmp	 SHORT $LN1@delMem
$LN6@delMem:

; 374  : 		//printf("CBufPool::delMem nPos[%d] nIdx[%d] nShift[%d] pMem[%p]\n", nPos, nIdx, nShift, pUsedMem);
; 375  : 		if (isBitSet_flag(nIdx, m_nFlagArray))

  000a4	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000a9	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  000ad	8b 4c 24 24	 mov	 ecx, DWORD PTR nIdx$[rsp]
  000b1	e8 00 00 00 00	 call	 ?isBitSet_flag@@YA_NHPEAD@Z ; isBitSet_flag
  000b6	0f b6 c0	 movzx	 eax, al
  000b9	85 c0		 test	 eax, eax
  000bb	74 22		 je	 SHORT $LN7@delMem

; 376  : 		{
; 377  : 			bitClear_flag(nIdx, m_nFlagArray);

  000bd	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000c2	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  000c6	8b 4c 24 24	 mov	 ecx, DWORD PTR nIdx$[rsp]
  000ca	e8 00 00 00 00	 call	 ?bitClear_flag@@YAXHPEAD@Z ; bitClear_flag

; 378  : 			m_nUseCnt--;

  000cf	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000d4	8b 00		 mov	 eax, DWORD PTR [rax]
  000d6	ff c8		 dec	 eax
  000d8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000dd	89 01		 mov	 DWORD PTR [rcx], eax
$LN7@delMem:

; 379  : 		}
; 380  : 		nIdx++;

  000df	8b 44 24 24	 mov	 eax, DWORD PTR nIdx$[rsp]
  000e3	ff c0		 inc	 eax
  000e5	89 44 24 24	 mov	 DWORD PTR nIdx$[rsp], eax

; 381  : 	}

  000e9	eb 93		 jmp	 SHORT $LN2@delMem
$LN3@delMem:

; 382  : 	return true;

  000eb	b0 01		 mov	 al, 1
$LN1@delMem:

; 383  : }

  000ed	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f1	5f		 pop	 rdi
  000f2	c3		 ret	 0
?delMem@CSBufPool@@QEAA_NPEADH@Z ENDP			; CSBufPool::delMem
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\combufpool.cpp
_TEXT	SEGMENT
i$ = 32
idx$ = 36
nLastLoopCnt$ = 40
this$ = 64
nCount$ = 72
?newMemList@CSBufPool@@QEAA_NH@Z PROC			; CSBufPool::newMemList

; 333  : {

$LN15:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 0c 00 00 00	 mov	 ecx, 12
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 334  : 	int i;
; 335  : 	int idx = m_nUseCnt, nLastLoopCnt=0;

  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00027	8b 00		 mov	 eax, DWORD PTR [rax]
  00029	89 44 24 24	 mov	 DWORD PTR idx$[rsp], eax
  0002d	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR nLastLoopCnt$[rsp], 0

; 336  : 
; 337  : 	if (m_nUseCnt == m_nAllocCount) return false;

  00035	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0003f	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  00042	39 08		 cmp	 DWORD PTR [rax], ecx
  00044	75 07		 jne	 SHORT $LN8@newMemList
  00046	32 c0		 xor	 al, al
  00048	e9 d1 00 00 00	 jmp	 $LN1@newMemList
$LN8@newMemList:

; 338  : 
; 339  : 	for (i = 0; i < nCount; i++) {

  0004d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00055	eb 0a		 jmp	 SHORT $LN4@newMemList
$LN2@newMemList:
  00057	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0005b	ff c0		 inc	 eax
  0005d	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@newMemList:
  00061	8b 44 24 48	 mov	 eax, DWORD PTR nCount$[rsp]
  00065	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00069	7d 43		 jge	 SHORT $LN3@newMemList

; 340  : 		if (idx >= m_nAllocCount) break;

  0006b	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00070	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00073	39 44 24 24	 cmp	 DWORD PTR idx$[rsp], eax
  00077	7c 02		 jl	 SHORT $LN9@newMemList
  00079	eb 33		 jmp	 SHORT $LN3@newMemList
$LN9@newMemList:

; 341  : 		if (!isBitSet_flag(idx, m_nFlagArray))

  0007b	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00080	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00084	8b 4c 24 24	 mov	 ecx, DWORD PTR idx$[rsp]
  00088	e8 00 00 00 00	 call	 ?isBitSet_flag@@YA_NHPEAD@Z ; isBitSet_flag
  0008d	0f b6 c0	 movzx	 eax, al
  00090	85 c0		 test	 eax, eax
  00092	75 0c		 jne	 SHORT $LN10@newMemList

; 342  : 		{
; 343  : 			nLastLoopCnt++;

  00094	8b 44 24 28	 mov	 eax, DWORD PTR nLastLoopCnt$[rsp]
  00098	ff c0		 inc	 eax
  0009a	89 44 24 28	 mov	 DWORD PTR nLastLoopCnt$[rsp], eax

; 344  : 		}
; 345  : 		else break;

  0009e	eb 02		 jmp	 SHORT $LN11@newMemList
$LN10@newMemList:
  000a0	eb 0c		 jmp	 SHORT $LN3@newMemList
$LN11@newMemList:

; 346  : 		idx++;

  000a2	8b 44 24 24	 mov	 eax, DWORD PTR idx$[rsp]
  000a6	ff c0		 inc	 eax
  000a8	89 44 24 24	 mov	 DWORD PTR idx$[rsp], eax

; 347  : 	}

  000ac	eb a9		 jmp	 SHORT $LN2@newMemList
$LN3@newMemList:

; 348  : 
; 349  : 	if (nLastLoopCnt == nCount) {

  000ae	8b 44 24 48	 mov	 eax, DWORD PTR nCount$[rsp]
  000b2	39 44 24 28	 cmp	 DWORD PTR nLastLoopCnt$[rsp], eax
  000b6	75 16		 jne	 SHORT $LN12@newMemList

; 350  : 		m_nUseCnt += nCount;

  000b8	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000bd	8b 00		 mov	 eax, DWORD PTR [rax]
  000bf	03 44 24 48	 add	 eax, DWORD PTR nCount$[rsp]
  000c3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000c8	89 01		 mov	 DWORD PTR [rcx], eax

; 351  : 		return true;

  000ca	b0 01		 mov	 al, 1
  000cc	eb 50		 jmp	 SHORT $LN1@newMemList
$LN12@newMemList:

; 352  : 	}
; 353  : 
; 354  : 	for (idx = m_nUseCnt; idx < nLastLoopCnt; idx++) {

  000ce	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000d3	8b 00		 mov	 eax, DWORD PTR [rax]
  000d5	89 44 24 24	 mov	 DWORD PTR idx$[rsp], eax
  000d9	eb 0a		 jmp	 SHORT $LN7@newMemList
$LN5@newMemList:
  000db	8b 44 24 24	 mov	 eax, DWORD PTR idx$[rsp]
  000df	ff c0		 inc	 eax
  000e1	89 44 24 24	 mov	 DWORD PTR idx$[rsp], eax
$LN7@newMemList:
  000e5	8b 44 24 28	 mov	 eax, DWORD PTR nLastLoopCnt$[rsp]
  000e9	39 44 24 24	 cmp	 DWORD PTR idx$[rsp], eax
  000ed	7d 2d		 jge	 SHORT $LN6@newMemList

; 355  : 		if (isBitSet_flag(idx, m_nFlagArray))

  000ef	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000f4	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  000f8	8b 4c 24 24	 mov	 ecx, DWORD PTR idx$[rsp]
  000fc	e8 00 00 00 00	 call	 ?isBitSet_flag@@YA_NHPEAD@Z ; isBitSet_flag
  00101	0f b6 c0	 movzx	 eax, al
  00104	85 c0		 test	 eax, eax
  00106	74 12		 je	 SHORT $LN13@newMemList

; 356  : 		{
; 357  : 			bitClear_flag(idx, m_nFlagArray);

  00108	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0010d	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00111	8b 4c 24 24	 mov	 ecx, DWORD PTR idx$[rsp]
  00115	e8 00 00 00 00	 call	 ?bitClear_flag@@YAXHPEAD@Z ; bitClear_flag
$LN13@newMemList:

; 358  : 		}
; 359  : 	}

  0011a	eb bf		 jmp	 SHORT $LN5@newMemList
$LN6@newMemList:

; 360  : 	return false;

  0011c	32 c0		 xor	 al, al
$LN1@newMemList:

; 361  : }

  0011e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00122	5f		 pop	 rdi
  00123	c3		 ret	 0
?newMemList@CSBufPool@@QEAA_NH@Z ENDP			; CSBufPool::newMemList
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\combufpool.cpp
_TEXT	SEGMENT
this$ = 48
pUsedMem$ = 56
nIdx$ = 64
?delMemByIdx@CSBufPool@@QEAA_NPEADH@Z PROC		; CSBufPool::delMemByIdx

; 316  : {

$LN5:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 08 00 00 00	 mov	 ecx, 8
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 317  : 	if (!ISINCLUDE(nIdx, m_nAllocCount)) {

  00028	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0002d	8b 50 04	 mov	 edx, DWORD PTR [rax+4]
  00030	8b 4c 24 40	 mov	 ecx, DWORD PTR nIdx$[rsp]
  00034	e8 00 00 00 00	 call	 ?ISINCLUDE@@YA_NHH@Z	; ISINCLUDE
  00039	0f b6 c0	 movzx	 eax, al
  0003c	85 c0		 test	 eax, eax
  0003e	75 0f		 jne	 SHORT $LN2@delMemById

; 318  : 		free(pUsedMem);

  00040	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pUsedMem$[rsp]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 319  : 		return false;

  0004b	32 c0		 xor	 al, al
  0004d	eb 51		 jmp	 SHORT $LN1@delMemById
$LN2@delMemById:

; 320  : 	}
; 321  : 
; 322  : 	if (pUsedMem == &m_pChunk[nIdx << m_nShift]) {

  0004f	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00054	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00057	0f b6 c8	 movzx	 ecx, al
  0005a	8b 44 24 40	 mov	 eax, DWORD PTR nIdx$[rsp]
  0005e	d3 e0		 shl	 eax, cl
  00060	48 98		 cdqe
  00062	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00067	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0006b	48 03 c8	 add	 rcx, rax
  0006e	48 8b c1	 mov	 rax, rcx
  00071	48 39 44 24 38	 cmp	 QWORD PTR pUsedMem$[rsp], rax
  00076	75 26		 jne	 SHORT $LN3@delMemById

; 323  : 		bitClear_flag(nIdx, m_nFlagArray);

  00078	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0007d	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00081	8b 4c 24 40	 mov	 ecx, DWORD PTR nIdx$[rsp]
  00085	e8 00 00 00 00	 call	 ?bitClear_flag@@YAXHPEAD@Z ; bitClear_flag

; 324  : 		m_nUseCnt--;

  0008a	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0008f	8b 00		 mov	 eax, DWORD PTR [rax]
  00091	ff c8		 dec	 eax
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00098	89 01		 mov	 DWORD PTR [rcx], eax

; 325  : 		return true;

  0009a	b0 01		 mov	 al, 1
  0009c	eb 02		 jmp	 SHORT $LN1@delMemById
$LN3@delMemById:

; 326  : 	}
; 327  : 	return false;

  0009e	32 c0		 xor	 al, al
$LN1@delMemById:

; 328  : }

  000a0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a4	5f		 pop	 rdi
  000a5	c3		 ret	 0
?delMemByIdx@CSBufPool@@QEAA_NPEADH@Z ENDP		; CSBufPool::delMemByIdx
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\combufpool.cpp
_TEXT	SEGMENT
nPos$ = 32
this$ = 64
pUsedMem$ = 72
?delMem@CSBufPool@@QEAA_NPEAD@Z PROC			; CSBufPool::delMem

; 299  : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 0c 00 00 00	 mov	 ecx, 12
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 300  : 	if (!ISINCLUDE_ADDRESS(pUsedMem)) {

  00023	48 8b 54 24 48	 mov	 rdx, QWORD PTR pUsedMem$[rsp]
  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0002d	e8 00 00 00 00	 call	 ?ISINCLUDE_ADDRESS@CSBufPool@@QEAA_NPEAD@Z ; CSBufPool::ISINCLUDE_ADDRESS
  00032	0f b6 c0	 movzx	 eax, al
  00035	85 c0		 test	 eax, eax
  00037	75 0f		 jne	 SHORT $LN2@delMem

; 301  : 		free(pUsedMem);

  00039	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pUsedMem$[rsp]
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 302  : 		return false;

  00044	32 c0		 xor	 al, al
  00046	eb 6a		 jmp	 SHORT $LN1@delMem
$LN2@delMem:

; 303  : 	}
; 304  : 	int nPos = (int)(pUsedMem - m_pChunk);

  00048	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0004d	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00051	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pUsedMem$[rsp]
  00056	48 2b c8	 sub	 rcx, rax
  00059	48 8b c1	 mov	 rax, rcx
  0005c	89 44 24 20	 mov	 DWORD PTR nPos$[rsp], eax

; 305  : 
; 306  : 	if (pUsedMem == &m_pChunk[nPos]) {

  00060	48 63 44 24 20	 movsxd	 rax, DWORD PTR nPos$[rsp]
  00065	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0006a	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0006e	48 03 c8	 add	 rcx, rax
  00071	48 8b c1	 mov	 rax, rcx
  00074	48 39 44 24 48	 cmp	 QWORD PTR pUsedMem$[rsp], rax
  00079	75 35		 jne	 SHORT $LN3@delMem

; 307  : 		bitClear_flag(nPos >> m_nShift, m_nFlagArray);

  0007b	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00080	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00083	0f b6 c8	 movzx	 ecx, al
  00086	8b 44 24 20	 mov	 eax, DWORD PTR nPos$[rsp]
  0008a	d3 f8		 sar	 eax, cl
  0008c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00091	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  00095	8b c8		 mov	 ecx, eax
  00097	e8 00 00 00 00	 call	 ?bitClear_flag@@YAXHPEAD@Z ; bitClear_flag

; 308  : 		m_nUseCnt--;

  0009c	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000a1	8b 00		 mov	 eax, DWORD PTR [rax]
  000a3	ff c8		 dec	 eax
  000a5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000aa	89 01		 mov	 DWORD PTR [rcx], eax

; 309  : 		return true;

  000ac	b0 01		 mov	 al, 1
  000ae	eb 02		 jmp	 SHORT $LN1@delMem
$LN3@delMem:

; 310  : 	}
; 311  : 	return false;

  000b0	32 c0		 xor	 al, al
$LN1@delMem:

; 312  : }

  000b2	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b6	5f		 pop	 rdi
  000b7	c3		 ret	 0
?delMem@CSBufPool@@QEAA_NPEAD@Z ENDP			; CSBufPool::delMem
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\combufpool.cpp
_TEXT	SEGMENT
i$ = 32
j$ = 36
this$ = 64
pKey$ = 72
?newMem@CSBufPool@@QEAAPEADPEAH@Z PROC			; CSBufPool::newMem

; 271  : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 0c 00 00 00	 mov	 ecx, 12
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 272  : 	int i = m_nUseCnt, j;

  00023	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00028	8b 00		 mov	 eax, DWORD PTR [rax]
  0002a	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax

; 273  : 
; 274  : 	if (m_nUseCnt == m_nAllocCount) goto NEW_ALLOC;

  0002e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00033	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00038	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  0003b	39 08		 cmp	 DWORD PTR [rax], ecx
  0003d	75 0a		 jne	 SHORT $LN5@newMem
  0003f	e9 fc 00 00 00	 jmp	 $LN6@newMem
  00044	e9 f7 00 00 00	 jmp	 $NEW_ALLOC$13
$LN5@newMem:

; 275  : 
; 276  : 	for (j = 0; j < m_nAllocCount; j++) {

  00049	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00051	eb 0a		 jmp	 SHORT $LN4@newMem
$LN2@newMem:
  00053	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  00057	ff c0		 inc	 eax
  00059	89 44 24 24	 mov	 DWORD PTR j$[rsp], eax
$LN4@newMem:
  0005d	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00062	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00065	39 44 24 24	 cmp	 DWORD PTR j$[rsp], eax
  00069	0f 8d d1 00 00
	00		 jge	 $LN3@newMem

; 277  : 		if (i >= m_nAllocCount) { i = 0; }

  0006f	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00074	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00077	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0007b	7c 08		 jl	 SHORT $LN7@newMem
  0007d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
$LN7@newMem:

; 278  : 		if (!isBitSet_flag(i, m_nFlagArray)) {

  00085	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0008a	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0008e	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  00092	e8 00 00 00 00	 call	 ?isBitSet_flag@@YA_NHPEAD@Z ; isBitSet_flag
  00097	0f b6 c0	 movzx	 eax, al
  0009a	85 c0		 test	 eax, eax
  0009c	0f 85 99 00 00
	00		 jne	 $LN8@newMem

; 279  : 			if (pKey) {

  000a2	48 83 7c 24 48
	00		 cmp	 QWORD PTR pKey$[rsp], 0
  000a8	74 0b		 je	 SHORT $LN9@newMem

; 280  : 				*pKey = i;

  000aa	48 8b 44 24 48	 mov	 rax, QWORD PTR pKey$[rsp]
  000af	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  000b3	89 08		 mov	 DWORD PTR [rax], ecx
$LN9@newMem:

; 281  : 			}
; 282  : 			m_nUseCnt++;

  000b5	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000ba	8b 00		 mov	 eax, DWORD PTR [rax]
  000bc	ff c0		 inc	 eax
  000be	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000c3	89 01		 mov	 DWORD PTR [rcx], eax

; 283  : 			bitSet_flag(i, m_nFlagArray);

  000c5	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000ca	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  000ce	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  000d2	e8 00 00 00 00	 call	 ?bitSet_flag@@YAXHPEAD@Z ; bitSet_flag

; 284  : 			memset(&m_pChunk[i<<m_nShift], 0, g_nSizeList[m_nShift]);

  000d7	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000dc	48 63 40 10	 movsxd	 rax, DWORD PTR [rax+16]
  000e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_nSizeList@@3QBHB ; g_nSizeList
  000e7	48 63 04 81	 movsxd	 rax, DWORD PTR [rcx+rax*4]
  000eb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000f0	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  000f3	8b 54 24 20	 mov	 edx, DWORD PTR i$[rsp]
  000f7	d3 e2		 shl	 edx, cl
  000f9	8b ca		 mov	 ecx, edx
  000fb	48 63 c9	 movsxd	 rcx, ecx
  000fe	48 8b 54 24 40	 mov	 rdx, QWORD PTR this$[rsp]
  00103	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  00107	48 03 d1	 add	 rdx, rcx
  0010a	48 8b ca	 mov	 rcx, rdx
  0010d	4c 8b c0	 mov	 r8, rax
  00110	33 d2		 xor	 edx, edx
  00112	e8 00 00 00 00	 call	 memset

; 285  : 			return &m_pChunk[i << m_nShift];

  00117	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0011c	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0011f	0f b6 c8	 movzx	 ecx, al
  00122	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00126	d3 e0		 shl	 eax, cl
  00128	48 98		 cdqe
  0012a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0012f	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00133	48 03 c8	 add	 rcx, rax
  00136	48 8b c1	 mov	 rax, rcx
  00139	eb 3a		 jmp	 SHORT $LN1@newMem
$LN8@newMem:

; 286  : 		}
; 287  : 	}

  0013b	e9 13 ff ff ff	 jmp	 $LN2@newMem
$LN3@newMem:
$LN6@newMem:
$NEW_ALLOC$13:

; 288  : 
; 289  : NEW_ALLOC:
; 290  : 	if (pKey) {

  00140	48 83 7c 24 48
	00		 cmp	 QWORD PTR pKey$[rsp], 0
  00146	74 0b		 je	 SHORT $LN10@newMem

; 291  : 		*pKey = -1;

  00148	48 8b 44 24 48	 mov	 rax, QWORD PTR pKey$[rsp]
  0014d	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [rax], -1
$LN10@newMem:

; 292  : 	}
; 293  : 	return (char *)calloc(1, g_nSizeList[m_nShift]);

  00153	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00158	48 63 40 10	 movsxd	 rax, DWORD PTR [rax+16]
  0015c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_nSizeList@@3QBHB ; g_nSizeList
  00163	48 63 04 81	 movsxd	 rax, DWORD PTR [rcx+rax*4]
  00167	48 8b d0	 mov	 rdx, rax
  0016a	b9 01 00 00 00	 mov	 ecx, 1
  0016f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
$LN1@newMem:

; 294  : }

  00175	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00179	5f		 pop	 rdi
  0017a	c3		 ret	 0
?newMem@CSBufPool@@QEAAPEADPEAH@Z ENDP			; CSBufPool::newMem
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\combufpool.cpp
_TEXT	SEGMENT
this$ = 48
?destroy@CSBufPool@@QEAAXXZ PROC			; CSBufPool::destroy

; 217  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 218  : 	if (m_pChunk) {

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00023	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00028	74 1c		 je	 SHORT $LN2@destroy

; 219  : 		free(m_pChunk);

  0002a	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0002f	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 220  : 		m_pChunk = NULL;

  00039	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0003e	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0
$LN2@destroy:

; 221  : 	}
; 222  : 
; 223  : 	if (m_nFlagArray) {

  00046	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0004b	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00050	74 1c		 je	 SHORT $LN3@destroy

; 224  : 		free(m_nFlagArray);

  00052	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00057	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 225  : 		m_nFlagArray = NULL;

  00061	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00066	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
$LN3@destroy:

; 226  : 	}
; 227  : }

  0006e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00072	5f		 pop	 rdi
  00073	c3		 ret	 0
?destroy@CSBufPool@@QEAAXXZ ENDP			; CSBufPool::destroy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\combufpool.cpp
_TEXT	SEGMENT
nFCount$ = 48
this$ = 80
nShift$ = 88
nMaxCount$ = 96
?alloc@CSBufPool@@QEAA_NHH@Z PROC			; CSBufPool::alloc

; 232  : {

$LN5:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 10 00 00 00	 mov	 ecx, 16
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 233  : 	int nFCount = (nMaxCount >> 3) + 1;

  00027	8b 44 24 60	 mov	 eax, DWORD PTR nMaxCount$[rsp]
  0002b	c1 f8 03	 sar	 eax, 3
  0002e	ff c0		 inc	 eax
  00030	89 44 24 30	 mov	 DWORD PTR nFCount$[rsp], eax

; 234  : 	m_nFlagArray = (char *)calloc(nFCount, sizeof(char));

  00034	48 63 44 24 30	 movsxd	 rax, DWORD PTR nFCount$[rsp]
  00039	ba 01 00 00 00	 mov	 edx, 1
  0003e	48 8b c8	 mov	 rcx, rax
  00041	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00047	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  0004c	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 235  : 
; 236  : 	if (m_nFlagArray == NULL) {

  00050	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00055	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0005a	75 31		 jne	 SHORT $LN2@alloc

; 237  : 		gs_cLogger.DebugLog(LEVEL_ERROR, "m_nFlagArray alloc");

  0005c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG44606
  00063	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00068	41 b9 ed 00 00
	00		 mov	 r9d, 237		; 000000edH
  0006e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG44607
  00075	ba 05 00 00 00	 mov	 edx, 5
  0007a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  00081	e8 00 00 00 00	 call	 ?__debugLog@CLogger@@QEAAXHPEBDH0ZZ ; CLogger::__debugLog

; 238  : 		return false;

  00086	32 c0		 xor	 al, al
  00088	e9 e0 00 00 00	 jmp	 $LN1@alloc
$LN2@alloc:

; 239  : 	} 
; 240  : 	m_nShift = nShift;

  0008d	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00092	8b 4c 24 58	 mov	 ecx, DWORD PTR nShift$[rsp]
  00096	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 241  : 	m_pChunk = (char *)calloc(nMaxCount, getSizeByIndex(m_nShift));

  00099	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0009e	8b 48 10	 mov	 ecx, DWORD PTR [rax+16]
  000a1	e8 00 00 00 00	 call	 ?getSizeByIndex@@YAHH@Z	; getSizeByIndex
  000a6	48 98		 cdqe
  000a8	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR nMaxCount$[rsp]
  000ad	48 8b d0	 mov	 rdx, rax
  000b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  000b6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  000bb	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 242  : 
; 243  : 	if (m_pChunk == NULL) {

  000bf	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  000c4	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  000c9	75 4a		 jne	 SHORT $LN3@alloc

; 244  : 		free(m_pChunk);

  000cb	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  000d0	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  000d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 245  : 		m_pChunk = NULL;

  000da	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  000df	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 246  : 		gs_cLogger.DebugLog(LEVEL_ERROR, "m_pChunk alloc");

  000e7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG44609
  000ee	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000f3	41 b9 f6 00 00
	00		 mov	 r9d, 246		; 000000f6H
  000f9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG44610
  00100	ba 05 00 00 00	 mov	 edx, 5
  00105	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  0010c	e8 00 00 00 00	 call	 ?__debugLog@CLogger@@QEAAXHPEBDH0ZZ ; CLogger::__debugLog

; 247  : 		return false;

  00111	32 c0		 xor	 al, al
  00113	eb 58		 jmp	 SHORT $LN1@alloc
$LN3@alloc:

; 248  : 	}
; 249  : 
; 250  : 	m_nAllocCount = nMaxCount;

  00115	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0011a	8b 4c 24 60	 mov	 ecx, DWORD PTR nMaxCount$[rsp]
  0011e	89 48 04	 mov	 DWORD PTR [rax+4], ecx

; 251  : 	m_pEnd = &m_pChunk[(m_nAllocCount - 1)<< m_nShift];

  00121	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00126	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00129	ff c8		 dec	 eax
  0012b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00130	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  00133	d3 e0		 shl	 eax, cl
  00135	48 98		 cdqe
  00137	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  0013c	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00140	48 03 c8	 add	 rcx, rax
  00143	48 8b c1	 mov	 rax, rcx
  00146	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  0014b	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 252  : 	_stprintf(g_szMessage, _T("mem allock list m_nAllocCount[%d]"), m_nAllocCount);

  0014f	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00154	44 8b 40 04	 mov	 r8d, DWORD PTR [rax+4]
  00158	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG44611
  0015f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  00166	e8 00 00 00 00	 call	 sprintf

; 253  : 
; 254  : 	return true;

  0016b	b0 01		 mov	 al, 1
$LN1@alloc:

; 255  : }

  0016d	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00171	5f		 pop	 rdi
  00172	c3		 ret	 0
?alloc@CSBufPool@@QEAA_NHH@Z ENDP			; CSBufPool::alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\combufpool.cpp
_TEXT	SEGMENT
this$ = 48
?clear@CSBufPool@@QEAAXXZ PROC				; CSBufPool::clear

; 260  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 261  : 	memset(m_nFlagArray, 0, sizeof(m_nFlagArray));

  0001e	41 b8 08 00 00
	00		 mov	 r8d, 8
  00024	33 d2		 xor	 edx, edx
  00026	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0002b	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0002f	e8 00 00 00 00	 call	 memset

; 262  : 	m_nUseCnt = 0;

  00034	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00039	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 263  : 	memset(m_pChunk, 0, getSizeByIndex(m_nShift)*m_nAllocCount);

  0003f	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00044	8b 48 10	 mov	 ecx, DWORD PTR [rax+16]
  00047	e8 00 00 00 00	 call	 ?getSizeByIndex@@YAHH@Z	; getSizeByIndex
  0004c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00051	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  00055	48 98		 cdqe
  00057	4c 8b c0	 mov	 r8, rax
  0005a	33 d2		 xor	 edx, edx
  0005c	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00061	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00065	e8 00 00 00 00	 call	 memset

; 264  : 	memset(g_szMessage, 0, sizeof(g_szMessage));

  0006a	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  00070	33 d2		 xor	 edx, edx
  00072	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  00079	e8 00 00 00 00	 call	 memset

; 265  : }

  0007e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00082	5f		 pop	 rdi
  00083	c3		 ret	 0
?clear@CSBufPool@@QEAAXXZ ENDP				; CSBufPool::clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\combufpool.cpp
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??1CSBufPool@@QEAA@XZ PROC				; CSBufPool::~CSBufPool

; 211  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  0001e	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2

; 212  : 	destroy();

  00027	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0002c	e8 00 00 00 00	 call	 ?destroy@CSBufPool@@QEAAXXZ ; CSBufPool::destroy
  00031	90		 npad	 1

; 213  : }

  00032	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00036	5f		 pop	 rdi
  00037	c3		 ret	 0
??1CSBufPool@@QEAA@XZ ENDP				; CSBufPool::~CSBufPool
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\combufpool.cpp
_TEXT	SEGMENT
this$ = 48
??0CSBufPool@@QEAA@XZ PROC				; CSBufPool::CSBufPool

; 199  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 200  : 	m_nAllocCount = 0;

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00023	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0

; 201  : 	memset(g_szMessage, 0, LEN_MEM_MESSAGE);

  0002a	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  00030	33 d2		 xor	 edx, edx
  00032	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  00039	e8 00 00 00 00	 call	 memset

; 202  : 	m_pChunk = NULL;

  0003e	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00043	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 203  : 	m_nUseCnt = 0;

  0004b	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00050	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 204  : 	m_nFlagArray = NULL;

  00056	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0005b	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 205  : 	m_pEnd = NULL;

  00063	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00068	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 206  : 	m_nShift = 0;

  00070	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00075	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 207  : }

  0007c	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00081	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00085	5f		 pop	 rdi
  00086	c3		 ret	 0
??0CSBufPool@@QEAA@XZ ENDP				; CSBufPool::CSBufPool
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\combufpool.h
;	COMDAT ?ISINCLUDE_ADDRESS@CBufPool@@QEAA_NPEAD@Z
_TEXT	SEGMENT
this$ = 16
p$ = 24
?ISINCLUDE_ADDRESS@CBufPool@@QEAA_NPEAD@Z PROC		; CBufPool::ISINCLUDE_ADDRESS, COMDAT

; 81   : 	inline bool ISINCLUDE_ADDRESS(char *p) { if(m_pChunk <= p && p <= m_pEnd) return true; return false; }

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  00010	48 8b 4c 24 18	 mov	 rcx, QWORD PTR p$[rsp]
  00015	48 39 48 28	 cmp	 QWORD PTR [rax+40], rcx
  00019	77 14		 ja	 SHORT $LN2@ISINCLUDE_
  0001b	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  00020	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00024	48 39 44 24 18	 cmp	 QWORD PTR p$[rsp], rax
  00029	77 04		 ja	 SHORT $LN2@ISINCLUDE_
  0002b	b0 01		 mov	 al, 1
  0002d	eb 02		 jmp	 SHORT $LN1@ISINCLUDE_
$LN2@ISINCLUDE_:
  0002f	32 c0		 xor	 al, al
$LN1@ISINCLUDE_:
  00031	5f		 pop	 rdi
  00032	c3		 ret	 0
?ISINCLUDE_ADDRESS@CBufPool@@QEAA_NPEAD@Z ENDP		; CBufPool::ISINCLUDE_ADDRESS
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\combufpool.cpp
_TEXT	SEGMENT
i$ = 32
nPos$ = 36
nIdx$ = 40
this$ = 64
pUsedMem$ = 72
nCount$ = 80
?delMem@CBufPool@@QEAAXPEADH@Z PROC			; CBufPool::delMem

; 94   : {

$LN9:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 0c 00 00 00	 mov	 ecx, 12
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 95   : 	int i;
; 96   : 	int nPos = (int)(pUsedMem - m_pChunk);

  00028	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0002d	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00031	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pUsedMem$[rsp]
  00036	48 2b c8	 sub	 rcx, rax
  00039	48 8b c1	 mov	 rax, rcx
  0003c	89 44 24 24	 mov	 DWORD PTR nPos$[rsp], eax

; 97   : 	int nIdx = nPos >> m_nShift;

  00040	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00045	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00048	0f b6 c8	 movzx	 ecx, al
  0004b	8b 44 24 24	 mov	 eax, DWORD PTR nPos$[rsp]
  0004f	d3 f8		 sar	 eax, cl
  00051	89 44 24 28	 mov	 DWORD PTR nIdx$[rsp], eax

; 98   : 
; 99   : 	if (pUsedMem != &m_pChunk[nPos]) return;

  00055	48 63 44 24 24	 movsxd	 rax, DWORD PTR nPos$[rsp]
  0005a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0005f	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00063	48 03 c8	 add	 rcx, rax
  00066	48 8b c1	 mov	 rax, rcx
  00069	48 39 44 24 48	 cmp	 QWORD PTR pUsedMem$[rsp], rax
  0006e	74 05		 je	 SHORT $LN5@delMem
  00070	e9 95 00 00 00	 jmp	 $LN1@delMem
$LN5@delMem:

; 100  : 	for (i = 0; i < nCount; i++)

  00075	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0007d	eb 0a		 jmp	 SHORT $LN4@delMem
$LN2@delMem:
  0007f	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00083	ff c0		 inc	 eax
  00085	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@delMem:
  00089	8b 44 24 50	 mov	 eax, DWORD PTR nCount$[rsp]
  0008d	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00091	7d 63		 jge	 SHORT $LN3@delMem

; 101  : 	{
; 102  : 		if (nIdx >= m_nAllocCount) return;

  00093	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00098	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  0009b	39 44 24 28	 cmp	 DWORD PTR nIdx$[rsp], eax
  0009f	7c 02		 jl	 SHORT $LN6@delMem
  000a1	eb 67		 jmp	 SHORT $LN1@delMem
$LN6@delMem:

; 103  : 		//printf("CBufPool::delMem nPos[%d] nIdx[%d] nShift[%d] pMem[%p]\n", nPos, nIdx, nShift, pUsedMem);
; 104  : 		if (m_nFlagArray[nIdx].getCount())

  000a3	48 63 44 24 28	 movsxd	 rax, DWORD PTR nIdx$[rsp]
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000ad	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000b0	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  000b4	48 8b c8	 mov	 rcx, rax
  000b7	e8 00 00 00 00	 call	 ?getCount@win64_atomic@win32@common@@QEAAHXZ ; common::win32::win64_atomic::getCount
  000bc	85 c0		 test	 eax, eax
  000be	74 2a		 je	 SHORT $LN7@delMem

; 105  : 		{
; 106  : 			m_nFlagArray[nIdx].init();

  000c0	48 63 44 24 28	 movsxd	 rax, DWORD PTR nIdx$[rsp]
  000c5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000ca	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000cd	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  000d1	48 8b c8	 mov	 rcx, rax
  000d4	e8 00 00 00 00	 call	 ?init@win64_atomic@win32@common@@QEAAXXZ ; common::win32::win64_atomic::init

; 107  : 			m_nUseCnt.atomic_decrement();

  000d9	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000de	48 83 c0 08	 add	 rax, 8
  000e2	48 8b c8	 mov	 rcx, rax
  000e5	e8 00 00 00 00	 call	 ?atomic_decrement@win64_atomic@win32@common@@QEAA_JXZ ; common::win32::win64_atomic::atomic_decrement
$LN7@delMem:

; 108  : 		}
; 109  : 		nIdx++;

  000ea	8b 44 24 28	 mov	 eax, DWORD PTR nIdx$[rsp]
  000ee	ff c0		 inc	 eax
  000f0	89 44 24 28	 mov	 DWORD PTR nIdx$[rsp], eax

; 110  : 	}

  000f4	eb 89		 jmp	 SHORT $LN2@delMem
$LN3@delMem:

; 111  : 	m_nLastCount = nIdx - nCount;

  000f6	8b 44 24 50	 mov	 eax, DWORD PTR nCount$[rsp]
  000fa	8b 4c 24 28	 mov	 ecx, DWORD PTR nIdx$[rsp]
  000fe	2b c8		 sub	 ecx, eax
  00100	8b c1		 mov	 eax, ecx
  00102	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00107	89 41 18	 mov	 DWORD PTR [rcx+24], eax
$LN1@delMem:

; 112  : }

  0010a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0010e	5f		 pop	 rdi
  0010f	c3		 ret	 0
?delMem@CBufPool@@QEAAXPEADH@Z ENDP			; CBufPool::delMem
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\combufpool.cpp
_TEXT	SEGMENT
idx$ = 32
nLastLoopCnt$ = 36
i$ = 40
this$ = 64
nCount$ = 72
?newMemList@CBufPool@@QEAA_NH@Z PROC			; CBufPool::newMemList

; 152  : {

$LN17:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 0c 00 00 00	 mov	 ecx, 12
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 153  : 	int idx = m_nLastCount, nLastLoopCnt=0;

  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00027	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0002a	89 44 24 20	 mov	 DWORD PTR idx$[rsp], eax
  0002e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR nLastLoopCnt$[rsp], 0

; 154  : 	int i;
; 155  : 	if (m_nUseCnt.getCount()+nCount > m_nAllocCount) return false;

  00036	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0003b	48 83 c0 08	 add	 rax, 8
  0003f	48 8b c8	 mov	 rcx, rax
  00042	e8 00 00 00 00	 call	 ?getCount@win64_atomic@win32@common@@QEAAHXZ ; common::win32::win64_atomic::getCount
  00047	03 44 24 48	 add	 eax, DWORD PTR nCount$[rsp]
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00050	3b 41 1c	 cmp	 eax, DWORD PTR [rcx+28]
  00053	7e 07		 jle	 SHORT $LN8@newMemList
  00055	32 c0		 xor	 al, al
  00057	e9 2e 01 00 00	 jmp	 $LN1@newMemList
$LN8@newMemList:

; 156  : 
; 157  : 	for (i=0; i < nCount; i++) {

  0005c	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00064	eb 0a		 jmp	 SHORT $LN4@newMemList
$LN2@newMemList:
  00066	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN4@newMemList:
  00070	8b 44 24 48	 mov	 eax, DWORD PTR nCount$[rsp]
  00074	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  00078	0f 8d 85 00 00
	00		 jge	 $LN3@newMemList

; 158  : 		if (idx >= m_nAllocCount) break;

  0007e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00083	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00086	39 44 24 20	 cmp	 DWORD PTR idx$[rsp], eax
  0008a	7c 02		 jl	 SHORT $LN9@newMemList
  0008c	eb 75		 jmp	 SHORT $LN3@newMemList
$LN9@newMemList:

; 159  : 		if (!m_nFlagArray[idx].getCount())

  0008e	48 63 44 24 20	 movsxd	 rax, DWORD PTR idx$[rsp]
  00093	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00098	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0009b	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  0009f	48 8b c8	 mov	 rcx, rax
  000a2	e8 00 00 00 00	 call	 ?getCount@win64_atomic@win32@common@@QEAAHXZ ; common::win32::win64_atomic::getCount
  000a7	85 c0		 test	 eax, eax
  000a9	75 47		 jne	 SHORT $LN10@newMemList

; 160  : 		{
; 161  : 			if (!m_nFlagArray[idx].atomic_compare_exchange(1, 0)) {

  000ab	48 63 44 24 20	 movsxd	 rax, DWORD PTR idx$[rsp]
  000b0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000b5	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000b8	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  000bc	45 33 c0	 xor	 r8d, r8d
  000bf	ba 01 00 00 00	 mov	 edx, 1
  000c4	48 8b c8	 mov	 rcx, rax
  000c7	e8 00 00 00 00	 call	 ?atomic_compare_exchange@win64_atomic@win32@common@@QEAA_J_J0@Z ; common::win32::win64_atomic::atomic_compare_exchange
  000cc	48 85 c0	 test	 rax, rax
  000cf	75 1d		 jne	 SHORT $LN12@newMemList

; 162  : 				m_nUseCnt.atomic_increment();

  000d1	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000d6	48 83 c0 08	 add	 rax, 8
  000da	48 8b c8	 mov	 rcx, rax
  000dd	e8 00 00 00 00	 call	 ?atomic_increment@win64_atomic@win32@common@@QEAA_JXZ ; common::win32::win64_atomic::atomic_increment

; 163  : 				nLastLoopCnt++;

  000e2	8b 44 24 24	 mov	 eax, DWORD PTR nLastLoopCnt$[rsp]
  000e6	ff c0		 inc	 eax
  000e8	89 44 24 24	 mov	 DWORD PTR nLastLoopCnt$[rsp], eax

; 164  : 			}
; 165  : 			else break;

  000ec	eb 02		 jmp	 SHORT $LN13@newMemList
$LN12@newMemList:
  000ee	eb 13		 jmp	 SHORT $LN3@newMemList
$LN13@newMemList:

; 166  : 		}
; 167  : 		else break;

  000f0	eb 02		 jmp	 SHORT $LN11@newMemList
$LN10@newMemList:
  000f2	eb 0f		 jmp	 SHORT $LN3@newMemList
$LN11@newMemList:

; 168  : 		idx++;

  000f4	8b 44 24 20	 mov	 eax, DWORD PTR idx$[rsp]
  000f8	ff c0		 inc	 eax
  000fa	89 44 24 20	 mov	 DWORD PTR idx$[rsp], eax

; 169  : 	}

  000fe	e9 63 ff ff ff	 jmp	 $LN2@newMemList
$LN3@newMemList:

; 170  : 
; 171  : 	if (nLastLoopCnt== nCount) {

  00103	8b 44 24 48	 mov	 eax, DWORD PTR nCount$[rsp]
  00107	39 44 24 24	 cmp	 DWORD PTR nLastLoopCnt$[rsp], eax
  0010b	75 10		 jne	 SHORT $LN14@newMemList

; 172  : 		m_nLastCount = idx;

  0010d	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00112	8b 4c 24 20	 mov	 ecx, DWORD PTR idx$[rsp]
  00116	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 173  : 		return true;

  00119	b0 01		 mov	 al, 1
  0011b	eb 6d		 jmp	 SHORT $LN1@newMemList
$LN14@newMemList:

; 174  : 	}
; 175  : 
; 176  : 	for (idx = m_nLastCount; idx < nLastLoopCnt; idx++) {

  0011d	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00122	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00125	89 44 24 20	 mov	 DWORD PTR idx$[rsp], eax
  00129	eb 0a		 jmp	 SHORT $LN7@newMemList
$LN5@newMemList:
  0012b	8b 44 24 20	 mov	 eax, DWORD PTR idx$[rsp]
  0012f	ff c0		 inc	 eax
  00131	89 44 24 20	 mov	 DWORD PTR idx$[rsp], eax
$LN7@newMemList:
  00135	8b 44 24 24	 mov	 eax, DWORD PTR nLastLoopCnt$[rsp]
  00139	39 44 24 20	 cmp	 DWORD PTR idx$[rsp], eax
  0013d	7d 49		 jge	 SHORT $LN6@newMemList

; 177  : 		if (m_nFlagArray[idx].getCount())

  0013f	48 63 44 24 20	 movsxd	 rax, DWORD PTR idx$[rsp]
  00144	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00149	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0014c	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  00150	48 8b c8	 mov	 rcx, rax
  00153	e8 00 00 00 00	 call	 ?getCount@win64_atomic@win32@common@@QEAAHXZ ; common::win32::win64_atomic::getCount
  00158	85 c0		 test	 eax, eax
  0015a	74 2a		 je	 SHORT $LN15@newMemList

; 178  : 		{
; 179  : 			m_nFlagArray[idx].init();

  0015c	48 63 44 24 20	 movsxd	 rax, DWORD PTR idx$[rsp]
  00161	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00166	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00169	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  0016d	48 8b c8	 mov	 rcx, rax
  00170	e8 00 00 00 00	 call	 ?init@win64_atomic@win32@common@@QEAAXXZ ; common::win32::win64_atomic::init

; 180  : 			m_nUseCnt.atomic_decrement();

  00175	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0017a	48 83 c0 08	 add	 rax, 8
  0017e	48 8b c8	 mov	 rcx, rax
  00181	e8 00 00 00 00	 call	 ?atomic_decrement@win64_atomic@win32@common@@QEAA_JXZ ; common::win32::win64_atomic::atomic_decrement
$LN15@newMemList:

; 181  : 		}
; 182  : 	}

  00186	eb a3		 jmp	 SHORT $LN5@newMemList
$LN6@newMemList:

; 183  : 	return false;

  00188	32 c0		 xor	 al, al
$LN1@newMemList:

; 184  : }

  0018a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0018e	5f		 pop	 rdi
  0018f	c3		 ret	 0
?newMemList@CBufPool@@QEAA_NH@Z ENDP			; CBufPool::newMemList
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\combufpool.cpp
_TEXT	SEGMENT
nPos$ = 32
nIdx$ = 36
this$ = 64
pUsedMem$ = 72
?delMem@CBufPool@@QEAAXPEAD@Z PROC			; CBufPool::delMem

; 76   : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 0c 00 00 00	 mov	 ecx, 12
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 77   : 	if(!ISINCLUDE_ADDRESS(pUsedMem)) {

  00023	48 8b 54 24 48	 mov	 rdx, QWORD PTR pUsedMem$[rsp]
  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0002d	e8 00 00 00 00	 call	 ?ISINCLUDE_ADDRESS@CBufPool@@QEAA_NPEAD@Z ; CBufPool::ISINCLUDE_ADDRESS
  00032	0f b6 c0	 movzx	 eax, al
  00035	85 c0		 test	 eax, eax
  00037	75 0d		 jne	 SHORT $LN2@delMem

; 78   : 		free(pUsedMem);

  00039	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pUsedMem$[rsp]
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 79   : 		//m_nOverCnt.atomic_decrement();
; 80   : 		return;

  00044	eb 7e		 jmp	 SHORT $LN1@delMem
$LN2@delMem:

; 81   : 	}
; 82   : 
; 83   : 	int nPos = (int)(pUsedMem - m_pChunk);

  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0004b	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0004f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pUsedMem$[rsp]
  00054	48 2b c8	 sub	 rcx, rax
  00057	48 8b c1	 mov	 rax, rcx
  0005a	89 44 24 20	 mov	 DWORD PTR nPos$[rsp], eax

; 84   : 	int nIdx = nPos >> m_nShift;

  0005e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00063	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00066	0f b6 c8	 movzx	 ecx, al
  00069	8b 44 24 20	 mov	 eax, DWORD PTR nPos$[rsp]
  0006d	d3 f8		 sar	 eax, cl
  0006f	89 44 24 24	 mov	 DWORD PTR nIdx$[rsp], eax

; 85   : 
; 86   :     if(pUsedMem == &m_pChunk[nPos]) {

  00073	48 63 44 24 20	 movsxd	 rax, DWORD PTR nPos$[rsp]
  00078	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0007d	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00081	48 03 c8	 add	 rcx, rax
  00084	48 8b c1	 mov	 rax, rcx
  00087	48 39 44 24 48	 cmp	 QWORD PTR pUsedMem$[rsp], rax
  0008c	75 36		 jne	 SHORT $LN3@delMem

; 87   : 		m_nFlagArray[nIdx].init();

  0008e	48 63 44 24 24	 movsxd	 rax, DWORD PTR nIdx$[rsp]
  00093	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00098	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0009b	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  0009f	48 8b c8	 mov	 rcx, rax
  000a2	e8 00 00 00 00	 call	 ?init@win64_atomic@win32@common@@QEAAXXZ ; common::win32::win64_atomic::init

; 88   : 		m_nUseCnt.atomic_decrement();

  000a7	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000ac	48 83 c0 08	 add	 rax, 8
  000b0	48 8b c8	 mov	 rcx, rax
  000b3	e8 00 00 00 00	 call	 ?atomic_decrement@win64_atomic@win32@common@@QEAA_JXZ ; common::win32::win64_atomic::atomic_decrement

; 89   : 		m_nLastCount = nIdx;

  000b8	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000bd	8b 4c 24 24	 mov	 ecx, DWORD PTR nIdx$[rsp]
  000c1	89 48 18	 mov	 DWORD PTR [rax+24], ecx
$LN3@delMem:
$LN1@delMem:

; 90   : 	}
; 91   : }

  000c4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c8	5f		 pop	 rdi
  000c9	c3		 ret	 0
?delMem@CBufPool@@QEAAXPEAD@Z ENDP			; CBufPool::delMem
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\combufpool.cpp
_TEXT	SEGMENT
i$ = 32
j$ = 36
p$ = 40
this$ = 64
?newMem@CBufPool@@QEAAPEADXZ PROC			; CBufPool::newMem

; 115  : {

$LN11:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 116  : 	int i= m_nLastCount,j;

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00023	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00026	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax

; 117  : 	if(m_nUseCnt.getCount() == m_nAllocCount) goto NEW_ALLOC;

  0002a	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0002f	48 83 c0 08	 add	 rax, 8
  00033	48 8b c8	 mov	 rcx, rax
  00036	e8 00 00 00 00	 call	 ?getCount@win64_atomic@win32@common@@QEAAHXZ ; common::win32::win64_atomic::getCount
  0003b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00040	3b 41 1c	 cmp	 eax, DWORD PTR [rcx+28]
  00043	75 0a		 jne	 SHORT $LN5@newMem
  00045	e9 1c 01 00 00	 jmp	 $LN6@newMem
  0004a	e9 17 01 00 00	 jmp	 $NEW_ALLOC$12
$LN5@newMem:

; 118  : 	
; 119  : 	for(j = 0; j < m_nAllocCount; j++)

  0004f	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00057	eb 0a		 jmp	 SHORT $LN4@newMem
$LN2@newMem:
  00059	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  0005d	ff c0		 inc	 eax
  0005f	89 44 24 24	 mov	 DWORD PTR j$[rsp], eax
$LN4@newMem:
  00063	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00068	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  0006b	39 44 24 24	 cmp	 DWORD PTR j$[rsp], eax
  0006f	0f 8d f1 00 00
	00		 jge	 $LN3@newMem

; 120  :     {
; 121  : 		if(i >= m_nAllocCount) {i = 0;} //    .  next    .

  00075	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0007a	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  0007d	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00081	7c 08		 jl	 SHORT $LN7@newMem
  00083	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
$LN7@newMem:

; 122  : 		if(!m_nFlagArray[i].getCount()) 

  0008b	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00090	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00095	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00098	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  0009c	48 8b c8	 mov	 rcx, rax
  0009f	e8 00 00 00 00	 call	 ?getCount@win64_atomic@win32@common@@QEAAHXZ ; common::win32::win64_atomic::getCount
  000a4	85 c0		 test	 eax, eax
  000a6	0f 85 ab 00 00
	00		 jne	 $LN8@newMem

; 123  : 		{
; 124  : 			if(!m_nFlagArray[i].atomic_compare_exchange(1,0)) 

  000ac	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000b1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000b6	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000b9	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  000bd	45 33 c0	 xor	 r8d, r8d
  000c0	ba 01 00 00 00	 mov	 edx, 1
  000c5	48 8b c8	 mov	 rcx, rax
  000c8	e8 00 00 00 00	 call	 ?atomic_compare_exchange@win64_atomic@win32@common@@QEAA_J_J0@Z ; common::win32::win64_atomic::atomic_compare_exchange
  000cd	48 85 c0	 test	 rax, rax
  000d0	0f 85 81 00 00
	00		 jne	 $LN9@newMem

; 125  : 			{
; 126  : 				m_nUseCnt.atomic_increment();

  000d6	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000db	48 83 c0 08	 add	 rax, 8
  000df	48 8b c8	 mov	 rcx, rax
  000e2	e8 00 00 00 00	 call	 ?atomic_increment@win64_atomic@win32@common@@QEAA_JXZ ; common::win32::win64_atomic::atomic_increment

; 127  : 				m_nLastCount=i;

  000e7	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000ec	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  000f0	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 128  : 				memset(&m_pChunk[i << m_nShift], 0, g_nSizeList[m_nShift]);

  000f3	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000f8	48 63 40 20	 movsxd	 rax, DWORD PTR [rax+32]
  000fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_nSizeList@@3QBHB ; g_nSizeList
  00103	48 63 04 81	 movsxd	 rax, DWORD PTR [rcx+rax*4]
  00107	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0010c	8b 49 20	 mov	 ecx, DWORD PTR [rcx+32]
  0010f	8b 54 24 20	 mov	 edx, DWORD PTR i$[rsp]
  00113	d3 e2		 shl	 edx, cl
  00115	8b ca		 mov	 ecx, edx
  00117	48 63 c9	 movsxd	 rcx, ecx
  0011a	48 8b 54 24 40	 mov	 rdx, QWORD PTR this$[rsp]
  0011f	48 8b 52 28	 mov	 rdx, QWORD PTR [rdx+40]
  00123	48 03 d1	 add	 rdx, rcx
  00126	48 8b ca	 mov	 rcx, rdx
  00129	4c 8b c0	 mov	 r8, rax
  0012c	33 d2		 xor	 edx, edx
  0012e	e8 00 00 00 00	 call	 memset

; 129  : 				return &m_pChunk[i << m_nShift];

  00133	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00138	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  0013b	0f b6 c8	 movzx	 ecx, al
  0013e	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00142	d3 e0		 shl	 eax, cl
  00144	48 98		 cdqe
  00146	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0014b	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0014f	48 03 c8	 add	 rcx, rax
  00152	48 8b c1	 mov	 rax, rcx
  00155	eb 3b		 jmp	 SHORT $LN1@newMem
$LN9@newMem:
$LN8@newMem:

; 130  : 			}
; 131  : 		}
; 132  : 		i++;

  00157	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0015b	ff c0		 inc	 eax
  0015d	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax

; 133  :     }    

  00161	e9 f3 fe ff ff	 jmp	 $LN2@newMem
$LN3@newMem:
$LN6@newMem:
$NEW_ALLOC$12:

; 134  : NEW_ALLOC:
; 135  : 	//if (m_nOverMaxCnt.getCount() < m_nOverCnt.getCount()) {
; 136  : 	//	m_nOverMaxCnt.atomic_exchange(m_nOverCnt.getCount());
; 137  : 	//	gs_cLogger.DebugLog(LEVEL_WARN, "update m_nOverMaxCnt[%d]", m_nOverMaxCnt.getCount());
; 138  : 	//}
; 139  : 	char * p = (char *)calloc(1, g_nSizeList[m_nShift]);

  00166	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0016b	48 63 40 20	 movsxd	 rax, DWORD PTR [rax+32]
  0016f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_nSizeList@@3QBHB ; g_nSizeList
  00176	48 63 04 81	 movsxd	 rax, DWORD PTR [rcx+rax*4]
  0017a	48 8b d0	 mov	 rdx, rax
  0017d	b9 01 00 00 00	 mov	 ecx, 1
  00182	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00188	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax

; 140  : 	//if (p) {
; 141  : 	//	m_nOverCnt.atomic_increment();
; 142  : 	//	gs_cLogger.DebugLog(LEVEL_TRACE, "update m_nOverCnt[%d] m_nShift[%d] m_nAllocCount[%d]", m_nOverCnt.atomic_increment(), m_nShift, m_nAllocCount);
; 143  : 	//}
; 144  : 	//else {
; 145  : 	//	gs_cLogger.DebugLog(LEVEL_ERROR, "calloc has Failed");
; 146  : 	//}
; 147  : 	return p;

  0018d	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
$LN1@newMem:

; 148  : }

  00192	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00196	5f		 pop	 rdi
  00197	c3		 ret	 0
?newMem@CBufPool@@QEAAPEADXZ ENDP			; CBufPool::newMem
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\combufpool.cpp
_TEXT	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 64
$T4 = 72
$T5 = 80
$T6 = 88
tv93 = 96
tv169 = 104
this$ = 128
nShift$ = 136
nMaxCount$ = 144
?alloc@CBufPool@@QEAA_NHH@Z PROC			; CBufPool::alloc

; 33   : {

$LN13:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 1c 00 00 00	 mov	 ecx, 28
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR [rsp+128]
  0002a	48 c7 44 24 58
	fe ff ff ff	 mov	 QWORD PTR $T6[rsp], -2

; 34   : 	m_nFlagArray = new (std::nothrow) atomic_nr[nMaxCount];

  00033	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR nMaxCount$[rsp]
  0003b	48 89 44 24 30	 mov	 QWORD PTR $T1[rsp], rax
  00040	b8 08 00 00 00	 mov	 eax, 8
  00045	48 f7 64 24 30	 mul	 QWORD PTR $T1[rsp]
  0004a	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  00051	48 0f 40 c1	 cmovo	 rax, rcx
  00055	48 83 c0 08	 add	 rax, 8
  00059	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  00060	48 0f 42 c1	 cmovb	 rax, rcx
  00064	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  0006b	48 8b c8	 mov	 rcx, rax
  0006e	e8 00 00 00 00	 call	 ??_U@YAPEAX_KAEBUnothrow_t@std@@@Z ; operator new[]
  00073	48 89 44 24 40	 mov	 QWORD PTR $T3[rsp], rax
  00078	48 83 7c 24 40
	00		 cmp	 QWORD PTR $T3[rsp], 0
  0007e	74 4b		 je	 SHORT $LN8@alloc
  00080	48 8b 44 24 40	 mov	 rax, QWORD PTR $T3[rsp]
  00085	48 8b 4c 24 30	 mov	 rcx, QWORD PTR $T1[rsp]
  0008a	48 89 08	 mov	 QWORD PTR [rax], rcx
  0008d	48 8b 44 24 40	 mov	 rax, QWORD PTR $T3[rsp]
  00092	48 83 c0 08	 add	 rax, 8
  00096	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??1win64_atomic@win32@common@@QEAA@XZ ; common::win32::win64_atomic::~win64_atomic
  0009d	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000a2	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??0win64_atomic@win32@common@@QEAA@XZ ; common::win32::win64_atomic::win64_atomic
  000a9	4c 8b 44 24 30	 mov	 r8, QWORD PTR $T1[rsp]
  000ae	ba 08 00 00 00	 mov	 edx, 8
  000b3	48 8b c8	 mov	 rcx, rax
  000b6	e8 00 00 00 00	 call	 ??_L@YAXPEAX_K1P6AX0@Z2@Z
  000bb	48 8b 44 24 40	 mov	 rax, QWORD PTR $T3[rsp]
  000c0	48 83 c0 08	 add	 rax, 8
  000c4	48 89 44 24 60	 mov	 QWORD PTR tv93[rsp], rax
  000c9	eb 09		 jmp	 SHORT $LN9@alloc
$LN8@alloc:
  000cb	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR tv93[rsp], 0
$LN9@alloc:
  000d4	48 8b 44 24 60	 mov	 rax, QWORD PTR tv93[rsp]
  000d9	48 89 44 24 38	 mov	 QWORD PTR $T2[rsp], rax
  000de	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000e6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR $T2[rsp]
  000eb	48 89 08	 mov	 QWORD PTR [rax], rcx

; 35   : 	if(m_nFlagArray == NULL) {

  000ee	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000f6	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  000fa	75 31		 jne	 SHORT $LN5@alloc

; 36   : 		gs_cLogger.DebugLog(LEVEL_ERROR, "new m_nFlagArray");

  000fc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG44510
  00103	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00108	41 b9 24 00 00
	00		 mov	 r9d, 36			; 00000024H
  0010e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG44511
  00115	ba 05 00 00 00	 mov	 edx, 5
  0011a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  00121	e8 00 00 00 00	 call	 ?__debugLog@CLogger@@QEAAXHPEBDH0ZZ ; CLogger::__debugLog

; 37   : 		return false;

  00126	32 c0		 xor	 al, al
  00128	e9 a4 01 00 00	 jmp	 $LN1@alloc
$LN5@alloc:

; 38   : 	}
; 39   : 	for (m_nLastCount = 0; m_nLastCount < nMaxCount; m_nLastCount++)

  0012d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00135	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0
  0013c	eb 18		 jmp	 SHORT $LN4@alloc
$LN2@alloc:
  0013e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00146	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00149	ff c0		 inc	 eax
  0014b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00153	89 41 18	 mov	 DWORD PTR [rcx+24], eax
$LN4@alloc:
  00156	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0015e	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR nMaxCount$[rsp]
  00165	39 48 18	 cmp	 DWORD PTR [rax+24], ecx
  00168	7d 25		 jge	 SHORT $LN3@alloc

; 40   : 	{
; 41   : 		m_nFlagArray[m_nLastCount].init();

  0016a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00172	48 63 40 18	 movsxd	 rax, DWORD PTR [rax+24]
  00176	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0017e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00181	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  00185	48 8b c8	 mov	 rcx, rax
  00188	e8 00 00 00 00	 call	 ?init@win64_atomic@win32@common@@QEAAXXZ ; common::win32::win64_atomic::init

; 42   : 	}

  0018d	eb af		 jmp	 SHORT $LN2@alloc
$LN3@alloc:

; 43   : 
; 44   : 	m_pChunk = (char *)calloc(nMaxCount, getSizeByIndex(nShift));

  0018f	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR nShift$[rsp]
  00196	e8 00 00 00 00	 call	 ?getSizeByIndex@@YAHH@Z	; getSizeByIndex
  0019b	48 98		 cdqe
  0019d	48 63 8c 24 90
	00 00 00	 movsxd	 rcx, DWORD PTR nMaxCount$[rsp]
  001a5	48 8b d0	 mov	 rdx, rax
  001a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  001ae	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  001b6	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 45   : 
; 46   :     if(m_pChunk == NULL) {

  001ba	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001c2	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  001c7	0f 85 81 00 00
	00		 jne	 $LN6@alloc

; 47   : 		gs_cLogger.DebugLog(LEVEL_ERROR, "m_pChunk alloc");

  001cd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG44513
  001d4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001d9	41 b9 2f 00 00
	00		 mov	 r9d, 47			; 0000002fH
  001df	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG44514
  001e6	ba 05 00 00 00	 mov	 edx, 5
  001eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  001f2	e8 00 00 00 00	 call	 ?__debugLog@CLogger@@QEAAXHPEBDH0ZZ ; CLogger::__debugLog

; 48   : 		delete[] m_nFlagArray;

  001f7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001ff	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00202	48 89 44 24 50	 mov	 QWORD PTR $T5[rsp], rax
  00207	48 8b 44 24 50	 mov	 rax, QWORD PTR $T5[rsp]
  0020c	48 89 44 24 48	 mov	 QWORD PTR $T4[rsp], rax
  00211	48 83 7c 24 48
	00		 cmp	 QWORD PTR $T4[rsp], 0
  00217	74 16		 je	 SHORT $LN10@alloc
  00219	ba 03 00 00 00	 mov	 edx, 3
  0021e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR $T4[rsp]
  00223	e8 00 00 00 00	 call	 ??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z
  00228	48 89 44 24 68	 mov	 QWORD PTR tv169[rsp], rax
  0022d	eb 09		 jmp	 SHORT $LN11@alloc
$LN10@alloc:
  0022f	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR tv169[rsp], 0
$LN11@alloc:

; 49   : 		m_nFlagArray = NULL;

  00238	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00240	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 50   : 		return false;

  00247	32 c0		 xor	 al, al
  00249	e9 83 00 00 00	 jmp	 $LN1@alloc
$LN6@alloc:

; 51   :     }
; 52   : 
; 53   :     m_nAllocCount   = nMaxCount;

  0024e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00256	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR nMaxCount$[rsp]
  0025d	89 48 1c	 mov	 DWORD PTR [rax+28], ecx

; 54   : 	m_nLastCount = 0;

  00260	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00268	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0

; 55   : 	m_nUseCnt.init();

  0026f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00277	48 83 c0 08	 add	 rax, 8
  0027b	48 8b c8	 mov	 rcx, rax
  0027e	e8 00 00 00 00	 call	 ?init@win64_atomic@win32@common@@QEAAXXZ ; common::win32::win64_atomic::init

; 56   : 	m_nShift = nShift;

  00283	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0028b	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR nShift$[rsp]
  00292	89 48 20	 mov	 DWORD PTR [rax+32], ecx

; 57   : 	m_pEnd = &m_pChunk[(m_nAllocCount-1)<< m_nShift];

  00295	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0029d	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  002a0	ff c8		 dec	 eax
  002a2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  002aa	8b 49 20	 mov	 ecx, DWORD PTR [rcx+32]
  002ad	d3 e0		 shl	 eax, cl
  002af	48 98		 cdqe
  002b1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  002b9	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  002bd	48 03 c8	 add	 rcx, rax
  002c0	48 8b c1	 mov	 rax, rcx
  002c3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  002cb	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 58   : 	return true;

  002cf	b0 01		 mov	 al, 1
$LN1@alloc:

; 59   : }

  002d1	48 83 c4 70	 add	 rsp, 112		; 00000070H
  002d5	5f		 pop	 rdi
  002d6	c3		 ret	 0
?alloc@CBufPool@@QEAA_NHH@Z ENDP			; CBufPool::alloc
_TEXT	ENDS
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 64
$T4 = 72
$T5 = 80
$T6 = 88
tv93 = 96
tv169 = 104
this$ = 128
nShift$ = 136
nMaxCount$ = 144
?dtor$0@?0??alloc@CBufPool@@QEAA_NHH@Z@4HA PROC		; `CBufPool::alloc'::`1'::dtor$0
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00010	48 8b ea	 mov	 rbp, rdx
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  0001a	48 8b 4d 40	 mov	 rcx, QWORD PTR $T3[rbp]
  0001e	e8 00 00 00 00	 call	 ??_V@YAXPEAXAEBUnothrow_t@std@@@Z ; operator delete[]
  00023	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00027	5f		 pop	 rdi
  00028	5d		 pop	 rbp
  00029	c3		 ret	 0
?dtor$0@?0??alloc@CBufPool@@QEAA_NHH@Z@4HA ENDP		; `CBufPool::alloc'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 64
$T4 = 72
$T5 = 80
$T6 = 88
tv93 = 96
tv169 = 104
this$ = 128
nShift$ = 136
nMaxCount$ = 144
?dtor$0@?0??alloc@CBufPool@@QEAA_NHH@Z@4HA PROC		; `CBufPool::alloc'::`1'::dtor$0
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00010	48 8b ea	 mov	 rbp, rdx
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  0001a	48 8b 4d 40	 mov	 rcx, QWORD PTR $T3[rbp]
  0001e	e8 00 00 00 00	 call	 ??_V@YAXPEAXAEBUnothrow_t@std@@@Z ; operator delete[]
  00023	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00027	5f		 pop	 rdi
  00028	5d		 pop	 rbp
  00029	c3		 ret	 0
?dtor$0@?0??alloc@CBufPool@@QEAA_NHH@Z@4HA ENDP		; `CBufPool::alloc'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\combufpool.cpp
_TEXT	SEGMENT
i$ = 32
this$ = 64
?clear@CBufPool@@QEAAXXZ PROC				; CBufPool::clear

; 63   : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 64   : 	int i;
; 65   : 	m_nUseCnt.init();

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00023	48 83 c0 08	 add	 rax, 8
  00027	48 8b c8	 mov	 rcx, rax
  0002a	e8 00 00 00 00	 call	 ?init@win64_atomic@win32@common@@QEAAXXZ ; common::win32::win64_atomic::init

; 66   : 	m_nLastCount = 0;

  0002f	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00034	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0

; 67   : 	for(i = 0; i < m_nAllocCount; i++)

  0003b	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00043	eb 0a		 jmp	 SHORT $LN4@clear
$LN2@clear:
  00045	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00049	ff c0		 inc	 eax
  0004b	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@clear:
  0004f	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00054	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00057	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0005b	7d 1b		 jge	 SHORT $LN3@clear

; 68   : 	{
; 69   : 		m_nFlagArray[i].init();

  0005d	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00062	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00067	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0006a	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  0006e	48 8b c8	 mov	 rcx, rax
  00071	e8 00 00 00 00	 call	 ?init@win64_atomic@win32@common@@QEAAXXZ ; common::win32::win64_atomic::init

; 70   : 	}

  00076	eb cd		 jmp	 SHORT $LN2@clear
$LN3@clear:

; 71   : 	memset(m_pChunk, 0, getSizeByIndex(m_nShift)*m_nAllocCount);

  00078	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0007d	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  00080	e8 00 00 00 00	 call	 ?getSizeByIndex@@YAHH@Z	; getSizeByIndex
  00085	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0008a	0f af 41 1c	 imul	 eax, DWORD PTR [rcx+28]
  0008e	48 98		 cdqe
  00090	4c 8b c0	 mov	 r8, rax
  00093	33 d2		 xor	 edx, edx
  00095	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0009a	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  0009e	e8 00 00 00 00	 call	 memset

; 72   : }

  000a3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a7	5f		 pop	 rdi
  000a8	c3		 ret	 0
?clear@CBufPool@@QEAAXXZ ENDP				; CBufPool::clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\combufpool.cpp
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
tv80 = 48
this$ = 80
??1CBufPool@@QEAA@XZ PROC				; CBufPool::~CBufPool

; 20   : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 10 00 00 00	 mov	 ecx, 16
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 21   :     if(m_pChunk) {

  0001e	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00023	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00028	74 1c		 je	 SHORT $LN2@CBufPool

; 22   :         free(m_pChunk);

  0002a	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0002f	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 23   :         m_pChunk = NULL;

  00039	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0003e	48 c7 40 28 00
	00 00 00	 mov	 QWORD PTR [rax+40], 0
$LN2@CBufPool:

; 24   :     }
; 25   : 
; 26   :     if(m_nFlagArray) {

  00046	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0004b	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0004f	74 4a		 je	 SHORT $LN3@CBufPool

; 27   :         delete [] m_nFlagArray;

  00051	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00056	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00059	48 89 44 24 28	 mov	 QWORD PTR $T2[rsp], rax
  0005e	48 8b 44 24 28	 mov	 rax, QWORD PTR $T2[rsp]
  00063	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax
  00068	48 83 7c 24 20
	00		 cmp	 QWORD PTR $T1[rsp], 0
  0006e	74 16		 je	 SHORT $LN5@CBufPool
  00070	ba 03 00 00 00	 mov	 edx, 3
  00075	48 8b 4c 24 20	 mov	 rcx, QWORD PTR $T1[rsp]
  0007a	e8 00 00 00 00	 call	 ??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z
  0007f	48 89 44 24 30	 mov	 QWORD PTR tv80[rsp], rax
  00084	eb 09		 jmp	 SHORT $LN6@CBufPool
$LN5@CBufPool:
  00086	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tv80[rsp], 0
$LN6@CBufPool:

; 28   :         m_nFlagArray = NULL;

  0008f	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00094	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN3@CBufPool:

; 29   :     }	
; 30   : }

  0009b	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  000a0	48 83 c0 10	 add	 rax, 16
  000a4	48 8b c8	 mov	 rcx, rax
  000a7	e8 00 00 00 00	 call	 ??1win64_atomic@win32@common@@QEAA@XZ ; common::win32::win64_atomic::~win64_atomic
  000ac	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  000b1	48 83 c0 08	 add	 rax, 8
  000b5	48 8b c8	 mov	 rcx, rax
  000b8	e8 00 00 00 00	 call	 ??1win64_atomic@win32@common@@QEAA@XZ ; common::win32::win64_atomic::~win64_atomic
  000bd	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000c1	5f		 pop	 rdi
  000c2	c3		 ret	 0
??1CBufPool@@QEAA@XZ ENDP				; CBufPool::~CBufPool
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\combufpool.cpp
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??0CBufPool@@QEAA@XZ PROC				; CBufPool::CBufPool

; 7    : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  0001e	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0002c	48 83 c0 08	 add	 rax, 8
  00030	48 8b c8	 mov	 rcx, rax
  00033	e8 00 00 00 00	 call	 ??0win64_atomic@win32@common@@QEAA@XZ ; common::win32::win64_atomic::win64_atomic
  00038	90		 npad	 1
  00039	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0003e	48 83 c0 10	 add	 rax, 16
  00042	48 8b c8	 mov	 rcx, rax
  00045	e8 00 00 00 00	 call	 ??0win64_atomic@win32@common@@QEAA@XZ ; common::win32::win64_atomic::win64_atomic

; 8    : 	m_nAllocCount = 0;

  0004a	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0004f	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [rax+28], 0

; 9    : 	m_nLastCount = 0;

  00056	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0005b	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0

; 10   : 	memset(g_szMessage, 0 ,LEN_MEM_MESSAGE); 

  00062	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  00068	33 d2		 xor	 edx, edx
  0006a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  00071	e8 00 00 00 00	 call	 memset

; 11   : 	m_pChunk = NULL;

  00076	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0007b	48 c7 40 28 00
	00 00 00	 mov	 QWORD PTR [rax+40], 0

; 12   : 	m_nFlagArray = NULL;

  00083	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00088	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 13   : 	m_nShift = 0;

  0008f	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00094	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [rax+32], 0

; 14   : 	m_pEnd = NULL;

  0009b	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000a0	48 c7 40 30 00
	00 00 00	 mov	 QWORD PTR [rax+48], 0

; 15   : 	//m_nOverCnt.init();
; 16   : 	//m_nOverMaxCnt.init();
; 17   : }

  000a8	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000ad	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b1	5f		 pop	 rdi
  000b2	c3		 ret	 0
??0CBufPool@@QEAA@XZ ENDP				; CBufPool::CBufPool
_TEXT	ENDS
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$0@?0???0CBufPool@@QEAA@XZ@4HA PROC		; `CBufPool::CBufPool'::`1'::dtor$0
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00010	48 8b ea	 mov	 rbp, rdx
  00013	48 8b 4d 40	 mov	 rcx, QWORD PTR this$[rbp]
  00017	48 83 c1 08	 add	 rcx, 8
  0001b	e8 00 00 00 00	 call	 ??1win64_atomic@win32@common@@QEAA@XZ ; common::win32::win64_atomic::~win64_atomic
  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	5f		 pop	 rdi
  00025	5d		 pop	 rbp
  00026	c3		 ret	 0
?dtor$0@?0???0CBufPool@@QEAA@XZ@4HA ENDP		; `CBufPool::CBufPool'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$0@?0???0CBufPool@@QEAA@XZ@4HA PROC		; `CBufPool::CBufPool'::`1'::dtor$0
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00010	48 8b ea	 mov	 rbp, rdx
  00013	48 8b 4d 40	 mov	 rcx, QWORD PTR this$[rbp]
  00017	48 83 c1 08	 add	 rcx, 8
  0001b	e8 00 00 00 00	 call	 ??1win64_atomic@win32@common@@QEAA@XZ ; common::win32::win64_atomic::~win64_atomic
  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	5f		 pop	 rdi
  00025	5d		 pop	 rbp
  00026	c3		 ret	 0
?dtor$0@?0???0CBufPool@@QEAA@XZ@4HA ENDP		; `CBufPool::CBufPool'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\combufpool.h
;	COMDAT ?getSizeByIndex@@YAHH@Z
_TEXT	SEGMENT
nIdx$ = 16
?getSizeByIndex@@YAHH@Z PROC				; getSizeByIndex, COMDAT

; 52   : inline int getSizeByIndex(int nIdx) { return g_nSizeList[nIdx]; }

$LN3:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi
  00005	48 63 44 24 10	 movsxd	 rax, DWORD PTR nIdx$[rsp]
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_nSizeList@@3QBHB ; g_nSizeList
  00011	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00014	5f		 pop	 rdi
  00015	c3		 ret	 0
?getSizeByIndex@@YAHH@Z ENDP				; getSizeByIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\comtypes.h
;	COMDAT ?ISINCLUDE@@YA_NHH@Z
_TEXT	SEGMENT
i$ = 16
max$ = 24
?ISINCLUDE@@YA_NHH@Z PROC				; ISINCLUDE, COMDAT

; 322  : inline bool ISINCLUDE(int i, int max) { if (0 <= i && i < max) return true; return false; }

$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	57		 push	 rdi
  00009	83 7c 24 10 00	 cmp	 DWORD PTR i$[rsp], 0
  0000e	7c 0e		 jl	 SHORT $LN2@ISINCLUDE
  00010	8b 44 24 18	 mov	 eax, DWORD PTR max$[rsp]
  00014	39 44 24 10	 cmp	 DWORD PTR i$[rsp], eax
  00018	7d 04		 jge	 SHORT $LN2@ISINCLUDE
  0001a	b0 01		 mov	 al, 1
  0001c	eb 02		 jmp	 SHORT $LN1@ISINCLUDE
$LN2@ISINCLUDE:
  0001e	32 c0		 xor	 al, al
$LN1@ISINCLUDE:
  00020	5f		 pop	 rdi
  00021	c3		 ret	 0
?ISINCLUDE@@YA_NHH@Z ENDP				; ISINCLUDE
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\comtypes.h
;	COMDAT ?bitSet_flag@@YAXHPEAD@Z
_TEXT	SEGMENT
n$ = 16
p$ = 24
?bitSet_flag@@YAXHPEAD@Z PROC				; bitSet_flag, COMDAT

; 316  : inline void bitSet_flag(int n, char *p) {  p[n >> 3] |= (n & 7); }

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	57		 push	 rdi
  0000a	8b 44 24 10	 mov	 eax, DWORD PTR n$[rsp]
  0000e	c1 f8 03	 sar	 eax, 3
  00011	48 98		 cdqe
  00013	8b 4c 24 10	 mov	 ecx, DWORD PTR n$[rsp]
  00017	83 e1 07	 and	 ecx, 7
  0001a	48 8b 54 24 18	 mov	 rdx, QWORD PTR p$[rsp]
  0001f	0f be 04 02	 movsx	 eax, BYTE PTR [rdx+rax]
  00023	0b c1		 or	 eax, ecx
  00025	8b 4c 24 10	 mov	 ecx, DWORD PTR n$[rsp]
  00029	c1 f9 03	 sar	 ecx, 3
  0002c	48 63 c9	 movsxd	 rcx, ecx
  0002f	48 8b 54 24 18	 mov	 rdx, QWORD PTR p$[rsp]
  00034	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00037	5f		 pop	 rdi
  00038	c3		 ret	 0
?bitSet_flag@@YAXHPEAD@Z ENDP				; bitSet_flag
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\comtypes.h
;	COMDAT ?bitClear_flag@@YAXHPEAD@Z
_TEXT	SEGMENT
n$ = 16
p$ = 24
?bitClear_flag@@YAXHPEAD@Z PROC				; bitClear_flag, COMDAT

; 315  : inline void bitClear_flag(int n, char *p) {  p[n >> 3] &= ~(n & 7); }

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	57		 push	 rdi
  0000a	8b 44 24 10	 mov	 eax, DWORD PTR n$[rsp]
  0000e	c1 f8 03	 sar	 eax, 3
  00011	48 98		 cdqe
  00013	8b 4c 24 10	 mov	 ecx, DWORD PTR n$[rsp]
  00017	83 e1 07	 and	 ecx, 7
  0001a	f7 d1		 not	 ecx
  0001c	48 8b 54 24 18	 mov	 rdx, QWORD PTR p$[rsp]
  00021	0f be 04 02	 movsx	 eax, BYTE PTR [rdx+rax]
  00025	23 c1		 and	 eax, ecx
  00027	8b 4c 24 10	 mov	 ecx, DWORD PTR n$[rsp]
  0002b	c1 f9 03	 sar	 ecx, 3
  0002e	48 63 c9	 movsxd	 rcx, ecx
  00031	48 8b 54 24 18	 mov	 rdx, QWORD PTR p$[rsp]
  00036	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00039	5f		 pop	 rdi
  0003a	c3		 ret	 0
?bitClear_flag@@YAXHPEAD@Z ENDP				; bitClear_flag
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\comtypes.h
;	COMDAT ?isBitSet_flag@@YA_NHPEAD@Z
_TEXT	SEGMENT
tv72 = 0
n$ = 32
p$ = 40
?isBitSet_flag@@YA_NHPEAD@Z PROC			; isBitSet_flag, COMDAT

; 314  : inline bool isBitSet_flag(int n, char *p) { return p[n >> 3] & (n & 7)?true:false; }  // 8bit char   .

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	57		 push	 rdi
  0000a	48 83 ec 10	 sub	 rsp, 16
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 04 00 00 00	 mov	 ecx, 4
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	8b 4c 24 20	 mov	 ecx, DWORD PTR [rsp+32]
  00021	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  00025	c1 f8 03	 sar	 eax, 3
  00028	48 98		 cdqe
  0002a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR p$[rsp]
  0002f	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00033	8b 4c 24 20	 mov	 ecx, DWORD PTR n$[rsp]
  00037	83 e1 07	 and	 ecx, 7
  0003a	23 c1		 and	 eax, ecx
  0003c	85 c0		 test	 eax, eax
  0003e	74 06		 je	 SHORT $LN3@isBitSet_f
  00040	c6 04 24 01	 mov	 BYTE PTR tv72[rsp], 1
  00044	eb 04		 jmp	 SHORT $LN4@isBitSet_f
$LN3@isBitSet_f:
  00046	c6 04 24 00	 mov	 BYTE PTR tv72[rsp], 0
$LN4@isBitSet_f:
  0004a	0f b6 04 24	 movzx	 eax, BYTE PTR tv72[rsp]
  0004e	48 83 c4 10	 add	 rsp, 16
  00052	5f		 pop	 rdi
  00053	c3		 ret	 0
?isBitSet_flag@@YA_NHPEAD@Z ENDP			; isBitSet_flag
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__flags$ = 72
??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z PROC		; common::win32::win64_atomic::`vector deleting destructor', COMDAT
$LN6:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 0c 00 00 00	 mov	 ecx, 12
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  00022	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  0002b	8b 44 24 48	 mov	 eax, DWORD PTR __flags$[rsp]
  0002f	83 e0 02	 and	 eax, 2
  00032	85 c0		 test	 eax, eax
  00034	74 59		 je	 SHORT $LN2@vector
  00036	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??1win64_atomic@win32@common@@QEAA@XZ ; common::win32::win64_atomic::~win64_atomic
  0003d	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00042	4c 8b 40 f8	 mov	 r8, QWORD PTR [rax-8]
  00046	ba 08 00 00 00	 mov	 edx, 8
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00050	e8 00 00 00 00	 call	 ??_M@YAXPEAX_K1P6AX0@Z@Z
  00055	90		 npad	 1
  00056	8b 44 24 48	 mov	 eax, DWORD PTR __flags$[rsp]
  0005a	83 e0 01	 and	 eax, 1
  0005d	85 c0		 test	 eax, eax
  0005f	74 23		 je	 SHORT $LN3@vector
  00061	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00066	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  0006a	48 8d 04 c5 08
	00 00 00	 lea	 rax, QWORD PTR [rax*8+8]
  00072	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00077	48 83 e9 08	 sub	 rcx, 8
  0007b	48 8b d0	 mov	 rdx, rax
  0007e	e8 00 00 00 00	 call	 ??_V@YAXPEAX_K@Z	; operator delete[]
  00083	90		 npad	 1
$LN3@vector:
  00084	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00089	48 83 e8 08	 sub	 rax, 8
  0008d	eb 2b		 jmp	 SHORT $LN1@vector
$LN2@vector:
  0008f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00094	e8 00 00 00 00	 call	 ??1win64_atomic@win32@common@@QEAA@XZ ; common::win32::win64_atomic::~win64_atomic
  00099	90		 npad	 1
  0009a	8b 44 24 48	 mov	 eax, DWORD PTR __flags$[rsp]
  0009e	83 e0 01	 and	 eax, 1
  000a1	85 c0		 test	 eax, eax
  000a3	74 10		 je	 SHORT $LN4@vector
  000a5	ba 08 00 00 00	 mov	 edx, 8
  000aa	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000af	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  000b4	90		 npad	 1
$LN4@vector:
  000b5	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
$LN1@vector:
  000ba	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000be	5f		 pop	 rdi
  000bf	c3		 ret	 0
??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z ENDP		; common::win32::win64_atomic::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ?atomic_compare_exchange@win64_atomic@win32@common@@QEAA_J_J0@Z
_TEXT	SEGMENT
tv70 = 0
this$ = 32
nExchange$ = 40
nComperand$ = 48
?atomic_compare_exchange@win64_atomic@win32@common@@QEAA_J_J0@Z PROC ; common::win32::win64_atomic::atomic_compare_exchange, COMDAT

; 120  : 	inline long long atomic_compare_exchange(long long nExchange, long long nComperand) {return InterlockedCompareExchange64(&m_count, nExchange, nComperand);} // return long

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 10	 sub	 rsp, 16
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 04 00 00 00	 mov	 ecx, 4
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 20	 mov	 rcx, QWORD PTR [rsp+32]
  00028	48 8b 44 24 20	 mov	 rax, QWORD PTR this$[rsp]
  0002d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR nExchange$[rsp]
  00032	48 89 04 24	 mov	 QWORD PTR tv70[rsp], rax
  00036	48 8b 44 24 30	 mov	 rax, QWORD PTR nComperand$[rsp]
  0003b	48 8b 14 24	 mov	 rdx, QWORD PTR tv70[rsp]
  0003f	48 8b 14 24	 mov	 rdx, QWORD PTR tv70[rsp]
  00043	f0 48 0f b1 0a	 lock cmpxchg QWORD PTR [rdx], rcx
  00048	48 83 c4 10	 add	 rsp, 16
  0004c	5f		 pop	 rdi
  0004d	c3		 ret	 0
?atomic_compare_exchange@win64_atomic@win32@common@@QEAA_J_J0@Z ENDP ; common::win32::win64_atomic::atomic_compare_exchange
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ?atomic_decrement@win64_atomic@win32@common@@QEAA_JXZ
_TEXT	SEGMENT
this$ = 16
?atomic_decrement@win64_atomic@win32@common@@QEAA_JXZ PROC ; common::win32::win64_atomic::atomic_decrement, COMDAT

; 118  : 	inline long long atomic_decrement() { return InterlockedDecrement64(&m_count);}

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  0000b	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  00012	f0 48 0f c1 08	 lock xadd QWORD PTR [rax], rcx
  00017	48 ff c9	 dec	 rcx
  0001a	48 8b c1	 mov	 rax, rcx
  0001d	5f		 pop	 rdi
  0001e	c3		 ret	 0
?atomic_decrement@win64_atomic@win32@common@@QEAA_JXZ ENDP ; common::win32::win64_atomic::atomic_decrement
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ?atomic_increment@win64_atomic@win32@common@@QEAA_JXZ
_TEXT	SEGMENT
this$ = 16
?atomic_increment@win64_atomic@win32@common@@QEAA_JXZ PROC ; common::win32::win64_atomic::atomic_increment, COMDAT

; 117  : 	inline long long atomic_increment() { return InterlockedIncrement64(&m_count);}

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  0000b	b9 01 00 00 00	 mov	 ecx, 1
  00010	f0 48 0f c1 08	 lock xadd QWORD PTR [rax], rcx
  00015	48 ff c1	 inc	 rcx
  00018	48 8b c1	 mov	 rax, rcx
  0001b	5f		 pop	 rdi
  0001c	c3		 ret	 0
?atomic_increment@win64_atomic@win32@common@@QEAA_JXZ ENDP ; common::win32::win64_atomic::atomic_increment
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ?init@win64_atomic@win32@common@@QEAAXXZ
_TEXT	SEGMENT
this$ = 16
?init@win64_atomic@win32@common@@QEAAXXZ PROC		; common::win32::win64_atomic::init, COMDAT

; 114  : 	inline void init() { m_count = 0; }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  0000b	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  00012	5f		 pop	 rdi
  00013	c3		 ret	 0
?init@win64_atomic@win32@common@@QEAAXXZ ENDP		; common::win32::win64_atomic::init
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ?getCount@win64_atomic@win32@common@@QEAAHXZ
_TEXT	SEGMENT
this$ = 16
?getCount@win64_atomic@win32@common@@QEAAHXZ PROC	; common::win32::win64_atomic::getCount, COMDAT

; 111  : 	inline int getCount() { return (int)m_count; }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  0000b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0000e	5f		 pop	 rdi
  0000f	c3		 ret	 0
?getCount@win64_atomic@win32@common@@QEAAHXZ ENDP	; common::win32::win64_atomic::getCount
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ??1win64_atomic@win32@common@@QEAA@XZ
_TEXT	SEGMENT
this$ = 16
??1win64_atomic@win32@common@@QEAA@XZ PROC		; common::win32::win64_atomic::~win64_atomic, COMDAT

; 108  : 	~win64_atomic() {}

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	5f		 pop	 rdi
  00007	c3		 ret	 0
??1win64_atomic@win32@common@@QEAA@XZ ENDP		; common::win32::win64_atomic::~win64_atomic
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ??0win64_atomic@win32@common@@QEAA@XZ
_TEXT	SEGMENT
this$ = 16
??0win64_atomic@win32@common@@QEAA@XZ PROC		; common::win32::win64_atomic::win64_atomic, COMDAT

; 107  : 	win64_atomic() {m_count = 0;}

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  0000b	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  00012	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  00017	5f		 pop	 rdi
  00018	c3		 ret	 0
??0win64_atomic@win32@common@@QEAA@XZ ENDP		; common::win32::win64_atomic::win64_atomic
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 56
__$ArrayPad$ = 80
_Buffer$ = 112
_Format$ = 120
sprintf	PROC						; COMDAT

; 1776 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	57		 push	 rdi
  00015	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 18 00 00 00	 mov	 ecx, 24
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 70	 mov	 rcx, QWORD PTR [rsp+112]
  0002d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00034	48 33 c4	 xor	 rax, rsp
  00037	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

  0003c	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
  00041	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR _Format$[rsp+8]
  00049	48 89 44 24 38	 mov	 QWORD PTR _ArgList$[rsp], rax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0004e	4c 8b 4c 24 38	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00053	45 33 c0	 xor	 r8d, r8d
  00056	48 8b 54 24 78	 mov	 rdx, QWORD PTR _Format$[rsp]
  0005b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00060	e8 00 00 00 00	 call	 _vsprintf_l
  00065	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

  00069	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 1787 :     return _Result;

  00072	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 1788 : }

  00076	8b f8		 mov	 edi, eax
  00078	48 8b cc	 mov	 rcx, rsp
  0007b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:sprintf$rtcFrameData
  00082	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00087	8b c7		 mov	 eax, edi
  00089	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0008e	48 33 cc	 xor	 rcx, rsp
  00091	e8 00 00 00 00	 call	 __security_check_cookie
  00096	48 83 c4 60	 add	 rsp, 96			; 00000060H
  0009a	5f		 pop	 rdi
  0009b	c3		 ret	 0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1455 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 0c 00 00 00	 mov	 ecx, 12
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  0002d	48 8b 44 24 58	 mov	 rax, QWORD PTR _ArgList$[rsp]
  00032	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00037	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  0003c	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00041	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  00048	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0004d	e8 00 00 00 00	 call	 _vsnprintf_l

; 1459 :     #pragma warning(pop)
; 1460 : }

  00052	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00056	5f		 pop	 rdi
  00057	c3		 ret	 0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1385 : {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 10 00 00 00	 mov	 ecx, 16
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 1386 :     int const _Result = __stdio_common_vsprintf(

  0002d	e8 00 00 00 00	 call	 __local_stdio_printf_options
  00032	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00035	48 83 c8 01	 or	 rax, 1
  00039	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  0003e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00043	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00048	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0004d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR _Format$[rsp]
  00052	4c 8b 44 24 58	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  00057	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  0005c	48 8b c8	 mov	 rcx, rax
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsprintf
  00065	89 44 24 30	 mov	 DWORD PTR _Result$[rsp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00069	83 7c 24 30 00	 cmp	 DWORD PTR _Result$[rsp], 0
  0006e	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00070	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  00078	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0007a	8b 44 24 30	 mov	 eax, DWORD PTR _Result$[rsp]
  0007e	89 44 24 34	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00082	8b 44 24 34	 mov	 eax, DWORD PTR tv74[rsp]

; 1391 : }

  00086	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0008a	5f		 pop	 rdi
  0008b	c3		 ret	 0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ PROC ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>, COMDAT

; 144  :         {

$LN3:
  00000	40 57		 push	 rdi

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00002	5f		 pop	 rdi
  00003	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ENDP ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 73   : {

$LN3:
  00000	40 57		 push	 rdi

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00002	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00009	5f		 pop	 rdi
  0000a	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
