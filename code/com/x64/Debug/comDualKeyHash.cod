; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG45277 DB	'CBMemPool::pPool alloc ERROR', 00H
	ORG $+3
$SG45279 DB	'CBMemPool::pFlag alloc ERROR', 00H
	ORG $+3
$SG45280 DB	'CBMemPool __alloc m_nAllocCount[%d]', 00H
	ORG $+4
$SG45347 DB	'CBMemPool::pPool alloc ERROR', 00H
	ORG $+3
$SG45349 DB	'CBMemPool::pFlag alloc ERROR', 00H
	ORG $+3
$SG45350 DB	'CBMemPool __alloc m_nAllocCount[%d]', 00H
	ORG $+4
$SG45003 DB	'DUPLICATE_KEYS pKey1[%s] pHash->hashLookup(pKey2[%s])', 00H
	ORG $+2
$SG45004 DB	'CDKeyHashMap::addKey', 00H
	ORG $+3
$SG45010 DB	'errorNo[%d] new CHash(max:%d) key1:%s', 00H
	ORG $+2
$SG45011 DB	'CDKeyHashMap::addKey', 00H
	ORG $+3
$SG45012 DB	'new CHash(max:%d) key1:%s hashNo[%d]', 00H
	ORG $+3
$SG45018 DB	'errorNo[%d] pHash->addNode(pNext, %s)', 00H
CONST	ENDS
PUBLIC	?setHashValue@CHash@@QEAAXPEAX@Z		; CHash::setHashValue
PUBLIC	?__autoclassinit2@CHash@@QEAAX_K@Z		; CHash::__autoclassinit2
PUBLIC	??_GCHash@@QEAAPEAXI@Z				; CHash::`scalar deleting destructor'
PUBLIC	__local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	sprintf
PUBLIC	?c_memcpy@@YAPEAXPEAXPEBXH@Z			; c_memcpy
PUBLIC	?ISINCLUDE@@YA_NHH@Z				; ISINCLUDE
PUBLIC	?getIndex@@YAHH@Z				; getIndex
PUBLIC	?init@CMemManager@@QEAAXW4E_IDX_BUF@@H@Z	; CMemManager::init
PUBLIC	?newBuf@CMemManager@@QEAAPEADH@Z		; CMemManager::newBuf
PUBLIC	?newBuf@CMemManager@@QEAAPEADHPEAH@Z		; CMemManager::newBuf
PUBLIC	?delBuf@CMemManager@@QEAAXPEADH@Z		; CMemManager::delBuf
PUBLIC	??0CDKeyHashMap@@QEAA@HH_N@Z			; CDKeyHashMap::CDKeyHashMap
PUBLIC	??1CDKeyHashMap@@QEAA@XZ			; CDKeyHashMap::~CDKeyHashMap
PUBLIC	?addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z ; CDKeyHashMap::addKey
PUBLIC	?addKeyValue@CDKeyHashMap@@QEAAHPEAD0PEAX1@Z	; CDKeyHashMap::addKeyValue
PUBLIC	?setValue@CDKeyHashMap@@QEAAHPEAD0PEAX@Z	; CDKeyHashMap::setValue
PUBLIC	?deleteHash@CDKeyHashMap@@QEAA_NPEAD@Z		; CDKeyHashMap::deleteHash
PUBLIC	?deleteNode@CDKeyHashMap@@QEAA_NPEAD0@Z		; CDKeyHashMap::deleteNode
PUBLIC	?newValueBuf@CDKeyHashMap@@QEAAPEAUSTValue@@HPEAD@Z ; CDKeyHashMap::newValueBuf
PUBLIC	?delValueBuf@CDKeyHashMap@@QEAAXPEAUSTValue@@@Z	; CDKeyHashMap::delValueBuf
PUBLIC	?isNode@CDKeyHashMap@@QEAA_NPEAD0@Z		; CDKeyHashMap::isNode
PUBLIC	?getHashMap@CDKeyHashMap@@QEAAPEAVCHash@@PEAD@Z	; CDKeyHashMap::getHashMap
PUBLIC	?getNode@CDKeyHashMap@@QEAAPEAUSTHash_Node@@PEAD0@Z ; CDKeyHashMap::getNode
PUBLIC	??0?$CBMemPool@USTValue@@@@QEAA@W4E_ALLOC_TYPE@@@Z ; CBMemPool<STValue>::CBMemPool<STValue>
PUBLIC	??1?$CBMemPool@USTValue@@@@QEAA@XZ		; CBMemPool<STValue>::~CBMemPool<STValue>
PUBLIC	?alloc@?$CBMemPool@USTValue@@@@QEAAHH@Z		; CBMemPool<STValue>::alloc
PUBLIC	?newMem@?$CBMemPool@USTValue@@@@QEAAPEAUSTValue@@XZ ; CBMemPool<STValue>::newMem
PUBLIC	?delMem@?$CBMemPool@USTValue@@@@QEAA_NPEAUSTValue@@@Z ; CBMemPool<STValue>::delMem
PUBLIC	?__unit_alloc@?$CBMemPool@USTValue@@@@AEAAPEAUSTValue@@XZ ; CBMemPool<STValue>::__unit_alloc
PUBLIC	?__alloc@?$CBMemPool@USTValue@@@@AEAAHH@Z	; CBMemPool<STValue>::__alloc
PUBLIC	?__autoclassinit2@?$CBMemPool@USTValue@@@@QEAAX_K@Z ; CBMemPool<STValue>::__autoclassinit2
PUBLIC	??_G?$CBMemPool@USTValue@@@@QEAAPEAXI@Z		; CBMemPool<STValue>::`scalar deleting destructor'
PUBLIC	??0?$CBMemPool@USThash_next@@@@QEAA@W4E_ALLOC_TYPE@@@Z ; CBMemPool<SThash_next>::CBMemPool<SThash_next>
PUBLIC	??1?$CBMemPool@USThash_next@@@@QEAA@XZ		; CBMemPool<SThash_next>::~CBMemPool<SThash_next>
PUBLIC	?alloc@?$CBMemPool@USThash_next@@@@QEAAHH@Z	; CBMemPool<SThash_next>::alloc
PUBLIC	?newMem@?$CBMemPool@USThash_next@@@@QEAAPEAUSThash_next@@XZ ; CBMemPool<SThash_next>::newMem
PUBLIC	?delMem@?$CBMemPool@USThash_next@@@@QEAA_NPEAUSThash_next@@@Z ; CBMemPool<SThash_next>::delMem
PUBLIC	?__unit_alloc@?$CBMemPool@USThash_next@@@@AEAAPEAUSThash_next@@XZ ; CBMemPool<SThash_next>::__unit_alloc
PUBLIC	?__alloc@?$CBMemPool@USThash_next@@@@AEAAHH@Z	; CBMemPool<SThash_next>::__alloc
PUBLIC	?__autoclassinit2@?$CBMemPool@USThash_next@@@@QEAAX_K@Z ; CBMemPool<SThash_next>::__autoclassinit2
PUBLIC	??_G?$CBMemPool@USThash_next@@@@QEAAPEAXI@Z	; CBMemPool<SThash_next>::`scalar deleting destructor'
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
EXTRN	??2@YAPEAX_K@Z:PROC				; operator new
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	??_V@YAXPEAX@Z:PROC				; operator delete[]
EXTRN	memset:PROC
EXTRN	strcpy:PROC
EXTRN	strlen:PROC
EXTRN	??0CHash@@QEAA@I@Z:PROC				; CHash::CHash
EXTRN	??1CHash@@QEAA@XZ:PROC				; CHash::~CHash
EXTRN	?hashLookup@CHash@@QEAAPEAUSTHash_Node@@PEAD@Z:PROC ; CHash::hashLookup
EXTRN	?getNext@CHash@@QEAAPEAUSThash_next@@I@Z:PROC	; CHash::getNext
EXTRN	?getNext@CHash@@QEAAPEAUSThash_next@@PEAD@Z:PROC ; CHash::getNext
EXTRN	?getNode@CHash@@QEAAPEAUSThash_next@@PEADPEAPEAU2@@Z:PROC ; CHash::getNode
EXTRN	?setValue@CHash@@QEAA?AW4HASH_RETURN_CODE@@IPEADPEAX@Z:PROC ; CHash::setValue
EXTRN	?addNode@CHash@@QEAAHPEAUSThash_next@@PEADPEAX@Z:PROC ; CHash::addNode
EXTRN	__imp___stdio_common_vsprintf:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	??2@YAPEAX_KAEBUnothrow_t@std@@@Z:PROC		; operator new
EXTRN	??_U@YAPEAX_KAEBUnothrow_t@std@@@Z:PROC		; operator new[]
EXTRN	??3@YAXPEAXAEBUnothrow_t@std@@@Z:PROC		; operator delete
EXTRN	?delBufByIndex@CMemManager@@QEAAXPEADH@Z:PROC	; CMemManager::delBufByIndex
EXTRN	?__newBuf@CMemManager@@AEAAPEADH_K@Z:PROC	; CMemManager::__newBuf
EXTRN	?PutLogQueue@CLogger@@QEAAXHPEBDZZ:PROC		; CLogger::PutLogQueue
EXTRN	?__debugLog@CLogger@@QEAAXHPEBDH0ZZ:PROC	; CLogger::__debugLog
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__CxxFrameHandler3:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	?nothrow@std@@3Unothrow_t@1@B:BYTE		; std::nothrow
EXTRN	?g_szMessage@@3PADA:BYTE			; g_szMessage
EXTRN	?gs_pMMgr@@3PEAVCMemManager@@EA:QWORD		; gs_pMMgr
EXTRN	?gs_cLogger@@3VCLogger@@A:BYTE			; gs_cLogger
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setHashValue@CHash@@QEAAXPEAX@Z DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?setHashValue@CHash@@QEAAXPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__autoclassinit2@CHash@@QEAAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?__autoclassinit2@CHash@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GCHash@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+81
	DD	imagerel $unwind$??_GCHash@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$__local_stdio_printf_options DD imagerel $LN3
	DD	imagerel $LN3+11
	DD	imagerel $unwind$__local_stdio_printf_options
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+4
	DD	imagerel $unwind$??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+140
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+156
	DD	imagerel $unwind$sprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?c_memcpy@@YAPEAXPEAXPEBXH@Z DD imagerel $LN5
	DD	imagerel $LN5+135
	DD	imagerel $unwind$?c_memcpy@@YAPEAXPEAXPEBXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ISINCLUDE@@YA_NHH@Z DD imagerel $LN4
	DD	imagerel $LN4+34
	DD	imagerel $unwind$?ISINCLUDE@@YA_NHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getIndex@@YAHH@Z DD imagerel $LN5
	DD	imagerel $LN5+162
	DD	imagerel $unwind$?getIndex@@YAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?init@CMemManager@@QEAAXW4E_IDX_BUF@@H@Z DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$?init@CMemManager@@QEAAXW4E_IDX_BUF@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?newBuf@CMemManager@@QEAAPEADH@Z DD imagerel $LN3
	DD	imagerel $LN3+75
	DD	imagerel $unwind$?newBuf@CMemManager@@QEAAPEADH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?newBuf@CMemManager@@QEAAPEADHPEAH@Z DD imagerel $LN3
	DD	imagerel $LN3+86
	DD	imagerel $unwind$?newBuf@CMemManager@@QEAAPEADHPEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?delBuf@CMemManager@@QEAAXPEADH@Z DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$?delBuf@CMemManager@@QEAAXPEADH@Z
pdata	ENDS
pdata	SEGMENT
$pdata$??0CDKeyHashMap@@QEAA@HH_N@Z DD imagerel $LN14
	DD	imagerel $LN14+725
	DD	imagerel $unwind$??0CDKeyHashMap@@QEAA@HH_N@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA DD imagerel ?dtor$0@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA
	DD	imagerel ?dtor$0@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA+40
	DD	imagerel $unwind$?dtor$0@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA
$pdata$?dtor$1@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA DD imagerel ?dtor$1@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA
	DD	imagerel ?dtor$1@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA+40
	DD	imagerel $unwind$?dtor$1@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA
$pdata$?dtor$2@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA DD imagerel ?dtor$2@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA
	DD	imagerel ?dtor$2@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA+40
	DD	imagerel $unwind$?dtor$2@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$??1CDKeyHashMap@@QEAA@XZ DD imagerel $LN22
	DD	imagerel $LN22+747
	DD	imagerel $unwind$??1CDKeyHashMap@@QEAA@XZ
$pdata$?addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z DD imagerel $LN18
	DD	imagerel $LN18+897
	DD	imagerel $unwind$?addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z@4HA DD imagerel ?dtor$0@?0??addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z@4HA
	DD	imagerel ?dtor$0@?0??addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z@4HA+42
	DD	imagerel $unwind$?dtor$0@?0??addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?addKeyValue@CDKeyHashMap@@QEAAHPEAD0PEAX1@Z DD imagerel $LN6
	DD	imagerel $LN6+221
	DD	imagerel $unwind$?addKeyValue@CDKeyHashMap@@QEAAHPEAD0PEAX1@Z
$pdata$?setValue@CDKeyHashMap@@QEAAHPEAD0PEAX@Z DD imagerel $LN6
	DD	imagerel $LN6+179
	DD	imagerel $unwind$?setValue@CDKeyHashMap@@QEAAHPEAD0PEAX@Z
$pdata$?deleteHash@CDKeyHashMap@@QEAA_NPEAD@Z DD imagerel $LN12
	DD	imagerel $LN12+419
	DD	imagerel $unwind$?deleteHash@CDKeyHashMap@@QEAA_NPEAD@Z
$pdata$?deleteNode@CDKeyHashMap@@QEAA_NPEAD0@Z DD imagerel $LN6
	DD	imagerel $LN6+250
	DD	imagerel $unwind$?deleteNode@CDKeyHashMap@@QEAA_NPEAD0@Z
$pdata$?newValueBuf@CDKeyHashMap@@QEAAPEAUSTValue@@HPEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+192
	DD	imagerel $unwind$?newValueBuf@CDKeyHashMap@@QEAAPEAUSTValue@@HPEAD@Z
$pdata$?delValueBuf@CDKeyHashMap@@QEAAXPEAUSTValue@@@Z DD imagerel $LN4
	DD	imagerel $LN4+102
	DD	imagerel $unwind$?delValueBuf@CDKeyHashMap@@QEAAXPEAUSTValue@@@Z
$pdata$?isNode@CDKeyHashMap@@QEAA_NPEAD0@Z DD imagerel $LN5
	DD	imagerel $LN5+118
	DD	imagerel $unwind$?isNode@CDKeyHashMap@@QEAA_NPEAD0@Z
$pdata$?getHashMap@CDKeyHashMap@@QEAAPEAVCHash@@PEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+74
	DD	imagerel $unwind$?getHashMap@CDKeyHashMap@@QEAAPEAVCHash@@PEAD@Z
$pdata$?getNode@CDKeyHashMap@@QEAAPEAUSTHash_Node@@PEAD0@Z DD imagerel $LN4
	DD	imagerel $LN4+111
	DD	imagerel $unwind$?getNode@CDKeyHashMap@@QEAAPEAUSTHash_Node@@PEAD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$CBMemPool@USTValue@@@@QEAA@W4E_ALLOC_TYPE@@@Z DD imagerel $LN3
	DD	imagerel $LN3+87
	DD	imagerel $unwind$??0?$CBMemPool@USTValue@@@@QEAA@W4E_ALLOC_TYPE@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$CBMemPool@USTValue@@@@QEAA@XZ DD imagerel $LN9
	DD	imagerel $LN9+177
	DD	imagerel $unwind$??1?$CBMemPool@USTValue@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?alloc@?$CBMemPool@USTValue@@@@QEAAHH@Z DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$?alloc@?$CBMemPool@USTValue@@@@QEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?newMem@?$CBMemPool@USTValue@@@@QEAAPEAUSTValue@@XZ DD imagerel $LN11
	DD	imagerel $LN11+303
	DD	imagerel $unwind$?newMem@?$CBMemPool@USTValue@@@@QEAAPEAUSTValue@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?delMem@?$CBMemPool@USTValue@@@@QEAA_NPEAUSTValue@@@Z DD imagerel $LN11
	DD	imagerel $LN11+265
	DD	imagerel $unwind$?delMem@?$CBMemPool@USTValue@@@@QEAA_NPEAUSTValue@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__unit_alloc@?$CBMemPool@USTValue@@@@AEAAPEAUSTValue@@XZ DD imagerel $LN8
	DD	imagerel $LN8+120
	DD	imagerel $unwind$?__unit_alloc@?$CBMemPool@USTValue@@@@AEAAPEAUSTValue@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__alloc@?$CBMemPool@USTValue@@@@AEAAHH@Z DD imagerel $LN10
	DD	imagerel $LN10+350
	DD	imagerel $unwind$?__alloc@?$CBMemPool@USTValue@@@@AEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__autoclassinit2@?$CBMemPool@USTValue@@@@QEAAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?__autoclassinit2@?$CBMemPool@USTValue@@@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$CBMemPool@USTValue@@@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+81
	DD	imagerel $unwind$??_G?$CBMemPool@USTValue@@@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$CBMemPool@USThash_next@@@@QEAA@W4E_ALLOC_TYPE@@@Z DD imagerel $LN3
	DD	imagerel $LN3+87
	DD	imagerel $unwind$??0?$CBMemPool@USThash_next@@@@QEAA@W4E_ALLOC_TYPE@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$CBMemPool@USThash_next@@@@QEAA@XZ DD imagerel $LN9
	DD	imagerel $LN9+177
	DD	imagerel $unwind$??1?$CBMemPool@USThash_next@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?alloc@?$CBMemPool@USThash_next@@@@QEAAHH@Z DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$?alloc@?$CBMemPool@USThash_next@@@@QEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?newMem@?$CBMemPool@USThash_next@@@@QEAAPEAUSThash_next@@XZ DD imagerel $LN11
	DD	imagerel $LN11+303
	DD	imagerel $unwind$?newMem@?$CBMemPool@USThash_next@@@@QEAAPEAUSThash_next@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?delMem@?$CBMemPool@USThash_next@@@@QEAA_NPEAUSThash_next@@@Z DD imagerel $LN11
	DD	imagerel $LN11+271
	DD	imagerel $unwind$?delMem@?$CBMemPool@USThash_next@@@@QEAA_NPEAUSThash_next@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__unit_alloc@?$CBMemPool@USThash_next@@@@AEAAPEAUSThash_next@@XZ DD imagerel $LN8
	DD	imagerel $LN8+120
	DD	imagerel $unwind$?__unit_alloc@?$CBMemPool@USThash_next@@@@AEAAPEAUSThash_next@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__alloc@?$CBMemPool@USThash_next@@@@AEAAHH@Z DD imagerel $LN10
	DD	imagerel $LN10+350
	DD	imagerel $unwind$?__alloc@?$CBMemPool@USThash_next@@@@AEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__autoclassinit2@?$CBMemPool@USThash_next@@@@QEAAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?__autoclassinit2@?$CBMemPool@USThash_next@@@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$CBMemPool@USThash_next@@@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+81
	DD	imagerel $unwind$??_G?$CBMemPool@USThash_next@@@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$CBMemPool@USThash_next@@@@QEAAPEAXI@Z DD 022201H
	DD	0700a320eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__autoclassinit2@?$CBMemPool@USThash_next@@@@QEAAX_K@Z DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__alloc@?$CBMemPool@USThash_next@@@@AEAAHH@Z DD 022201H
	DD	0700a920eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__unit_alloc@?$CBMemPool@USThash_next@@@@AEAAPEAUSThash_next@@XZ DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?delMem@?$CBMemPool@USThash_next@@@@QEAA_NPEAUSThash_next@@@Z DD 022301H
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?newMem@?$CBMemPool@USThash_next@@@@QEAAPEAUSThash_next@@XZ DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?alloc@?$CBMemPool@USThash_next@@@@QEAAHH@Z DD 022201H
	DD	0700a320eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$CBMemPool@USThash_next@@@@QEAA@XZ DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$CBMemPool@USThash_next@@@@QEAA@W4E_ALLOC_TYPE@@@Z DD 010a01H
	DD	0700aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$CBMemPool@USTValue@@@@QEAAPEAXI@Z DD 022201H
	DD	0700a320eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__autoclassinit2@?$CBMemPool@USTValue@@@@QEAAX_K@Z DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__alloc@?$CBMemPool@USTValue@@@@AEAAHH@Z DD 022201H
	DD	0700a920eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__unit_alloc@?$CBMemPool@USTValue@@@@AEAAPEAUSTValue@@XZ DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?delMem@?$CBMemPool@USTValue@@@@QEAA_NPEAUSTValue@@@Z DD 022301H
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?newMem@?$CBMemPool@USTValue@@@@QEAAPEAUSTValue@@XZ DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?alloc@?$CBMemPool@USTValue@@@@QEAAHH@Z DD 022201H
	DD	0700a320eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$CBMemPool@USTValue@@@@QEAA@XZ DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$CBMemPool@USTValue@@@@QEAA@W4E_ALLOC_TYPE@@@Z DD 010a01H
	DD	0700aH
xdata	ENDS
CONST	SEGMENT
	ORG $+2
$cppxdata$??0CDKeyHashMap@@QEAA@HH_N@Z DD 019930522H
	DD	03H
	DD	imagerel $stateUnwindMap$??0CDKeyHashMap@@QEAA@HH_N@Z
	DD	00H
	DD	00H
	DD	07H
	DD	imagerel $ip2state$??0CDKeyHashMap@@QEAA@HH_N@Z
	DD	058H
	DD	00H
	DD	01H
$cppxdata$??1CDKeyHashMap@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1CDKeyHashMap@@QEAA@XZ
	DD	088H
	DD	00H
	DD	05H
$cppxdata$?addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z
	DD	078H
	DD	00H
	DD	01H
?addKeyValue@CDKeyHashMap@@QEAAHPEAD0PEAX1@Z$rtcName$0 DB 070H ; CDKeyHashMap::addKeyValue
	DB	048H
	DB	061H
	DB	073H
	DB	068H
	DB	00H
	ORG $+2
?addKeyValue@CDKeyHashMap@@QEAAHPEAD0PEAX1@Z$rtcVarDesc DD 038H ; CDKeyHashMap::addKeyValue
	DD	08H
	DQ	FLAT:?addKeyValue@CDKeyHashMap@@QEAAHPEAD0PEAX1@Z$rtcName$0
	ORG $+48
?addKeyValue@CDKeyHashMap@@QEAAHPEAD0PEAX1@Z$rtcFrameData DD 01H ; CDKeyHashMap::addKeyValue
	DD	00H
	DQ	FLAT:?addKeyValue@CDKeyHashMap@@QEAAHPEAD0PEAX1@Z$rtcVarDesc
?newValueBuf@CDKeyHashMap@@QEAAPEAUSTValue@@HPEAD@Z$rtcName$0 DB 06eH ; CDKeyHashMap::newValueBuf
	DB	049H
	DB	064H
	DB	078H
	DB	00H
	ORG $+3
?newValueBuf@CDKeyHashMap@@QEAAPEAUSTValue@@HPEAD@Z$rtcFrameData DD 01H ; CDKeyHashMap::newValueBuf
	DD	00H
	DQ	FLAT:?newValueBuf@CDKeyHashMap@@QEAAPEAUSTValue@@HPEAD@Z$rtcVarDesc
	ORG $+8
?newValueBuf@CDKeyHashMap@@QEAAPEAUSTValue@@HPEAD@Z$rtcVarDesc DD 024H ; CDKeyHashMap::newValueBuf
	DD	04H
	DQ	FLAT:?newValueBuf@CDKeyHashMap@@QEAAPEAUSTValue@@HPEAD@Z$rtcName$0
CONST	ENDS
xdata	SEGMENT
$unwind$??0CDKeyHashMap@@QEAA@HH_N@Z DD 023b11H
	DD	07014f21bH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0CDKeyHashMap@@QEAA@HH_N@Z
$stateUnwindMap$??0CDKeyHashMap@@QEAA@HH_N@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$1@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$2@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA
$ip2state$??0CDKeyHashMap@@QEAA@HH_N@Z DD imagerel ??0CDKeyHashMap@@QEAA@HH_N@Z
	DD	0ffffffffH
	DD	imagerel ??0CDKeyHashMap@@QEAA@HH_N@Z+110
	DD	00H
	DD	imagerel ??0CDKeyHashMap@@QEAA@HH_N@Z+174
	DD	0ffffffffH
	DD	imagerel ??0CDKeyHashMap@@QEAA@HH_N@Z+241
	DD	01H
	DD	imagerel ??0CDKeyHashMap@@QEAA@HH_N@Z+307
	DD	0ffffffffH
	DD	imagerel ??0CDKeyHashMap@@QEAA@HH_N@Z+580
	DD	02H
	DD	imagerel ??0CDKeyHashMap@@QEAA@HH_N@Z+644
	DD	0ffffffffH
$unwind$?dtor$0@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
$unwind$?dtor$1@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
$unwind$?dtor$2@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
$unwind$??1CDKeyHashMap@@QEAA@XZ DD 033019H
	DD	016010dH
	DD	07006H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1CDKeyHashMap@@QEAA@XZ
$ip2state$??1CDKeyHashMap@@QEAA@XZ DD imagerel ??1CDKeyHashMap@@QEAA@XZ
	DD	0ffffffffH
$unwind$?addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z DD 033c11H
	DD	012011cH
	DD	07015H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z
$stateUnwindMap$?addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z@4HA
$ip2state$?addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z DD imagerel ?addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z
	DD	0ffffffffH
	DD	imagerel ?addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z+256
	DD	00H
	DD	imagerel ?addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z+320
	DD	0ffffffffH
$unwind$?dtor$0@?0??addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
$unwind$?addKeyValue@CDKeyHashMap@@QEAAHPEAD0PEAX1@Z DD 023c19H
	DD	07015b219H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$?setValue@CDKeyHashMap@@QEAAHPEAD0PEAX@Z DD 022d01H
	DD	070155219H
$unwind$?deleteHash@CDKeyHashMap@@QEAA_NPEAD@Z DD 022301H
	DD	0700bb20fH
$unwind$?deleteNode@CDKeyHashMap@@QEAA_NPEAD0@Z DD 022801H
	DD	070107214H
$unwind$?newValueBuf@CDKeyHashMap@@QEAAPEAUSTValue@@HPEAD@Z DD 023619H
	DD	0700fb213H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$?delValueBuf@CDKeyHashMap@@QEAAXPEAUSTValue@@@Z DD 022301H
	DD	0700b320fH
$unwind$?isNode@CDKeyHashMap@@QEAA_NPEAD0@Z DD 022801H
	DD	070105214H
$unwind$?getHashMap@CDKeyHashMap@@QEAAPEAVCHash@@PEAD@Z DD 022301H
	DD	0700b520fH
$unwind$?getNode@CDKeyHashMap@@QEAAPEAUSTHash_Node@@PEAD0@Z DD 022801H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?delBuf@CMemManager@@QEAAXPEADH@Z DD 022801H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?newBuf@CMemManager@@QEAAPEADHPEAH@Z DD 022701H
	DD	0700f3213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?newBuf@CMemManager@@QEAAPEADH@Z DD 022201H
	DD	0700a520eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?init@CMemManager@@QEAAXW4E_IDX_BUF@@H@Z DD 010f01H
	DD	0700fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getIndex@@YAHH@Z DD 021c01H
	DD	070059209H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?getIndex@@YAHH@Z$rtcName$0 DB 024H			; getIndex
	DB	053H
	DB	031H
	DB	00H
	ORG $+12
?getIndex@@YAHH@Z$rtcVarDesc DD 038H			; getIndex
	DD	08H
	DQ	FLAT:?getIndex@@YAHH@Z$rtcName$0
	ORG $+48
?getIndex@@YAHH@Z$rtcFrameData DD 01H			; getIndex
	DD	00H
	DQ	FLAT:?getIndex@@YAHH@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ISINCLUDE@@YA_NHH@Z DD 010901H
	DD	07009H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?c_memcpy@@YAPEAXPEAXPEBXH@Z DD 022801H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 023c19H
	DD	07015b219H
	DD	imagerel __GSHandlerCheck
	DD	050H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
sprintf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
sprintf$rtcVarDesc DD 038H
	DD	08H
	DQ	FLAT:sprintf$rtcName$0
	ORG $+48
sprintf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:sprintf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 022d01H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 022d01H
	DD	070157219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ DD 010201H
	DD	07002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$__local_stdio_printf_options DD 010201H
	DD	07002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GCHash@@QEAAPEAXI@Z DD 022201H
	DD	0700a320eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__autoclassinit2@CHash@@QEAAX_K@Z DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setHashValue@CHash@@QEAAXPEAX@Z DD 010b01H
	DD	0700bH
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_G?$CBMemPool@USThash_next@@@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$CBMemPool@USThash_next@@@@QEAAPEAXI@Z PROC	; CBMemPool<SThash_next>::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 08 00 00 00	 mov	 ecx, 8
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]
  00022	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00027	e8 00 00 00 00	 call	 ??1?$CBMemPool@USThash_next@@@@QEAA@XZ ; CBMemPool<SThash_next>::~CBMemPool<SThash_next>
  0002c	8b 44 24 38	 mov	 eax, DWORD PTR __flags$[rsp]
  00030	83 e0 01	 and	 eax, 1
  00033	85 c0		 test	 eax, eax
  00035	74 0f		 je	 SHORT $LN2@scalar
  00037	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0003c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00041	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00046	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0004b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004f	5f		 pop	 rdi
  00050	c3		 ret	 0
??_G?$CBMemPool@USThash_next@@@@QEAAPEAXI@Z ENDP	; CBMemPool<SThash_next>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?__autoclassinit2@?$CBMemPool@USThash_next@@@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 16
classSize$ = 24
?__autoclassinit2@?$CBMemPool@USThash_next@@@@QEAAX_K@Z PROC ; CBMemPool<SThash_next>::__autoclassinit2, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 8b 7c 24 10	 mov	 rdi, QWORD PTR this$[rsp]
  00010	33 c0		 xor	 eax, eax
  00012	48 8b 4c 24 18	 mov	 rcx, QWORD PTR classSize$[rsp]
  00017	f3 aa		 rep stosb
  00019	5f		 pop	 rdi
  0001a	c3		 ret	 0
?__autoclassinit2@?$CBMemPool@USThash_next@@@@QEAAX_K@Z ENDP ; CBMemPool<SThash_next>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\combmempool.h
;	COMDAT ?__alloc@?$CBMemPool@USThash_next@@@@AEAAHH@Z
_TEXT	SEGMENT
pPool$ = 32
pFlag$ = 40
$T1 = 48
tv65 = 56
tv70 = 64
this$ = 96
nMaxCount$ = 104
?__alloc@?$CBMemPool@USThash_next@@@@AEAAHH@Z PROC	; CBMemPool<SThash_next>::__alloc, COMDAT

; 104  : {	

$LN10:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 14 00 00 00	 mov	 ecx, 20
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]

; 105  : 	MEMTYPE* pPool;
; 106  : 	switch (m_nObjAllocType) {

  00022	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00027	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  0002a	89 44 24 38	 mov	 DWORD PTR tv65[rsp], eax
  0002e	83 7c 24 38 02	 cmp	 DWORD PTR tv65[rsp], 2
  00033	74 10		 je	 SHORT $LN4@alloc
  00035	83 7c 24 38 03	 cmp	 DWORD PTR tv65[rsp], 3
  0003a	74 4b		 je	 SHORT $LN5@alloc
  0003c	83 7c 24 38 05	 cmp	 DWORD PTR tv65[rsp], 5
  00041	74 02		 je	 SHORT $LN4@alloc
  00043	eb 5c		 jmp	 SHORT $LN6@alloc
$LN4@alloc:

; 107  : 	case eAlloc_Type_new		: 
; 108  : 	case eAlloc_Type_newArray	:	pPool = new (std::nothrow) MEMTYPE[nMaxCount]; break;

  00045	48 63 44 24 68	 movsxd	 rax, DWORD PTR nMaxCount$[rsp]
  0004a	48 89 44 24 40	 mov	 QWORD PTR tv70[rsp], rax
  0004f	b8 18 00 00 00	 mov	 eax, 24
  00054	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv70[rsp]
  00059	48 f7 e1	 mul	 rcx
  0005c	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  00063	48 0f 40 c1	 cmovo	 rax, rcx
  00067	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  0006e	48 8b c8	 mov	 rcx, rax
  00071	e8 00 00 00 00	 call	 ??_U@YAPEAX_KAEBUnothrow_t@std@@@Z ; operator new[]
  00076	48 89 44 24 30	 mov	 QWORD PTR $T1[rsp], rax
  0007b	48 8b 44 24 30	 mov	 rax, QWORD PTR $T1[rsp]
  00080	48 89 44 24 20	 mov	 QWORD PTR pPool$[rsp], rax
  00085	eb 23		 jmp	 SHORT $LN2@alloc
$LN5@alloc:

; 109  : 	case eAlloc_Type_alloc		:	pPool = (MEMTYPE *)calloc(nMaxCount, sizeof(MEMTYPE)); break;

  00087	48 63 44 24 68	 movsxd	 rax, DWORD PTR nMaxCount$[rsp]
  0008c	ba 18 00 00 00	 mov	 edx, 24
  00091	48 8b c8	 mov	 rcx, rax
  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  0009a	48 89 44 24 20	 mov	 QWORD PTR pPool$[rsp], rax
  0009f	eb 09		 jmp	 SHORT $LN2@alloc
$LN6@alloc:

; 110  : 	default: pPool=NULL;

  000a1	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR pPool$[rsp], 0
$LN2@alloc:

; 111  : 	}	
; 112  : 	if (!pPool) {

  000aa	48 83 7c 24 20
	00		 cmp	 QWORD PTR pPool$[rsp], 0
  000b0	75 1a		 jne	 SHORT $LN7@alloc

; 113  : 		_stprintf(g_szMessage, _T("CBMemPool::pPool alloc ERROR"));

  000b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45277
  000b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  000c0	e8 00 00 00 00	 call	 sprintf

; 114  : 		return 0;

  000c5	33 c0		 xor	 eax, eax
  000c7	e9 8c 00 00 00	 jmp	 $LN1@alloc
$LN7@alloc:

; 115  : 	}
; 116  : 
; 117  : 	char* pFlag = (char*)calloc(nMaxCount, sizeof(char));

  000cc	48 63 44 24 68	 movsxd	 rax, DWORD PTR nMaxCount$[rsp]
  000d1	ba 01 00 00 00	 mov	 edx, 1
  000d6	48 8b c8	 mov	 rcx, rax
  000d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  000df	48 89 44 24 28	 mov	 QWORD PTR pFlag$[rsp], rax

; 118  : 	if (!pFlag) {

  000e4	48 83 7c 24 28
	00		 cmp	 QWORD PTR pFlag$[rsp], 0
  000ea	75 22		 jne	 SHORT $LN8@alloc

; 119  : 		free(pPool);

  000ec	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pPool$[rsp]
  000f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 120  : 		_stprintf(g_szMessage, _T("CBMemPool::pFlag alloc ERROR"));

  000f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45279
  000fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  00105	e8 00 00 00 00	 call	 sprintf

; 121  : 		return 0;

  0010a	33 c0		 xor	 eax, eax
  0010c	eb 4a		 jmp	 SHORT $LN1@alloc
$LN8@alloc:

; 122  : 	}
; 123  : 	memset(pFlag, 0, sizeof(pFlag));

  0010e	41 b8 08 00 00
	00		 mov	 r8d, 8
  00114	33 d2		 xor	 edx, edx
  00116	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pFlag$[rsp]
  0011b	e8 00 00 00 00	 call	 memset

; 124  : 
; 125  : 	_stprintf(g_szMessage, _T("CBMemPool __alloc m_nAllocCount[%d]"), nMaxCount);

  00120	44 8b 44 24 68	 mov	 r8d, DWORD PTR nMaxCount$[rsp]
  00125	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45280
  0012c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  00133	e8 00 00 00 00	 call	 sprintf

; 126  : 	m_pChunk = pPool;

  00138	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  0013d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pPool$[rsp]
  00142	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 127  : 	m_nFlagArray = pFlag;

  00146	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  0014b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pFlag$[rsp]
  00150	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 128  : 	return nMaxCount;

  00154	8b 44 24 68	 mov	 eax, DWORD PTR nMaxCount$[rsp]
$LN1@alloc:

; 129  : }

  00158	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0015c	5f		 pop	 rdi
  0015d	c3		 ret	 0
?__alloc@?$CBMemPool@USThash_next@@@@AEAAHH@Z ENDP	; CBMemPool<SThash_next>::__alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\combmempool.h
;	COMDAT ?__unit_alloc@?$CBMemPool@USThash_next@@@@AEAAPEAUSThash_next@@XZ
_TEXT	SEGMENT
$T1 = 32
tv65 = 40
this$ = 64
?__unit_alloc@?$CBMemPool@USThash_next@@@@AEAAPEAUSThash_next@@XZ PROC ; CBMemPool<SThash_next>::__unit_alloc, COMDAT

; 134  : {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 135  : 	switch (m_nObjAllocType) {

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00023	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00026	89 44 24 28	 mov	 DWORD PTR tv65[rsp], eax
  0002a	83 7c 24 28 02	 cmp	 DWORD PTR tv65[rsp], 2
  0002f	74 10		 je	 SHORT $LN4@unit_alloc
  00031	83 7c 24 28 03	 cmp	 DWORD PTR tv65[rsp], 3
  00036	74 26		 je	 SHORT $LN5@unit_alloc
  00038	83 7c 24 28 05	 cmp	 DWORD PTR tv65[rsp], 5
  0003d	74 02		 je	 SHORT $LN4@unit_alloc
  0003f	eb 2f		 jmp	 SHORT $LN6@unit_alloc
$LN4@unit_alloc:

; 136  : 	case eAlloc_Type_new		:	
; 137  : 	case eAlloc_Type_newArray	:	return new (std::nothrow) MEMTYPE;

  00041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00048	b9 18 00 00 00	 mov	 ecx, 24
  0004d	e8 00 00 00 00	 call	 ??2@YAPEAX_KAEBUnothrow_t@std@@@Z ; operator new
  00052	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax
  00057	48 8b 44 24 20	 mov	 rax, QWORD PTR $T1[rsp]
  0005c	eb 14		 jmp	 SHORT $LN1@unit_alloc
$LN5@unit_alloc:

; 138  : 	case eAlloc_Type_alloc		:	return (MEMTYPE *)calloc(1, sizeof(MEMTYPE));

  0005e	ba 18 00 00 00	 mov	 edx, 24
  00063	b9 01 00 00 00	 mov	 ecx, 1
  00068	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  0006e	eb 02		 jmp	 SHORT $LN1@unit_alloc
$LN6@unit_alloc:

; 139  : 	default: return NULL;

  00070	33 c0		 xor	 eax, eax
$LN1@unit_alloc:

; 140  : 	}
; 141  : }

  00072	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00076	5f		 pop	 rdi
  00077	c3		 ret	 0
?__unit_alloc@?$CBMemPool@USThash_next@@@@AEAAPEAUSThash_next@@XZ ENDP ; CBMemPool<SThash_next>::__unit_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\combmempool.h
;	COMDAT ?delMem@?$CBMemPool@USThash_next@@@@QEAA_NPEAUSThash_next@@@Z
_TEXT	SEGMENT
nIdx$ = 32
$T1 = 40
tv86 = 48
tv90 = 56
this$ = 80
pUsedMem$ = 88
?delMem@?$CBMemPool@USThash_next@@@@QEAA_NPEAUSThash_next@@@Z PROC ; CBMemPool<SThash_next>::delMem, COMDAT

; 193  : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 10 00 00 00	 mov	 ecx, 16
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 194  : 	int nIdx = int(pUsedMem - m_pChunk);

  00023	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00028	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0002c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pUsedMem$[rsp]
  00031	48 2b c8	 sub	 rcx, rax
  00034	48 8b c1	 mov	 rax, rcx
  00037	48 99		 cdq
  00039	b9 18 00 00 00	 mov	 ecx, 24
  0003e	48 f7 f9	 idiv	 rcx
  00041	89 44 24 20	 mov	 DWORD PTR nIdx$[rsp], eax

; 195  : 
; 196  : 	if (ISINCLUDE(nIdx, m_nAllocCount)) {

  00045	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0004a	8b 50 08	 mov	 edx, DWORD PTR [rax+8]
  0004d	8b 4c 24 20	 mov	 ecx, DWORD PTR nIdx$[rsp]
  00051	e8 00 00 00 00	 call	 ?ISINCLUDE@@YA_NHH@Z	; ISINCLUDE
  00056	0f b6 c0	 movzx	 eax, al
  00059	85 c0		 test	 eax, eax
  0005b	74 2b		 je	 SHORT $LN4@delMem

; 197  : 		m_nFlagArray[nIdx] = 0;

  0005d	48 63 44 24 20	 movsxd	 rax, DWORD PTR nIdx$[rsp]
  00062	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00067	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0006b	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 198  : 		m_nUseCnt--;

  0006f	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00074	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00077	ff c8		 dec	 eax
  00079	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  0007e	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 199  : 		return true;

  00081	b0 01		 mov	 al, 1
  00083	e9 81 00 00 00	 jmp	 $LN1@delMem
$LN4@delMem:

; 200  : 	}
; 201  : 	if (m_bSlot) return false;

  00088	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0008d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00090	85 c0		 test	 eax, eax
  00092	74 04		 je	 SHORT $LN5@delMem
  00094	32 c0		 xor	 al, al
  00096	eb 71		 jmp	 SHORT $LN1@delMem
$LN5@delMem:

; 202  : 	switch (m_nObjAllocType) {

  00098	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0009d	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  000a0	89 44 24 30	 mov	 DWORD PTR tv86[rsp], eax
  000a4	83 7c 24 30 02	 cmp	 DWORD PTR tv86[rsp], 2
  000a9	74 10		 je	 SHORT $LN6@delMem
  000ab	83 7c 24 30 03	 cmp	 DWORD PTR tv86[rsp], 3
  000b0	74 4a		 je	 SHORT $LN7@delMem
  000b2	83 7c 24 30 05	 cmp	 DWORD PTR tv86[rsp], 5
  000b7	74 02		 je	 SHORT $LN6@delMem
  000b9	eb 4c		 jmp	 SHORT $LN2@delMem
$LN6@delMem:

; 203  : 	case eAlloc_Type_new:	
; 204  : 	case eAlloc_Type_newArray:	delete pUsedMem; break;

  000bb	48 8b 44 24 58	 mov	 rax, QWORD PTR pUsedMem$[rsp]
  000c0	48 89 44 24 28	 mov	 QWORD PTR $T1[rsp], rax
  000c5	ba 18 00 00 00	 mov	 edx, 24
  000ca	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T1[rsp]
  000cf	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  000d4	48 83 7c 24 28
	00		 cmp	 QWORD PTR $T1[rsp], 0
  000da	75 0b		 jne	 SHORT $LN9@delMem
  000dc	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tv90[rsp], 0
  000e5	eb 13		 jmp	 SHORT $LN10@delMem
$LN9@delMem:
  000e7	48 c7 44 24 58
	23 81 00 00	 mov	 QWORD PTR pUsedMem$[rsp], 33059 ; 00008123H
  000f0	48 8b 44 24 58	 mov	 rax, QWORD PTR pUsedMem$[rsp]
  000f5	48 89 44 24 38	 mov	 QWORD PTR tv90[rsp], rax
$LN10@delMem:
  000fa	eb 0b		 jmp	 SHORT $LN2@delMem
$LN7@delMem:

; 205  : 	case eAlloc_Type_alloc:	free(pUsedMem); break;

  000fc	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pUsedMem$[rsp]
  00101	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN2@delMem:

; 206  : 	}
; 207  : 	return false;

  00107	32 c0		 xor	 al, al
$LN1@delMem:

; 208  : }

  00109	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0010d	5f		 pop	 rdi
  0010e	c3		 ret	 0
?delMem@?$CBMemPool@USThash_next@@@@QEAA_NPEAUSThash_next@@@Z ENDP ; CBMemPool<SThash_next>::delMem
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\combmempool.h
;	COMDAT ?newMem@?$CBMemPool@USThash_next@@@@QEAAPEAUSThash_next@@XZ
_TEXT	SEGMENT
i$ = 32
j$ = 36
this$ = 64
?newMem@?$CBMemPool@USThash_next@@@@QEAAPEAUSThash_next@@XZ PROC ; CBMemPool<SThash_next>::newMem, COMDAT

; 145  : {

$LN11:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 146  : 	int i = m_nUseCnt, j;

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00023	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00026	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax

; 147  : 	if (m_nUseCnt == m_nAllocCount) {

  0002a	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00034	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  00037	39 48 04	 cmp	 DWORD PTR [rax+4], ecx
  0003a	75 22		 jne	 SHORT $LN5@newMem

; 148  : 		if (m_bSlot) return NULL;

  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00041	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00044	85 c0		 test	 eax, eax
  00046	74 07		 je	 SHORT $LN6@newMem
  00048	33 c0		 xor	 eax, eax
  0004a	e9 da 00 00 00	 jmp	 $LN1@newMem
$LN6@newMem:

; 149  : 		return __unit_alloc();

  0004f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00054	e8 00 00 00 00	 call	 ?__unit_alloc@?$CBMemPool@USThash_next@@@@AEAAPEAUSThash_next@@XZ ; CBMemPool<SThash_next>::__unit_alloc
  00059	e9 cb 00 00 00	 jmp	 $LN1@newMem
$LN5@newMem:

; 150  : 	}
; 151  : 	for (j = 0; j < m_nAllocCount; j++) {

  0005e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00066	eb 0a		 jmp	 SHORT $LN4@newMem
$LN2@newMem:
  00068	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  0006c	ff c0		 inc	 eax
  0006e	89 44 24 24	 mov	 DWORD PTR j$[rsp], eax
$LN4@newMem:
  00072	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00077	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0007a	39 44 24 24	 cmp	 DWORD PTR j$[rsp], eax
  0007e	0f 8d 8b 00 00
	00		 jge	 $LN3@newMem

; 152  : 		if (i >= m_nAllocCount) { i = 0; }

  00084	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00089	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0008c	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00090	7c 08		 jl	 SHORT $LN7@newMem
  00092	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
$LN7@newMem:

; 153  : 		if (!m_nFlagArray[i]) {

  0009a	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0009f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000a4	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000a8	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  000ac	85 c0		 test	 eax, eax
  000ae	75 5a		 jne	 SHORT $LN8@newMem

; 154  : 			m_nFlagArray[i] = 1;

  000b0	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000b5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000ba	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000be	c6 04 01 01	 mov	 BYTE PTR [rcx+rax], 1

; 155  : 			memset(&m_pChunk[i], 0, sizeof(MEMTYPE));

  000c2	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000c7	48 6b c0 18	 imul	 rax, rax, 24
  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000d0	48 03 41 18	 add	 rax, QWORD PTR [rcx+24]
  000d4	41 b8 18 00 00
	00		 mov	 r8d, 24
  000da	33 d2		 xor	 edx, edx
  000dc	48 8b c8	 mov	 rcx, rax
  000df	e8 00 00 00 00	 call	 memset

; 156  : 			m_nUseCnt++;

  000e4	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000e9	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  000ec	ff c0		 inc	 eax
  000ee	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000f3	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 157  : 			return &m_pChunk[i];

  000f6	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000fb	48 6b c0 18	 imul	 rax, rax, 24
  000ff	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00104	48 03 41 18	 add	 rax, QWORD PTR [rcx+24]
  00108	eb 1f		 jmp	 SHORT $LN1@newMem
$LN8@newMem:

; 158  : 		}
; 159  : 	}

  0010a	e9 59 ff ff ff	 jmp	 $LN2@newMem
$LN3@newMem:

; 160  : 	if (m_bSlot) return NULL;

  0010f	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00114	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00117	85 c0		 test	 eax, eax
  00119	74 04		 je	 SHORT $LN9@newMem
  0011b	33 c0		 xor	 eax, eax
  0011d	eb 0a		 jmp	 SHORT $LN1@newMem
$LN9@newMem:

; 161  : 	return __unit_alloc();

  0011f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00124	e8 00 00 00 00	 call	 ?__unit_alloc@?$CBMemPool@USThash_next@@@@AEAAPEAUSThash_next@@XZ ; CBMemPool<SThash_next>::__unit_alloc
$LN1@newMem:

; 162  : }

  00129	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0012d	5f		 pop	 rdi
  0012e	c3		 ret	 0
?newMem@?$CBMemPool@USThash_next@@@@QEAAPEAUSThash_next@@XZ ENDP ; CBMemPool<SThash_next>::newMem
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\combmempool.h
;	COMDAT ?alloc@?$CBMemPool@USThash_next@@@@QEAAHH@Z
_TEXT	SEGMENT
this$ = 48
nMaxCount$ = 56
?alloc@?$CBMemPool@USThash_next@@@@QEAAHH@Z PROC	; CBMemPool<SThash_next>::alloc, COMDAT

; 32   : 	inline int alloc(int nMaxCount) { m_nAllocCount = __alloc(nMaxCount); return m_nAllocCount; }

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 08 00 00 00	 mov	 ecx, 8
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]
  00022	8b 54 24 38	 mov	 edx, DWORD PTR nMaxCount$[rsp]
  00026	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002b	e8 00 00 00 00	 call	 ?__alloc@?$CBMemPool@USThash_next@@@@AEAAHH@Z ; CBMemPool<SThash_next>::__alloc
  00030	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00035	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  00038	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0003d	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00040	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00044	5f		 pop	 rdi
  00045	c3		 ret	 0
?alloc@?$CBMemPool@USThash_next@@@@QEAAHH@Z ENDP	; CBMemPool<SThash_next>::alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\combmempool.h
;	COMDAT ??1?$CBMemPool@USThash_next@@@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
tv67 = 40
this$ = 64
??1?$CBMemPool@USThash_next@@@@QEAA@XZ PROC		; CBMemPool<SThash_next>::~CBMemPool<SThash_next>, COMDAT

; 85   : {

$LN9:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 86   : 	if (m_pChunk) {

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00023	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00028	74 59		 je	 SHORT $LN4@CBMemPool

; 87   : 		switch (m_nObjAllocType) {

  0002a	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0002f	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00032	89 44 24 28	 mov	 DWORD PTR tv67[rsp], eax
  00036	83 7c 24 28 02	 cmp	 DWORD PTR tv67[rsp], 2
  0003b	74 10		 je	 SHORT $LN5@CBMemPool
  0003d	83 7c 24 28 03	 cmp	 DWORD PTR tv67[rsp], 3
  00042	74 23		 je	 SHORT $LN6@CBMemPool
  00044	83 7c 24 28 05	 cmp	 DWORD PTR tv67[rsp], 5
  00049	74 02		 je	 SHORT $LN5@CBMemPool
  0004b	eb 29		 jmp	 SHORT $LN2@CBMemPool
$LN5@CBMemPool:

; 88   : 		case eAlloc_Type_new:		
; 89   : 		case eAlloc_Type_newArray:	delete[] m_pChunk;	break;

  0004d	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00052	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00056	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax
  0005b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR $T1[rsp]
  00060	e8 00 00 00 00	 call	 ??_V@YAXPEAX@Z		; operator delete[]
  00065	eb 0f		 jmp	 SHORT $LN2@CBMemPool
$LN6@CBMemPool:

; 90   : 		case eAlloc_Type_alloc:		free(m_pChunk);		break;

  00067	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0006c	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00070	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN2@CBMemPool:

; 91   : 		}
; 92   : 
; 93   : 		m_pChunk = NULL;

  00076	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0007b	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0
$LN4@CBMemPool:

; 94   : 	}
; 95   : 
; 96   : 	if (m_nFlagArray) {

  00083	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00088	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0008d	74 1c		 je	 SHORT $LN7@CBMemPool

; 97   : 		free(m_nFlagArray);

  0008f	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00094	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00098	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 98   : 		m_nFlagArray = NULL;

  0009e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000a3	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0
$LN7@CBMemPool:

; 99   : 	}
; 100  : }

  000ab	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000af	5f		 pop	 rdi
  000b0	c3		 ret	 0
??1?$CBMemPool@USThash_next@@@@QEAA@XZ ENDP		; CBMemPool<SThash_next>::~CBMemPool<SThash_next>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\combmempool.h
;	COMDAT ??0?$CBMemPool@USThash_next@@@@QEAA@W4E_ALLOC_TYPE@@@Z
_TEXT	SEGMENT
this$ = 16
nType$ = 24
??0?$CBMemPool@USThash_next@@@@QEAA@W4E_ALLOC_TYPE@@@Z PROC ; CBMemPool<SThash_next>::CBMemPool<SThash_next>, COMDAT

; 74   : {

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi

; 75   : 	m_nAllocCount = 0;

  0000a	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  0000f	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0

; 76   : 	m_pChunk = NULL;

  00016	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  0001b	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 77   : 	m_nUseCnt = 0;

  00023	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  00028	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0

; 78   : 	m_nFlagArray = NULL;

  0002f	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  00034	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 79   : 	m_nObjAllocType = nType;

  0003c	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  00041	8b 4c 24 18	 mov	 ecx, DWORD PTR nType$[rsp]
  00045	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 80   : 	m_bSlot = false;

  00048	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  0004d	c6 00 00	 mov	 BYTE PTR [rax], 0

; 81   : }

  00050	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  00055	5f		 pop	 rdi
  00056	c3		 ret	 0
??0?$CBMemPool@USThash_next@@@@QEAA@W4E_ALLOC_TYPE@@@Z ENDP ; CBMemPool<SThash_next>::CBMemPool<SThash_next>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_G?$CBMemPool@USTValue@@@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$CBMemPool@USTValue@@@@QEAAPEAXI@Z PROC		; CBMemPool<STValue>::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 08 00 00 00	 mov	 ecx, 8
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]
  00022	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00027	e8 00 00 00 00	 call	 ??1?$CBMemPool@USTValue@@@@QEAA@XZ ; CBMemPool<STValue>::~CBMemPool<STValue>
  0002c	8b 44 24 38	 mov	 eax, DWORD PTR __flags$[rsp]
  00030	83 e0 01	 and	 eax, 1
  00033	85 c0		 test	 eax, eax
  00035	74 0f		 je	 SHORT $LN2@scalar
  00037	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0003c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00041	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00046	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0004b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004f	5f		 pop	 rdi
  00050	c3		 ret	 0
??_G?$CBMemPool@USTValue@@@@QEAAPEAXI@Z ENDP		; CBMemPool<STValue>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?__autoclassinit2@?$CBMemPool@USTValue@@@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 16
classSize$ = 24
?__autoclassinit2@?$CBMemPool@USTValue@@@@QEAAX_K@Z PROC ; CBMemPool<STValue>::__autoclassinit2, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 8b 7c 24 10	 mov	 rdi, QWORD PTR this$[rsp]
  00010	33 c0		 xor	 eax, eax
  00012	48 8b 4c 24 18	 mov	 rcx, QWORD PTR classSize$[rsp]
  00017	f3 aa		 rep stosb
  00019	5f		 pop	 rdi
  0001a	c3		 ret	 0
?__autoclassinit2@?$CBMemPool@USTValue@@@@QEAAX_K@Z ENDP ; CBMemPool<STValue>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\combmempool.h
;	COMDAT ?__alloc@?$CBMemPool@USTValue@@@@AEAAHH@Z
_TEXT	SEGMENT
pPool$ = 32
pFlag$ = 40
$T1 = 48
tv65 = 56
tv70 = 64
this$ = 96
nMaxCount$ = 104
?__alloc@?$CBMemPool@USTValue@@@@AEAAHH@Z PROC		; CBMemPool<STValue>::__alloc, COMDAT

; 104  : {	

$LN10:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 14 00 00 00	 mov	 ecx, 20
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]

; 105  : 	MEMTYPE* pPool;
; 106  : 	switch (m_nObjAllocType) {

  00022	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00027	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  0002a	89 44 24 38	 mov	 DWORD PTR tv65[rsp], eax
  0002e	83 7c 24 38 02	 cmp	 DWORD PTR tv65[rsp], 2
  00033	74 10		 je	 SHORT $LN4@alloc
  00035	83 7c 24 38 03	 cmp	 DWORD PTR tv65[rsp], 3
  0003a	74 4b		 je	 SHORT $LN5@alloc
  0003c	83 7c 24 38 05	 cmp	 DWORD PTR tv65[rsp], 5
  00041	74 02		 je	 SHORT $LN4@alloc
  00043	eb 5c		 jmp	 SHORT $LN6@alloc
$LN4@alloc:

; 107  : 	case eAlloc_Type_new		: 
; 108  : 	case eAlloc_Type_newArray	:	pPool = new (std::nothrow) MEMTYPE[nMaxCount]; break;

  00045	48 63 44 24 68	 movsxd	 rax, DWORD PTR nMaxCount$[rsp]
  0004a	48 89 44 24 40	 mov	 QWORD PTR tv70[rsp], rax
  0004f	b8 10 00 00 00	 mov	 eax, 16
  00054	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv70[rsp]
  00059	48 f7 e1	 mul	 rcx
  0005c	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  00063	48 0f 40 c1	 cmovo	 rax, rcx
  00067	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  0006e	48 8b c8	 mov	 rcx, rax
  00071	e8 00 00 00 00	 call	 ??_U@YAPEAX_KAEBUnothrow_t@std@@@Z ; operator new[]
  00076	48 89 44 24 30	 mov	 QWORD PTR $T1[rsp], rax
  0007b	48 8b 44 24 30	 mov	 rax, QWORD PTR $T1[rsp]
  00080	48 89 44 24 20	 mov	 QWORD PTR pPool$[rsp], rax
  00085	eb 23		 jmp	 SHORT $LN2@alloc
$LN5@alloc:

; 109  : 	case eAlloc_Type_alloc		:	pPool = (MEMTYPE *)calloc(nMaxCount, sizeof(MEMTYPE)); break;

  00087	48 63 44 24 68	 movsxd	 rax, DWORD PTR nMaxCount$[rsp]
  0008c	ba 10 00 00 00	 mov	 edx, 16
  00091	48 8b c8	 mov	 rcx, rax
  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  0009a	48 89 44 24 20	 mov	 QWORD PTR pPool$[rsp], rax
  0009f	eb 09		 jmp	 SHORT $LN2@alloc
$LN6@alloc:

; 110  : 	default: pPool=NULL;

  000a1	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR pPool$[rsp], 0
$LN2@alloc:

; 111  : 	}	
; 112  : 	if (!pPool) {

  000aa	48 83 7c 24 20
	00		 cmp	 QWORD PTR pPool$[rsp], 0
  000b0	75 1a		 jne	 SHORT $LN7@alloc

; 113  : 		_stprintf(g_szMessage, _T("CBMemPool::pPool alloc ERROR"));

  000b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45347
  000b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  000c0	e8 00 00 00 00	 call	 sprintf

; 114  : 		return 0;

  000c5	33 c0		 xor	 eax, eax
  000c7	e9 8c 00 00 00	 jmp	 $LN1@alloc
$LN7@alloc:

; 115  : 	}
; 116  : 
; 117  : 	char* pFlag = (char*)calloc(nMaxCount, sizeof(char));

  000cc	48 63 44 24 68	 movsxd	 rax, DWORD PTR nMaxCount$[rsp]
  000d1	ba 01 00 00 00	 mov	 edx, 1
  000d6	48 8b c8	 mov	 rcx, rax
  000d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  000df	48 89 44 24 28	 mov	 QWORD PTR pFlag$[rsp], rax

; 118  : 	if (!pFlag) {

  000e4	48 83 7c 24 28
	00		 cmp	 QWORD PTR pFlag$[rsp], 0
  000ea	75 22		 jne	 SHORT $LN8@alloc

; 119  : 		free(pPool);

  000ec	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pPool$[rsp]
  000f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 120  : 		_stprintf(g_szMessage, _T("CBMemPool::pFlag alloc ERROR"));

  000f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45349
  000fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  00105	e8 00 00 00 00	 call	 sprintf

; 121  : 		return 0;

  0010a	33 c0		 xor	 eax, eax
  0010c	eb 4a		 jmp	 SHORT $LN1@alloc
$LN8@alloc:

; 122  : 	}
; 123  : 	memset(pFlag, 0, sizeof(pFlag));

  0010e	41 b8 08 00 00
	00		 mov	 r8d, 8
  00114	33 d2		 xor	 edx, edx
  00116	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pFlag$[rsp]
  0011b	e8 00 00 00 00	 call	 memset

; 124  : 
; 125  : 	_stprintf(g_szMessage, _T("CBMemPool __alloc m_nAllocCount[%d]"), nMaxCount);

  00120	44 8b 44 24 68	 mov	 r8d, DWORD PTR nMaxCount$[rsp]
  00125	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45350
  0012c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  00133	e8 00 00 00 00	 call	 sprintf

; 126  : 	m_pChunk = pPool;

  00138	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  0013d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pPool$[rsp]
  00142	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 127  : 	m_nFlagArray = pFlag;

  00146	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  0014b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pFlag$[rsp]
  00150	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 128  : 	return nMaxCount;

  00154	8b 44 24 68	 mov	 eax, DWORD PTR nMaxCount$[rsp]
$LN1@alloc:

; 129  : }

  00158	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0015c	5f		 pop	 rdi
  0015d	c3		 ret	 0
?__alloc@?$CBMemPool@USTValue@@@@AEAAHH@Z ENDP		; CBMemPool<STValue>::__alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\combmempool.h
;	COMDAT ?__unit_alloc@?$CBMemPool@USTValue@@@@AEAAPEAUSTValue@@XZ
_TEXT	SEGMENT
$T1 = 32
tv65 = 40
this$ = 64
?__unit_alloc@?$CBMemPool@USTValue@@@@AEAAPEAUSTValue@@XZ PROC ; CBMemPool<STValue>::__unit_alloc, COMDAT

; 134  : {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 135  : 	switch (m_nObjAllocType) {

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00023	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00026	89 44 24 28	 mov	 DWORD PTR tv65[rsp], eax
  0002a	83 7c 24 28 02	 cmp	 DWORD PTR tv65[rsp], 2
  0002f	74 10		 je	 SHORT $LN4@unit_alloc
  00031	83 7c 24 28 03	 cmp	 DWORD PTR tv65[rsp], 3
  00036	74 26		 je	 SHORT $LN5@unit_alloc
  00038	83 7c 24 28 05	 cmp	 DWORD PTR tv65[rsp], 5
  0003d	74 02		 je	 SHORT $LN4@unit_alloc
  0003f	eb 2f		 jmp	 SHORT $LN6@unit_alloc
$LN4@unit_alloc:

; 136  : 	case eAlloc_Type_new		:	
; 137  : 	case eAlloc_Type_newArray	:	return new (std::nothrow) MEMTYPE;

  00041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00048	b9 10 00 00 00	 mov	 ecx, 16
  0004d	e8 00 00 00 00	 call	 ??2@YAPEAX_KAEBUnothrow_t@std@@@Z ; operator new
  00052	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax
  00057	48 8b 44 24 20	 mov	 rax, QWORD PTR $T1[rsp]
  0005c	eb 14		 jmp	 SHORT $LN1@unit_alloc
$LN5@unit_alloc:

; 138  : 	case eAlloc_Type_alloc		:	return (MEMTYPE *)calloc(1, sizeof(MEMTYPE));

  0005e	ba 10 00 00 00	 mov	 edx, 16
  00063	b9 01 00 00 00	 mov	 ecx, 1
  00068	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  0006e	eb 02		 jmp	 SHORT $LN1@unit_alloc
$LN6@unit_alloc:

; 139  : 	default: return NULL;

  00070	33 c0		 xor	 eax, eax
$LN1@unit_alloc:

; 140  : 	}
; 141  : }

  00072	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00076	5f		 pop	 rdi
  00077	c3		 ret	 0
?__unit_alloc@?$CBMemPool@USTValue@@@@AEAAPEAUSTValue@@XZ ENDP ; CBMemPool<STValue>::__unit_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\combmempool.h
;	COMDAT ?delMem@?$CBMemPool@USTValue@@@@QEAA_NPEAUSTValue@@@Z
_TEXT	SEGMENT
nIdx$ = 32
$T1 = 40
tv86 = 48
tv90 = 56
this$ = 80
pUsedMem$ = 88
?delMem@?$CBMemPool@USTValue@@@@QEAA_NPEAUSTValue@@@Z PROC ; CBMemPool<STValue>::delMem, COMDAT

; 193  : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 10 00 00 00	 mov	 ecx, 16
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 194  : 	int nIdx = int(pUsedMem - m_pChunk);

  00023	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00028	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0002c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pUsedMem$[rsp]
  00031	48 2b c8	 sub	 rcx, rax
  00034	48 8b c1	 mov	 rax, rcx
  00037	48 c1 f8 04	 sar	 rax, 4
  0003b	89 44 24 20	 mov	 DWORD PTR nIdx$[rsp], eax

; 195  : 
; 196  : 	if (ISINCLUDE(nIdx, m_nAllocCount)) {

  0003f	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00044	8b 50 08	 mov	 edx, DWORD PTR [rax+8]
  00047	8b 4c 24 20	 mov	 ecx, DWORD PTR nIdx$[rsp]
  0004b	e8 00 00 00 00	 call	 ?ISINCLUDE@@YA_NHH@Z	; ISINCLUDE
  00050	0f b6 c0	 movzx	 eax, al
  00053	85 c0		 test	 eax, eax
  00055	74 2b		 je	 SHORT $LN4@delMem

; 197  : 		m_nFlagArray[nIdx] = 0;

  00057	48 63 44 24 20	 movsxd	 rax, DWORD PTR nIdx$[rsp]
  0005c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00061	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00065	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 198  : 		m_nUseCnt--;

  00069	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0006e	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00071	ff c8		 dec	 eax
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00078	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 199  : 		return true;

  0007b	b0 01		 mov	 al, 1
  0007d	e9 81 00 00 00	 jmp	 $LN1@delMem
$LN4@delMem:

; 200  : 	}
; 201  : 	if (m_bSlot) return false;

  00082	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00087	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0008a	85 c0		 test	 eax, eax
  0008c	74 04		 je	 SHORT $LN5@delMem
  0008e	32 c0		 xor	 al, al
  00090	eb 71		 jmp	 SHORT $LN1@delMem
$LN5@delMem:

; 202  : 	switch (m_nObjAllocType) {

  00092	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00097	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  0009a	89 44 24 30	 mov	 DWORD PTR tv86[rsp], eax
  0009e	83 7c 24 30 02	 cmp	 DWORD PTR tv86[rsp], 2
  000a3	74 10		 je	 SHORT $LN6@delMem
  000a5	83 7c 24 30 03	 cmp	 DWORD PTR tv86[rsp], 3
  000aa	74 4a		 je	 SHORT $LN7@delMem
  000ac	83 7c 24 30 05	 cmp	 DWORD PTR tv86[rsp], 5
  000b1	74 02		 je	 SHORT $LN6@delMem
  000b3	eb 4c		 jmp	 SHORT $LN2@delMem
$LN6@delMem:

; 203  : 	case eAlloc_Type_new:	
; 204  : 	case eAlloc_Type_newArray:	delete pUsedMem; break;

  000b5	48 8b 44 24 58	 mov	 rax, QWORD PTR pUsedMem$[rsp]
  000ba	48 89 44 24 28	 mov	 QWORD PTR $T1[rsp], rax
  000bf	ba 10 00 00 00	 mov	 edx, 16
  000c4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T1[rsp]
  000c9	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  000ce	48 83 7c 24 28
	00		 cmp	 QWORD PTR $T1[rsp], 0
  000d4	75 0b		 jne	 SHORT $LN9@delMem
  000d6	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tv90[rsp], 0
  000df	eb 13		 jmp	 SHORT $LN10@delMem
$LN9@delMem:
  000e1	48 c7 44 24 58
	23 81 00 00	 mov	 QWORD PTR pUsedMem$[rsp], 33059 ; 00008123H
  000ea	48 8b 44 24 58	 mov	 rax, QWORD PTR pUsedMem$[rsp]
  000ef	48 89 44 24 38	 mov	 QWORD PTR tv90[rsp], rax
$LN10@delMem:
  000f4	eb 0b		 jmp	 SHORT $LN2@delMem
$LN7@delMem:

; 205  : 	case eAlloc_Type_alloc:	free(pUsedMem); break;

  000f6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pUsedMem$[rsp]
  000fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN2@delMem:

; 206  : 	}
; 207  : 	return false;

  00101	32 c0		 xor	 al, al
$LN1@delMem:

; 208  : }

  00103	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00107	5f		 pop	 rdi
  00108	c3		 ret	 0
?delMem@?$CBMemPool@USTValue@@@@QEAA_NPEAUSTValue@@@Z ENDP ; CBMemPool<STValue>::delMem
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\combmempool.h
;	COMDAT ?newMem@?$CBMemPool@USTValue@@@@QEAAPEAUSTValue@@XZ
_TEXT	SEGMENT
i$ = 32
j$ = 36
this$ = 64
?newMem@?$CBMemPool@USTValue@@@@QEAAPEAUSTValue@@XZ PROC ; CBMemPool<STValue>::newMem, COMDAT

; 145  : {

$LN11:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 146  : 	int i = m_nUseCnt, j;

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00023	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00026	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax

; 147  : 	if (m_nUseCnt == m_nAllocCount) {

  0002a	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00034	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  00037	39 48 04	 cmp	 DWORD PTR [rax+4], ecx
  0003a	75 22		 jne	 SHORT $LN5@newMem

; 148  : 		if (m_bSlot) return NULL;

  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00041	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00044	85 c0		 test	 eax, eax
  00046	74 07		 je	 SHORT $LN6@newMem
  00048	33 c0		 xor	 eax, eax
  0004a	e9 da 00 00 00	 jmp	 $LN1@newMem
$LN6@newMem:

; 149  : 		return __unit_alloc();

  0004f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00054	e8 00 00 00 00	 call	 ?__unit_alloc@?$CBMemPool@USTValue@@@@AEAAPEAUSTValue@@XZ ; CBMemPool<STValue>::__unit_alloc
  00059	e9 cb 00 00 00	 jmp	 $LN1@newMem
$LN5@newMem:

; 150  : 	}
; 151  : 	for (j = 0; j < m_nAllocCount; j++) {

  0005e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00066	eb 0a		 jmp	 SHORT $LN4@newMem
$LN2@newMem:
  00068	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  0006c	ff c0		 inc	 eax
  0006e	89 44 24 24	 mov	 DWORD PTR j$[rsp], eax
$LN4@newMem:
  00072	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00077	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0007a	39 44 24 24	 cmp	 DWORD PTR j$[rsp], eax
  0007e	0f 8d 8b 00 00
	00		 jge	 $LN3@newMem

; 152  : 		if (i >= m_nAllocCount) { i = 0; }

  00084	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00089	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0008c	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00090	7c 08		 jl	 SHORT $LN7@newMem
  00092	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
$LN7@newMem:

; 153  : 		if (!m_nFlagArray[i]) {

  0009a	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0009f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000a4	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000a8	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  000ac	85 c0		 test	 eax, eax
  000ae	75 5a		 jne	 SHORT $LN8@newMem

; 154  : 			m_nFlagArray[i] = 1;

  000b0	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000b5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000ba	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000be	c6 04 01 01	 mov	 BYTE PTR [rcx+rax], 1

; 155  : 			memset(&m_pChunk[i], 0, sizeof(MEMTYPE));

  000c2	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000c7	48 6b c0 10	 imul	 rax, rax, 16
  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000d0	48 03 41 18	 add	 rax, QWORD PTR [rcx+24]
  000d4	41 b8 10 00 00
	00		 mov	 r8d, 16
  000da	33 d2		 xor	 edx, edx
  000dc	48 8b c8	 mov	 rcx, rax
  000df	e8 00 00 00 00	 call	 memset

; 156  : 			m_nUseCnt++;

  000e4	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000e9	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  000ec	ff c0		 inc	 eax
  000ee	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000f3	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 157  : 			return &m_pChunk[i];

  000f6	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000fb	48 6b c0 10	 imul	 rax, rax, 16
  000ff	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00104	48 03 41 18	 add	 rax, QWORD PTR [rcx+24]
  00108	eb 1f		 jmp	 SHORT $LN1@newMem
$LN8@newMem:

; 158  : 		}
; 159  : 	}

  0010a	e9 59 ff ff ff	 jmp	 $LN2@newMem
$LN3@newMem:

; 160  : 	if (m_bSlot) return NULL;

  0010f	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00114	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00117	85 c0		 test	 eax, eax
  00119	74 04		 je	 SHORT $LN9@newMem
  0011b	33 c0		 xor	 eax, eax
  0011d	eb 0a		 jmp	 SHORT $LN1@newMem
$LN9@newMem:

; 161  : 	return __unit_alloc();

  0011f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00124	e8 00 00 00 00	 call	 ?__unit_alloc@?$CBMemPool@USTValue@@@@AEAAPEAUSTValue@@XZ ; CBMemPool<STValue>::__unit_alloc
$LN1@newMem:

; 162  : }

  00129	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0012d	5f		 pop	 rdi
  0012e	c3		 ret	 0
?newMem@?$CBMemPool@USTValue@@@@QEAAPEAUSTValue@@XZ ENDP ; CBMemPool<STValue>::newMem
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\combmempool.h
;	COMDAT ?alloc@?$CBMemPool@USTValue@@@@QEAAHH@Z
_TEXT	SEGMENT
this$ = 48
nMaxCount$ = 56
?alloc@?$CBMemPool@USTValue@@@@QEAAHH@Z PROC		; CBMemPool<STValue>::alloc, COMDAT

; 32   : 	inline int alloc(int nMaxCount) { m_nAllocCount = __alloc(nMaxCount); return m_nAllocCount; }

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 08 00 00 00	 mov	 ecx, 8
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]
  00022	8b 54 24 38	 mov	 edx, DWORD PTR nMaxCount$[rsp]
  00026	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002b	e8 00 00 00 00	 call	 ?__alloc@?$CBMemPool@USTValue@@@@AEAAHH@Z ; CBMemPool<STValue>::__alloc
  00030	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00035	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  00038	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0003d	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00040	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00044	5f		 pop	 rdi
  00045	c3		 ret	 0
?alloc@?$CBMemPool@USTValue@@@@QEAAHH@Z ENDP		; CBMemPool<STValue>::alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\combmempool.h
;	COMDAT ??1?$CBMemPool@USTValue@@@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
tv67 = 40
this$ = 64
??1?$CBMemPool@USTValue@@@@QEAA@XZ PROC			; CBMemPool<STValue>::~CBMemPool<STValue>, COMDAT

; 85   : {

$LN9:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 86   : 	if (m_pChunk) {

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00023	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00028	74 59		 je	 SHORT $LN4@CBMemPool

; 87   : 		switch (m_nObjAllocType) {

  0002a	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0002f	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00032	89 44 24 28	 mov	 DWORD PTR tv67[rsp], eax
  00036	83 7c 24 28 02	 cmp	 DWORD PTR tv67[rsp], 2
  0003b	74 10		 je	 SHORT $LN5@CBMemPool
  0003d	83 7c 24 28 03	 cmp	 DWORD PTR tv67[rsp], 3
  00042	74 23		 je	 SHORT $LN6@CBMemPool
  00044	83 7c 24 28 05	 cmp	 DWORD PTR tv67[rsp], 5
  00049	74 02		 je	 SHORT $LN5@CBMemPool
  0004b	eb 29		 jmp	 SHORT $LN2@CBMemPool
$LN5@CBMemPool:

; 88   : 		case eAlloc_Type_new:		
; 89   : 		case eAlloc_Type_newArray:	delete[] m_pChunk;	break;

  0004d	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00052	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00056	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax
  0005b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR $T1[rsp]
  00060	e8 00 00 00 00	 call	 ??_V@YAXPEAX@Z		; operator delete[]
  00065	eb 0f		 jmp	 SHORT $LN2@CBMemPool
$LN6@CBMemPool:

; 90   : 		case eAlloc_Type_alloc:		free(m_pChunk);		break;

  00067	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0006c	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00070	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN2@CBMemPool:

; 91   : 		}
; 92   : 
; 93   : 		m_pChunk = NULL;

  00076	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0007b	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0
$LN4@CBMemPool:

; 94   : 	}
; 95   : 
; 96   : 	if (m_nFlagArray) {

  00083	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00088	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0008d	74 1c		 je	 SHORT $LN7@CBMemPool

; 97   : 		free(m_nFlagArray);

  0008f	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00094	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00098	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 98   : 		m_nFlagArray = NULL;

  0009e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000a3	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0
$LN7@CBMemPool:

; 99   : 	}
; 100  : }

  000ab	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000af	5f		 pop	 rdi
  000b0	c3		 ret	 0
??1?$CBMemPool@USTValue@@@@QEAA@XZ ENDP			; CBMemPool<STValue>::~CBMemPool<STValue>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\combmempool.h
;	COMDAT ??0?$CBMemPool@USTValue@@@@QEAA@W4E_ALLOC_TYPE@@@Z
_TEXT	SEGMENT
this$ = 16
nType$ = 24
??0?$CBMemPool@USTValue@@@@QEAA@W4E_ALLOC_TYPE@@@Z PROC	; CBMemPool<STValue>::CBMemPool<STValue>, COMDAT

; 74   : {

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi

; 75   : 	m_nAllocCount = 0;

  0000a	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  0000f	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0

; 76   : 	m_pChunk = NULL;

  00016	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  0001b	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 77   : 	m_nUseCnt = 0;

  00023	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  00028	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0

; 78   : 	m_nFlagArray = NULL;

  0002f	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  00034	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 79   : 	m_nObjAllocType = nType;

  0003c	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  00041	8b 4c 24 18	 mov	 ecx, DWORD PTR nType$[rsp]
  00045	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 80   : 	m_bSlot = false;

  00048	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  0004d	c6 00 00	 mov	 BYTE PTR [rax], 0

; 81   : }

  00050	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  00055	5f		 pop	 rdi
  00056	c3		 ret	 0
??0?$CBMemPool@USTValue@@@@QEAA@W4E_ALLOC_TYPE@@@Z ENDP	; CBMemPool<STValue>::CBMemPool<STValue>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comdualkeyhash.cpp
_TEXT	SEGMENT
pNode$ = 32
pHash$1 = 40
this$ = 64
pKey1$ = 72
pKey2$ = 80
?getNode@CDKeyHashMap@@QEAAPEAUSTHash_Node@@PEAD0@Z PROC ; CDKeyHashMap::getNode

; 170  : {

$LN4:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 0c 00 00 00	 mov	 ecx, 12
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 171  : 	STHash_Node *pNode = m_pHashGroup->hashLookup(pKey1);

  00028	48 8b 54 24 48	 mov	 rdx, QWORD PTR pKey1$[rsp]
  0002d	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00032	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00036	e8 00 00 00 00	 call	 ?hashLookup@CHash@@QEAAPEAUSTHash_Node@@PEAD@Z ; CHash::hashLookup
  0003b	48 89 44 24 20	 mov	 QWORD PTR pNode$[rsp], rax

; 172  : 	if (pNode) {

  00040	48 83 7c 24 20
	00		 cmp	 QWORD PTR pNode$[rsp], 0
  00046	74 1f		 je	 SHORT $LN2@getNode

; 173  : 		CHash *pHash = (CHash *)pNode->value;

  00048	48 8b 44 24 20	 mov	 rax, QWORD PTR pNode$[rsp]
  0004d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00051	48 89 44 24 28	 mov	 QWORD PTR pHash$1[rsp], rax

; 174  : 		return pHash->hashLookup(pKey2);

  00056	48 8b 54 24 50	 mov	 rdx, QWORD PTR pKey2$[rsp]
  0005b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pHash$1[rsp]
  00060	e8 00 00 00 00	 call	 ?hashLookup@CHash@@QEAAPEAUSTHash_Node@@PEAD@Z ; CHash::hashLookup
  00065	eb 02		 jmp	 SHORT $LN1@getNode
$LN2@getNode:

; 175  : 	}
; 176  : 	return NULL;

  00067	33 c0		 xor	 eax, eax
$LN1@getNode:

; 177  : }

  00069	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006d	5f		 pop	 rdi
  0006e	c3		 ret	 0
?getNode@CDKeyHashMap@@QEAAPEAUSTHash_Node@@PEAD0@Z ENDP ; CDKeyHashMap::getNode
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comdualkeyhash.cpp
_TEXT	SEGMENT
pNode$ = 32
this$ = 64
pKey1$ = 72
?getHashMap@CDKeyHashMap@@QEAAPEAVCHash@@PEAD@Z PROC	; CDKeyHashMap::getHashMap

; 164  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 0c 00 00 00	 mov	 ecx, 12
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 165  : 	STHash_Node *pNode = m_pHashGroup->hashLookup(pKey1);

  00023	48 8b 54 24 48	 mov	 rdx, QWORD PTR pKey1$[rsp]
  00028	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0002d	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00031	e8 00 00 00 00	 call	 ?hashLookup@CHash@@QEAAPEAUSTHash_Node@@PEAD@Z ; CHash::hashLookup
  00036	48 89 44 24 20	 mov	 QWORD PTR pNode$[rsp], rax

; 166  : 	return (CHash *)pNode->value;		// return NULL 

  0003b	48 8b 44 24 20	 mov	 rax, QWORD PTR pNode$[rsp]
  00040	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 167  : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5f		 pop	 rdi
  00049	c3		 ret	 0
?getHashMap@CDKeyHashMap@@QEAAPEAVCHash@@PEAD@Z ENDP	; CDKeyHashMap::getHashMap
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comdualkeyhash.cpp
_TEXT	SEGMENT
pNode$ = 32
pHash$1 = 40
this$ = 64
pKey1$ = 72
pKey2$ = 80
?isNode@CDKeyHashMap@@QEAA_NPEAD0@Z PROC		; CDKeyHashMap::isNode

; 154  : {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 0c 00 00 00	 mov	 ecx, 12
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 155  : 	STHash_Node *pNode = m_pHashGroup->hashLookup(pKey1);

  00028	48 8b 54 24 48	 mov	 rdx, QWORD PTR pKey1$[rsp]
  0002d	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00032	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00036	e8 00 00 00 00	 call	 ?hashLookup@CHash@@QEAAPEAUSTHash_Node@@PEAD@Z ; CHash::hashLookup
  0003b	48 89 44 24 20	 mov	 QWORD PTR pNode$[rsp], rax

; 156  : 	if (pNode) {

  00040	48 83 7c 24 20
	00		 cmp	 QWORD PTR pNode$[rsp], 0
  00046	74 26		 je	 SHORT $LN2@isNode

; 157  : 		CHash *pHash = (CHash *)pNode->value;

  00048	48 8b 44 24 20	 mov	 rax, QWORD PTR pNode$[rsp]
  0004d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00051	48 89 44 24 28	 mov	 QWORD PTR pHash$1[rsp], rax

; 158  : 		if (pHash->hashLookup(pKey2)) return true;

  00056	48 8b 54 24 50	 mov	 rdx, QWORD PTR pKey2$[rsp]
  0005b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pHash$1[rsp]
  00060	e8 00 00 00 00	 call	 ?hashLookup@CHash@@QEAAPEAUSTHash_Node@@PEAD@Z ; CHash::hashLookup
  00065	48 85 c0	 test	 rax, rax
  00068	74 04		 je	 SHORT $LN3@isNode
  0006a	b0 01		 mov	 al, 1
  0006c	eb 02		 jmp	 SHORT $LN1@isNode
$LN3@isNode:
$LN2@isNode:

; 159  : 	}
; 160  : 	return false;

  0006e	32 c0		 xor	 al, al
$LN1@isNode:

; 161  : }

  00070	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00074	5f		 pop	 rdi
  00075	c3		 ret	 0
?isNode@CDKeyHashMap@@QEAA_NPEAD0@Z ENDP		; CDKeyHashMap::isNode
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comdualkeyhash.cpp
_TEXT	SEGMENT
this$ = 48
pValue$ = 56
?delValueBuf@CDKeyHashMap@@QEAAXPEAUSTValue@@@Z PROC	; CDKeyHashMap::delValueBuf

; 248  : { 

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 08 00 00 00	 mov	 ecx, 8
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]

; 249  : 	if (m_bValInternal) {

  00023	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00028	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  0002c	85 c0		 test	 eax, eax
  0002e	74 30		 je	 SHORT $LN2@delValueBu

; 250  : 		gs_pMMgr->delBufByIndex((TCHAR *)pValue->pValue, pValue->nIdx); m_pValue->delMem(pValue);

  00030	48 8b 44 24 38	 mov	 rax, QWORD PTR pValue$[rsp]
  00035	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  00038	48 8b 44 24 38	 mov	 rax, QWORD PTR pValue$[rsp]
  0003d	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00041	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  00048	e8 00 00 00 00	 call	 ?delBufByIndex@CMemManager@@QEAAXPEADH@Z ; CMemManager::delBufByIndex
  0004d	48 8b 54 24 38	 mov	 rdx, QWORD PTR pValue$[rsp]
  00052	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00057	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0005b	e8 00 00 00 00	 call	 ?delMem@?$CBMemPool@USTValue@@@@QEAA_NPEAUSTValue@@@Z ; CBMemPool<STValue>::delMem
$LN2@delValueBu:

; 251  : 	}
; 252  : 
; 253  : 	//   ...  
; 254  : } // value     

  00060	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00064	5f		 pop	 rdi
  00065	c3		 ret	 0
?delValueBuf@CDKeyHashMap@@QEAAXPEAUSTValue@@@Z ENDP	; CDKeyHashMap::delValueBuf
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comdualkeyhash.cpp
_TEXT	SEGMENT
nIdx$ = 36
pSTValue$ = 56
pValueBuf$ = 64
__$ArrayPad$ = 80
this$ = 112
size$ = 120
pValue$ = 128
?newValueBuf@CDKeyHashMap@@QEAAPEAUSTValue@@HPEAD@Z PROC ; CDKeyHashMap::newValueBuf

; 235  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 18 00 00 00	 mov	 ecx, 24
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 4c 24 70	 mov	 rcx, QWORD PTR [rsp+112]
  00027	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002e	48 33 c4	 xor	 rax, rsp
  00031	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 236  : 	int nIdx;
; 237  : 	STValue *pSTValue = m_pValue->newMem();

  00036	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  0003b	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0003f	e8 00 00 00 00	 call	 ?newMem@?$CBMemPool@USTValue@@@@QEAAPEAUSTValue@@XZ ; CBMemPool<STValue>::newMem
  00044	48 89 44 24 38	 mov	 QWORD PTR pSTValue$[rsp], rax

; 238  : 	TCHAR *pValueBuf = gs_pMMgr->newBuf(size, &nIdx);

  00049	4c 8d 44 24 24	 lea	 r8, QWORD PTR nIdx$[rsp]
  0004e	8b 54 24 78	 mov	 edx, DWORD PTR size$[rsp]
  00052	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  00059	e8 00 00 00 00	 call	 ?newBuf@CMemManager@@QEAAPEADHPEAH@Z ; CMemManager::newBuf
  0005e	48 89 44 24 40	 mov	 QWORD PTR pValueBuf$[rsp], rax

; 239  : 	c_memcpy(pValueBuf, pValue, size);

  00063	44 8b 44 24 78	 mov	 r8d, DWORD PTR size$[rsp]
  00068	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR pValue$[rsp]
  00070	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pValueBuf$[rsp]
  00075	e8 00 00 00 00	 call	 ?c_memcpy@@YAPEAXPEAXPEBXH@Z ; c_memcpy

; 240  : 	pSTValue->nIdx = nIdx;

  0007a	48 8b 44 24 38	 mov	 rax, QWORD PTR pSTValue$[rsp]
  0007f	8b 4c 24 24	 mov	 ecx, DWORD PTR nIdx$[rsp]
  00083	89 08		 mov	 DWORD PTR [rax], ecx

; 241  : 	pSTValue->pValue = pValueBuf;

  00085	48 8b 44 24 38	 mov	 rax, QWORD PTR pSTValue$[rsp]
  0008a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pValueBuf$[rsp]
  0008f	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 242  : 
; 243  : 	return pSTValue;

  00093	48 8b 44 24 38	 mov	 rax, QWORD PTR pSTValue$[rsp]

; 244  : }

  00098	48 8b f8	 mov	 rdi, rax
  0009b	48 8b cc	 mov	 rcx, rsp
  0009e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?newValueBuf@CDKeyHashMap@@QEAAPEAUSTValue@@HPEAD@Z$rtcFrameData
  000a5	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000aa	48 8b c7	 mov	 rax, rdi
  000ad	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000b2	48 33 cc	 xor	 rcx, rsp
  000b5	e8 00 00 00 00	 call	 __security_check_cookie
  000ba	48 83 c4 60	 add	 rsp, 96			; 00000060H
  000be	5f		 pop	 rdi
  000bf	c3		 ret	 0
?newValueBuf@CDKeyHashMap@@QEAAPEAUSTValue@@HPEAD@Z ENDP ; CDKeyHashMap::newValueBuf
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comdualkeyhash.cpp
_TEXT	SEGMENT
ppPrev$ = 32
pNext1$ = 40
pCur2$ = 48
pHash$1 = 56
this$ = 80
pKey1$ = 88
pKey2$ = 96
?deleteNode@CDKeyHashMap@@QEAA_NPEAD0@Z PROC		; CDKeyHashMap::deleteNode

; 212  : {

$LN6:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 10 00 00 00	 mov	 ecx, 16
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 213  : 	SThash_next **ppPrev=NULL;

  00028	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR ppPrev$[rsp], 0

; 214  : 	SThash_next *pNext1, *pCur2;
; 215  : 
; 216  : 	pNext1 = m_pHashGroup->getNext(pKey1);

  00031	48 8b 54 24 58	 mov	 rdx, QWORD PTR pKey1$[rsp]
  00036	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0003b	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0003f	e8 00 00 00 00	 call	 ?getNext@CHash@@QEAAPEAUSThash_next@@PEAD@Z ; CHash::getNext
  00044	48 89 44 24 28	 mov	 QWORD PTR pNext1$[rsp], rax

; 217  : 
; 218  : 	if (pNext1) {

  00049	48 83 7c 24 28
	00		 cmp	 QWORD PTR pNext1$[rsp], 0
  0004f	0f 84 9d 00 00
	00		 je	 $LN2@deleteNode

; 219  : 		CHash *pHash = (CHash *)pNext1->pNode.value;

  00055	48 8b 44 24 28	 mov	 rax, QWORD PTR pNext1$[rsp]
  0005a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0005e	48 89 44 24 38	 mov	 QWORD PTR pHash$1[rsp], rax

; 220  : 		pCur2 = pHash->getNode(pKey2, ppPrev);

  00063	4c 8b 44 24 20	 mov	 r8, QWORD PTR ppPrev$[rsp]
  00068	48 8b 54 24 60	 mov	 rdx, QWORD PTR pKey2$[rsp]
  0006d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pHash$1[rsp]
  00072	e8 00 00 00 00	 call	 ?getNode@CHash@@QEAAPEAUSThash_next@@PEADPEAPEAU2@@Z ; CHash::getNode
  00077	48 89 44 24 30	 mov	 QWORD PTR pCur2$[rsp], rax

; 221  : 		if (pCur2) {

  0007c	48 83 7c 24 30
	00		 cmp	 QWORD PTR pCur2$[rsp], 0
  00082	74 6e		 je	 SHORT $LN3@deleteNode

; 222  : 			*ppPrev = pCur2->next;  // NULL  .

  00084	48 8b 44 24 20	 mov	 rax, QWORD PTR ppPrev$[rsp]
  00089	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pCur2$[rsp]
  0008e	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00092	48 89 08	 mov	 QWORD PTR [rax], rcx

; 223  : 			gs_pMMgr->delBuf(pCur2->pNode.pKey, STRING_SIZE(pCur2->pNode.pKey));	// key2  

  00095	48 8b 44 24 30	 mov	 rax, QWORD PTR pCur2$[rsp]
  0009a	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0009d	e8 00 00 00 00	 call	 strlen
  000a2	48 ff c0	 inc	 rax
  000a5	44 8b c0	 mov	 r8d, eax
  000a8	48 8b 44 24 30	 mov	 rax, QWORD PTR pCur2$[rsp]
  000ad	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  000b0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  000b7	e8 00 00 00 00	 call	 ?delBuf@CMemManager@@QEAAXPEADH@Z ; CMemManager::delBuf

; 224  : 			if (m_bValInternal)delValueBuf((STValue *)pCur2->pNode.value);	// key2  value  

  000bc	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  000c1	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  000c5	85 c0		 test	 eax, eax
  000c7	74 13		 je	 SHORT $LN4@deleteNode
  000c9	48 8b 44 24 30	 mov	 rax, QWORD PTR pCur2$[rsp]
  000ce	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  000d2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  000d7	e8 00 00 00 00	 call	 ?delValueBuf@CDKeyHashMap@@QEAAXPEAUSTValue@@@Z ; CDKeyHashMap::delValueBuf
$LN4@deleteNode:

; 225  : 			m_pHashNext->delMem(pCur2);										// key2,value,next  node 

  000dc	48 8b 54 24 30	 mov	 rdx, QWORD PTR pCur2$[rsp]
  000e1	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  000e6	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000e9	e8 00 00 00 00	 call	 ?delMem@?$CBMemPool@USThash_next@@@@QEAA_NPEAUSThash_next@@@Z ; CBMemPool<SThash_next>::delMem

; 226  : 
; 227  : 			return true;

  000ee	b0 01		 mov	 al, 1
  000f0	eb 02		 jmp	 SHORT $LN1@deleteNode
$LN3@deleteNode:
$LN2@deleteNode:

; 228  : 		}
; 229  : 	}
; 230  : 	return false;

  000f2	32 c0		 xor	 al, al
$LN1@deleteNode:

; 231  : }

  000f4	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000f8	5f		 pop	 rdi
  000f9	c3		 ret	 0
?deleteNode@CDKeyHashMap@@QEAA_NPEAD0@Z ENDP		; CDKeyHashMap::deleteNode
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comdualkeyhash.cpp
_TEXT	SEGMENT
ppPrev$ = 32
pNext2$ = 40
pCur$ = 48
pHash$ = 56
j$ = 64
$T1 = 72
$T2 = 80
tv149 = 88
this$ = 112
pKey1$ = 120
?deleteHash@CDKeyHashMap@@QEAA_NPEAD@Z PROC		; CDKeyHashMap::deleteHash

; 180  : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 18 00 00 00	 mov	 ecx, 24
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR [rsp+112]

; 181  : 	SThash_next **ppPrev=NULL;

  00023	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR ppPrev$[rsp], 0

; 182  : 	SThash_next *pNext2;
; 183  : 	SThash_next *pCur = m_pHashGroup->getNode(pKey1, ppPrev);

  0002c	4c 8b 44 24 20	 mov	 r8, QWORD PTR ppPrev$[rsp]
  00031	48 8b 54 24 78	 mov	 rdx, QWORD PTR pKey1$[rsp]
  00036	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  0003b	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0003f	e8 00 00 00 00	 call	 ?getNode@CHash@@QEAAPEAUSThash_next@@PEADPEAPEAU2@@Z ; CHash::getNode
  00044	48 89 44 24 30	 mov	 QWORD PTR pCur$[rsp], rax

; 184  : 	CHash *pHash;
; 185  : 	unsigned int j;
; 186  : 
; 187  : 	if (pCur) {

  00049	48 83 7c 24 30
	00		 cmp	 QWORD PTR pCur$[rsp], 0
  0004f	0f 84 46 01 00
	00		 je	 $LN7@deleteHash

; 188  : 		*ppPrev = pCur->next; // NULL  .

  00055	48 8b 44 24 20	 mov	 rax, QWORD PTR ppPrev$[rsp]
  0005a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pCur$[rsp]
  0005f	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00063	48 89 08	 mov	 QWORD PTR [rax], rcx

; 189  : 
; 190  : 		pHash = (CHash *)pCur->pNode.value;

  00066	48 8b 44 24 30	 mov	 rax, QWORD PTR pCur$[rsp]
  0006b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0006f	48 89 44 24 38	 mov	 QWORD PTR pHash$[rsp], rax

; 191  : 		for (j = 0; j < m_nMaxCount2; j++) {

  00074	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  0007c	eb 0a		 jmp	 SHORT $LN4@deleteHash
$LN2@deleteHash:
  0007e	8b 44 24 40	 mov	 eax, DWORD PTR j$[rsp]
  00082	ff c0		 inc	 eax
  00084	89 44 24 40	 mov	 DWORD PTR j$[rsp], eax
$LN4@deleteHash:
  00088	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  0008d	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00090	39 44 24 40	 cmp	 DWORD PTR j$[rsp], eax
  00094	0f 83 89 00 00
	00		 jae	 $LN3@deleteHash

; 192  : 			pNext2 = pHash->getNext(j);

  0009a	8b 54 24 40	 mov	 edx, DWORD PTR j$[rsp]
  0009e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pHash$[rsp]
  000a3	e8 00 00 00 00	 call	 ?getNext@CHash@@QEAAPEAUSThash_next@@I@Z ; CHash::getNext
  000a8	48 89 44 24 28	 mov	 QWORD PTR pNext2$[rsp], rax
$LN5@deleteHash:

; 193  : 			while (pNext2) {

  000ad	48 83 7c 24 28
	00		 cmp	 QWORD PTR pNext2$[rsp], 0
  000b3	74 69		 je	 SHORT $LN6@deleteHash

; 194  : 				gs_pMMgr->delBuf(pNext2->pNode.pKey, STRING_SIZE(pNext2->pNode.pKey));	// key2  

  000b5	48 8b 44 24 28	 mov	 rax, QWORD PTR pNext2$[rsp]
  000ba	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000bd	e8 00 00 00 00	 call	 strlen
  000c2	48 ff c0	 inc	 rax
  000c5	44 8b c0	 mov	 r8d, eax
  000c8	48 8b 44 24 28	 mov	 rax, QWORD PTR pNext2$[rsp]
  000cd	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  000d0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  000d7	e8 00 00 00 00	 call	 ?delBuf@CMemManager@@QEAAXPEADH@Z ; CMemManager::delBuf

; 195  : 				if (m_bValInternal) delValueBuf((STValue *)pNext2->pNode.value);	// key2  value  

  000dc	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  000e1	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  000e5	85 c0		 test	 eax, eax
  000e7	74 13		 je	 SHORT $LN8@deleteHash
  000e9	48 8b 44 24 28	 mov	 rax, QWORD PTR pNext2$[rsp]
  000ee	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  000f2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR this$[rsp]
  000f7	e8 00 00 00 00	 call	 ?delValueBuf@CDKeyHashMap@@QEAAXPEAUSTValue@@@Z ; CDKeyHashMap::delValueBuf
$LN8@deleteHash:

; 196  : 				m_pHashNext->delMem(pNext2);										// key2,value,next  node 

  000fc	48 8b 54 24 28	 mov	 rdx, QWORD PTR pNext2$[rsp]
  00101	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  00106	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00109	e8 00 00 00 00	 call	 ?delMem@?$CBMemPool@USThash_next@@@@QEAA_NPEAUSThash_next@@@Z ; CBMemPool<SThash_next>::delMem

; 197  : 				pNext2 = pNext2->next;

  0010e	48 8b 44 24 28	 mov	 rax, QWORD PTR pNext2$[rsp]
  00113	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00117	48 89 44 24 28	 mov	 QWORD PTR pNext2$[rsp], rax

; 198  : 			}

  0011c	eb 8f		 jmp	 SHORT $LN5@deleteHash
$LN6@deleteHash:

; 199  : 		}

  0011e	e9 5b ff ff ff	 jmp	 $LN2@deleteHash
$LN3@deleteHash:

; 200  : 		gs_pMMgr->delBuf(pCur->pNode.pKey, STRING_SIZE(pCur->pNode.pKey));	// key1  

  00123	48 8b 44 24 30	 mov	 rax, QWORD PTR pCur$[rsp]
  00128	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0012b	e8 00 00 00 00	 call	 strlen
  00130	48 ff c0	 inc	 rax
  00133	44 8b c0	 mov	 r8d, eax
  00136	48 8b 44 24 30	 mov	 rax, QWORD PTR pCur$[rsp]
  0013b	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0013e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  00145	e8 00 00 00 00	 call	 ?delBuf@CMemManager@@QEAAXPEADH@Z ; CMemManager::delBuf

; 201  : 		delete pHash;															// key1  value  

  0014a	48 8b 44 24 38	 mov	 rax, QWORD PTR pHash$[rsp]
  0014f	48 89 44 24 50	 mov	 QWORD PTR $T2[rsp], rax
  00154	48 8b 44 24 50	 mov	 rax, QWORD PTR $T2[rsp]
  00159	48 89 44 24 48	 mov	 QWORD PTR $T1[rsp], rax
  0015e	48 83 7c 24 48
	00		 cmp	 QWORD PTR $T1[rsp], 0
  00164	74 16		 je	 SHORT $LN10@deleteHash
  00166	ba 01 00 00 00	 mov	 edx, 1
  0016b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR $T1[rsp]
  00170	e8 00 00 00 00	 call	 ??_GCHash@@QEAAPEAXI@Z
  00175	48 89 44 24 58	 mov	 QWORD PTR tv149[rsp], rax
  0017a	eb 09		 jmp	 SHORT $LN11@deleteHash
$LN10@deleteHash:
  0017c	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR tv149[rsp], 0
$LN11@deleteHash:

; 202  : 		m_pHashNext->delMem(pCur);												// key1,value,next  node 

  00185	48 8b 54 24 30	 mov	 rdx, QWORD PTR pCur$[rsp]
  0018a	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  0018f	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00192	e8 00 00 00 00	 call	 ?delMem@?$CBMemPool@USThash_next@@@@QEAA_NPEAUSThash_next@@@Z ; CBMemPool<SThash_next>::delMem

; 203  : 
; 204  : 		return true;

  00197	b0 01		 mov	 al, 1
  00199	eb 02		 jmp	 SHORT $LN1@deleteHash
$LN7@deleteHash:

; 205  : 	}		
; 206  : 	return false;

  0019b	32 c0		 xor	 al, al
$LN1@deleteHash:

; 207  : }

  0019d	48 83 c4 60	 add	 rsp, 96			; 00000060H
  001a1	5f		 pop	 rdi
  001a2	c3		 ret	 0
?deleteHash@CDKeyHashMap@@QEAA_NPEAD@Z ENDP		; CDKeyHashMap::deleteHash
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comdualkeyhash.cpp
_TEXT	SEGMENT
pHash$ = 32
pNode$ = 40
this$ = 64
pKey1$ = 72
pKey2$ = 80
pValue$ = 88
?setValue@CDKeyHashMap@@QEAAHPEAD0PEAX@Z PROC		; CDKeyHashMap::setValue

; 137  : {

$LN6:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 0c 00 00 00	 mov	 ecx, 12
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 138  : 	CHash *pHash;
; 139  : 	STHash_Node *pNode = m_pHashGroup->hashLookup(pKey1);

  0002d	48 8b 54 24 48	 mov	 rdx, QWORD PTR pKey1$[rsp]
  00032	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00037	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0003b	e8 00 00 00 00	 call	 ?hashLookup@CHash@@QEAAPEAUSTHash_Node@@PEAD@Z ; CHash::hashLookup
  00040	48 89 44 24 28	 mov	 QWORD PTR pNode$[rsp], rax

; 140  : 	if (pNode) {

  00045	48 83 7c 24 28
	00		 cmp	 QWORD PTR pNode$[rsp], 0
  0004b	74 5b		 je	 SHORT $LN2@setValue

; 141  : 		pHash = (CHash *)pNode->value;

  0004d	48 8b 44 24 28	 mov	 rax, QWORD PTR pNode$[rsp]
  00052	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00056	48 89 44 24 20	 mov	 QWORD PTR pHash$[rsp], rax

; 142  : 		pNode = pHash->hashLookup(pKey2);

  0005b	48 8b 54 24 50	 mov	 rdx, QWORD PTR pKey2$[rsp]
  00060	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pHash$[rsp]
  00065	e8 00 00 00 00	 call	 ?hashLookup@CHash@@QEAAPEAUSTHash_Node@@PEAD@Z ; CHash::hashLookup
  0006a	48 89 44 24 28	 mov	 QWORD PTR pNode$[rsp], rax

; 143  : 		if (pNode) {

  0006f	48 83 7c 24 28
	00		 cmp	 QWORD PTR pNode$[rsp], 0
  00075	74 31		 je	 SHORT $LN3@setValue

; 144  : 			if (pNode->value) { delValueBuf((STValue *)pNode->value); }

  00077	48 8b 44 24 28	 mov	 rax, QWORD PTR pNode$[rsp]
  0007c	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00081	74 13		 je	 SHORT $LN4@setValue
  00083	48 8b 44 24 28	 mov	 rax, QWORD PTR pNode$[rsp]
  00088	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0008c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00091	e8 00 00 00 00	 call	 ?delValueBuf@CDKeyHashMap@@QEAAXPEAUSTValue@@@Z ; CDKeyHashMap::delValueBuf
$LN4@setValue:

; 145  : 			pNode->value = pValue; 

  00096	48 8b 44 24 28	 mov	 rax, QWORD PTR pNode$[rsp]
  0009b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pValue$[rsp]
  000a0	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 146  : 			return eHASH_RESULT_SUCESS;

  000a4	33 c0		 xor	 eax, eax
  000a6	eb 05		 jmp	 SHORT $LN1@setValue
$LN3@setValue:
$LN2@setValue:

; 147  : 		}
; 148  : 	}
; 149  : 	return eHASH_RESULT_INVALID_KEY;

  000a8	b8 fd ff ff ff	 mov	 eax, -3
$LN1@setValue:

; 150  : }

  000ad	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b1	5f		 pop	 rdi
  000b2	c3		 ret	 0
?setValue@CDKeyHashMap@@QEAAHPEAD0PEAX@Z ENDP		; CDKeyHashMap::setValue
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comdualkeyhash.cpp
_TEXT	SEGMENT
pHash$ = 56
nRes$ = 68
__$ArrayPad$ = 80
this$ = 112
pKey1$ = 120
pKey2$ = 128
pValue$ = 136
pHashValue$ = 144
?addKeyValue@CDKeyHashMap@@QEAAHPEAD0PEAX1@Z PROC	; CDKeyHashMap::addKeyValue

; 123  : {

$LN6:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 18 00 00 00	 mov	 ecx, 24
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 70	 mov	 rcx, QWORD PTR [rsp+112]
  0002d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00034	48 33 c4	 xor	 rax, rsp
  00037	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 124  : 	CHash *pHash;
; 125  : 	int nRes; // 1. key2's hashKey -> 2. nRes
; 126  : 	nRes = addKey(pKey1, pKey2, &pHash);

  0003c	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00045	4c 8d 4c 24 38	 lea	 r9, QWORD PTR pHash$[rsp]
  0004a	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR pKey2$[rsp]
  00052	48 8b 54 24 78	 mov	 rdx, QWORD PTR pKey1$[rsp]
  00057	48 8b 4c 24 70	 mov	 rcx, QWORD PTR this$[rsp]
  0005c	e8 00 00 00 00	 call	 ?addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z ; CDKeyHashMap::addKey
  00061	89 44 24 44	 mov	 DWORD PTR nRes$[rsp], eax

; 127  : 	if (pHash) {

  00065	48 83 7c 24 38
	00		 cmp	 QWORD PTR pHash$[rsp], 0
  0006b	74 46		 je	 SHORT $LN2@addKeyValu

; 128  : 		if(pHashValue) pHash->setHashValue(pHashValue);

  0006d	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR pHashValue$[rsp], 0
  00076	74 12		 je	 SHORT $LN3@addKeyValu
  00078	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR pHashValue$[rsp]
  00080	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pHash$[rsp]
  00085	e8 00 00 00 00	 call	 ?setHashValue@CHash@@QEAAXPEAX@Z ; CHash::setHashValue
$LN3@addKeyValu:

; 129  : 		if (nRes >= 0) {

  0008a	83 7c 24 44 00	 cmp	 DWORD PTR nRes$[rsp], 0
  0008f	7c 22		 jl	 SHORT $LN4@addKeyValu

; 130  : 			nRes = pHash->setValue(nRes, pKey2, pValue);

  00091	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR pValue$[rsp]
  00099	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR pKey2$[rsp]
  000a1	8b 54 24 44	 mov	 edx, DWORD PTR nRes$[rsp]
  000a5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pHash$[rsp]
  000aa	e8 00 00 00 00	 call	 ?setValue@CHash@@QEAA?AW4HASH_RETURN_CODE@@IPEADPEAX@Z ; CHash::setValue
  000af	89 44 24 44	 mov	 DWORD PTR nRes$[rsp], eax
$LN4@addKeyValu:
$LN2@addKeyValu:

; 131  : 		}
; 132  : 	}
; 133  : 	return nRes;

  000b3	8b 44 24 44	 mov	 eax, DWORD PTR nRes$[rsp]

; 134  : }

  000b7	8b f8		 mov	 edi, eax
  000b9	48 8b cc	 mov	 rcx, rsp
  000bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?addKeyValue@CDKeyHashMap@@QEAAHPEAD0PEAX1@Z$rtcFrameData
  000c3	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000c8	8b c7		 mov	 eax, edi
  000ca	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000cf	48 33 cc	 xor	 rcx, rsp
  000d2	e8 00 00 00 00	 call	 __security_check_cookie
  000d7	48 83 c4 60	 add	 rsp, 96			; 00000060H
  000db	5f		 pop	 rdi
  000dc	c3		 ret	 0
?addKeyValue@CDKeyHashMap@@QEAAHPEAD0PEAX1@Z ENDP	; CDKeyHashMap::addKeyValue
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comdualkeyhash.cpp
_TEXT	SEGMENT
pNext$ = 64
pHash$ = 72
pBuf$ = 80
nRes1$ = 88
nRes2$ = 92
pNode$ = 96
$T1 = 104
$T2 = 112
$T3 = 120
tv95 = 128
this$ = 160
pKey1$ = 168
pKey2$ = 176
pTarget$ = 184
pHashValue$ = 192
?addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z PROC ; CDKeyHashMap::addKey

; 75   : {

$LN18:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  0001c	48 8b fc	 mov	 rdi, rsp
  0001f	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
  00024	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00029	f3 ab		 rep stosd
  0002b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR [rsp+160]
  00033	48 c7 44 24 78
	fe ff ff ff	 mov	 QWORD PTR $T3[rsp], -2

; 76   : 	SThash_next *pNext;
; 77   : 	CHash *pHash;
; 78   : 	TCHAR *pBuf;
; 79   : 	int nRes1=0, nRes2=0;

  0003c	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR nRes1$[rsp], 0
  00044	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR nRes2$[rsp], 0

; 80   : 
; 81   : 
; 82   : 	STHash_Node *pNode = m_pHashGroup->hashLookup(pKey1);

  0004c	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR pKey1$[rsp]
  00054	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0005c	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00060	e8 00 00 00 00	 call	 ?hashLookup@CHash@@QEAAPEAUSTHash_Node@@PEAD@Z ; CHash::hashLookup
  00065	48 89 44 24 60	 mov	 QWORD PTR pNode$[rsp], rax

; 83   : 	if (pNode) {

  0006a	48 83 7c 24 60
	00		 cmp	 QWORD PTR pNode$[rsp], 0
  00070	74 78		 je	 SHORT $LN2@addKey

; 84   : 		pHash = (CHash *)pNode->value;

  00072	48 8b 44 24 60	 mov	 rax, QWORD PTR pNode$[rsp]
  00077	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0007b	48 89 44 24 48	 mov	 QWORD PTR pHash$[rsp], rax

; 85   : 		if (pHash->hashLookup(pKey2)) {

  00080	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR pKey2$[rsp]
  00088	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pHash$[rsp]
  0008d	e8 00 00 00 00	 call	 ?hashLookup@CHash@@QEAAPEAUSTHash_Node@@PEAD@Z ; CHash::hashLookup
  00092	48 85 c0	 test	 rax, rax
  00095	74 4e		 je	 SHORT $LN4@addKey

; 86   : 			gs_cLogger.DebugLog(LEVEL_ERROR, "DUPLICATE_KEYS pKey1[%s] pHash->hashLookup(pKey2[%s])", pKey1, pKey2);

  00097	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pKey2$[rsp]
  0009f	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  000a4	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR pKey1$[rsp]
  000ac	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000b1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG45003
  000b8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000bd	41 b9 56 00 00
	00		 mov	 r9d, 86			; 00000056H
  000c3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG45004
  000ca	ba 05 00 00 00	 mov	 edx, 5
  000cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  000d6	e8 00 00 00 00	 call	 ?__debugLog@CLogger@@QEAAXHPEBDH0ZZ ; CLogger::__debugLog

; 87   : 			return eHASH_RESULT_DUPLICATE_KEYS;

  000db	b8 ff ff ff ff	 mov	 eax, -1
  000e0	e9 93 02 00 00	 jmp	 $LN1@addKey
$LN4@addKey:

; 88   : 		}
; 89   : 	}
; 90   : 	else {

  000e5	e9 95 01 00 00	 jmp	 $LN3@addKey
$LN2@addKey:

; 91   : 		pHash = new (std::nothrow)CHash(m_nMaxCount2);					// key1  value  

  000ea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  000f1	b9 18 00 00 00	 mov	 ecx, 24
  000f6	e8 00 00 00 00	 call	 ??2@YAPEAX_KAEBUnothrow_t@std@@@Z ; operator new
  000fb	48 89 44 24 70	 mov	 QWORD PTR $T2[rsp], rax
  00100	48 83 7c 24 70
	00		 cmp	 QWORD PTR $T2[rsp], 0
  00106	74 1f		 je	 SHORT $LN15@addKey
  00108	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00110	8b 50 1c	 mov	 edx, DWORD PTR [rax+28]
  00113	48 8b 4c 24 70	 mov	 rcx, QWORD PTR $T2[rsp]
  00118	e8 00 00 00 00	 call	 ??0CHash@@QEAA@I@Z	; CHash::CHash
  0011d	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv95[rsp], rax
  00125	eb 0c		 jmp	 SHORT $LN16@addKey
$LN15@addKey:
  00127	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv95[rsp], 0
$LN16@addKey:
  00133	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv95[rsp]
  0013b	48 89 44 24 68	 mov	 QWORD PTR $T1[rsp], rax
  00140	48 8b 44 24 68	 mov	 rax, QWORD PTR $T1[rsp]
  00145	48 89 44 24 48	 mov	 QWORD PTR pHash$[rsp], rax

; 92   : 		if (!pHash) return eHASH_RESULT_FAIL_ALLOCATION;

  0014a	48 83 7c 24 48
	00		 cmp	 QWORD PTR pHash$[rsp], 0
  00150	75 0a		 jne	 SHORT $LN5@addKey
  00152	b8 fb ff ff ff	 mov	 eax, -5
  00157	e9 1c 02 00 00	 jmp	 $LN1@addKey
$LN5@addKey:

; 93   : 		pNext = m_pHashNext->newMem();						// key1,value,next  node 

  0015c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00164	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00167	e8 00 00 00 00	 call	 ?newMem@?$CBMemPool@USThash_next@@@@QEAAPEAUSThash_next@@XZ ; CBMemPool<SThash_next>::newMem
  0016c	48 89 44 24 40	 mov	 QWORD PTR pNext$[rsp], rax

; 94   : 		if(!pNext) return eHASH_RESULT_FAIL_ALLOCATION;

  00171	48 83 7c 24 40
	00		 cmp	 QWORD PTR pNext$[rsp], 0
  00177	75 0a		 jne	 SHORT $LN6@addKey
  00179	b8 fb ff ff ff	 mov	 eax, -5
  0017e	e9 f5 01 00 00	 jmp	 $LN1@addKey
$LN6@addKey:

; 95   : 		pBuf = (TCHAR*)gs_pMMgr->newBuf(STRING_SIZE(pKey1));				// key1  

  00183	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pKey1$[rsp]
  0018b	e8 00 00 00 00	 call	 strlen
  00190	48 ff c0	 inc	 rax
  00193	8b d0		 mov	 edx, eax
  00195	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  0019c	e8 00 00 00 00	 call	 ?newBuf@CMemManager@@QEAAPEADH@Z ; CMemManager::newBuf
  001a1	48 89 44 24 50	 mov	 QWORD PTR pBuf$[rsp], rax

; 96   : 		if(!pBuf) return eHASH_RESULT_FAIL_ALLOCATION;

  001a6	48 83 7c 24 50
	00		 cmp	 QWORD PTR pBuf$[rsp], 0
  001ac	75 0a		 jne	 SHORT $LN7@addKey
  001ae	b8 fb ff ff ff	 mov	 eax, -5
  001b3	e9 c0 01 00 00	 jmp	 $LN1@addKey
$LN7@addKey:

; 97   : 		_tcscpy(pBuf, pKey1);

  001b8	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR pKey1$[rsp]
  001c0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pBuf$[rsp]
  001c5	e8 00 00 00 00	 call	 strcpy

; 98   : 		nRes1 = m_pHashGroup->addNode(pNext, pBuf, (void *)pHash);	// 1  

  001ca	4c 8b 4c 24 48	 mov	 r9, QWORD PTR pHash$[rsp]
  001cf	4c 8b 44 24 50	 mov	 r8, QWORD PTR pBuf$[rsp]
  001d4	48 8b 54 24 40	 mov	 rdx, QWORD PTR pNext$[rsp]
  001d9	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001e1	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  001e5	e8 00 00 00 00	 call	 ?addNode@CHash@@QEAAHPEAUSThash_next@@PEADPEAX@Z ; CHash::addNode
  001ea	89 44 24 58	 mov	 DWORD PTR nRes1$[rsp], eax

; 99   : 		if (nRes1 < 0) {

  001ee	83 7c 24 58 00	 cmp	 DWORD PTR nRes1$[rsp], 0
  001f3	7d 54		 jge	 SHORT $LN8@addKey

; 100  : 			gs_cLogger.DebugLog(LEVEL_ERROR, "errorNo[%d] new CHash(max:%d) key1:%s", nRes1, m_nMaxCount2, pBuf);

  001f5	48 8b 44 24 50	 mov	 rax, QWORD PTR pBuf$[rsp]
  001fa	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  001ff	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00207	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  0020a	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0020e	8b 44 24 58	 mov	 eax, DWORD PTR nRes1$[rsp]
  00212	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00216	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG45010
  0021d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00222	41 b9 64 00 00
	00		 mov	 r9d, 100		; 00000064H
  00228	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG45011
  0022f	ba 05 00 00 00	 mov	 edx, 5
  00234	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  0023b	e8 00 00 00 00	 call	 ?__debugLog@CLogger@@QEAAXHPEBDH0ZZ ; CLogger::__debugLog

; 101  : 			return nRes1;

  00240	8b 44 24 58	 mov	 eax, DWORD PTR nRes1$[rsp]
  00244	e9 2f 01 00 00	 jmp	 $LN1@addKey
$LN8@addKey:

; 102  : 		}
; 103  : 		gs_cLogger.PutLogQueue(LEVEL_DEBUG, _T("new CHash(max:%d) key1:%s hashNo[%d]"), m_nMaxCount2, pBuf, nRes1);

  00249	8b 44 24 58	 mov	 eax, DWORD PTR nRes1$[rsp]
  0024d	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00251	48 8b 44 24 50	 mov	 rax, QWORD PTR pBuf$[rsp]
  00256	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0025b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00263	44 8b 48 1c	 mov	 r9d, DWORD PTR [rax+28]
  00267	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG45012
  0026e	ba 01 00 00 00	 mov	 edx, 1
  00273	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  0027a	e8 00 00 00 00	 call	 ?PutLogQueue@CLogger@@QEAAXHPEBDZZ ; CLogger::PutLogQueue
$LN3@addKey:

; 104  : 	}
; 105  : 
; 106  : 	pNext = m_pHashNext->newMem();						// key2, value, next  node 

  0027f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00287	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0028a	e8 00 00 00 00	 call	 ?newMem@?$CBMemPool@USThash_next@@@@QEAAPEAUSThash_next@@XZ ; CBMemPool<SThash_next>::newMem
  0028f	48 89 44 24 40	 mov	 QWORD PTR pNext$[rsp], rax

; 107  : 	if (!pNext) return eHASH_RESULT_FAIL_ALLOCATION;

  00294	48 83 7c 24 40
	00		 cmp	 QWORD PTR pNext$[rsp], 0
  0029a	75 0a		 jne	 SHORT $LN9@addKey
  0029c	b8 fb ff ff ff	 mov	 eax, -5
  002a1	e9 d2 00 00 00	 jmp	 $LN1@addKey
$LN9@addKey:

; 108  : 	pBuf = (TCHAR*)gs_pMMgr->newBuf(STRING_SIZE(pKey2));				// key2  

  002a6	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pKey2$[rsp]
  002ae	e8 00 00 00 00	 call	 strlen
  002b3	48 ff c0	 inc	 rax
  002b6	8b d0		 mov	 edx, eax
  002b8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  002bf	e8 00 00 00 00	 call	 ?newBuf@CMemManager@@QEAAPEADH@Z ; CMemManager::newBuf
  002c4	48 89 44 24 50	 mov	 QWORD PTR pBuf$[rsp], rax

; 109  : 	if (!pBuf) return eHASH_RESULT_FAIL_ALLOCATION;

  002c9	48 83 7c 24 50
	00		 cmp	 QWORD PTR pBuf$[rsp], 0
  002cf	75 0a		 jne	 SHORT $LN10@addKey
  002d1	b8 fb ff ff ff	 mov	 eax, -5
  002d6	e9 9d 00 00 00	 jmp	 $LN1@addKey
$LN10@addKey:

; 110  : 	_tcscpy(pBuf, pKey2);

  002db	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR pKey2$[rsp]
  002e3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pBuf$[rsp]
  002e8	e8 00 00 00 00	 call	 strcpy

; 111  : 	if (pHashValue) pHash->setHashValue(pHashValue);

  002ed	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR pHashValue$[rsp], 0
  002f6	74 12		 je	 SHORT $LN11@addKey
  002f8	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR pHashValue$[rsp]
  00300	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pHash$[rsp]
  00305	e8 00 00 00 00	 call	 ?setHashValue@CHash@@QEAAXPEAX@Z ; CHash::setHashValue
$LN11@addKey:

; 112  : 	if(pTarget) *pTarget = pHash;

  0030a	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR pTarget$[rsp], 0
  00313	74 10		 je	 SHORT $LN12@addKey
  00315	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pTarget$[rsp]
  0031d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pHash$[rsp]
  00322	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN12@addKey:

; 113  : 	// 2   (key2  value   )
; 114  : 	nRes2 = pHash->addNode(pNext, pBuf); // 2   (key2  value   )

  00325	45 33 c9	 xor	 r9d, r9d
  00328	4c 8b 44 24 50	 mov	 r8, QWORD PTR pBuf$[rsp]
  0032d	48 8b 54 24 40	 mov	 rdx, QWORD PTR pNext$[rsp]
  00332	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pHash$[rsp]
  00337	e8 00 00 00 00	 call	 ?addNode@CHash@@QEAAHPEAUSThash_next@@PEADPEAX@Z ; CHash::addNode
  0033c	89 44 24 5c	 mov	 DWORD PTR nRes2$[rsp], eax

; 115  : 	if (nRes2 < 0) {

  00340	83 7c 24 5c 00	 cmp	 DWORD PTR nRes2$[rsp], 0
  00345	7d 2d		 jge	 SHORT $LN13@addKey

; 116  : 		gs_cLogger.PutQueue(LEVEL_ERROR, "errorNo[%d] pHash->addNode(pNext, %s)", nRes2, pBuf);

  00347	48 8b 44 24 50	 mov	 rax, QWORD PTR pBuf$[rsp]
  0034c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00351	44 8b 4c 24 5c	 mov	 r9d, DWORD PTR nRes2$[rsp]
  00356	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG45018
  0035d	ba 05 00 00 00	 mov	 edx, 5
  00362	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  00369	e8 00 00 00 00	 call	 ?PutLogQueue@CLogger@@QEAAXHPEBDZZ ; CLogger::PutLogQueue

; 117  : 		return nRes2;

  0036e	8b 44 24 5c	 mov	 eax, DWORD PTR nRes2$[rsp]
  00372	eb 04		 jmp	 SHORT $LN1@addKey
$LN13@addKey:

; 118  : 	}
; 119  : 	return nRes2;

  00374	8b 44 24 5c	 mov	 eax, DWORD PTR nRes2$[rsp]
$LN1@addKey:

; 120  : }

  00378	48 81 c4 90 00
	00 00		 add	 rsp, 144		; 00000090H
  0037f	5f		 pop	 rdi
  00380	c3		 ret	 0
?addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z ENDP ; CDKeyHashMap::addKey
_TEXT	ENDS
text$x	SEGMENT
pNext$ = 64
pHash$ = 72
pBuf$ = 80
nRes1$ = 88
nRes2$ = 92
pNode$ = 96
$T1 = 104
$T2 = 112
$T3 = 120
tv95 = 128
this$ = 160
pKey1$ = 168
pKey2$ = 176
pTarget$ = 184
pHashValue$ = 192
?dtor$0@?0??addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z@4HA PROC ; `CDKeyHashMap::addKey'::`1'::dtor$0
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00010	48 8b ea	 mov	 rbp, rdx
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  0001a	48 8b 4d 70	 mov	 rcx, QWORD PTR $T2[rbp]
  0001e	e8 00 00 00 00	 call	 ??3@YAXPEAXAEBUnothrow_t@std@@@Z ; operator delete
  00023	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00027	5f		 pop	 rdi
  00028	5d		 pop	 rbp
  00029	c3		 ret	 0
?dtor$0@?0??addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z@4HA ENDP ; `CDKeyHashMap::addKey'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu
text$x	SEGMENT
pNext$ = 64
pHash$ = 72
pBuf$ = 80
nRes1$ = 88
nRes2$ = 92
pNode$ = 96
$T1 = 104
$T2 = 112
$T3 = 120
tv95 = 128
this$ = 160
pKey1$ = 168
pKey2$ = 176
pTarget$ = 184
pHashValue$ = 192
?dtor$0@?0??addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z@4HA PROC ; `CDKeyHashMap::addKey'::`1'::dtor$0
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00010	48 8b ea	 mov	 rbp, rdx
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  0001a	48 8b 4d 70	 mov	 rcx, QWORD PTR $T2[rbp]
  0001e	e8 00 00 00 00	 call	 ??3@YAXPEAXAEBUnothrow_t@std@@@Z ; operator delete
  00023	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00027	5f		 pop	 rdi
  00028	5d		 pop	 rbp
  00029	c3		 ret	 0
?dtor$0@?0??addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z@4HA ENDP ; `CDKeyHashMap::addKey'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comdualkeyhash.cpp
_TEXT	SEGMENT
pNext1$ = 32
pNext2$ = 40
pDelNode$ = 48
pHash$ = 56
i$ = 64
j$ = 68
$T1 = 72
$T2 = 80
$T3 = 88
$T4 = 96
$T5 = 104
$T6 = 112
$T7 = 120
$T8 = 128
$T9 = 136
tv150 = 144
tv160 = 152
tv166 = 160
tv172 = 168
this$ = 192
??1CDKeyHashMap@@QEAA@XZ PROC				; CDKeyHashMap::~CDKeyHashMap

; 37   : {

$LN22:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec b0 00
	00 00		 sub	 rsp, 176		; 000000b0H
  0000d	48 8b fc	 mov	 rdi, rsp
  00010	b9 2c 00 00 00	 mov	 ecx, 44			; 0000002cH
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR [rsp+192]
  00024	48 c7 84 24 88
	00 00 00 fe ff
	ff ff		 mov	 QWORD PTR $T9[rsp], -2

; 38   : 	SThash_next *pNext1, *pNext2, *pDelNode;
; 39   : 	CHash *pHash;
; 40   : 	unsigned int i,j;
; 41   : 	
; 42   : 	//      ,       . OS    .
; 43   : 	//                     .
; 44   : 	//              .
; 45   : 	for (i = 0; i < m_nMaxCount1; i++) {

  00030	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00038	eb 0a		 jmp	 SHORT $LN4@CDKeyHashM
$LN2@CDKeyHashM:
  0003a	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  0003e	ff c0		 inc	 eax
  00040	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN4@CDKeyHashM:
  00044	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0004c	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0004f	39 44 24 40	 cmp	 DWORD PTR i$[rsp], eax
  00053	0f 83 a9 01 00
	00		 jae	 $LN3@CDKeyHashM

; 46   : 		pNext1 = m_pHashGroup->getNext(i);

  00059	8b 54 24 40	 mov	 edx, DWORD PTR i$[rsp]
  0005d	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00065	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00069	e8 00 00 00 00	 call	 ?getNext@CHash@@QEAAPEAUSThash_next@@I@Z ; CHash::getNext
  0006e	90		 npad	 1
  0006f	48 89 44 24 20	 mov	 QWORD PTR pNext1$[rsp], rax
$LN5@CDKeyHashM:

; 47   : 		while (pNext1) {

  00074	48 83 7c 24 20
	00		 cmp	 QWORD PTR pNext1$[rsp], 0
  0007a	0f 84 7d 01 00
	00		 je	 $LN6@CDKeyHashM

; 48   : 			pHash = (CHash *)pNext1->pNode.value;

  00080	48 8b 44 24 20	 mov	 rax, QWORD PTR pNext1$[rsp]
  00085	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00089	48 89 44 24 38	 mov	 QWORD PTR pHash$[rsp], rax

; 49   : 			for (j = 0; j < m_nMaxCount2; j++) {

  0008e	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00096	eb 0a		 jmp	 SHORT $LN9@CDKeyHashM
$LN7@CDKeyHashM:
  00098	8b 44 24 44	 mov	 eax, DWORD PTR j$[rsp]
  0009c	ff c0		 inc	 eax
  0009e	89 44 24 44	 mov	 DWORD PTR j$[rsp], eax
$LN9@CDKeyHashM:
  000a2	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000aa	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  000ad	39 44 24 44	 cmp	 DWORD PTR j$[rsp], eax
  000b1	0f 83 a8 00 00
	00		 jae	 $LN8@CDKeyHashM

; 50   : 				pNext2 = pHash->getNext(j);

  000b7	8b 54 24 44	 mov	 edx, DWORD PTR j$[rsp]
  000bb	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pHash$[rsp]
  000c0	e8 00 00 00 00	 call	 ?getNext@CHash@@QEAAPEAUSThash_next@@I@Z ; CHash::getNext
  000c5	90		 npad	 1
  000c6	48 89 44 24 28	 mov	 QWORD PTR pNext2$[rsp], rax
$LN10@CDKeyHashM:

; 51   : 				while (pNext2) {

  000cb	48 83 7c 24 28
	00		 cmp	 QWORD PTR pNext2$[rsp], 0
  000d1	0f 84 83 00 00
	00		 je	 $LN11@CDKeyHashM

; 52   : 					gs_pMMgr->delBuf(pNext2->pNode.pKey, STRING_SIZE(pNext2->pNode.pKey));	// key2  

  000d7	48 8b 44 24 28	 mov	 rax, QWORD PTR pNext2$[rsp]
  000dc	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000df	e8 00 00 00 00	 call	 strlen
  000e4	90		 npad	 1
  000e5	48 ff c0	 inc	 rax
  000e8	44 8b c0	 mov	 r8d, eax
  000eb	48 8b 44 24 28	 mov	 rax, QWORD PTR pNext2$[rsp]
  000f0	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  000f3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  000fa	e8 00 00 00 00	 call	 ?delBuf@CMemManager@@QEAAXPEADH@Z ; CMemManager::delBuf
  000ff	90		 npad	 1

; 53   : 					if(m_bValInternal)delValueBuf((STValue *)pNext2->pNode.value);					// key2  value  

  00100	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00108	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  0010c	85 c0		 test	 eax, eax
  0010e	74 17		 je	 SHORT $LN12@CDKeyHashM
  00110	48 8b 44 24 28	 mov	 rax, QWORD PTR pNext2$[rsp]
  00115	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00119	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00121	e8 00 00 00 00	 call	 ?delValueBuf@CDKeyHashMap@@QEAAXPEAUSTValue@@@Z ; CDKeyHashMap::delValueBuf
  00126	90		 npad	 1
$LN12@CDKeyHashM:

; 54   : 					pDelNode = pNext2;

  00127	48 8b 44 24 28	 mov	 rax, QWORD PTR pNext2$[rsp]
  0012c	48 89 44 24 30	 mov	 QWORD PTR pDelNode$[rsp], rax

; 55   : 					pNext2 = pNext2->next;

  00131	48 8b 44 24 28	 mov	 rax, QWORD PTR pNext2$[rsp]
  00136	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0013a	48 89 44 24 28	 mov	 QWORD PTR pNext2$[rsp], rax

; 56   : 					m_pHashNext->delMem(pDelNode);												// key2,value,next  node 

  0013f	48 8b 54 24 30	 mov	 rdx, QWORD PTR pDelNode$[rsp]
  00144	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0014c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0014f	e8 00 00 00 00	 call	 ?delMem@?$CBMemPool@USThash_next@@@@QEAA_NPEAUSThash_next@@@Z ; CBMemPool<SThash_next>::delMem
  00154	90		 npad	 1

; 57   : 				}

  00155	e9 71 ff ff ff	 jmp	 $LN10@CDKeyHashM
$LN11@CDKeyHashM:

; 58   : 			}

  0015a	e9 39 ff ff ff	 jmp	 $LN7@CDKeyHashM
$LN8@CDKeyHashM:

; 59   : 			gs_pMMgr->delBuf(pNext1->pNode.pKey, STRING_SIZE(pNext1->pNode.pKey));	// key1  

  0015f	48 8b 44 24 20	 mov	 rax, QWORD PTR pNext1$[rsp]
  00164	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00167	e8 00 00 00 00	 call	 strlen
  0016c	90		 npad	 1
  0016d	48 ff c0	 inc	 rax
  00170	44 8b c0	 mov	 r8d, eax
  00173	48 8b 44 24 20	 mov	 rax, QWORD PTR pNext1$[rsp]
  00178	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0017b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  00182	e8 00 00 00 00	 call	 ?delBuf@CMemManager@@QEAAXPEADH@Z ; CMemManager::delBuf
  00187	90		 npad	 1

; 60   : 			delete pHash;																	// key1  value  

  00188	48 8b 44 24 38	 mov	 rax, QWORD PTR pHash$[rsp]
  0018d	48 89 44 24 50	 mov	 QWORD PTR $T2[rsp], rax
  00192	48 8b 44 24 50	 mov	 rax, QWORD PTR $T2[rsp]
  00197	48 89 44 24 48	 mov	 QWORD PTR $T1[rsp], rax
  0019c	48 83 7c 24 48
	00		 cmp	 QWORD PTR $T1[rsp], 0
  001a2	74 1a		 je	 SHORT $LN14@CDKeyHashM
  001a4	ba 01 00 00 00	 mov	 edx, 1
  001a9	48 8b 4c 24 48	 mov	 rcx, QWORD PTR $T1[rsp]
  001ae	e8 00 00 00 00	 call	 ??_GCHash@@QEAAPEAXI@Z
  001b3	90		 npad	 1
  001b4	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv150[rsp], rax
  001bc	eb 0c		 jmp	 SHORT $LN15@CDKeyHashM
$LN14@CDKeyHashM:
  001be	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv150[rsp], 0
$LN15@CDKeyHashM:

; 61   : 			pDelNode = pNext1;

  001ca	48 8b 44 24 20	 mov	 rax, QWORD PTR pNext1$[rsp]
  001cf	48 89 44 24 30	 mov	 QWORD PTR pDelNode$[rsp], rax

; 62   : 			pNext1 = pNext1->next;

  001d4	48 8b 44 24 20	 mov	 rax, QWORD PTR pNext1$[rsp]
  001d9	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001dd	48 89 44 24 20	 mov	 QWORD PTR pNext1$[rsp], rax

; 63   : 			m_pHashNext->delMem(pDelNode);												// key1,value,next  node 

  001e2	48 8b 54 24 30	 mov	 rdx, QWORD PTR pDelNode$[rsp]
  001e7	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001ef	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  001f2	e8 00 00 00 00	 call	 ?delMem@?$CBMemPool@USThash_next@@@@QEAA_NPEAUSThash_next@@@Z ; CBMemPool<SThash_next>::delMem
  001f7	90		 npad	 1

; 64   : 		}

  001f8	e9 77 fe ff ff	 jmp	 $LN5@CDKeyHashM
$LN6@CDKeyHashM:

; 65   : 	}

  001fd	e9 38 fe ff ff	 jmp	 $LN2@CDKeyHashM
$LN3@CDKeyHashM:

; 66   : 
; 67   : 	//        .
; 68   : 	delete m_pValue;

  00202	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0020a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0020e	48 89 44 24 60	 mov	 QWORD PTR $T4[rsp], rax
  00213	48 8b 44 24 60	 mov	 rax, QWORD PTR $T4[rsp]
  00218	48 89 44 24 58	 mov	 QWORD PTR $T3[rsp], rax
  0021d	48 83 7c 24 58
	00		 cmp	 QWORD PTR $T3[rsp], 0
  00223	74 1a		 je	 SHORT $LN16@CDKeyHashM
  00225	ba 01 00 00 00	 mov	 edx, 1
  0022a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR $T3[rsp]
  0022f	e8 00 00 00 00	 call	 ??_G?$CBMemPool@USTValue@@@@QEAAPEAXI@Z
  00234	90		 npad	 1
  00235	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv160[rsp], rax
  0023d	eb 0c		 jmp	 SHORT $LN17@CDKeyHashM
$LN16@CDKeyHashM:
  0023f	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv160[rsp], 0
$LN17@CDKeyHashM:

; 69   : 	delete m_pHashNext;

  0024b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00253	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00256	48 89 44 24 70	 mov	 QWORD PTR $T6[rsp], rax
  0025b	48 8b 44 24 70	 mov	 rax, QWORD PTR $T6[rsp]
  00260	48 89 44 24 68	 mov	 QWORD PTR $T5[rsp], rax
  00265	48 83 7c 24 68
	00		 cmp	 QWORD PTR $T5[rsp], 0
  0026b	74 1a		 je	 SHORT $LN18@CDKeyHashM
  0026d	ba 01 00 00 00	 mov	 edx, 1
  00272	48 8b 4c 24 68	 mov	 rcx, QWORD PTR $T5[rsp]
  00277	e8 00 00 00 00	 call	 ??_G?$CBMemPool@USThash_next@@@@QEAAPEAXI@Z
  0027c	90		 npad	 1
  0027d	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv166[rsp], rax
  00285	eb 0c		 jmp	 SHORT $LN19@CDKeyHashM
$LN18@CDKeyHashM:
  00287	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv166[rsp], 0
$LN19@CDKeyHashM:

; 70   : 	delete m_pHashGroup;

  00293	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0029b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0029f	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR $T8[rsp], rax
  002a7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR $T8[rsp]
  002af	48 89 44 24 78	 mov	 QWORD PTR $T7[rsp], rax
  002b4	48 83 7c 24 78
	00		 cmp	 QWORD PTR $T7[rsp], 0
  002ba	74 1a		 je	 SHORT $LN20@CDKeyHashM
  002bc	ba 01 00 00 00	 mov	 edx, 1
  002c1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR $T7[rsp]
  002c6	e8 00 00 00 00	 call	 ??_GCHash@@QEAAPEAXI@Z
  002cb	90		 npad	 1
  002cc	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv172[rsp], rax
  002d4	eb 0c		 jmp	 SHORT $LN21@CDKeyHashM
$LN20@CDKeyHashM:
  002d6	48 c7 84 24 a8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv172[rsp], 0
$LN21@CDKeyHashM:

; 71   : }

  002e2	48 81 c4 b0 00
	00 00		 add	 rsp, 176		; 000000b0H
  002e9	5f		 pop	 rdi
  002ea	c3		 ret	 0
??1CDKeyHashMap@@QEAA@XZ ENDP				; CDKeyHashMap::~CDKeyHashMap
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comdualkeyhash.cpp
_TEXT	SEGMENT
nBasicCount$ = 32
$T1 = 40
$T2 = 48
$T3 = 56
$T4 = 64
$T5 = 72
$T6 = 80
$T7 = 88
tv81 = 96
tv133 = 104
tv180 = 112
this$ = 144
nKey1Max$ = 152
nKey2Max$ = 160
bValInternal$ = 168
??0CDKeyHashMap@@QEAA@HH_N@Z PROC			; CDKeyHashMap::CDKeyHashMap

; 9    : {

$LN14:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0001b	48 8b fc	 mov	 rdi, rsp
  0001e	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR [rsp+144]
  00032	48 c7 44 24 58
	fe ff ff ff	 mov	 QWORD PTR $T7[rsp], -2

; 10   : 	m_nMaxCount1 = nKey1Max;

  0003b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00043	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR nKey1Max$[rsp]
  0004a	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 11   : 	m_nMaxCount2 = nKey2Max;

  0004d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00055	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR nKey2Max$[rsp]
  0005c	89 48 1c	 mov	 DWORD PTR [rax+28], ecx

; 12   : 	m_pHashNext = new CBMemPool<SThash_next>(eAlloc_Type_alloc);

  0005f	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00064	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00069	48 89 44 24 30	 mov	 QWORD PTR $T2[rsp], rax
  0006e	48 83 7c 24 30
	00		 cmp	 QWORD PTR $T2[rsp], 0
  00074	74 25		 je	 SHORT $LN5@CDKeyHashM
  00076	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0007b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR $T2[rsp]
  00080	e8 00 00 00 00	 call	 ?__autoclassinit2@?$CBMemPool@USThash_next@@@@QEAAX_K@Z
  00085	ba 03 00 00 00	 mov	 edx, 3
  0008a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR $T2[rsp]
  0008f	e8 00 00 00 00	 call	 ??0?$CBMemPool@USThash_next@@@@QEAA@W4E_ALLOC_TYPE@@@Z ; CBMemPool<SThash_next>::CBMemPool<SThash_next>
  00094	48 89 44 24 60	 mov	 QWORD PTR tv81[rsp], rax
  00099	eb 09		 jmp	 SHORT $LN6@CDKeyHashM
$LN5@CDKeyHashM:
  0009b	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR tv81[rsp], 0
$LN6@CDKeyHashM:
  000a4	48 8b 44 24 60	 mov	 rax, QWORD PTR tv81[rsp]
  000a9	48 89 44 24 28	 mov	 QWORD PTR $T1[rsp], rax
  000ae	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000b6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T1[rsp]
  000bb	48 89 08	 mov	 QWORD PTR [rax], rcx

; 13   : 	m_pHashNext->alloc(nKey1Max + nKey2Max + 50);

  000be	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR nKey1Max$[rsp]
  000c5	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR nKey2Max$[rsp]
  000cc	8d 44 08 32	 lea	 eax, DWORD PTR [rax+rcx+50]
  000d0	8b d0		 mov	 edx, eax
  000d2	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000da	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000dd	e8 00 00 00 00	 call	 ?alloc@?$CBMemPool@USThash_next@@@@QEAAHH@Z ; CBMemPool<SThash_next>::alloc

; 14   : 	m_pHashGroup = new CHash(nKey1Max);

  000e2	b9 18 00 00 00	 mov	 ecx, 24
  000e7	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  000ec	48 89 44 24 40	 mov	 QWORD PTR $T4[rsp], rax
  000f1	48 83 7c 24 40
	00		 cmp	 QWORD PTR $T4[rsp], 0
  000f7	74 27		 je	 SHORT $LN7@CDKeyHashM
  000f9	ba 18 00 00 00	 mov	 edx, 24
  000fe	48 8b 4c 24 40	 mov	 rcx, QWORD PTR $T4[rsp]
  00103	e8 00 00 00 00	 call	 ?__autoclassinit2@CHash@@QEAAX_K@Z
  00108	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR nKey1Max$[rsp]
  0010f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR $T4[rsp]
  00114	e8 00 00 00 00	 call	 ??0CHash@@QEAA@I@Z	; CHash::CHash
  00119	48 89 44 24 68	 mov	 QWORD PTR tv133[rsp], rax
  0011e	eb 09		 jmp	 SHORT $LN8@CDKeyHashM
$LN7@CDKeyHashM:
  00120	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR tv133[rsp], 0
$LN8@CDKeyHashM:
  00129	48 8b 44 24 68	 mov	 rax, QWORD PTR tv133[rsp]
  0012e	48 89 44 24 38	 mov	 QWORD PTR $T3[rsp], rax
  00133	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0013b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR $T3[rsp]
  00140	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 15   : 
; 16   : 	int nBasicCount = nKey2Max << 1;	//(nKey2Max * 2)

  00144	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR nKey2Max$[rsp]
  0014b	d1 e0		 shl	 eax, 1
  0014d	89 44 24 20	 mov	 DWORD PTR nBasicCount$[rsp], eax

; 17   : 	gs_pMMgr->init(IDX_BUF_4, nBasicCount);

  00151	44 8b 44 24 20	 mov	 r8d, DWORD PTR nBasicCount$[rsp]
  00156	ba 02 00 00 00	 mov	 edx, 2
  0015b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  00162	e8 00 00 00 00	 call	 ?init@CMemManager@@QEAAXW4E_IDX_BUF@@H@Z ; CMemManager::init

; 18   : 	gs_pMMgr->init(IDX_BUF_8, nBasicCount + 50);

  00167	8b 44 24 20	 mov	 eax, DWORD PTR nBasicCount$[rsp]
  0016b	83 c0 32	 add	 eax, 50			; 00000032H
  0016e	44 8b c0	 mov	 r8d, eax
  00171	ba 03 00 00 00	 mov	 edx, 3
  00176	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  0017d	e8 00 00 00 00	 call	 ?init@CMemManager@@QEAAXW4E_IDX_BUF@@H@Z ; CMemManager::init

; 19   : 	gs_pMMgr->init(IDX_BUF_16, nBasicCount + 50);

  00182	8b 44 24 20	 mov	 eax, DWORD PTR nBasicCount$[rsp]
  00186	83 c0 32	 add	 eax, 50			; 00000032H
  00189	44 8b c0	 mov	 r8d, eax
  0018c	ba 04 00 00 00	 mov	 edx, 4
  00191	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  00198	e8 00 00 00 00	 call	 ?init@CMemManager@@QEAAXW4E_IDX_BUF@@H@Z ; CMemManager::init

; 20   : 	gs_pMMgr->init(IDX_BUF_32, nBasicCount + 50);

  0019d	8b 44 24 20	 mov	 eax, DWORD PTR nBasicCount$[rsp]
  001a1	83 c0 32	 add	 eax, 50			; 00000032H
  001a4	44 8b c0	 mov	 r8d, eax
  001a7	ba 05 00 00 00	 mov	 edx, 5
  001ac	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  001b3	e8 00 00 00 00	 call	 ?init@CMemManager@@QEAAXW4E_IDX_BUF@@H@Z ; CMemManager::init

; 21   : 	gs_pMMgr->init(IDX_BUF_64, nBasicCount);

  001b8	44 8b 44 24 20	 mov	 r8d, DWORD PTR nBasicCount$[rsp]
  001bd	ba 06 00 00 00	 mov	 edx, 6
  001c2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  001c9	e8 00 00 00 00	 call	 ?init@CMemManager@@QEAAXW4E_IDX_BUF@@H@Z ; CMemManager::init

; 22   : 	gs_pMMgr->init(IDX_BUF_128, nBasicCount);

  001ce	44 8b 44 24 20	 mov	 r8d, DWORD PTR nBasicCount$[rsp]
  001d3	ba 07 00 00 00	 mov	 edx, 7
  001d8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  001df	e8 00 00 00 00	 call	 ?init@CMemManager@@QEAAXW4E_IDX_BUF@@H@Z ; CMemManager::init

; 23   : 	gs_pMMgr->init(IDX_BUF_256, 10);

  001e4	41 b8 0a 00 00
	00		 mov	 r8d, 10
  001ea	ba 08 00 00 00	 mov	 edx, 8
  001ef	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  001f6	e8 00 00 00 00	 call	 ?init@CMemManager@@QEAAXW4E_IDX_BUF@@H@Z ; CMemManager::init

; 24   : 	gs_pMMgr->init(IDX_BUF_512, 10);

  001fb	41 b8 0a 00 00
	00		 mov	 r8d, 10
  00201	ba 09 00 00 00	 mov	 edx, 9
  00206	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  0020d	e8 00 00 00 00	 call	 ?init@CMemManager@@QEAAXW4E_IDX_BUF@@H@Z ; CMemManager::init

; 25   : 
; 26   : 	m_bValInternal = bValInternal;

  00212	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0021a	0f b6 8c 24 a8
	00 00 00	 movzx	 ecx, BYTE PTR bValInternal$[rsp]
  00222	88 48 20	 mov	 BYTE PTR [rax+32], cl

; 27   : 
; 28   : 	if (m_bValInternal) {

  00225	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0022d	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  00231	85 c0		 test	 eax, eax
  00233	74 7f		 je	 SHORT $LN2@CDKeyHashM

; 29   : 		m_pValue = new CBMemPool<STValue>(eAlloc_Type_alloc);

  00235	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0023a	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0023f	48 89 44 24 50	 mov	 QWORD PTR $T6[rsp], rax
  00244	48 83 7c 24 50
	00		 cmp	 QWORD PTR $T6[rsp], 0
  0024a	74 25		 je	 SHORT $LN9@CDKeyHashM
  0024c	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00251	48 8b 4c 24 50	 mov	 rcx, QWORD PTR $T6[rsp]
  00256	e8 00 00 00 00	 call	 ?__autoclassinit2@?$CBMemPool@USTValue@@@@QEAAX_K@Z
  0025b	ba 03 00 00 00	 mov	 edx, 3
  00260	48 8b 4c 24 50	 mov	 rcx, QWORD PTR $T6[rsp]
  00265	e8 00 00 00 00	 call	 ??0?$CBMemPool@USTValue@@@@QEAA@W4E_ALLOC_TYPE@@@Z ; CBMemPool<STValue>::CBMemPool<STValue>
  0026a	48 89 44 24 70	 mov	 QWORD PTR tv180[rsp], rax
  0026f	eb 09		 jmp	 SHORT $LN10@CDKeyHashM
$LN9@CDKeyHashM:
  00271	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR tv180[rsp], 0
$LN10@CDKeyHashM:
  0027a	48 8b 44 24 70	 mov	 rax, QWORD PTR tv180[rsp]
  0027f	48 89 44 24 48	 mov	 QWORD PTR $T5[rsp], rax
  00284	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0028c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR $T5[rsp]
  00291	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 30   : 		m_pValue->alloc(nKey2Max + 50);

  00295	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR nKey2Max$[rsp]
  0029c	83 c0 32	 add	 eax, 50			; 00000032H
  0029f	8b d0		 mov	 edx, eax
  002a1	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  002a9	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  002ad	e8 00 00 00 00	 call	 ?alloc@?$CBMemPool@USTValue@@@@QEAAHH@Z ; CBMemPool<STValue>::alloc
  002b2	eb 10		 jmp	 SHORT $LN3@CDKeyHashM
$LN2@CDKeyHashM:

; 31   : 	}
; 32   : 	else m_pValue = NULL;

  002b4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  002bc	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
$LN3@CDKeyHashM:

; 33   : }

  002c4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  002cc	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  002d3	5f		 pop	 rdi
  002d4	c3		 ret	 0
??0CDKeyHashMap@@QEAA@HH_N@Z ENDP			; CDKeyHashMap::CDKeyHashMap
_TEXT	ENDS
text$x	SEGMENT
nBasicCount$ = 32
$T1 = 40
$T2 = 48
$T3 = 56
$T4 = 64
$T5 = 72
$T6 = 80
$T7 = 88
tv81 = 96
tv133 = 104
tv180 = 112
this$ = 144
nKey1Max$ = 152
nKey2Max$ = 160
bValInternal$ = 168
?dtor$0@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA PROC	; `CDKeyHashMap::CDKeyHashMap'::`1'::dtor$0
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00010	48 8b ea	 mov	 rbp, rdx
  00013	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00018	48 8b 4d 30	 mov	 rcx, QWORD PTR $T2[rbp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00021	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00025	5f		 pop	 rdi
  00026	5d		 pop	 rbp
  00027	c3		 ret	 0
?dtor$0@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA ENDP	; `CDKeyHashMap::CDKeyHashMap'::`1'::dtor$0
nBasicCount$ = 32
$T1 = 40
$T2 = 48
$T3 = 56
$T4 = 64
$T5 = 72
$T6 = 80
$T7 = 88
tv81 = 96
tv133 = 104
tv180 = 112
this$ = 144
nKey1Max$ = 152
nKey2Max$ = 160
bValInternal$ = 168
?dtor$1@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA PROC	; `CDKeyHashMap::CDKeyHashMap'::`1'::dtor$1
  00028	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0002d	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00032	55		 push	 rbp
  00033	57		 push	 rdi
  00034	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00038	48 8b ea	 mov	 rbp, rdx
  0003b	ba 18 00 00 00	 mov	 edx, 24
  00040	48 8b 4d 40	 mov	 rcx, QWORD PTR $T4[rbp]
  00044	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00049	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004d	5f		 pop	 rdi
  0004e	5d		 pop	 rbp
  0004f	c3		 ret	 0
?dtor$1@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA ENDP	; `CDKeyHashMap::CDKeyHashMap'::`1'::dtor$1
nBasicCount$ = 32
$T1 = 40
$T2 = 48
$T3 = 56
$T4 = 64
$T5 = 72
$T6 = 80
$T7 = 88
tv81 = 96
tv133 = 104
tv180 = 112
this$ = 144
nKey1Max$ = 152
nKey2Max$ = 160
bValInternal$ = 168
?dtor$2@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA PROC	; `CDKeyHashMap::CDKeyHashMap'::`1'::dtor$2
  00050	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00055	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0005a	55		 push	 rbp
  0005b	57		 push	 rdi
  0005c	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00060	48 8b ea	 mov	 rbp, rdx
  00063	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00068	48 8b 4d 50	 mov	 rcx, QWORD PTR $T6[rbp]
  0006c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00071	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00075	5f		 pop	 rdi
  00076	5d		 pop	 rbp
  00077	c3		 ret	 0
?dtor$2@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA ENDP	; `CDKeyHashMap::CDKeyHashMap'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp /RTCsu
text$x	SEGMENT
nBasicCount$ = 32
$T1 = 40
$T2 = 48
$T3 = 56
$T4 = 64
$T5 = 72
$T6 = 80
$T7 = 88
tv81 = 96
tv133 = 104
tv180 = 112
this$ = 144
nKey1Max$ = 152
nKey2Max$ = 160
bValInternal$ = 168
?dtor$0@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA PROC	; `CDKeyHashMap::CDKeyHashMap'::`1'::dtor$0
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00010	48 8b ea	 mov	 rbp, rdx
  00013	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00018	48 8b 4d 30	 mov	 rcx, QWORD PTR $T2[rbp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00021	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00025	5f		 pop	 rdi
  00026	5d		 pop	 rbp
  00027	c3		 ret	 0
?dtor$0@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA ENDP	; `CDKeyHashMap::CDKeyHashMap'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu
text$x	SEGMENT
nBasicCount$ = 32
$T1 = 40
$T2 = 48
$T3 = 56
$T4 = 64
$T5 = 72
$T6 = 80
$T7 = 88
tv81 = 96
tv133 = 104
tv180 = 112
this$ = 144
nKey1Max$ = 152
nKey2Max$ = 160
bValInternal$ = 168
?dtor$1@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA PROC	; `CDKeyHashMap::CDKeyHashMap'::`1'::dtor$1
  00028	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0002d	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00032	55		 push	 rbp
  00033	57		 push	 rdi
  00034	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00038	48 8b ea	 mov	 rbp, rdx
  0003b	ba 18 00 00 00	 mov	 edx, 24
  00040	48 8b 4d 40	 mov	 rcx, QWORD PTR $T4[rbp]
  00044	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00049	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004d	5f		 pop	 rdi
  0004e	5d		 pop	 rbp
  0004f	c3		 ret	 0
?dtor$1@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA ENDP	; `CDKeyHashMap::CDKeyHashMap'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp /RTCsu
text$x	SEGMENT
nBasicCount$ = 32
$T1 = 40
$T2 = 48
$T3 = 56
$T4 = 64
$T5 = 72
$T6 = 80
$T7 = 88
tv81 = 96
tv133 = 104
tv180 = 112
this$ = 144
nKey1Max$ = 152
nKey2Max$ = 160
bValInternal$ = 168
?dtor$2@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA PROC	; `CDKeyHashMap::CDKeyHashMap'::`1'::dtor$2
  00050	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00055	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0005a	55		 push	 rbp
  0005b	57		 push	 rdi
  0005c	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00060	48 8b ea	 mov	 rbp, rdx
  00063	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00068	48 8b 4d 50	 mov	 rcx, QWORD PTR $T6[rbp]
  0006c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00071	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00075	5f		 pop	 rdi
  00076	5d		 pop	 rbp
  00077	c3		 ret	 0
?dtor$2@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA ENDP	; `CDKeyHashMap::CDKeyHashMap'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\commemmanager.h
;	COMDAT ?delBuf@CMemManager@@QEAAXPEADH@Z
_TEXT	SEGMENT
nIdx$ = 32
this$ = 64
pBuf$ = 72
nSize$ = 80
?delBuf@CMemManager@@QEAAXPEADH@Z PROC			; CMemManager::delBuf, COMDAT

; 38   : 	inline void delBuf(char *pBuf, int nSize) { int nIdx = getIndex(nSize); delBufByIndex(pBuf, nIdx); }

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 0c 00 00 00	 mov	 ecx, 12
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  00028	8b 4c 24 50	 mov	 ecx, DWORD PTR nSize$[rsp]
  0002c	e8 00 00 00 00	 call	 ?getIndex@@YAHH@Z	; getIndex
  00031	89 44 24 20	 mov	 DWORD PTR nIdx$[rsp], eax
  00035	44 8b 44 24 20	 mov	 r8d, DWORD PTR nIdx$[rsp]
  0003a	48 8b 54 24 48	 mov	 rdx, QWORD PTR pBuf$[rsp]
  0003f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00044	e8 00 00 00 00	 call	 ?delBufByIndex@CMemManager@@QEAAXPEADH@Z ; CMemManager::delBufByIndex
  00049	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004d	5f		 pop	 rdi
  0004e	c3		 ret	 0
?delBuf@CMemManager@@QEAAXPEADH@Z ENDP			; CMemManager::delBuf
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\commemmanager.h
;	COMDAT ?newBuf@CMemManager@@QEAAPEADHPEAH@Z
_TEXT	SEGMENT
this$ = 48
nSize$ = 56
pIndex$ = 64
?newBuf@CMemManager@@QEAAPEADHPEAH@Z PROC		; CMemManager::newBuf, COMDAT

; 35   : 	inline char *newBuf(int nSize, int *pIndex) { *pIndex = getIndex(nSize);  return __newBuf(*pIndex, nSize); }

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 08 00 00 00	 mov	 ecx, 8
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]
  00027	8b 4c 24 38	 mov	 ecx, DWORD PTR nSize$[rsp]
  0002b	e8 00 00 00 00	 call	 ?getIndex@@YAHH@Z	; getIndex
  00030	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pIndex$[rsp]
  00035	89 01		 mov	 DWORD PTR [rcx], eax
  00037	48 63 44 24 38	 movsxd	 rax, DWORD PTR nSize$[rsp]
  0003c	4c 8b c0	 mov	 r8, rax
  0003f	48 8b 44 24 40	 mov	 rax, QWORD PTR pIndex$[rsp]
  00044	8b 10		 mov	 edx, DWORD PTR [rax]
  00046	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0004b	e8 00 00 00 00	 call	 ?__newBuf@CMemManager@@AEAAPEADH_K@Z ; CMemManager::__newBuf
  00050	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00054	5f		 pop	 rdi
  00055	c3		 ret	 0
?newBuf@CMemManager@@QEAAPEADHPEAH@Z ENDP		; CMemManager::newBuf
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\commemmanager.h
;	COMDAT ?newBuf@CMemManager@@QEAAPEADH@Z
_TEXT	SEGMENT
nIdx$ = 32
this$ = 64
nSize$ = 72
?newBuf@CMemManager@@QEAAPEADH@Z PROC			; CMemManager::newBuf, COMDAT

; 34   : 	inline char *newBuf(int nSize) { int nIdx = getIndex(nSize);  return __newBuf(nIdx, nSize); }

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 0c 00 00 00	 mov	 ecx, 12
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  00022	8b 4c 24 48	 mov	 ecx, DWORD PTR nSize$[rsp]
  00026	e8 00 00 00 00	 call	 ?getIndex@@YAHH@Z	; getIndex
  0002b	89 44 24 20	 mov	 DWORD PTR nIdx$[rsp], eax
  0002f	48 63 44 24 48	 movsxd	 rax, DWORD PTR nSize$[rsp]
  00034	4c 8b c0	 mov	 r8, rax
  00037	8b 54 24 20	 mov	 edx, DWORD PTR nIdx$[rsp]
  0003b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00040	e8 00 00 00 00	 call	 ?__newBuf@CMemManager@@AEAAPEADH_K@Z ; CMemManager::__newBuf
  00045	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00049	5f		 pop	 rdi
  0004a	c3		 ret	 0
?newBuf@CMemManager@@QEAAPEADH@Z ENDP			; CMemManager::newBuf
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\commemmanager.h
;	COMDAT ?init@CMemManager@@QEAAXW4E_IDX_BUF@@H@Z
_TEXT	SEGMENT
this$ = 16
eIdx$ = 24
nMax$ = 32
?init@CMemManager@@QEAAXW4E_IDX_BUF@@H@Z PROC		; CMemManager::init, COMDAT

; 29   : 	inline void init(E_IDX_BUF eIdx, int nMax) { m_stConfig.nMaxList[eIdx] += nMax; }

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 63 44 24 18	 movsxd	 rax, DWORD PTR eIdx$[rsp]
  00014	48 8b 4c 24 10	 mov	 rcx, QWORD PTR this$[rsp]
  00019	8b 84 81 b0 00
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+176]
  00020	03 44 24 20	 add	 eax, DWORD PTR nMax$[rsp]
  00024	48 63 4c 24 18	 movsxd	 rcx, DWORD PTR eIdx$[rsp]
  00029	48 8b 54 24 10	 mov	 rdx, QWORD PTR this$[rsp]
  0002e	89 84 8a b0 00
	00 00		 mov	 DWORD PTR [rdx+rcx*4+176], eax
  00035	5f		 pop	 rdi
  00036	c3		 ret	 0
?init@CMemManager@@QEAAXW4E_IDX_BUF@@H@Z ENDP		; CMemManager::init
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\combufpool.h
;	COMDAT ?getIndex@@YAHH@Z
_TEXT	SEGMENT
m$ = 32
$S1$ = 56
tv80 = 68
tv73 = 72
s$ = 96
?getIndex@@YAHH@Z PROC					; getIndex, COMDAT

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

$LN5:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi
  00005	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00009	48 8b fc	 mov	 rdi, rsp
  0000c	b9 14 00 00 00	 mov	 ecx, 20
  00011	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00016	f3 ab		 rep stosd
  00018	8b 4c 24 60	 mov	 ecx, DWORD PTR [rsp+96]
  0001c	f2 0f 2a 44 24
	60		 cvtsi2sd xmm0, DWORD PTR s$[rsp]
  00022	f2 0f 11 44 24
	38		 movsd	 QWORD PTR $S1$[rsp], xmm0
  00028	b8 04 00 00 00	 mov	 eax, 4
  0002d	48 6b c0 01	 imul	 rax, rax, 1
  00031	8b 44 04 38	 mov	 eax, DWORD PTR $S1$[rsp+rax]
  00035	c1 f8 14	 sar	 eax, 20
  00038	2d ff 03 00 00	 sub	 eax, 1023		; 000003ffH
  0003d	89 44 24 20	 mov	 DWORD PTR m$[rsp], eax
  00041	8b 44 24 20	 mov	 eax, DWORD PTR m$[rsp]
  00045	b9 01 00 00 00	 mov	 ecx, 1
  0004a	89 4c 24 44	 mov	 DWORD PTR tv80[rsp], ecx
  0004e	0f b6 c8	 movzx	 ecx, al
  00051	8b 44 24 44	 mov	 eax, DWORD PTR tv80[rsp]
  00055	d3 e0		 shl	 eax, cl
  00057	8b 4c 24 60	 mov	 ecx, DWORD PTR s$[rsp]
  0005b	2b c8		 sub	 ecx, eax
  0005d	8b c1		 mov	 eax, ecx
  0005f	8b 4c 24 60	 mov	 ecx, DWORD PTR s$[rsp]
  00063	23 c8		 and	 ecx, eax
  00065	8b c1		 mov	 eax, ecx
  00067	85 c0		 test	 eax, eax
  00069	74 0a		 je	 SHORT $LN3@getIndex
  0006b	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv73[rsp], 1
  00073	eb 08		 jmp	 SHORT $LN4@getIndex
$LN3@getIndex:
  00075	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
$LN4@getIndex:
  0007d	8b 44 24 48	 mov	 eax, DWORD PTR tv73[rsp]
  00081	8b 4c 24 20	 mov	 ecx, DWORD PTR m$[rsp]
  00085	03 c8		 add	 ecx, eax
  00087	8b c1		 mov	 eax, ecx
  00089	8b f8		 mov	 edi, eax
  0008b	48 8b cc	 mov	 rcx, rsp
  0008e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?getIndex@@YAHH@Z$rtcFrameData
  00095	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  0009a	8b c7		 mov	 eax, edi
  0009c	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000a0	5f		 pop	 rdi
  000a1	c3		 ret	 0
?getIndex@@YAHH@Z ENDP					; getIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\comtypes.h
;	COMDAT ?ISINCLUDE@@YA_NHH@Z
_TEXT	SEGMENT
i$ = 16
max$ = 24
?ISINCLUDE@@YA_NHH@Z PROC				; ISINCLUDE, COMDAT

; 322  : inline bool ISINCLUDE(int i, int max) { if (0 <= i && i < max) return true; return false; }

$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	57		 push	 rdi
  00009	83 7c 24 10 00	 cmp	 DWORD PTR i$[rsp], 0
  0000e	7c 0e		 jl	 SHORT $LN2@ISINCLUDE
  00010	8b 44 24 18	 mov	 eax, DWORD PTR max$[rsp]
  00014	39 44 24 10	 cmp	 DWORD PTR i$[rsp], eax
  00018	7d 04		 jge	 SHORT $LN2@ISINCLUDE
  0001a	b0 01		 mov	 al, 1
  0001c	eb 02		 jmp	 SHORT $LN1@ISINCLUDE
$LN2@ISINCLUDE:
  0001e	32 c0		 xor	 al, al
$LN1@ISINCLUDE:
  00020	5f		 pop	 rdi
  00021	c3		 ret	 0
?ISINCLUDE@@YA_NHH@Z ENDP				; ISINCLUDE
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\comtypes.h
;	COMDAT ?c_memcpy@@YAPEAXPEAXPEBXH@Z
_TEXT	SEGMENT
d$ = 0
s$ = 8
tv65 = 16
de$ = 48
so$ = 56
l$ = 64
?c_memcpy@@YAPEAXPEAXPEBXH@Z PROC			; c_memcpy, COMDAT

; 309  : inline void *c_memcpy(void *de, const void *so, int l) { char *d = (char*)de; const char *s = (char*)so; while (l--) *d++ = *s++; return de;}

$LN5:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 08 00 00 00	 mov	 ecx, 8
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]
  00028	48 8b 44 24 30	 mov	 rax, QWORD PTR de$[rsp]
  0002d	48 89 04 24	 mov	 QWORD PTR d$[rsp], rax
  00031	48 8b 44 24 38	 mov	 rax, QWORD PTR so$[rsp]
  00036	48 89 44 24 08	 mov	 QWORD PTR s$[rsp], rax
$LN2@c_memcpy:
  0003b	8b 44 24 40	 mov	 eax, DWORD PTR l$[rsp]
  0003f	89 44 24 10	 mov	 DWORD PTR tv65[rsp], eax
  00043	8b 44 24 40	 mov	 eax, DWORD PTR l$[rsp]
  00047	ff c8		 dec	 eax
  00049	89 44 24 40	 mov	 DWORD PTR l$[rsp], eax
  0004d	83 7c 24 10 00	 cmp	 DWORD PTR tv65[rsp], 0
  00052	74 28		 je	 SHORT $LN3@c_memcpy
  00054	48 8b 04 24	 mov	 rax, QWORD PTR d$[rsp]
  00058	48 8b 4c 24 08	 mov	 rcx, QWORD PTR s$[rsp]
  0005d	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00060	88 08		 mov	 BYTE PTR [rax], cl
  00062	48 8b 04 24	 mov	 rax, QWORD PTR d$[rsp]
  00066	48 ff c0	 inc	 rax
  00069	48 89 04 24	 mov	 QWORD PTR d$[rsp], rax
  0006d	48 8b 44 24 08	 mov	 rax, QWORD PTR s$[rsp]
  00072	48 ff c0	 inc	 rax
  00075	48 89 44 24 08	 mov	 QWORD PTR s$[rsp], rax
  0007a	eb bf		 jmp	 SHORT $LN2@c_memcpy
$LN3@c_memcpy:
  0007c	48 8b 44 24 30	 mov	 rax, QWORD PTR de$[rsp]
  00081	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00085	5f		 pop	 rdi
  00086	c3		 ret	 0
?c_memcpy@@YAPEAXPEAXPEBXH@Z ENDP			; c_memcpy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 56
__$ArrayPad$ = 80
_Buffer$ = 112
_Format$ = 120
sprintf	PROC						; COMDAT

; 1776 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	57		 push	 rdi
  00015	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 18 00 00 00	 mov	 ecx, 24
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 70	 mov	 rcx, QWORD PTR [rsp+112]
  0002d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00034	48 33 c4	 xor	 rax, rsp
  00037	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

  0003c	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
  00041	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR _Format$[rsp+8]
  00049	48 89 44 24 38	 mov	 QWORD PTR _ArgList$[rsp], rax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0004e	4c 8b 4c 24 38	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00053	45 33 c0	 xor	 r8d, r8d
  00056	48 8b 54 24 78	 mov	 rdx, QWORD PTR _Format$[rsp]
  0005b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00060	e8 00 00 00 00	 call	 _vsprintf_l
  00065	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

  00069	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 1787 :     return _Result;

  00072	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 1788 : }

  00076	8b f8		 mov	 edi, eax
  00078	48 8b cc	 mov	 rcx, rsp
  0007b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:sprintf$rtcFrameData
  00082	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00087	8b c7		 mov	 eax, edi
  00089	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0008e	48 33 cc	 xor	 rcx, rsp
  00091	e8 00 00 00 00	 call	 __security_check_cookie
  00096	48 83 c4 60	 add	 rsp, 96			; 00000060H
  0009a	5f		 pop	 rdi
  0009b	c3		 ret	 0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1455 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 0c 00 00 00	 mov	 ecx, 12
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  0002d	48 8b 44 24 58	 mov	 rax, QWORD PTR _ArgList$[rsp]
  00032	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00037	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  0003c	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00041	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  00048	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0004d	e8 00 00 00 00	 call	 _vsnprintf_l

; 1459 :     #pragma warning(pop)
; 1460 : }

  00052	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00056	5f		 pop	 rdi
  00057	c3		 ret	 0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1385 : {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 10 00 00 00	 mov	 ecx, 16
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]

; 1386 :     int const _Result = __stdio_common_vsprintf(

  0002d	e8 00 00 00 00	 call	 __local_stdio_printf_options
  00032	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00035	48 83 c8 01	 or	 rax, 1
  00039	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  0003e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00043	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00048	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0004d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR _Format$[rsp]
  00052	4c 8b 44 24 58	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  00057	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  0005c	48 8b c8	 mov	 rcx, rax
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsprintf
  00065	89 44 24 30	 mov	 DWORD PTR _Result$[rsp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00069	83 7c 24 30 00	 cmp	 DWORD PTR _Result$[rsp], 0
  0006e	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00070	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  00078	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0007a	8b 44 24 30	 mov	 eax, DWORD PTR _Result$[rsp]
  0007e	89 44 24 34	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00082	8b 44 24 34	 mov	 eax, DWORD PTR tv74[rsp]

; 1391 : }

  00086	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0008a	5f		 pop	 rdi
  0008b	c3		 ret	 0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ PROC ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>, COMDAT

; 144  :         {

$LN3:
  00000	40 57		 push	 rdi

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00002	5f		 pop	 rdi
  00003	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ENDP ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 73   : {

$LN3:
  00000	40 57		 push	 rdi

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00002	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00009	5f		 pop	 rdi
  0000a	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_GCHash@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GCHash@@QEAAPEAXI@Z PROC				; CHash::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 08 00 00 00	 mov	 ecx, 8
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]
  00022	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00027	e8 00 00 00 00	 call	 ??1CHash@@QEAA@XZ	; CHash::~CHash
  0002c	8b 44 24 38	 mov	 eax, DWORD PTR __flags$[rsp]
  00030	83 e0 01	 and	 eax, 1
  00033	85 c0		 test	 eax, eax
  00035	74 0f		 je	 SHORT $LN2@scalar
  00037	ba 18 00 00 00	 mov	 edx, 24
  0003c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00041	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00046	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0004b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004f	5f		 pop	 rdi
  00050	c3		 ret	 0
??_GCHash@@QEAAPEAXI@Z ENDP				; CHash::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?__autoclassinit2@CHash@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 16
classSize$ = 24
?__autoclassinit2@CHash@@QEAAX_K@Z PROC			; CHash::__autoclassinit2, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 8b 7c 24 10	 mov	 rdi, QWORD PTR this$[rsp]
  00010	33 c0		 xor	 eax, eax
  00012	48 8b 4c 24 18	 mov	 rcx, QWORD PTR classSize$[rsp]
  00017	f3 aa		 rep stosb
  00019	5f		 pop	 rdi
  0001a	c3		 ret	 0
?__autoclassinit2@CHash@@QEAAX_K@Z ENDP			; CHash::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\comhash.h
;	COMDAT ?setHashValue@CHash@@QEAAXPEAX@Z
_TEXT	SEGMENT
this$ = 16
p$ = 24
?setHashValue@CHash@@QEAAXPEAX@Z PROC			; CHash::setHashValue, COMDAT

; 86   : 	inline void setHashValue(void *p) { m_pHashValue = p; }

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  00010	48 8b 4c 24 18	 mov	 rcx, QWORD PTR p$[rsp]
  00015	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
  00019	5f		 pop	 rdi
  0001a	c3		 ret	 0
?setHashValue@CHash@@QEAAXPEAX@Z ENDP			; CHash::setHashValue
_TEXT	ENDS
END
