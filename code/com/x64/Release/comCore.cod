; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?gs_pCore@@3PEAVCCoreList@@EA			; gs_pCore
PUBLIC	?gs_today_time@@3USTTodayTime@@A		; gs_today_time
_BSS	SEGMENT
?gs_pCore@@3PEAVCCoreList@@EA DQ 01H DUP (?)		; gs_pCore
?gs_today_time@@3USTTodayTime@@A DB 01cH DUP (?)	; gs_today_time
_BSS	ENDS
CONST	SEGMENT
$SG46101 DB	'LIST_COUNT', 00H
	ORG $+5
$SG47129 DB	'i[%d] m_nMax[%d]', 00H
	ORG $+3
$SG45340 DB	'%s_%d', 00H
	ORG $+2
$SG45944 DB	'LOG', 00H
$SG46106 DB	'new (std::nothrow) CTList<CScheduler>() is NULL', 00H
$SG46107 DB	'CCoreList::initScheduler', 00H
	ORG $+3
$SG45488 DB	'%s_%d', 00H
	ORG $+6
$SG46109 DB	'm_pSchedulerList->alloc nCnt[%d]', 00H
	ORG $+3
$SG45563 DB	'%s_%d', 00H
	ORG $+6
$SG46110 DB	'CCoreList::initScheduler', 00H
	ORG $+3
$SG45910 DB	'MPOOL', 00H
	ORG $+6
$SG46111 DB	'TIME_POOL_MAX', 00H
	ORG $+2
$SG46114 DB	'has Failed!! m_pIntervalPool.alloc(%d)', 0aH, 00H
$SG47140 DB	'pList calloc is NULL', 00H
	ORG $+3
$SG46117 DB	'[seq:%d] new (std::nothrow) CScheduler() is NULL', 00H
	ORG $+3
$SG45914 DB	'MPOOL', 00H
	ORG $+6
$SG46118 DB	'CCoreList::initScheduler', 00H
	ORG $+3
$SG45916 DB	'MPOOL', 00H
	ORG $+6
$SG46120 DB	'[seq:%d] pScheduler->init', 00H
	ORG $+6
$SG46121 DB	'CCoreList::initScheduler', 00H
	ORG $+3
$SG45918 DB	'MPOOL', 00H
	ORG $+6
$SG46123 DB	'[seq:%d] pScheduler->push_back', 00H
	ORG $+1
$SG46124 DB	'CCoreList::initScheduler', 00H
	ORG $+3
$SG45920 DB	'MPOOL', 00H
	ORG $+6
$SG46153 DB	'LIST_COUNT', 00H
	ORG $+5
$SG46158 DB	'EVENT_POOL_MAX', 00H
	ORG $+1
$SG46161 DB	'has Failed!! m_pEventPool.alloc(%d)', 0aH, 00H
	ORG $+3
$SG46157 DB	'has Failed!! m_pEventThreadList = new CTList<CComQueueTh'
	DB	'read>()', 0aH, 00H
	ORG $+3
$SG45922 DB	'MPOOL', 00H
	ORG $+6
$SG47187 DB	'atomic_nr[%d] is NULL', 00H
	ORG $+2
$SG47192 DB	'm_pChunk is NULL [%d]', 00H
	ORG $+2
$SG46164 DB	'has Failed!! [seq:%d] pEventThread = new (std::nothrow) '
	DB	'CComQueueThread()', 0aH, 00H
	ORG $+5
$SG46166 DB	'has Failed!! [seq:%d] pEventThread->init()', 0aH, 00H
	ORG $+4
$SG46168 DB	'has Failed!! [seq:%d] m_pEventThreadList->setNewObj(pSch'
	DB	'eduler)', 0aH, 00H
	ORG $+3
$SG45924 DB	'MPOOL', 00H
	ORG $+6
$SG46186 DB	'pLogger is NULL! [%s:%s]', 00H
	ORG $+3
$SG45926 DB	'MPOOL', 00H
	ORG $+6
$SG46187 DB	'CCoreList::initLogger', 00H
	ORG $+2
$SG46190 DB	'pLogger->initConfig has Failed!!![%s:%s]', 00H
	ORG $+3
$SG45928 DB	'MPOOL', 00H
	ORG $+6
$SG46191 DB	'CCoreList::initLogger', 00H
	ORG $+2
$SG46194 DB	'pWriter is NULL!!![%s:%s] [nSTLNo:%d]', 00H
	ORG $+2
$SG46195 DB	'CCoreList::initLogger', 00H
	ORG $+2
$SG46202 DB	'CCoreList::initLogger', 00H
	ORG $+2
$SG46204 DB	'pWriter is NULL!!![nSTLNo:%d]', 0aH, 00H
	ORG $+1
$SG46205 DB	'CCoreList::initLogger', 00H
	ORG $+2
$SG46215 DB	'pWriter is NULL! pLogger[nSTLNo:%d]', 00H
	ORG $+4
$SG46216 DB	'CCoreList::setLoggerEnable', 00H
	ORG $+5
$SG46226 DB	'pWriter is NULL! pLogger[nSTLNo:%d]', 00H
	ORG $+4
$SG46227 DB	'CCoreList::setLoggerDisable', 00H
	ORG $+4
$SG47263 DB	'atomic_nr[%d] is NULL', 00H
	ORG $+2
$SG47268 DB	'm_pChunk is NULL [%d]', 00H
	ORG $+2
$SG45234 DB	'CComThread::start', 00H
	ORG $+6
$SG45235 DB	'm_fpLoopProc is NULL', 00H
	ORG $+3
$SG45237 DB	'CComThread::start', 00H
	ORG $+6
$SG45238 DB	'0 > m_stInfo.nIdx', 00H
	ORG $+6
$SG45241 DB	'CComThread::start', 00H
	ORG $+6
$SG45242 DB	'THREAD_CREATE has Failed', 00H
	ORG $+7
$SG46305 DB	'[lastIdx:%d] new CComThread', 00H
	ORG $+4
$SG46306 DB	'CCoreList::addComThread', 00H
$SG46309 DB	'[lastIdx:%d] pComThread->init()', 00H
$SG46310 DB	'CCoreList::addComThread', 00H
$SG46313 DB	'[idx:%d] m_pThreadList->push_back()', 00H
	ORG $+4
$SG46314 DB	'CCoreList::addComThread', 00H
$SG46317 DB	'[idx:%d] pComThread->start()', 00H
	ORG $+3
$SG46318 DB	'CCoreList::addComThread', 00H
$SG46351 DB	'CCoreList::addLogWriter', 00H
$SG46352 DB	'pWriter = new (std::nothrow) CSTLogger()', 00H
	ORG $+7
$SG46354 DB	'[idx:%d] pWriter->push_back(pWriter)', 00H
	ORG $+3
$SG46355 DB	'CCoreList::addLogWriter', 00H
$SG46358 DB	'pWriter->init(nCount:%d, idx:%d)', 00H
	ORG $+7
$SG46359 DB	'CCoreList::addLogWriter', 00H
$SG46362 DB	'[idx:%d] pWriter->start()!', 00H
	ORG $+5
$SG46363 DB	'CCoreList::addLogWriter', 00H
$SG45341 DB	'LIST_COUNT', 00H
	ORG $+5
$SG46389 DB	'CCoreList::addScheduler', 00H
$SG46390 DB	'pScheduler = new (std::nothrow) CScheduler()', 00H
	ORG $+3
$SG46392 DB	'[idx:%d] pScheduler->push_back(pWriter)', 00H
$SG46393 DB	'CCoreList::addScheduler', 00H
$SG46396 DB	'pScheduler->init(nCount:%d, millisecWait:%d, idx:%d)', 00H
	ORG $+3
$SG46397 DB	'CCoreList::addScheduler', 00H
$SG46400 DB	'[idx:%d] pScheduler->start()', 00H
	ORG $+3
$SG46401 DB	'CCoreList::addScheduler', 00H
$SG45378 DB	'CSTLogger::start', 00H
	ORG $+7
$SG45379 DB	'm_cThread.init', 00H
	ORG $+1
$SG45381 DB	'CSTLogger::start', 00H
	ORG $+7
$SG45382 DB	'm_cThread.start', 00H
$SG45383 DB	'CSTLogger::start()', 0aH, 00H
	ORG $+4
$SG46426 DB	'CCoreList::addQueueThread', 00H
	ORG $+6
$SG46427 DB	'FAIL! pEventThread = new (std::nothrow) CComQueueThread('
	DB	')', 00H
	ORG $+6
$SG46429 DB	'[idx:%d] m_pEventThreadList->push_back(pEventThread)', 00H
	ORG $+3
$SG46430 DB	'CCoreList::addQueueThread', 00H
	ORG $+6
$SG45407 DB	'Logger is already Enabled!', 00H
	ORG $+5
$SG46433 DB	'pEventThread->init(nCount:%d, idx:%d)', 00H
	ORG $+2
$SG46434 DB	'CCoreList::addQueueThread', 00H
	ORG $+6
$SG45412 DB	'CSTLogger::procLoggerEnable', 00H
	ORG $+4
$SG46437 DB	'[idx:%d] pEventThread->start()! ', 00H
	ORG $+7
$SG45413 DB	'Logger has not Initialized!', 00H
	ORG $+4
$SG46438 DB	'CCoreList::addQueueThread', 00H
	ORG $+6
$SG45416 DB	'Logger already exist!', 0aH, 00H
	ORG $+1
$SG45418 DB	'm_pLoggerList->push_back failed!', 0aH, 00H
	ORG $+6
$SG45419 DB	'[%s] procLoggerEnable', 0aH, 00H
	ORG $+1
$SG45430 DB	'writeCount[%d] [%s] porcLoggerDisable', 0aH, 00H
	ORG $+1
$SG46458 DB	'm_pThreadList->alloc(%d)', 00H
	ORG $+7
$SG46459 DB	'CCoreList::initComThread', 00H
	ORG $+7
$SG46474 DB	'm_pWriterList->alloc(%d)', 00H
	ORG $+7
$SG46475 DB	'CCoreList::initLogWriter', 00H
	ORG $+7
$SG46493 DB	'm_pSchedulerList->alloc(%d)', 00H
	ORG $+4
$SG46494 DB	'CCoreList::initScheduler', 00H
	ORG $+7
$SG46499 DB	'has Failed!! m_pIntervalPool->alloc(%d)', 0aH, 00H
	ORG $+7
$SG46500 DB	'CCoreList::initScheduler', 00H
	ORG $+7
$SG45489 DB	'LIST_COUNT', 00H
	ORG $+5
$SG45491 DB	'TIME_WAIT', 00H
	ORG $+6
$SG45494 DB	'has Failed!! m_pTimeList->alloc(%d)', 0aH, 00H
	ORG $+3
$SG46524 DB	'm_pEventThreadList->alloc(%d)', 00H
	ORG $+2
$SG46525 DB	'CCoreList::initQueueThread', 00H
	ORG $+5
$SG46530 DB	'has Failed!! m_pEventPool->alloc(%d)', 0aH, 00H
	ORG $+2
$SG46531 DB	'CCoreList::initQueueThread', 00H
	ORG $+5
$SG45516 DB	'has Failed!! m_pTimeList->alloc(%d)', 0aH, 00H
	ORG $+3
$SG45522 DB	'CScheduler::start', 00H
	ORG $+6
$SG45523 DB	'm_cThread.init', 00H
	ORG $+1
$SG45525 DB	'CScheduler::start', 00H
	ORG $+6
$SG45526 DB	'm_cThread.start', 00H
$SG45564 DB	'LIST_COUNT', 00H
	ORG $+5
$SG45566 DB	'has Failed!! m_sLogQueue.alloc(%d)', 0aH, 00H
	ORG $+4
$SG45573 DB	'has Failed!! m_sLogQueue.alloc(%d)', 0aH, 00H
	ORG $+4
$SG45579 DB	'CComQueueThread::start', 00H
	ORG $+1
$SG45580 DB	'm_cThread.init', 00H
	ORG $+1
$SG45582 DB	'CComQueueThread::start', 00H
	ORG $+1
$SG45583 DB	'm_cThread.start', 00H
$SG45606 DB	'CCoreList::CCoreList', 00H
	ORG $+3
$SG45607 DB	'gs_pMMgr alloc has Failed!!!', 00H
	ORG $+3
$SG45609 DB	'CCoreList::CCoreList', 00H
	ORG $+3
$SG45610 DB	'initSystemFile() has Failed!!!', 00H
	ORG $+1
$SG45612 DB	'CCoreList::CCoreList', 00H
	ORG $+3
$SG45613 DB	'start() has Failed!!!', 00H
	ORG $+2
$SG46738 DB	' del FAIL! i[%d] m_nMax[%d]', 00H
	ORG $+4
$SG46749 DB	'pList calloc is NULL', 00H
	ORG $+3
$SG46844 DB	'FULL! m_nMaxCount[%d]', 00H
	ORG $+2
$SG46845 DB	'CMemList<struct STIntervalInfo>::add', 00H
	ORG $+3
$SG46856 DB	'CMemList<struct STIntervalInfo>::del', 00H
	ORG $+3
$SG46857 DB	'can''t find obj', 00H
	ORG $+1
$SG46916 DB	'i[%d] m_nMax[%d]', 00H
	ORG $+7
$SG46927 DB	'pList calloc is NULL', 00H
	ORG $+3
$SG45909 DB	'IDX_BUF_32', 00H
	ORG $+5
$SG45913 DB	'IDX_BUF_2', 00H
	ORG $+6
$SG45915 DB	'IDX_BUF_%d', 00H
	ORG $+5
$SG45917 DB	'IDX_BUF_%d', 00H
	ORG $+5
$SG45919 DB	'IDX_BUF_%dk', 00H
	ORG $+4
$SG45921 DB	'IDX_BUF_%dk', 00H
	ORG $+4
$SG45923 DB	'IDX_BUF_512k', 00H
	ORG $+3
$SG45925 DB	'IDX_BUF_1m', 00H
	ORG $+5
$SG45927 DB	'IDX_BUF_2m', 00H
	ORG $+5
$SG45930 DB	'CCoreList::initSystemFile', 00H
	ORG $+6
$SG45931 DB	'gs_pMMgr->alloc() has Failed!!!', 00H
$SG45933 DB	'COMTHREAD', 00H
	ORG $+6
$SG45935 DB	'LOG_WRITER', 00H
	ORG $+5
$SG45937 DB	'SCHEDULER', 00H
	ORG $+6
$SG45939 DB	'EVENTPROC', 00H
	ORG $+6
$SG45941 DB	'CCoreList::initSystemFile', 00H
	ORG $+6
$SG45942 DB	'gs_DTEManager.initConfig has Failed!!!', 00H
	ORG $+1
$SG45945 DB	'CCoreList::initSystemFile', 00H
	ORG $+6
$SG45946 DB	'initLogger has Failed!!!', 00H
	ORG $+7
$SG46987 DB	'i[%d] m_nMax[%d]', 00H
	ORG $+7
$SG45970 DB	'CCoreList::initDefaultPool', 00H
	ORG $+5
$SG45971 DB	'gs_pMMgr->alloc() has Failed!!!', 00H
$SG46998 DB	'pList calloc is NULL', 00H
	ORG $+3
$SG46005 DB	'LIST_COUNT', 00H
	ORG $+5
$SG46010 DB	'CCoreList::initComThread', 00H
	ORG $+7
$SG46011 DB	'm_pThreadList = new CTList<CComThread>() is NULL', 00H
	ORG $+7
$SG46014 DB	'CCoreList::initComThread', 00H
	ORG $+7
$SG46015 DB	'new (std::nothrow) CComThread() is NULL', 00H
$SG46017 DB	'CCoreList::initComThread', 00H
	ORG $+7
$SG46018 DB	'm_pThreadList->push_back', 00H
	ORG $+7
$SG47058 DB	'i[%d] m_nMax[%d]', 00H
	ORG $+7
$SG47069 DB	'pList calloc is NULL', 00H
	ORG $+3
$SG46047 DB	'LIST_COUNT', 00H
	ORG $+5
$SG46052 DB	'm_pWriterList->alloc nCnt[%d]', 00H
	ORG $+2
$SG46053 DB	'CCoreList::initLogWriter', 00H
	ORG $+7
$SG46056 DB	'[seq:%d] new (std::nothrow) CSTLogger() is NULL', 00H
$SG46057 DB	'CCoreList::initLogWriter', 00H
	ORG $+7
$SG46061 DB	'[seq:%d] pWriter->init', 00H
	ORG $+1
$SG46062 DB	'CCoreList::initLogWriter', 00H
	ORG $+7
$SG46064 DB	'[seq:%d] pWriter->push_back', 00H
	ORG $+4
$SG46065 DB	'CCoreList::initLogWriter', 00H
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
PUBLIC	printf
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	sprintf
PUBLIC	??1abstract_condition@common@@UEAA@XZ		; common::abstract_condition::~abstract_condition
PUBLIC	??0abstract_condition@common@@QEAA@XZ		; common::abstract_condition::abstract_condition
PUBLIC	??_Gabstract_condition@common@@UEAAPEAXI@Z	; common::abstract_condition::`scalar deleting destructor'
PUBLIC	??0condition@win32@common@@QEAA@XZ		; common::win32::condition::condition
PUBLIC	??1condition@win32@common@@UEAA@XZ		; common::win32::condition::~condition
PUBLIC	?signal@condition@win32@common@@UEAAXXZ		; common::win32::condition::signal
PUBLIC	?signal_all@condition@win32@common@@UEAAXXZ	; common::win32::condition::signal_all
PUBLIC	?wait@condition@win32@common@@QEAA_NHPEAVcritical_section@23@@Z ; common::win32::condition::wait
PUBLIC	??_Gcondition@win32@common@@UEAAPEAXI@Z		; common::win32::condition::`scalar deleting destructor'
PUBLIC	??0win64_atomic@win32@common@@QEAA@XZ		; common::win32::win64_atomic::win64_atomic
PUBLIC	??1win64_atomic@win32@common@@QEAA@XZ		; common::win32::win64_atomic::~win64_atomic
PUBLIC	?getCount@win64_atomic@win32@common@@QEAAHXZ	; common::win32::win64_atomic::getCount
PUBLIC	?setCount@win64_atomic@win32@common@@QEAAXH@Z	; common::win32::win64_atomic::setCount
PUBLIC	?init@win64_atomic@win32@common@@QEAAXXZ	; common::win32::win64_atomic::init
PUBLIC	?atomic_increment@win64_atomic@win32@common@@QEAA_JXZ ; common::win32::win64_atomic::atomic_increment
PUBLIC	?atomic_decrement@win64_atomic@win32@common@@QEAA_JXZ ; common::win32::win64_atomic::atomic_decrement
PUBLIC	?atomic_compare_exchange@win64_atomic@win32@common@@QEAA_J_J0@Z ; common::win32::win64_atomic::atomic_compare_exchange
PUBLIC	??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z	; common::win32::win64_atomic::`vector deleting destructor'
PUBLIC	?ISABLETODELETE@@YA_NW4E_ALLOC_TYPE@@@Z		; ISABLETODELETE
PUBLIC	?ISINCLUDE@@YA_NHH@Z				; ISINCLUDE
PUBLIC	?comGlobalErrorProc@@YAXPEADPEBDH@Z		; comGlobalErrorProc
PUBLIC	?__autoclassinit2@CQueueS@@QEAAX_K@Z		; CQueueS::__autoclassinit2
PUBLIC	??_GCQueueS@@QEAAPEAXI@Z			; CQueueS::`scalar deleting destructor'
PUBLIC	?Year@CDateTime@@QEAAHXZ			; CDateTime::Year
PUBLIC	?Month@CDateTime@@QEAAHXZ			; CDateTime::Month
PUBLIC	?Mday@CDateTime@@QEAAHXZ			; CDateTime::Mday
PUBLIC	?Hour@CDateTime@@QEAAHXZ			; CDateTime::Hour
PUBLIC	?Minute@CDateTime@@QEAAHXZ			; CDateTime::Minute
PUBLIC	?Sec@CDateTime@@QEAAHXZ				; CDateTime::Sec
PUBLIC	?getIndex@@YAHH@Z				; getIndex
PUBLIC	?newBuf@CMemManager@@QEAAPEADH@Z		; CMemManager::newBuf
PUBLIC	?delBuf@CMemManager@@QEAAXPEADH@Z		; CMemManager::delBuf
PUBLIC	?addLogSize@CLogger@@QEAAXH@Z			; CLogger::addLogSize
PUBLIC	?getSTLNo@CLogger@@QEAAHXZ			; CLogger::getSTLNo
PUBLIC	?setLogFlag@CLogger@@QEAAXW4E_LOG_FLAG@@@Z	; CLogger::setLogFlag
PUBLIC	?clearLogFlag@CLogger@@QEAAXW4E_LOG_FLAG@@@Z	; CLogger::clearLogFlag
PUBLIC	?isLogFlag@CLogger@@QEAA_NW4E_LOG_FLAG@@@Z	; CLogger::isLogFlag
PUBLIC	?pop@CLogger@@QEAAPEADXZ			; CLogger::pop
PUBLIC	?getLogName@CLogger@@QEAAPEADXZ			; CLogger::getLogName
PUBLIC	?setCondition@CLogger@@QEAAXPEAVcondition@win32@common@@@Z ; CLogger::setCondition
PUBLIC	??_GCLogger@@QEAAPEAXI@Z			; CLogger::`scalar deleting destructor'
PUBLIC	??_ECLogger@@QEAAPEAXI@Z			; CLogger::`vector deleting destructor'
PUBLIC	??0STThreadInfo@@QEAA@XZ			; STThreadInfo::STThreadInfo
PUBLIC	??1STThreadInfo@@QEAA@XZ			; STThreadInfo::~STThreadInfo
PUBLIC	??0CComThread@@QEAA@XZ				; CComThread::CComThread
PUBLIC	??1CComThread@@QEAA@XZ				; CComThread::~CComThread
PUBLIC	?init@CComThread@@QEAA_NP6AXPEAUSTThreadInfo@@@ZPEAXH2@Z ; CComThread::init
PUBLIC	?start@CComThread@@QEAA_NXZ			; CComThread::start
PUBLIC	?quit@CComThread@@QEAA_NXZ			; CComThread::quit
PUBLIC	?ProcThread@CComThread@@SAKPEAX@Z		; CComThread::ProcThread
PUBLIC	?setIdx@CComThread@@QEAAXH@Z			; CComThread::setIdx
PUBLIC	?bActive@CComThread@@QEAA_NXZ			; CComThread::bActive
PUBLIC	?sendSignal@CComThread@@QEAAXXZ			; CComThread::sendSignal
PUBLIC	??_GCComThread@@QEAAPEAXI@Z			; CComThread::`scalar deleting destructor'
PUBLIC	??_ECComThread@@QEAAPEAXI@Z			; CComThread::`vector deleting destructor'
PUBLIC	?loggerLoop@@YAXPEAUSTThreadInfo@@@Z		; loggerLoop
PUBLIC	??0CSTLogger@@QEAA@XZ				; CSTLogger::CSTLogger
PUBLIC	??1CSTLogger@@QEAA@XZ				; CSTLogger::~CSTLogger
PUBLIC	?initConfig@CSTLogger@@QEAA_NPEADH0@Z		; CSTLogger::initConfig
PUBLIC	?init@CSTLogger@@QEAA_NHH@Z			; CSTLogger::init
PUBLIC	?start@CSTLogger@@QEAA_NXZ			; CSTLogger::start
PUBLIC	?quit@CSTLogger@@QEAA_NXZ			; CSTLogger::quit
PUBLIC	?IsCommand@CSTLogger@@QEAA_NXZ			; CSTLogger::IsCommand
PUBLIC	?GetQueue@CSTLogger@@QEAAXXZ			; CSTLogger::GetQueue
PUBLIC	?TimeProc@CSTLogger@@QEAAXXZ			; CSTLogger::TimeProc
PUBLIC	?procLoggerEnable@CSTLogger@@QEAAXPEAVCLogger@@@Z ; CSTLogger::procLoggerEnable
PUBLIC	?porcLoggerDisable@CSTLogger@@QEAAXPEAVCLogger@@@Z ; CSTLogger::porcLoggerDisable
PUBLIC	?pushCommand@CSTLogger@@QEAA_NPEAUSTLCommand@@@Z ; CSTLogger::pushCommand
PUBLIC	?_init@CSTLogger@@AEAA_NH@Z			; CSTLogger::_init
PUBLIC	??_GCSTLogger@@QEAAPEAXI@Z			; CSTLogger::`scalar deleting destructor'
PUBLIC	??_ECSTLogger@@QEAAPEAXI@Z			; CSTLogger::`vector deleting destructor'
PUBLIC	?schedulerLoop@@YAXPEAUSTThreadInfo@@@Z		; schedulerLoop
PUBLIC	??0CScheduler@@QEAA@XZ				; CScheduler::CScheduler
PUBLIC	??1CScheduler@@QEAA@XZ				; CScheduler::~CScheduler
PUBLIC	?initConfig@CScheduler@@QEAA_NPEADH0@Z		; CScheduler::initConfig
PUBLIC	?init@CScheduler@@QEAA_NHHH@Z			; CScheduler::init
PUBLIC	?start@CScheduler@@QEAA_NXZ			; CScheduler::start
PUBLIC	?quit@CScheduler@@QEAA_NXZ			; CScheduler::quit
PUBLIC	?timeNext@CScheduler@@QEAAPEAUSTIntervalInfo@@PEAH@Z ; CScheduler::timeNext
PUBLIC	?deleteTime@CScheduler@@QEAA_NPEAUSTIntervalInfo@@@Z ; CScheduler::deleteTime
PUBLIC	?addTime@CScheduler@@QEAAHPEAUSTIntervalInfo@@@Z ; CScheduler::addTime
PUBLIC	?getMilliSecHalf@CScheduler@@QEAAHXZ		; CScheduler::getMilliSecHalf
PUBLIC	?setGoal@CScheduler@@QEAAXXZ			; CScheduler::setGoal
PUBLIC	?getGoal@CScheduler@@QEAAIXZ			; CScheduler::getGoal
PUBLIC	??_GCScheduler@@QEAAPEAXI@Z			; CScheduler::`scalar deleting destructor'
PUBLIC	??_ECScheduler@@QEAAPEAXI@Z			; CScheduler::`vector deleting destructor'
PUBLIC	??0?$CMemList@USTIntervalInfo@@@@QEAA@XZ	; CMemList<STIntervalInfo>::CMemList<STIntervalInfo>
PUBLIC	??1?$CMemList@USTIntervalInfo@@@@QEAA@XZ	; CMemList<STIntervalInfo>::~CMemList<STIntervalInfo>
PUBLIC	?alloc@?$CMemList@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z ; CMemList<STIntervalInfo>::alloc
PUBLIC	?getNext@?$CMemList@USTIntervalInfo@@@@QEAAPEAUSTIntervalInfo@@PEAH@Z ; CMemList<STIntervalInfo>::getNext
PUBLIC	?add@?$CMemList@USTIntervalInfo@@@@QEAAHPEAUSTIntervalInfo@@@Z ; CMemList<STIntervalInfo>::add
PUBLIC	?del@?$CMemList@USTIntervalInfo@@@@QEAA_NPEAUSTIntervalInfo@@@Z ; CMemList<STIntervalInfo>::del
PUBLIC	?_del@?$CMemList@USTIntervalInfo@@@@AEAAXH@Z	; CMemList<STIntervalInfo>::_del
PUBLIC	?__autoclassinit2@?$CMemList@USTIntervalInfo@@@@QEAAX_K@Z ; CMemList<STIntervalInfo>::__autoclassinit2
PUBLIC	??_G?$CMemList@USTIntervalInfo@@@@QEAAPEAXI@Z	; CMemList<STIntervalInfo>::`scalar deleting destructor'
PUBLIC	?eventThreadLoop@@YAXPEAUSTThreadInfo@@@Z	; eventThreadLoop
PUBLIC	??0CComQueueThread@@QEAA@XZ			; CComQueueThread::CComQueueThread
PUBLIC	??1CComQueueThread@@QEAA@XZ			; CComQueueThread::~CComQueueThread
PUBLIC	?initConfig@CComQueueThread@@QEAA_NPEADH0@Z	; CComQueueThread::initConfig
PUBLIC	?init@CComQueueThread@@QEAA_NHH@Z		; CComQueueThread::init
PUBLIC	?start@CComQueueThread@@QEAA_NXZ		; CComQueueThread::start
PUBLIC	?quit@CComQueueThread@@QEAA_NXZ			; CComQueueThread::quit
PUBLIC	?putQueue@CComQueueThread@@QEAA_NPEAUSTEvent@@@Z ; CComQueueThread::putQueue
PUBLIC	?getEvent@CComQueueThread@@QEAAPEAUSTEvent@@XZ	; CComQueueThread::getEvent
PUBLIC	??_GCComQueueThread@@QEAAPEAXI@Z		; CComQueueThread::`scalar deleting destructor'
PUBLIC	??_ECComQueueThread@@QEAAPEAXI@Z		; CComQueueThread::`vector deleting destructor'
PUBLIC	??0CCoreList@@QEAA@XZ				; CCoreList::CCoreList
PUBLIC	??1CCoreList@@QEAA@XZ				; CCoreList::~CCoreList
PUBLIC	?initSystemFile@CCoreList@@QEAA_NXZ		; CCoreList::initSystemFile
PUBLIC	?initDefaultPool@CCoreList@@QEAA_NHHH@Z		; CCoreList::initDefaultPool
PUBLIC	?initLogger@CCoreList@@QEAA_NPEAVCLogger@@PEAD1@Z ; CCoreList::initLogger
PUBLIC	?initLogger@CCoreList@@QEAA_NPEAVCLogger@@@Z	; CCoreList::initLogger
PUBLIC	?setLoggerEnable@CCoreList@@QEAA_NPEAVCLogger@@@Z ; CCoreList::setLoggerEnable
PUBLIC	?setLoggerDisable@CCoreList@@QEAA_NPEAVCLogger@@@Z ; CCoreList::setLoggerDisable
PUBLIC	?start@CCoreList@@QEAA_NXZ			; CCoreList::start
PUBLIC	?destroy@CCoreList@@QEAAXXZ			; CCoreList::destroy
PUBLIC	?delEvent@CCoreList@@QEAA_NPEAUSTEvent@@@Z	; CCoreList::delEvent
PUBLIC	?putEvent@CCoreList@@QEAA_NPEAUSTEvent@@@Z	; CCoreList::putEvent
PUBLIC	?putTimer@CCoreList@@QEAA_NPEAUSTIntervalInfo@@@Z ; CCoreList::putTimer
PUBLIC	?addComThread@CCoreList@@QEAAHP6AXPEAUSTThreadInfo@@@ZPEAXH2@Z ; CCoreList::addComThread
PUBLIC	?delComThread@CCoreList@@QEAA_NH@Z		; CCoreList::delComThread
PUBLIC	?addLogWriter@CCoreList@@QEAAHH@Z		; CCoreList::addLogWriter
PUBLIC	?addScheduler@CCoreList@@QEAAHHH@Z		; CCoreList::addScheduler
PUBLIC	?addQueueThread@CCoreList@@QEAAHH@Z		; CCoreList::addQueueThread
PUBLIC	?initComThread@CCoreList@@QEAA_NPEAD0@Z		; CCoreList::initComThread
PUBLIC	?initLogWriter@CCoreList@@QEAA_NPEAD0_N@Z	; CCoreList::initLogWriter
PUBLIC	?initScheduler@CCoreList@@QEAA_NPEAD0@Z		; CCoreList::initScheduler
PUBLIC	?initQueueThread@CCoreList@@QEAA_NPEAD0@Z	; CCoreList::initQueueThread
PUBLIC	?initComThread@CCoreList@@QEAA_NH@Z		; CCoreList::initComThread
PUBLIC	?initLogWriter@CCoreList@@QEAA_NH@Z		; CCoreList::initLogWriter
PUBLIC	?initScheduler@CCoreList@@QEAA_NHH@Z		; CCoreList::initScheduler
PUBLIC	?initQueueThread@CCoreList@@QEAA_NHH@Z		; CCoreList::initQueueThread
PUBLIC	?setListAllocType@CCoreList@@QEAAXW4E_ALLOC_TYPE@@W4E_SYS_LIST_TYPE@@@Z ; CCoreList::setListAllocType
PUBLIC	??0?$CMemPool@USTIntervalInfo@@@@QEAA@XZ	; CMemPool<STIntervalInfo>::CMemPool<STIntervalInfo>
PUBLIC	??1?$CMemPool@USTIntervalInfo@@@@QEAA@XZ	; CMemPool<STIntervalInfo>::~CMemPool<STIntervalInfo>
PUBLIC	?clear@?$CMemPool@USTIntervalInfo@@@@QEAAXXZ	; CMemPool<STIntervalInfo>::clear
PUBLIC	?alloc@?$CMemPool@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z ; CMemPool<STIntervalInfo>::alloc
PUBLIC	?__autoclassinit2@?$CMemPool@USTIntervalInfo@@@@QEAAX_K@Z ; CMemPool<STIntervalInfo>::__autoclassinit2
PUBLIC	??_G?$CMemPool@USTIntervalInfo@@@@QEAAPEAXI@Z	; CMemPool<STIntervalInfo>::`scalar deleting destructor'
PUBLIC	??0?$CMemPool@USTEvent@@@@QEAA@XZ		; CMemPool<STEvent>::CMemPool<STEvent>
PUBLIC	??1?$CMemPool@USTEvent@@@@QEAA@XZ		; CMemPool<STEvent>::~CMemPool<STEvent>
PUBLIC	?clear@?$CMemPool@USTEvent@@@@QEAAXXZ		; CMemPool<STEvent>::clear
PUBLIC	?alloc@?$CMemPool@USTEvent@@@@QEAAHHW4E_ALLOC_TYPE@@@Z ; CMemPool<STEvent>::alloc
PUBLIC	?delMem@?$CMemPool@USTEvent@@@@QEAA_NPEAUSTEvent@@@Z ; CMemPool<STEvent>::delMem
PUBLIC	?__autoclassinit2@?$CMemPool@USTEvent@@@@QEAAX_K@Z ; CMemPool<STEvent>::__autoclassinit2
PUBLIC	??_G?$CMemPool@USTEvent@@@@QEAAPEAXI@Z		; CMemPool<STEvent>::`scalar deleting destructor'
PUBLIC	??0?$CTList@VCLogger@@@@QEAA@XZ			; CTList<CLogger>::CTList<CLogger>
PUBLIC	??1?$CTList@VCLogger@@@@QEAA@XZ			; CTList<CLogger>::~CTList<CLogger>
PUBLIC	?alloc@?$CTList@VCLogger@@@@QEAAHHW4E_ALLOC_TYPE@@@Z ; CTList<CLogger>::alloc
PUBLIC	?push_back@?$CTList@VCLogger@@@@QEAA_NPEAVCLogger@@PEAH@Z ; CTList<CLogger>::push_back
PUBLIC	?IsExist@?$CTList@VCLogger@@@@QEAA_NPEAVCLogger@@@Z ; CTList<CLogger>::IsExist
PUBLIC	?del@?$CTList@VCLogger@@@@QEAA_NPEAVCLogger@@@Z	; CTList<CLogger>::del
PUBLIC	?getNext@?$CTList@VCLogger@@@@QEAAPEAVCLogger@@PEAH@Z ; CTList<CLogger>::getNext
PUBLIC	?__alloc@?$CTList@VCLogger@@@@AEAAHH@Z		; CTList<CLogger>::__alloc
PUBLIC	?_DEL@?$CTList@VCLogger@@@@AEAAXH@Z		; CTList<CLogger>::_DEL
PUBLIC	?__autoclassinit2@?$CTList@VCLogger@@@@QEAAX_K@Z ; CTList<CLogger>::__autoclassinit2
PUBLIC	??_G?$CTList@VCLogger@@@@QEAAPEAXI@Z		; CTList<CLogger>::`scalar deleting destructor'
PUBLIC	??0?$CTList@VCSTLogger@@@@QEAA@XZ		; CTList<CSTLogger>::CTList<CSTLogger>
PUBLIC	??1?$CTList@VCSTLogger@@@@QEAA@XZ		; CTList<CSTLogger>::~CTList<CSTLogger>
PUBLIC	?alloc@?$CTList@VCSTLogger@@@@QEAAHHW4E_ALLOC_TYPE@@@Z ; CTList<CSTLogger>::alloc
PUBLIC	?push_back@?$CTList@VCSTLogger@@@@QEAA_NPEAVCSTLogger@@PEAH@Z ; CTList<CSTLogger>::push_back
PUBLIC	?del@?$CTList@VCSTLogger@@@@QEAA_NH@Z		; CTList<CSTLogger>::del
PUBLIC	?getObj@?$CTList@VCSTLogger@@@@QEAAPEAVCSTLogger@@H@Z ; CTList<CSTLogger>::getObj
PUBLIC	?getNext@?$CTList@VCSTLogger@@@@QEAAPEAVCSTLogger@@PEAH@Z ; CTList<CSTLogger>::getNext
PUBLIC	?size@?$CTList@VCSTLogger@@@@QEAAHXZ		; CTList<CSTLogger>::size
PUBLIC	?setObjAllocType@?$CTList@VCSTLogger@@@@QEAAXW4E_ALLOC_TYPE@@@Z ; CTList<CSTLogger>::setObjAllocType
PUBLIC	?__alloc@?$CTList@VCSTLogger@@@@AEAAHH@Z	; CTList<CSTLogger>::__alloc
PUBLIC	?_DEL@?$CTList@VCSTLogger@@@@AEAAXH@Z		; CTList<CSTLogger>::_DEL
PUBLIC	?__autoclassinit2@?$CTList@VCSTLogger@@@@QEAAX_K@Z ; CTList<CSTLogger>::__autoclassinit2
PUBLIC	??_G?$CTList@VCSTLogger@@@@QEAAPEAXI@Z		; CTList<CSTLogger>::`scalar deleting destructor'
PUBLIC	??0?$CTList@VCScheduler@@@@QEAA@XZ		; CTList<CScheduler>::CTList<CScheduler>
PUBLIC	??1?$CTList@VCScheduler@@@@QEAA@XZ		; CTList<CScheduler>::~CTList<CScheduler>
PUBLIC	?alloc@?$CTList@VCScheduler@@@@QEAAHHW4E_ALLOC_TYPE@@@Z ; CTList<CScheduler>::alloc
PUBLIC	?push_back@?$CTList@VCScheduler@@@@QEAA_NPEAVCScheduler@@PEAH@Z ; CTList<CScheduler>::push_back
PUBLIC	?del@?$CTList@VCScheduler@@@@QEAA_NH@Z		; CTList<CScheduler>::del
PUBLIC	?getObj@?$CTList@VCScheduler@@@@QEAAPEAVCScheduler@@H@Z ; CTList<CScheduler>::getObj
PUBLIC	?getNext@?$CTList@VCScheduler@@@@QEAAPEAVCScheduler@@PEAH@Z ; CTList<CScheduler>::getNext
PUBLIC	?size@?$CTList@VCScheduler@@@@QEAAHXZ		; CTList<CScheduler>::size
PUBLIC	?setObjAllocType@?$CTList@VCScheduler@@@@QEAAXW4E_ALLOC_TYPE@@@Z ; CTList<CScheduler>::setObjAllocType
PUBLIC	?__alloc@?$CTList@VCScheduler@@@@AEAAHH@Z	; CTList<CScheduler>::__alloc
PUBLIC	?_DEL@?$CTList@VCScheduler@@@@AEAAXH@Z		; CTList<CScheduler>::_DEL
PUBLIC	?__autoclassinit2@?$CTList@VCScheduler@@@@QEAAX_K@Z ; CTList<CScheduler>::__autoclassinit2
PUBLIC	??_G?$CTList@VCScheduler@@@@QEAAPEAXI@Z		; CTList<CScheduler>::`scalar deleting destructor'
PUBLIC	??0?$CTList@VCComThread@@@@QEAA@XZ		; CTList<CComThread>::CTList<CComThread>
PUBLIC	??1?$CTList@VCComThread@@@@QEAA@XZ		; CTList<CComThread>::~CTList<CComThread>
PUBLIC	?alloc@?$CTList@VCComThread@@@@QEAAHHW4E_ALLOC_TYPE@@@Z ; CTList<CComThread>::alloc
PUBLIC	?push_back@?$CTList@VCComThread@@@@QEAA_NPEAVCComThread@@PEAH@Z ; CTList<CComThread>::push_back
PUBLIC	?del@?$CTList@VCComThread@@@@QEAA_NH@Z		; CTList<CComThread>::del
PUBLIC	?getObj@?$CTList@VCComThread@@@@QEAAPEAVCComThread@@H@Z ; CTList<CComThread>::getObj
PUBLIC	?getNext@?$CTList@VCComThread@@@@QEAAPEAVCComThread@@PEAH@Z ; CTList<CComThread>::getNext
PUBLIC	?size@?$CTList@VCComThread@@@@QEAAHXZ		; CTList<CComThread>::size
PUBLIC	?lastIdx@?$CTList@VCComThread@@@@QEAAHXZ	; CTList<CComThread>::lastIdx
PUBLIC	?setObjAllocType@?$CTList@VCComThread@@@@QEAAXW4E_ALLOC_TYPE@@@Z ; CTList<CComThread>::setObjAllocType
PUBLIC	?__alloc@?$CTList@VCComThread@@@@AEAAHH@Z	; CTList<CComThread>::__alloc
PUBLIC	?_DEL@?$CTList@VCComThread@@@@AEAAXH@Z		; CTList<CComThread>::_DEL
PUBLIC	?__autoclassinit2@?$CTList@VCComThread@@@@QEAAX_K@Z ; CTList<CComThread>::__autoclassinit2
PUBLIC	??_G?$CTList@VCComThread@@@@QEAAPEAXI@Z		; CTList<CComThread>::`scalar deleting destructor'
PUBLIC	??0?$CTList@VCComQueueThread@@@@QEAA@XZ		; CTList<CComQueueThread>::CTList<CComQueueThread>
PUBLIC	??1?$CTList@VCComQueueThread@@@@QEAA@XZ		; CTList<CComQueueThread>::~CTList<CComQueueThread>
PUBLIC	?alloc@?$CTList@VCComQueueThread@@@@QEAAHHW4E_ALLOC_TYPE@@@Z ; CTList<CComQueueThread>::alloc
PUBLIC	?push_back@?$CTList@VCComQueueThread@@@@QEAA_NPEAVCComQueueThread@@PEAH@Z ; CTList<CComQueueThread>::push_back
PUBLIC	?del@?$CTList@VCComQueueThread@@@@QEAA_NH@Z	; CTList<CComQueueThread>::del
PUBLIC	?getObj@?$CTList@VCComQueueThread@@@@QEAAPEAVCComQueueThread@@H@Z ; CTList<CComQueueThread>::getObj
PUBLIC	?getNext@?$CTList@VCComQueueThread@@@@QEAAPEAVCComQueueThread@@PEAH@Z ; CTList<CComQueueThread>::getNext
PUBLIC	?size@?$CTList@VCComQueueThread@@@@QEAAHXZ	; CTList<CComQueueThread>::size
PUBLIC	?setObjAllocType@?$CTList@VCComQueueThread@@@@QEAAXW4E_ALLOC_TYPE@@@Z ; CTList<CComQueueThread>::setObjAllocType
PUBLIC	?__alloc@?$CTList@VCComQueueThread@@@@AEAAHH@Z	; CTList<CComQueueThread>::__alloc
PUBLIC	?_DEL@?$CTList@VCComQueueThread@@@@AEAAXH@Z	; CTList<CComQueueThread>::_DEL
PUBLIC	?__autoclassinit2@?$CTList@VCComQueueThread@@@@QEAAX_K@Z ; CTList<CComQueueThread>::__autoclassinit2
PUBLIC	??_G?$CTList@VCComQueueThread@@@@QEAAPEAXI@Z	; CTList<CComQueueThread>::`scalar deleting destructor'
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7abstract_condition@common@@6B@		; common::abstract_condition::`vftable'
PUBLIC	??_7condition@win32@common@@6B@			; common::win32::condition::`vftable'
PUBLIC	??_C@_0BD@KEHDJCKJ@ERROR?$CB?5?$FL?$CFs?3?$CFd?$FN?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_R4abstract_condition@common@@6B@		; common::abstract_condition::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVabstract_condition@common@@@8		; common::abstract_condition `RTTI Type Descriptor'
PUBLIC	??_R3abstract_condition@common@@8		; common::abstract_condition::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2abstract_condition@common@@8		; common::abstract_condition::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@abstract_condition@common@@8	; common::abstract_condition::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4condition@win32@common@@6B@		; common::win32::condition::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVcondition@win32@common@@@8		; common::win32::condition `RTTI Type Descriptor'
PUBLIC	??_R3condition@win32@common@@8			; common::win32::condition::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2condition@win32@common@@8			; common::win32::condition::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@condition@win32@common@@8		; common::win32::condition::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_L@YAXPEAX_K1P6AX0@Z2@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YAXPEAX_K1P6AX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	_purecall:PROC
EXTRN	??2@YAPEAX_K@Z:PROC				; operator new
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	??_V@YAXPEAX@Z:PROC				; operator delete[]
EXTRN	??_V@YAXPEAX_K@Z:PROC				; operator delete[]
EXTRN	?initSystem@CEnv@@SAHPEAD@Z:PROC		; CEnv::initSystem
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	__imp___stdio_common_vsprintf:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_exit:PROC
EXTRN	__imp_abort:PROC
EXTRN	__imp_atoi:PROC
EXTRN	??2@YAPEAX_KAEBUnothrow_t@std@@@Z:PROC		; operator new
EXTRN	??_U@YAPEAX_KAEBUnothrow_t@std@@@Z:PROC		; operator new[]
EXTRN	??3@YAXPEAXAEBUnothrow_t@std@@@Z:PROC		; operator delete
EXTRN	??_V@YAXPEAXAEBUnothrow_t@std@@@Z:PROC		; operator delete[]
EXTRN	__imp_CreateThread:PROC
EXTRN	__imp_SetEvent:PROC
EXTRN	__imp_ResetEvent:PROC
EXTRN	__imp_WaitForSingleObject:PROC
EXTRN	__imp_CloseHandle:PROC
EXTRN	__imp_GetTickCount:PROC
EXTRN	__imp_CreateEventA:PROC
EXTRN	__imp_GetPrivateProfileIntA:PROC
EXTRN	??_Eabstract_condition@common@@UEAAPEAXI@Z:PROC	; common::abstract_condition::`vector deleting destructor'
EXTRN	??_Econdition@win32@common@@UEAAPEAXI@Z:PROC	; common::win32::condition::`vector deleting destructor'
EXTRN	??0CQueueS@@QEAA@XZ:PROC			; CQueueS::CQueueS
EXTRN	??1CQueueS@@QEAA@XZ:PROC			; CQueueS::~CQueueS
EXTRN	?alloc@CQueueS@@QEAA_NHW4E_ALLOC_TYPE@@@Z:PROC	; CQueueS::alloc
EXTRN	?push@CQueueS@@QEAA_NPEAX@Z:PROC		; CQueueS::push
EXTRN	?pop@CQueueS@@QEAAPEAXXZ:PROC			; CQueueS::pop
EXTRN	??0CDateTime@@QEAA@W4DT_TYPE@@W4TZ_TYPE@@@Z:PROC ; CDateTime::CDateTime
EXTRN	??1CDateTime@@QEAA@XZ:PROC			; CDateTime::~CDateTime
EXTRN	?DateString@CDateTime@@QEAAPEBDD@Z:PROC		; CDateTime::DateString
EXTRN	??0CMemManager@@QEAA@XZ:PROC			; CMemManager::CMemManager
EXTRN	?init@CMemManager@@QEAAXPEAUSTBufConf@@@Z:PROC	; CMemManager::init
EXTRN	?alloc@CMemManager@@QEAA_NXZ:PROC		; CMemManager::alloc
EXTRN	?delBufByIndex@CMemManager@@QEAAXPEADH@Z:PROC	; CMemManager::delBufByIndex
EXTRN	?__newBuf@CMemManager@@AEAAPEADH_K@Z:PROC	; CMemManager::__newBuf
EXTRN	?initConfig@CTimeExpManager@@QEAA_NPEAD@Z:PROC	; CTimeExpManager::initConfig
EXTRN	??1CLogger@@QEAA@XZ:PROC			; CLogger::~CLogger
EXTRN	?initConfig@CLogger@@QEAA?AW4E_LOG_INIT_RES@@PEAD0@Z:PROC ; CLogger::initConfig
EXTRN	?OpenLogger@CLogger@@QEAAXXZ:PROC		; CLogger::OpenLogger
EXTRN	?LogPrint@CLogger@@QEAAXPEAD@Z:PROC		; CLogger::LogPrint
EXTRN	?disable@CLogger@@QEAAXXZ:PROC			; CLogger::disable
EXTRN	?checkChangeProc@CLogger@@QEAAXH@Z:PROC		; CLogger::checkChangeProc
EXTRN	__CxxFrameHandler3:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__GSHandlerCheck_EH:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	?nothrow@std@@3Unothrow_t@1@B:BYTE		; std::nothrow
EXTRN	?g_pSystem@@3PEADEA:QWORD			; g_pSystem
EXTRN	?g_szSystemError@@3PADA:BYTE			; g_szSystemError
EXTRN	?g_szMessage@@3PADA:BYTE			; g_szMessage
EXTRN	?gs_pMMgr@@3PEAVCMemManager@@EA:QWORD		; gs_pMMgr
EXTRN	?gs_cLogger@@3VCLogger@@A:BYTE			; gs_cLogger
EXTRN	?gs_DTEManager@@3VCTimeExpManager@@A:QWORD	; gs_DTEManager
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+121
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+118
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+112
	DD	imagerel $unwind$sprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gabstract_condition@common@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_Gabstract_condition@common@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0condition@win32@common@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+72
	DD	imagerel $unwind$??0condition@win32@common@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1condition@win32@common@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$??1condition@win32@common@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?signal@condition@win32@common@@UEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$?signal@condition@win32@common@@UEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?signal_all@condition@win32@common@@UEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+20
	DD	imagerel $unwind$?signal_all@condition@win32@common@@UEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?wait@condition@win32@common@@QEAA_NHPEAVcritical_section@23@@Z DD imagerel $LN9
	DD	imagerel $LN9+176
	DD	imagerel $unwind$?wait@condition@win32@common@@QEAA_NHPEAVcritical_section@23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gcondition@win32@common@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_Gcondition@win32@common@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?atomic_compare_exchange@win64_atomic@win32@common@@QEAA_J_J0@Z DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$?atomic_compare_exchange@win64_atomic@win32@common@@QEAA_J_J0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z DD imagerel $LN6
	DD	imagerel $LN6+170
	DD	imagerel $unwind$??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?comGlobalErrorProc@@YAXPEADPEBDH@Z DD imagerel $LN3
	DD	imagerel $LN3+75
	DD	imagerel $unwind$?comGlobalErrorProc@@YAXPEADPEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__autoclassinit2@CQueueS@@QEAAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?__autoclassinit2@CQueueS@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GCQueueS@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_GCQueueS@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getIndex@@YAHH@Z DD imagerel $LN5
	DD	imagerel $LN5+119
	DD	imagerel $unwind$?getIndex@@YAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?newBuf@CMemManager@@QEAAPEADH@Z DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$?newBuf@CMemManager@@QEAAPEADH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?delBuf@CMemManager@@QEAAXPEADH@Z DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$?delBuf@CMemManager@@QEAAXPEADH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isLogFlag@CLogger@@QEAA_NW4E_LOG_FLAG@@@Z DD imagerel $LN5
	DD	imagerel $LN5+53
	DD	imagerel $unwind$?isLogFlag@CLogger@@QEAA_NW4E_LOG_FLAG@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pop@CLogger@@QEAAPEADXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?pop@CLogger@@QEAAPEADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GCLogger@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_GCLogger@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_ECLogger@@QEAAPEAXI@Z DD imagerel $LN6
	DD	imagerel $LN6+170
	DD	imagerel $unwind$??_ECLogger@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0STThreadInfo@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+36
	DD	imagerel $unwind$??0STThreadInfo@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1STThreadInfo@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+31
	DD	imagerel $unwind$??1STThreadInfo@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0CComThread@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+132
	DD	imagerel $unwind$??0CComThread@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1CComThread@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$??1CComThread@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?start@CComThread@@QEAA_NXZ DD imagerel $LN7
	DD	imagerel $LN7+220
	DD	imagerel $unwind$?start@CComThread@@QEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?quit@CComThread@@QEAA_NXZ DD imagerel $LN4
	DD	imagerel $LN4+64
	DD	imagerel $unwind$?quit@CComThread@@QEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ProcThread@CComThread@@SAKPEAX@Z DD imagerel $LN5
	DD	imagerel $LN5+105
	DD	imagerel $unwind$?ProcThread@CComThread@@SAKPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?sendSignal@CComThread@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$?sendSignal@CComThread@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GCComThread@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_GCComThread@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_ECComThread@@QEAAPEAXI@Z DD imagerel $LN6
	DD	imagerel $LN6+167
	DD	imagerel $unwind$??_ECComThread@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?loggerLoop@@YAXPEAUSTThreadInfo@@@Z DD imagerel $LN4
	DD	imagerel $LN4+67
	DD	imagerel $unwind$?loggerLoop@@YAXPEAUSTThreadInfo@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0CSTLogger@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+58
	DD	imagerel $unwind$??0CSTLogger@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1CSTLogger@@QEAA@XZ DD imagerel $LN9
	DD	imagerel $LN9+226
	DD	imagerel $unwind$??1CSTLogger@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?initConfig@CSTLogger@@QEAA_NPEADH0@Z DD imagerel $LN5
	DD	imagerel $LN5+152
	DD	imagerel $unwind$?initConfig@CSTLogger@@QEAA_NPEADH0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?init@CSTLogger@@QEAA_NHH@Z DD imagerel $LN5
	DD	imagerel $LN5+78
	DD	imagerel $unwind$?init@CSTLogger@@QEAA_NHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?start@CSTLogger@@QEAA_NXZ DD imagerel $LN6
	DD	imagerel $LN6+180
	DD	imagerel $unwind$?start@CSTLogger@@QEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?quit@CSTLogger@@QEAA_NXZ DD imagerel $LN6
	DD	imagerel $LN6+117
	DD	imagerel $unwind$?quit@CSTLogger@@QEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?IsCommand@CSTLogger@@QEAA_NXZ DD imagerel $LN8
	DD	imagerel $LN8+164
	DD	imagerel $unwind$?IsCommand@CSTLogger@@QEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetQueue@CSTLogger@@QEAAXXZ DD imagerel $LN8
	DD	imagerel $LN8+267
	DD	imagerel $unwind$?GetQueue@CSTLogger@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TimeProc@CSTLogger@@QEAAXXZ DD imagerel $LN10
	DD	imagerel $LN10+413
	DD	imagerel $unwind$?TimeProc@CSTLogger@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??TimeProc@CSTLogger@@QEAAXXZ@4HA DD imagerel ?dtor$0@?0??TimeProc@CSTLogger@@QEAAXXZ@4HA
	DD	imagerel ?dtor$0@?0??TimeProc@CSTLogger@@QEAAXXZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??TimeProc@CSTLogger@@QEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?procLoggerEnable@CSTLogger@@QEAAXPEAVCLogger@@@Z DD imagerel $LN12
	DD	imagerel $LN12+295
	DD	imagerel $unwind$?procLoggerEnable@CSTLogger@@QEAAXPEAVCLogger@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?porcLoggerDisable@CSTLogger@@QEAAXPEAVCLogger@@@Z DD imagerel $LN6
	DD	imagerel $LN6+259
	DD	imagerel $unwind$?porcLoggerDisable@CSTLogger@@QEAAXPEAVCLogger@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pushCommand@CSTLogger@@QEAA_NPEAUSTLCommand@@@Z DD imagerel $LN4
	DD	imagerel $LN4+64
	DD	imagerel $unwind$?pushCommand@CSTLogger@@QEAA_NPEAUSTLCommand@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_init@CSTLogger@@AEAA_NH@Z DD imagerel $LN11
	DD	imagerel $LN11+267
	DD	imagerel $unwind$?_init@CSTLogger@@AEAA_NH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??_init@CSTLogger@@AEAA_NH@Z@4HA DD imagerel ?dtor$0@?0??_init@CSTLogger@@AEAA_NH@Z@4HA
	DD	imagerel ?dtor$0@?0??_init@CSTLogger@@AEAA_NH@Z@4HA+29
	DD	imagerel $unwind$?dtor$0@?0??_init@CSTLogger@@AEAA_NH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??_init@CSTLogger@@AEAA_NH@Z@4HA DD imagerel ?dtor$1@?0??_init@CSTLogger@@AEAA_NH@Z@4HA
	DD	imagerel ?dtor$1@?0??_init@CSTLogger@@AEAA_NH@Z@4HA+29
	DD	imagerel $unwind$?dtor$1@?0??_init@CSTLogger@@AEAA_NH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GCSTLogger@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_GCSTLogger@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_ECSTLogger@@QEAAPEAXI@Z DD imagerel $LN6
	DD	imagerel $LN6+167
	DD	imagerel $unwind$??_ECSTLogger@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?schedulerLoop@@YAXPEAUSTThreadInfo@@@Z DD imagerel $LN8
	DD	imagerel $LN8+245
	DD	imagerel $unwind$?schedulerLoop@@YAXPEAUSTThreadInfo@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0CScheduler@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+69
	DD	imagerel $unwind$??0CScheduler@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1CScheduler@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$??1CScheduler@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?initConfig@CScheduler@@QEAA_NPEADH0@Z DD imagerel $LN10
	DD	imagerel $LN10+457
	DD	imagerel $unwind$?initConfig@CScheduler@@QEAA_NPEADH0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??initConfig@CScheduler@@QEAA_NPEADH0@Z@4HA DD imagerel ?dtor$0@?0??initConfig@CScheduler@@QEAA_NPEADH0@Z@4HA
	DD	imagerel ?dtor$0@?0??initConfig@CScheduler@@QEAA_NPEADH0@Z@4HA+29
	DD	imagerel $unwind$?dtor$0@?0??initConfig@CScheduler@@QEAA_NPEADH0@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?init@CScheduler@@QEAA_NHHH@Z DD imagerel $LN9
	DD	imagerel $LN9+313
	DD	imagerel $unwind$?init@CScheduler@@QEAA_NHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??init@CScheduler@@QEAA_NHHH@Z@4HA DD imagerel ?dtor$0@?0??init@CScheduler@@QEAA_NHHH@Z@4HA
	DD	imagerel ?dtor$0@?0??init@CScheduler@@QEAA_NHHH@Z@4HA+29
	DD	imagerel $unwind$?dtor$0@?0??init@CScheduler@@QEAA_NHHH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?start@CScheduler@@QEAA_NXZ DD imagerel $LN6
	DD	imagerel $LN6+171
	DD	imagerel $unwind$?start@CScheduler@@QEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?quit@CScheduler@@QEAA_NXZ DD imagerel $LN6
	DD	imagerel $LN6+117
	DD	imagerel $unwind$?quit@CScheduler@@QEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?timeNext@CScheduler@@QEAAPEAUSTIntervalInfo@@PEAH@Z DD imagerel $LN3
	DD	imagerel $LN3+38
	DD	imagerel $unwind$?timeNext@CScheduler@@QEAAPEAUSTIntervalInfo@@PEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deleteTime@CScheduler@@QEAA_NPEAUSTIntervalInfo@@@Z DD imagerel $LN3
	DD	imagerel $LN3+38
	DD	imagerel $unwind$?deleteTime@CScheduler@@QEAA_NPEAUSTIntervalInfo@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?addTime@CScheduler@@QEAAHPEAUSTIntervalInfo@@@Z DD imagerel $LN3
	DD	imagerel $LN3+38
	DD	imagerel $unwind$?addTime@CScheduler@@QEAAHPEAUSTIntervalInfo@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GCScheduler@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_GCScheduler@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_ECScheduler@@QEAAPEAXI@Z DD imagerel $LN6
	DD	imagerel $LN6+167
	DD	imagerel $unwind$??_ECScheduler@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$CMemList@USTIntervalInfo@@@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+101
	DD	imagerel $unwind$??0?$CMemList@USTIntervalInfo@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$CMemList@USTIntervalInfo@@@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0?$CMemList@USTIntervalInfo@@@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0?$CMemList@USTIntervalInfo@@@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???0?$CMemList@USTIntervalInfo@@@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$CMemList@USTIntervalInfo@@@@QEAA@XZ DD imagerel $LN24
	DD	imagerel $LN24+643
	DD	imagerel $unwind$??1?$CMemList@USTIntervalInfo@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?alloc@?$CMemList@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z DD imagerel $LN11
	DD	imagerel $LN11+408
	DD	imagerel $unwind$?alloc@?$CMemList@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??alloc@?$CMemList@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z@4HA DD imagerel ?dtor$0@?0??alloc@?$CMemList@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z@4HA
	DD	imagerel ?dtor$0@?0??alloc@?$CMemList@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z@4HA+31
	DD	imagerel $unwind$?dtor$0@?0??alloc@?$CMemList@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getNext@?$CMemList@USTIntervalInfo@@@@QEAAPEAUSTIntervalInfo@@PEAH@Z DD imagerel $LN10
	DD	imagerel $LN10+212
	DD	imagerel $unwind$?getNext@?$CMemList@USTIntervalInfo@@@@QEAAPEAUSTIntervalInfo@@PEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?add@?$CMemList@USTIntervalInfo@@@@QEAAHPEAUSTIntervalInfo@@@Z DD imagerel $LN16
	DD	imagerel $LN16+474
	DD	imagerel $unwind$?add@?$CMemList@USTIntervalInfo@@@@QEAAHPEAUSTIntervalInfo@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?del@?$CMemList@USTIntervalInfo@@@@QEAA_NPEAUSTIntervalInfo@@@Z DD imagerel $LN7
	DD	imagerel $LN7+124
	DD	imagerel $unwind$?del@?$CMemList@USTIntervalInfo@@@@QEAA_NPEAUSTIntervalInfo@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_del@?$CMemList@USTIntervalInfo@@@@AEAAXH@Z DD imagerel $LN6
	DD	imagerel $LN6+114
	DD	imagerel $unwind$?_del@?$CMemList@USTIntervalInfo@@@@AEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__autoclassinit2@?$CMemList@USTIntervalInfo@@@@QEAAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?__autoclassinit2@?$CMemList@USTIntervalInfo@@@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$CMemList@USTIntervalInfo@@@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_G?$CMemList@USTIntervalInfo@@@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?eventThreadLoop@@YAXPEAUSTThreadInfo@@@Z DD imagerel $LN5
	DD	imagerel $LN5+120
	DD	imagerel $unwind$?eventThreadLoop@@YAXPEAUSTThreadInfo@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0CComQueueThread@@QEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+60
	DD	imagerel $unwind$??0CComQueueThread@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0CComQueueThread@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0CComQueueThread@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0CComQueueThread@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0CComQueueThread@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1CComQueueThread@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$??1CComQueueThread@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?initConfig@CComQueueThread@@QEAA_NPEADH0@Z DD imagerel $LN4
	DD	imagerel $LN4+173
	DD	imagerel $unwind$?initConfig@CComQueueThread@@QEAA_NPEADH0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?init@CComQueueThread@@QEAA_NHH@Z DD imagerel $LN4
	DD	imagerel $LN4+93
	DD	imagerel $unwind$?init@CComQueueThread@@QEAA_NHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?start@CComQueueThread@@QEAA_NXZ DD imagerel $LN6
	DD	imagerel $LN6+165
	DD	imagerel $unwind$?start@CComQueueThread@@QEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?quit@CComQueueThread@@QEAA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$?quit@CComQueueThread@@QEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?putQueue@CComQueueThread@@QEAA_NPEAUSTEvent@@@Z DD imagerel $LN4
	DD	imagerel $LN4+80
	DD	imagerel $unwind$?putQueue@CComQueueThread@@QEAA_NPEAUSTEvent@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getEvent@CComQueueThread@@QEAAPEAUSTEvent@@XZ DD imagerel $LN3
	DD	imagerel $LN3+31
	DD	imagerel $unwind$?getEvent@CComQueueThread@@QEAAPEAUSTEvent@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GCComQueueThread@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_GCComQueueThread@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_ECComQueueThread@@QEAAPEAXI@Z DD imagerel $LN6
	DD	imagerel $LN6+170
	DD	imagerel $unwind$??_ECComQueueThread@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0CCoreList@@QEAA@XZ DD imagerel $LN10
	DD	imagerel $LN10+326
	DD	imagerel $unwind$??0CCoreList@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0CCoreList@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0CCoreList@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0CCoreList@@QEAA@XZ@4HA+31
	DD	imagerel $unwind$?dtor$0@?0???0CCoreList@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1CCoreList@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$??1CCoreList@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?initSystemFile@CCoreList@@QEAA_NXZ DD imagerel $LN25
	DD	imagerel $LN25+1193
	DD	imagerel $unwind$?initSystemFile@CCoreList@@QEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?initDefaultPool@CCoreList@@QEAA_NHHH@Z DD imagerel $LN16
	DD	imagerel $LN16+458
	DD	imagerel $unwind$?initDefaultPool@CCoreList@@QEAA_NHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?initLogger@CCoreList@@QEAA_NPEAVCLogger@@PEAD1@Z DD imagerel $LN10
	DD	imagerel $LN10+355
	DD	imagerel $unwind$?initLogger@CCoreList@@QEAA_NPEAVCLogger@@PEAD1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?initLogger@CCoreList@@QEAA_NPEAVCLogger@@@Z DD imagerel $LN5
	DD	imagerel $LN5+172
	DD	imagerel $unwind$?initLogger@CCoreList@@QEAA_NPEAVCLogger@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setLoggerEnable@CCoreList@@QEAA_NPEAVCLogger@@@Z DD imagerel $LN4
	DD	imagerel $LN4+197
	DD	imagerel $unwind$?setLoggerEnable@CCoreList@@QEAA_NPEAVCLogger@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setLoggerDisable@CCoreList@@QEAA_NPEAVCLogger@@@Z DD imagerel $LN4
	DD	imagerel $LN4+197
	DD	imagerel $unwind$?setLoggerDisable@CCoreList@@QEAA_NPEAVCLogger@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?start@CCoreList@@QEAA_NXZ DD imagerel $LN32
	DD	imagerel $LN32+734
	DD	imagerel $unwind$?start@CCoreList@@QEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??start@CCoreList@@QEAA_NXZ@4HA DD imagerel ?dtor$0@?0??start@CCoreList@@QEAA_NXZ@4HA
	DD	imagerel ?dtor$0@?0??start@CCoreList@@QEAA_NXZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??start@CCoreList@@QEAA_NXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?destroy@CCoreList@@QEAAXXZ DD imagerel $LN21
	DD	imagerel $LN21+635
	DD	imagerel $unwind$?destroy@CCoreList@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?delEvent@CCoreList@@QEAA_NPEAUSTEvent@@@Z DD imagerel $LN3
	DD	imagerel $LN3+38
	DD	imagerel $unwind$?delEvent@CCoreList@@QEAA_NPEAUSTEvent@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?putEvent@CCoreList@@QEAA_NPEAUSTEvent@@@Z DD imagerel $LN5
	DD	imagerel $LN5+85
	DD	imagerel $unwind$?putEvent@CCoreList@@QEAA_NPEAUSTEvent@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?putTimer@CCoreList@@QEAA_NPEAUSTIntervalInfo@@@Z DD imagerel $LN5
	DD	imagerel $LN5+82
	DD	imagerel $unwind$?putTimer@CCoreList@@QEAA_NPEAUSTIntervalInfo@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?addComThread@CCoreList@@QEAAHP6AXPEAUSTThreadInfo@@@ZPEAXH2@Z DD imagerel $LN18
	DD	imagerel $LN18+656
	DD	imagerel $unwind$?addComThread@CCoreList@@QEAAHP6AXPEAUSTThreadInfo@@@ZPEAXH2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??addComThread@CCoreList@@QEAAHP6AXPEAUSTThreadInfo@@@ZPEAXH2@Z@4HA DD imagerel ?dtor$0@?0??addComThread@CCoreList@@QEAAHP6AXPEAUSTThreadInfo@@@ZPEAXH2@Z@4HA
	DD	imagerel ?dtor$0@?0??addComThread@CCoreList@@QEAAHP6AXPEAUSTThreadInfo@@@ZPEAXH2@Z@4HA+31
	DD	imagerel $unwind$?dtor$0@?0??addComThread@CCoreList@@QEAAHP6AXPEAUSTThreadInfo@@@ZPEAXH2@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?delComThread@CCoreList@@QEAA_NH@Z DD imagerel $LN6
	DD	imagerel $LN6+132
	DD	imagerel $unwind$?delComThread@CCoreList@@QEAA_NH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?addLogWriter@CCoreList@@QEAAHH@Z DD imagerel $LN17
	DD	imagerel $LN17+576
	DD	imagerel $unwind$?addLogWriter@CCoreList@@QEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??addLogWriter@CCoreList@@QEAAHH@Z@4HA DD imagerel ?dtor$0@?0??addLogWriter@CCoreList@@QEAAHH@Z@4HA
	DD	imagerel ?dtor$0@?0??addLogWriter@CCoreList@@QEAAHH@Z@4HA+31
	DD	imagerel $unwind$?dtor$0@?0??addLogWriter@CCoreList@@QEAAHH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?addScheduler@CCoreList@@QEAAHHH@Z DD imagerel $LN17
	DD	imagerel $LN17+613
	DD	imagerel $unwind$?addScheduler@CCoreList@@QEAAHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??addScheduler@CCoreList@@QEAAHHH@Z@4HA DD imagerel ?dtor$0@?0??addScheduler@CCoreList@@QEAAHHH@Z@4HA
	DD	imagerel ?dtor$0@?0??addScheduler@CCoreList@@QEAAHHH@Z@4HA+31
	DD	imagerel $unwind$?dtor$0@?0??addScheduler@CCoreList@@QEAAHHH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?addQueueThread@CCoreList@@QEAAHH@Z DD imagerel $LN17
	DD	imagerel $LN17+583
	DD	imagerel $unwind$?addQueueThread@CCoreList@@QEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??addQueueThread@CCoreList@@QEAAHH@Z@4HA DD imagerel ?dtor$0@?0??addQueueThread@CCoreList@@QEAAHH@Z@4HA
	DD	imagerel ?dtor$0@?0??addQueueThread@CCoreList@@QEAAHH@Z@4HA+31
	DD	imagerel $unwind$?dtor$0@?0??addQueueThread@CCoreList@@QEAAHH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?initComThread@CCoreList@@QEAA_NPEAD0@Z DD imagerel $LN17
	DD	imagerel $LN17+520
	DD	imagerel $unwind$?initComThread@CCoreList@@QEAA_NPEAD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??initComThread@CCoreList@@QEAA_NPEAD0@Z@4HA DD imagerel ?dtor$0@?0??initComThread@CCoreList@@QEAA_NPEAD0@Z@4HA
	DD	imagerel ?dtor$0@?0??initComThread@CCoreList@@QEAA_NPEAD0@Z@4HA+29
	DD	imagerel $unwind$?dtor$0@?0??initComThread@CCoreList@@QEAA_NPEAD0@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??initComThread@CCoreList@@QEAA_NPEAD0@Z@4HA DD imagerel ?dtor$1@?0??initComThread@CCoreList@@QEAA_NPEAD0@Z@4HA
	DD	imagerel ?dtor$1@?0??initComThread@CCoreList@@QEAA_NPEAD0@Z@4HA+31
	DD	imagerel $unwind$?dtor$1@?0??initComThread@CCoreList@@QEAA_NPEAD0@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?initLogWriter@CCoreList@@QEAA_NPEAD0_N@Z DD imagerel $LN20
	DD	imagerel $LN20+755
	DD	imagerel $unwind$?initLogWriter@CCoreList@@QEAA_NPEAD0_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??initLogWriter@CCoreList@@QEAA_NPEAD0_N@Z@4HA DD imagerel ?dtor$0@?0??initLogWriter@CCoreList@@QEAA_NPEAD0_N@Z@4HA
	DD	imagerel ?dtor$0@?0??initLogWriter@CCoreList@@QEAA_NPEAD0_N@Z@4HA+29
	DD	imagerel $unwind$?dtor$0@?0??initLogWriter@CCoreList@@QEAA_NPEAD0_N@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??initLogWriter@CCoreList@@QEAA_NPEAD0_N@Z@4HA DD imagerel ?dtor$1@?0??initLogWriter@CCoreList@@QEAA_NPEAD0_N@Z@4HA
	DD	imagerel ?dtor$1@?0??initLogWriter@CCoreList@@QEAA_NPEAD0_N@Z@4HA+31
	DD	imagerel $unwind$?dtor$1@?0??initLogWriter@CCoreList@@QEAA_NPEAD0_N@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?initScheduler@CCoreList@@QEAA_NPEAD0@Z DD imagerel $LN23
	DD	imagerel $LN23+956
	DD	imagerel $unwind$?initScheduler@CCoreList@@QEAA_NPEAD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??initScheduler@CCoreList@@QEAA_NPEAD0@Z@4HA DD imagerel ?dtor$0@?0??initScheduler@CCoreList@@QEAA_NPEAD0@Z@4HA
	DD	imagerel ?dtor$0@?0??initScheduler@CCoreList@@QEAA_NPEAD0@Z@4HA+31
	DD	imagerel $unwind$?dtor$0@?0??initScheduler@CCoreList@@QEAA_NPEAD0@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??initScheduler@CCoreList@@QEAA_NPEAD0@Z@4HA DD imagerel ?dtor$1@?0??initScheduler@CCoreList@@QEAA_NPEAD0@Z@4HA
	DD	imagerel ?dtor$1@?0??initScheduler@CCoreList@@QEAA_NPEAD0@Z@4HA+31
	DD	imagerel $unwind$?dtor$1@?0??initScheduler@CCoreList@@QEAA_NPEAD0@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0??initScheduler@CCoreList@@QEAA_NPEAD0@Z@4HA DD imagerel ?dtor$2@?0??initScheduler@CCoreList@@QEAA_NPEAD0@Z@4HA
	DD	imagerel ?dtor$2@?0??initScheduler@CCoreList@@QEAA_NPEAD0@Z@4HA+31
	DD	imagerel $unwind$?dtor$2@?0??initScheduler@CCoreList@@QEAA_NPEAD0@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?initQueueThread@CCoreList@@QEAA_NPEAD0@Z DD imagerel $LN21
	DD	imagerel $LN21+750
	DD	imagerel $unwind$?initQueueThread@CCoreList@@QEAA_NPEAD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??initQueueThread@CCoreList@@QEAA_NPEAD0@Z@4HA DD imagerel ?dtor$0@?0??initQueueThread@CCoreList@@QEAA_NPEAD0@Z@4HA
	DD	imagerel ?dtor$0@?0??initQueueThread@CCoreList@@QEAA_NPEAD0@Z@4HA+29
	DD	imagerel $unwind$?dtor$0@?0??initQueueThread@CCoreList@@QEAA_NPEAD0@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??initQueueThread@CCoreList@@QEAA_NPEAD0@Z@4HA DD imagerel ?dtor$1@?0??initQueueThread@CCoreList@@QEAA_NPEAD0@Z@4HA
	DD	imagerel ?dtor$1@?0??initQueueThread@CCoreList@@QEAA_NPEAD0@Z@4HA+29
	DD	imagerel $unwind$?dtor$1@?0??initQueueThread@CCoreList@@QEAA_NPEAD0@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0??initQueueThread@CCoreList@@QEAA_NPEAD0@Z@4HA DD imagerel ?dtor$2@?0??initQueueThread@CCoreList@@QEAA_NPEAD0@Z@4HA
	DD	imagerel ?dtor$2@?0??initQueueThread@CCoreList@@QEAA_NPEAD0@Z@4HA+31
	DD	imagerel $unwind$?dtor$2@?0??initQueueThread@CCoreList@@QEAA_NPEAD0@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?initComThread@CCoreList@@QEAA_NH@Z DD imagerel $LN8
	DD	imagerel $LN8+264
	DD	imagerel $unwind$?initComThread@CCoreList@@QEAA_NH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??initComThread@CCoreList@@QEAA_NH@Z@4HA DD imagerel ?dtor$0@?0??initComThread@CCoreList@@QEAA_NH@Z@4HA
	DD	imagerel ?dtor$0@?0??initComThread@CCoreList@@QEAA_NH@Z@4HA+31
	DD	imagerel $unwind$?dtor$0@?0??initComThread@CCoreList@@QEAA_NH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?initLogWriter@CCoreList@@QEAA_NH@Z DD imagerel $LN8
	DD	imagerel $LN8+261
	DD	imagerel $unwind$?initLogWriter@CCoreList@@QEAA_NH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??initLogWriter@CCoreList@@QEAA_NH@Z@4HA DD imagerel ?dtor$0@?0??initLogWriter@CCoreList@@QEAA_NH@Z@4HA
	DD	imagerel ?dtor$0@?0??initLogWriter@CCoreList@@QEAA_NH@Z@4HA+31
	DD	imagerel $unwind$?dtor$0@?0??initLogWriter@CCoreList@@QEAA_NH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?initScheduler@CCoreList@@QEAA_NHH@Z DD imagerel $LN14
	DD	imagerel $LN14+490
	DD	imagerel $unwind$?initScheduler@CCoreList@@QEAA_NHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??initScheduler@CCoreList@@QEAA_NHH@Z@4HA DD imagerel ?dtor$0@?0??initScheduler@CCoreList@@QEAA_NHH@Z@4HA
	DD	imagerel ?dtor$0@?0??initScheduler@CCoreList@@QEAA_NHH@Z@4HA+29
	DD	imagerel $unwind$?dtor$0@?0??initScheduler@CCoreList@@QEAA_NHH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??initScheduler@CCoreList@@QEAA_NHH@Z@4HA DD imagerel ?dtor$1@?0??initScheduler@CCoreList@@QEAA_NHH@Z@4HA
	DD	imagerel ?dtor$1@?0??initScheduler@CCoreList@@QEAA_NHH@Z@4HA+29
	DD	imagerel $unwind$?dtor$1@?0??initScheduler@CCoreList@@QEAA_NHH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?initQueueThread@CCoreList@@QEAA_NHH@Z DD imagerel $LN14
	DD	imagerel $LN14+490
	DD	imagerel $unwind$?initQueueThread@CCoreList@@QEAA_NHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??initQueueThread@CCoreList@@QEAA_NHH@Z@4HA DD imagerel ?dtor$0@?0??initQueueThread@CCoreList@@QEAA_NHH@Z@4HA
	DD	imagerel ?dtor$0@?0??initQueueThread@CCoreList@@QEAA_NHH@Z@4HA+29
	DD	imagerel $unwind$?dtor$0@?0??initQueueThread@CCoreList@@QEAA_NHH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??initQueueThread@CCoreList@@QEAA_NHH@Z@4HA DD imagerel ?dtor$1@?0??initQueueThread@CCoreList@@QEAA_NHH@Z@4HA
	DD	imagerel ?dtor$1@?0??initQueueThread@CCoreList@@QEAA_NHH@Z@4HA+29
	DD	imagerel $unwind$?dtor$1@?0??initQueueThread@CCoreList@@QEAA_NHH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setListAllocType@CCoreList@@QEAAXW4E_ALLOC_TYPE@@W4E_SYS_LIST_TYPE@@@Z DD imagerel $LN9
	DD	imagerel $LN9+138
	DD	imagerel $unwind$?setListAllocType@CCoreList@@QEAAXW4E_ALLOC_TYPE@@W4E_SYS_LIST_TYPE@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$CMemPool@USTIntervalInfo@@@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+97
	DD	imagerel $unwind$??0?$CMemPool@USTIntervalInfo@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$CMemPool@USTIntervalInfo@@@@QEAA@XZ DD imagerel $LN11
	DD	imagerel $LN11+217
	DD	imagerel $unwind$??1?$CMemPool@USTIntervalInfo@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$CMemPool@USTIntervalInfo@@@@QEAAXXZ DD imagerel $LN6
	DD	imagerel $LN6+104
	DD	imagerel $unwind$?clear@?$CMemPool@USTIntervalInfo@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?alloc@?$CMemPool@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z DD imagerel $LN15
	DD	imagerel $LN15+604
	DD	imagerel $unwind$?alloc@?$CMemPool@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??alloc@?$CMemPool@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z@4HA DD imagerel ?dtor$0@?0??alloc@?$CMemPool@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z@4HA
	DD	imagerel ?dtor$0@?0??alloc@?$CMemPool@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z@4HA+31
	DD	imagerel $unwind$?dtor$0@?0??alloc@?$CMemPool@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__autoclassinit2@?$CMemPool@USTIntervalInfo@@@@QEAAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?__autoclassinit2@?$CMemPool@USTIntervalInfo@@@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$CMemPool@USTIntervalInfo@@@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_G?$CMemPool@USTIntervalInfo@@@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$CMemPool@USTEvent@@@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+97
	DD	imagerel $unwind$??0?$CMemPool@USTEvent@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$CMemPool@USTEvent@@@@QEAA@XZ DD imagerel $LN11
	DD	imagerel $LN11+217
	DD	imagerel $unwind$??1?$CMemPool@USTEvent@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$CMemPool@USTEvent@@@@QEAAXXZ DD imagerel $LN6
	DD	imagerel $LN6+104
	DD	imagerel $unwind$?clear@?$CMemPool@USTEvent@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?alloc@?$CMemPool@USTEvent@@@@QEAAHHW4E_ALLOC_TYPE@@@Z DD imagerel $LN15
	DD	imagerel $LN15+604
	DD	imagerel $unwind$?alloc@?$CMemPool@USTEvent@@@@QEAAHHW4E_ALLOC_TYPE@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??alloc@?$CMemPool@USTEvent@@@@QEAAHHW4E_ALLOC_TYPE@@@Z@4HA DD imagerel ?dtor$0@?0??alloc@?$CMemPool@USTEvent@@@@QEAAHHW4E_ALLOC_TYPE@@@Z@4HA
	DD	imagerel ?dtor$0@?0??alloc@?$CMemPool@USTEvent@@@@QEAAHHW4E_ALLOC_TYPE@@@Z@4HA+31
	DD	imagerel $unwind$?dtor$0@?0??alloc@?$CMemPool@USTEvent@@@@QEAAHHW4E_ALLOC_TYPE@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?delMem@?$CMemPool@USTEvent@@@@QEAA_NPEAUSTEvent@@@Z DD imagerel $LN10
	DD	imagerel $LN10+230
	DD	imagerel $unwind$?delMem@?$CMemPool@USTEvent@@@@QEAA_NPEAUSTEvent@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__autoclassinit2@?$CMemPool@USTEvent@@@@QEAAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?__autoclassinit2@?$CMemPool@USTEvent@@@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$CMemPool@USTEvent@@@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_G?$CMemPool@USTEvent@@@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$CTList@VCLogger@@@@QEAA@XZ DD imagerel $LN21
	DD	imagerel $LN21+506
	DD	imagerel $unwind$??1?$CTList@VCLogger@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?alloc@?$CTList@VCLogger@@@@QEAAHHW4E_ALLOC_TYPE@@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$?alloc@?$CTList@VCLogger@@@@QEAAHHW4E_ALLOC_TYPE@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$CTList@VCLogger@@@@QEAA_NPEAVCLogger@@PEAH@Z DD imagerel $LN15
	DD	imagerel $LN15+344
	DD	imagerel $unwind$?push_back@?$CTList@VCLogger@@@@QEAA_NPEAVCLogger@@PEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?IsExist@?$CTList@VCLogger@@@@QEAA_NPEAVCLogger@@@Z DD imagerel $LN8
	DD	imagerel $LN8+99
	DD	imagerel $unwind$?IsExist@?$CTList@VCLogger@@@@QEAA_NPEAVCLogger@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?del@?$CTList@VCLogger@@@@QEAA_NPEAVCLogger@@@Z DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$?del@?$CTList@VCLogger@@@@QEAA_NPEAVCLogger@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__alloc@?$CTList@VCLogger@@@@AEAAHH@Z DD imagerel $LN5
	DD	imagerel $LN5+150
	DD	imagerel $unwind$?__alloc@?$CTList@VCLogger@@@@AEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__autoclassinit2@?$CTList@VCLogger@@@@QEAAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?__autoclassinit2@?$CTList@VCLogger@@@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$CTList@VCLogger@@@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_G?$CTList@VCLogger@@@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$CTList@VCSTLogger@@@@QEAA@XZ DD imagerel $LN21
	DD	imagerel $LN21+506
	DD	imagerel $unwind$??1?$CTList@VCSTLogger@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?alloc@?$CTList@VCSTLogger@@@@QEAAHHW4E_ALLOC_TYPE@@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$?alloc@?$CTList@VCSTLogger@@@@QEAAHHW4E_ALLOC_TYPE@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$CTList@VCSTLogger@@@@QEAA_NPEAVCSTLogger@@PEAH@Z DD imagerel $LN15
	DD	imagerel $LN15+344
	DD	imagerel $unwind$?push_back@?$CTList@VCSTLogger@@@@QEAA_NPEAVCSTLogger@@PEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?del@?$CTList@VCSTLogger@@@@QEAA_NH@Z DD imagerel $LN4
	DD	imagerel $LN4+95
	DD	imagerel $unwind$?del@?$CTList@VCSTLogger@@@@QEAA_NH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getObj@?$CTList@VCSTLogger@@@@QEAAPEAVCSTLogger@@H@Z DD imagerel $LN4
	DD	imagerel $LN4+63
	DD	imagerel $unwind$?getObj@?$CTList@VCSTLogger@@@@QEAAPEAVCSTLogger@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__alloc@?$CTList@VCSTLogger@@@@AEAAHH@Z DD imagerel $LN5
	DD	imagerel $LN5+150
	DD	imagerel $unwind$?__alloc@?$CTList@VCSTLogger@@@@AEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__autoclassinit2@?$CTList@VCSTLogger@@@@QEAAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?__autoclassinit2@?$CTList@VCSTLogger@@@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$CTList@VCSTLogger@@@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_G?$CTList@VCSTLogger@@@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$CTList@VCScheduler@@@@QEAA@XZ DD imagerel $LN21
	DD	imagerel $LN21+506
	DD	imagerel $unwind$??1?$CTList@VCScheduler@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?alloc@?$CTList@VCScheduler@@@@QEAAHHW4E_ALLOC_TYPE@@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$?alloc@?$CTList@VCScheduler@@@@QEAAHHW4E_ALLOC_TYPE@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$CTList@VCScheduler@@@@QEAA_NPEAVCScheduler@@PEAH@Z DD imagerel $LN15
	DD	imagerel $LN15+344
	DD	imagerel $unwind$?push_back@?$CTList@VCScheduler@@@@QEAA_NPEAVCScheduler@@PEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?del@?$CTList@VCScheduler@@@@QEAA_NH@Z DD imagerel $LN4
	DD	imagerel $LN4+95
	DD	imagerel $unwind$?del@?$CTList@VCScheduler@@@@QEAA_NH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getObj@?$CTList@VCScheduler@@@@QEAAPEAVCScheduler@@H@Z DD imagerel $LN4
	DD	imagerel $LN4+63
	DD	imagerel $unwind$?getObj@?$CTList@VCScheduler@@@@QEAAPEAVCScheduler@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__alloc@?$CTList@VCScheduler@@@@AEAAHH@Z DD imagerel $LN5
	DD	imagerel $LN5+150
	DD	imagerel $unwind$?__alloc@?$CTList@VCScheduler@@@@AEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__autoclassinit2@?$CTList@VCScheduler@@@@QEAAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?__autoclassinit2@?$CTList@VCScheduler@@@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$CTList@VCScheduler@@@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_G?$CTList@VCScheduler@@@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$CTList@VCComThread@@@@QEAA@XZ DD imagerel $LN21
	DD	imagerel $LN21+506
	DD	imagerel $unwind$??1?$CTList@VCComThread@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?alloc@?$CTList@VCComThread@@@@QEAAHHW4E_ALLOC_TYPE@@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$?alloc@?$CTList@VCComThread@@@@QEAAHHW4E_ALLOC_TYPE@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$CTList@VCComThread@@@@QEAA_NPEAVCComThread@@PEAH@Z DD imagerel $LN15
	DD	imagerel $LN15+344
	DD	imagerel $unwind$?push_back@?$CTList@VCComThread@@@@QEAA_NPEAVCComThread@@PEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?del@?$CTList@VCComThread@@@@QEAA_NH@Z DD imagerel $LN4
	DD	imagerel $LN4+95
	DD	imagerel $unwind$?del@?$CTList@VCComThread@@@@QEAA_NH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getObj@?$CTList@VCComThread@@@@QEAAPEAVCComThread@@H@Z DD imagerel $LN4
	DD	imagerel $LN4+63
	DD	imagerel $unwind$?getObj@?$CTList@VCComThread@@@@QEAAPEAVCComThread@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__alloc@?$CTList@VCComThread@@@@AEAAHH@Z DD imagerel $LN5
	DD	imagerel $LN5+150
	DD	imagerel $unwind$?__alloc@?$CTList@VCComThread@@@@AEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__autoclassinit2@?$CTList@VCComThread@@@@QEAAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?__autoclassinit2@?$CTList@VCComThread@@@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$CTList@VCComThread@@@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_G?$CTList@VCComThread@@@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$CTList@VCComQueueThread@@@@QEAA@XZ DD imagerel $LN21
	DD	imagerel $LN21+506
	DD	imagerel $unwind$??1?$CTList@VCComQueueThread@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?alloc@?$CTList@VCComQueueThread@@@@QEAAHHW4E_ALLOC_TYPE@@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$?alloc@?$CTList@VCComQueueThread@@@@QEAAHHW4E_ALLOC_TYPE@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$CTList@VCComQueueThread@@@@QEAA_NPEAVCComQueueThread@@PEAH@Z DD imagerel $LN15
	DD	imagerel $LN15+344
	DD	imagerel $unwind$?push_back@?$CTList@VCComQueueThread@@@@QEAA_NPEAVCComQueueThread@@PEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?del@?$CTList@VCComQueueThread@@@@QEAA_NH@Z DD imagerel $LN4
	DD	imagerel $LN4+95
	DD	imagerel $unwind$?del@?$CTList@VCComQueueThread@@@@QEAA_NH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getObj@?$CTList@VCComQueueThread@@@@QEAAPEAVCComQueueThread@@H@Z DD imagerel $LN4
	DD	imagerel $LN4+63
	DD	imagerel $unwind$?getObj@?$CTList@VCComQueueThread@@@@QEAAPEAVCComQueueThread@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__alloc@?$CTList@VCComQueueThread@@@@AEAAHH@Z DD imagerel $LN5
	DD	imagerel $LN5+150
	DD	imagerel $unwind$?__alloc@?$CTList@VCComQueueThread@@@@AEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__autoclassinit2@?$CTList@VCComQueueThread@@@@QEAAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?__autoclassinit2@?$CTList@VCComQueueThread@@@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$CTList@VCComQueueThread@@@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_G?$CTList@VCComQueueThread@@@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT ??_R1A@?0A@EA@condition@win32@common@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@condition@win32@common@@8 DD imagerel ??_R0?AVcondition@win32@common@@@8 ; common::win32::condition::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3condition@win32@common@@8
rdata$r	ENDS
;	COMDAT ??_R2condition@win32@common@@8
rdata$r	SEGMENT
??_R2condition@win32@common@@8 DD imagerel ??_R1A@?0A@EA@condition@win32@common@@8 ; common::win32::condition::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@abstract_condition@common@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3condition@win32@common@@8
rdata$r	SEGMENT
??_R3condition@win32@common@@8 DD 00H			; common::win32::condition::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2condition@win32@common@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVcondition@win32@common@@@8
data$r	SEGMENT
??_R0?AVcondition@win32@common@@@8 DQ FLAT:??_7type_info@@6B@ ; common::win32::condition `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVcondition@win32@common@@', 00H
data$r	ENDS
;	COMDAT ??_R4condition@win32@common@@6B@
rdata$r	SEGMENT
??_R4condition@win32@common@@6B@ DD 01H			; common::win32::condition::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVcondition@win32@common@@@8
	DD	imagerel ??_R3condition@win32@common@@8
	DD	imagerel ??_R4condition@win32@common@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@abstract_condition@common@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@abstract_condition@common@@8 DD imagerel ??_R0?AVabstract_condition@common@@@8 ; common::abstract_condition::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3abstract_condition@common@@8
rdata$r	ENDS
;	COMDAT ??_R2abstract_condition@common@@8
rdata$r	SEGMENT
??_R2abstract_condition@common@@8 DD imagerel ??_R1A@?0A@EA@abstract_condition@common@@8 ; common::abstract_condition::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3abstract_condition@common@@8
rdata$r	SEGMENT
??_R3abstract_condition@common@@8 DD 00H		; common::abstract_condition::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2abstract_condition@common@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVabstract_condition@common@@@8
data$r	SEGMENT
??_R0?AVabstract_condition@common@@@8 DQ FLAT:??_7type_info@@6B@ ; common::abstract_condition `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVabstract_condition@common@@', 00H
data$r	ENDS
;	COMDAT ??_R4abstract_condition@common@@6B@
rdata$r	SEGMENT
??_R4abstract_condition@common@@6B@ DD 01H		; common::abstract_condition::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVabstract_condition@common@@@8
	DD	imagerel ??_R3abstract_condition@common@@8
	DD	imagerel ??_R4abstract_condition@common@@6B@
rdata$r	ENDS
;	COMDAT ??_C@_0BD@KEHDJCKJ@ERROR?$CB?5?$FL?$CFs?3?$CFd?$FN?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BD@KEHDJCKJ@ERROR?$CB?5?$FL?$CFs?3?$CFd?$FN?5?$CFs?6?$AA@ DB 'ERRO'
	DB	'R! [%s:%d] %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_7condition@win32@common@@6B@
CONST	SEGMENT
??_7condition@win32@common@@6B@ DQ FLAT:??_R4condition@win32@common@@6B@ ; common::win32::condition::`vftable'
	DQ	FLAT:??_Econdition@win32@common@@UEAAPEAXI@Z
	DQ	FLAT:?signal@condition@win32@common@@UEAAXXZ
	DQ	FLAT:?signal_all@condition@win32@common@@UEAAXXZ
CONST	ENDS
;	COMDAT ??_7abstract_condition@common@@6B@
CONST	SEGMENT
??_7abstract_condition@common@@6B@ DQ FLAT:??_R4abstract_condition@common@@6B@ ; common::abstract_condition::`vftable'
	DQ	FLAT:??_Eabstract_condition@common@@UEAAPEAXI@Z
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$CTList@VCComQueueThread@@@@QEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__autoclassinit2@?$CTList@VCComQueueThread@@@@QEAAX_K@Z DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__alloc@?$CTList@VCComQueueThread@@@@AEAAHH@Z DD 030f01H
	DD	0700b620fH
	DD	0600aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getObj@?$CTList@VCComQueueThread@@@@QEAAPEAVCComQueueThread@@H@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?del@?$CTList@VCComQueueThread@@@@QEAA_NH@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$CTList@VCComQueueThread@@@@QEAA_NPEAVCComQueueThread@@PEAH@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?alloc@?$CTList@VCComQueueThread@@@@QEAAHHW4E_ALLOC_TYPE@@@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$CTList@VCComQueueThread@@@@QEAA@XZ DD imagerel ??1?$CTList@VCComQueueThread@@@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1?$CTList@VCComQueueThread@@@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1?$CTList@VCComQueueThread@@@@QEAA@XZ
	DD	070H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$CTList@VCComQueueThread@@@@QEAA@XZ DD 022719H
	DD	013010cH
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$??1?$CTList@VCComQueueThread@@@@QEAA@XZ
	DD	083H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$CTList@VCComThread@@@@QEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__autoclassinit2@?$CTList@VCComThread@@@@QEAAX_K@Z DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__alloc@?$CTList@VCComThread@@@@AEAAHH@Z DD 030f01H
	DD	0700b620fH
	DD	0600aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getObj@?$CTList@VCComThread@@@@QEAAPEAVCComThread@@H@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?del@?$CTList@VCComThread@@@@QEAA_NH@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$CTList@VCComThread@@@@QEAA_NPEAVCComThread@@PEAH@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?alloc@?$CTList@VCComThread@@@@QEAAHHW4E_ALLOC_TYPE@@@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$CTList@VCComThread@@@@QEAA@XZ DD imagerel ??1?$CTList@VCComThread@@@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1?$CTList@VCComThread@@@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1?$CTList@VCComThread@@@@QEAA@XZ
	DD	070H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$CTList@VCComThread@@@@QEAA@XZ DD 022719H
	DD	013010cH
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$??1?$CTList@VCComThread@@@@QEAA@XZ
	DD	083H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$CTList@VCScheduler@@@@QEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__autoclassinit2@?$CTList@VCScheduler@@@@QEAAX_K@Z DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__alloc@?$CTList@VCScheduler@@@@AEAAHH@Z DD 030f01H
	DD	0700b620fH
	DD	0600aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getObj@?$CTList@VCScheduler@@@@QEAAPEAVCScheduler@@H@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?del@?$CTList@VCScheduler@@@@QEAA_NH@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$CTList@VCScheduler@@@@QEAA_NPEAVCScheduler@@PEAH@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?alloc@?$CTList@VCScheduler@@@@QEAAHHW4E_ALLOC_TYPE@@@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$CTList@VCScheduler@@@@QEAA@XZ DD imagerel ??1?$CTList@VCScheduler@@@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1?$CTList@VCScheduler@@@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1?$CTList@VCScheduler@@@@QEAA@XZ
	DD	070H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$CTList@VCScheduler@@@@QEAA@XZ DD 022719H
	DD	013010cH
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$??1?$CTList@VCScheduler@@@@QEAA@XZ
	DD	083H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$CTList@VCSTLogger@@@@QEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__autoclassinit2@?$CTList@VCSTLogger@@@@QEAAX_K@Z DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__alloc@?$CTList@VCSTLogger@@@@AEAAHH@Z DD 030f01H
	DD	0700b620fH
	DD	0600aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getObj@?$CTList@VCSTLogger@@@@QEAAPEAVCSTLogger@@H@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?del@?$CTList@VCSTLogger@@@@QEAA_NH@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$CTList@VCSTLogger@@@@QEAA_NPEAVCSTLogger@@PEAH@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?alloc@?$CTList@VCSTLogger@@@@QEAAHHW4E_ALLOC_TYPE@@@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$CTList@VCSTLogger@@@@QEAA@XZ DD imagerel ??1?$CTList@VCSTLogger@@@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1?$CTList@VCSTLogger@@@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1?$CTList@VCSTLogger@@@@QEAA@XZ
	DD	070H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$CTList@VCSTLogger@@@@QEAA@XZ DD 022719H
	DD	013010cH
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$??1?$CTList@VCSTLogger@@@@QEAA@XZ
	DD	083H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$CTList@VCLogger@@@@QEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__autoclassinit2@?$CTList@VCLogger@@@@QEAAX_K@Z DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__alloc@?$CTList@VCLogger@@@@AEAAHH@Z DD 030f01H
	DD	0700b620fH
	DD	0600aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?del@?$CTList@VCLogger@@@@QEAA_NPEAVCLogger@@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?IsExist@?$CTList@VCLogger@@@@QEAA_NPEAVCLogger@@@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$CTList@VCLogger@@@@QEAA_NPEAVCLogger@@PEAH@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?alloc@?$CTList@VCLogger@@@@QEAAHHW4E_ALLOC_TYPE@@@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$CTList@VCLogger@@@@QEAA@XZ DD imagerel ??1?$CTList@VCLogger@@@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1?$CTList@VCLogger@@@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1?$CTList@VCLogger@@@@QEAA@XZ
	DD	070H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$CTList@VCLogger@@@@QEAA@XZ DD 022719H
	DD	013010cH
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$??1?$CTList@VCLogger@@@@QEAA@XZ
	DD	083H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$CMemPool@USTEvent@@@@QEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__autoclassinit2@?$CMemPool@USTEvent@@@@QEAAX_K@Z DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?delMem@?$CMemPool@USTEvent@@@@QEAA_NPEAUSTEvent@@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??alloc@?$CMemPool@USTEvent@@@@QEAAHHW4E_ALLOC_TYPE@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?alloc@?$CMemPool@USTEvent@@@@QEAAHHW4E_ALLOC_TYPE@@@Z DD imagerel ?alloc@?$CMemPool@USTEvent@@@@QEAAHHW4E_ALLOC_TYPE@@@Z
	DD	0ffffffffH
	DD	imagerel ?alloc@?$CMemPool@USTEvent@@@@QEAAHHW4E_ALLOC_TYPE@@@Z+102
	DD	00H
	DD	imagerel ?alloc@?$CMemPool@USTEvent@@@@QEAAHHW4E_ALLOC_TYPE@@@Z+204
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?alloc@?$CMemPool@USTEvent@@@@QEAAHHW4E_ALLOC_TYPE@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??alloc@?$CMemPool@USTEvent@@@@QEAAHHW4E_ALLOC_TYPE@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?alloc@?$CMemPool@USTEvent@@@@QEAAHHW4E_ALLOC_TYPE@@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?alloc@?$CMemPool@USTEvent@@@@QEAAHHW4E_ALLOC_TYPE@@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?alloc@?$CMemPool@USTEvent@@@@QEAAHHW4E_ALLOC_TYPE@@@Z
	DD	080H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?alloc@?$CMemPool@USTEvent@@@@QEAAHHW4E_ALLOC_TYPE@@@Z DD 022111H
	DD	0130115H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?alloc@?$CMemPool@USTEvent@@@@QEAAHHW4E_ALLOC_TYPE@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$CMemPool@USTEvent@@@@QEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$CMemPool@USTEvent@@@@QEAA@XZ DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$CMemPool@USTEvent@@@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$CMemPool@USTIntervalInfo@@@@QEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__autoclassinit2@?$CMemPool@USTIntervalInfo@@@@QEAAX_K@Z DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??alloc@?$CMemPool@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?alloc@?$CMemPool@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z DD imagerel ?alloc@?$CMemPool@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z
	DD	0ffffffffH
	DD	imagerel ?alloc@?$CMemPool@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z+102
	DD	00H
	DD	imagerel ?alloc@?$CMemPool@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z+204
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?alloc@?$CMemPool@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??alloc@?$CMemPool@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?alloc@?$CMemPool@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?alloc@?$CMemPool@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?alloc@?$CMemPool@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z
	DD	080H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?alloc@?$CMemPool@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z DD 022111H
	DD	0130115H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?alloc@?$CMemPool@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$CMemPool@USTIntervalInfo@@@@QEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$CMemPool@USTIntervalInfo@@@@QEAA@XZ DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$CMemPool@USTIntervalInfo@@@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setListAllocType@CCoreList@@QEAAXW4E_ALLOC_TYPE@@W4E_SYS_LIST_TYPE@@@Z DD 011201H
	DD	06212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??initQueueThread@CCoreList@@QEAA_NHH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??initQueueThread@CCoreList@@QEAA_NHH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?initQueueThread@CCoreList@@QEAA_NHH@Z DD imagerel ?initQueueThread@CCoreList@@QEAA_NHH@Z
	DD	0ffffffffH
	DD	imagerel ?initQueueThread@CCoreList@@QEAA_NHH@Z+82
	DD	00H
	DD	imagerel ?initQueueThread@CCoreList@@QEAA_NHH@Z+141
	DD	0ffffffffH
	DD	imagerel ?initQueueThread@CCoreList@@QEAA_NHH@Z+302
	DD	01H
	DD	imagerel ?initQueueThread@CCoreList@@QEAA_NHH@Z+361
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?initQueueThread@CCoreList@@QEAA_NHH@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??initQueueThread@CCoreList@@QEAA_NHH@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$1@?0??initQueueThread@CCoreList@@QEAA_NHH@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?initQueueThread@CCoreList@@QEAA_NHH@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$?initQueueThread@CCoreList@@QEAA_NHH@Z
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$?initQueueThread@CCoreList@@QEAA_NHH@Z
	DD	050H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?initQueueThread@CCoreList@@QEAA_NHH@Z DD 023019H
	DD	01f0115H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?initQueueThread@CCoreList@@QEAA_NHH@Z
	DD	0e2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??initScheduler@CCoreList@@QEAA_NHH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??initScheduler@CCoreList@@QEAA_NHH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?initScheduler@CCoreList@@QEAA_NHH@Z DD imagerel ?initScheduler@CCoreList@@QEAA_NHH@Z
	DD	0ffffffffH
	DD	imagerel ?initScheduler@CCoreList@@QEAA_NHH@Z+82
	DD	00H
	DD	imagerel ?initScheduler@CCoreList@@QEAA_NHH@Z+141
	DD	0ffffffffH
	DD	imagerel ?initScheduler@CCoreList@@QEAA_NHH@Z+302
	DD	01H
	DD	imagerel ?initScheduler@CCoreList@@QEAA_NHH@Z+361
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?initScheduler@CCoreList@@QEAA_NHH@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??initScheduler@CCoreList@@QEAA_NHH@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$1@?0??initScheduler@CCoreList@@QEAA_NHH@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?initScheduler@CCoreList@@QEAA_NHH@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$?initScheduler@CCoreList@@QEAA_NHH@Z
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$?initScheduler@CCoreList@@QEAA_NHH@Z
	DD	050H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?initScheduler@CCoreList@@QEAA_NHH@Z DD 023019H
	DD	01f0115H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?initScheduler@CCoreList@@QEAA_NHH@Z
	DD	0e2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??initLogWriter@CCoreList@@QEAA_NH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?initLogWriter@CCoreList@@QEAA_NH@Z DD imagerel ?initLogWriter@CCoreList@@QEAA_NH@Z
	DD	0ffffffffH
	DD	imagerel ?initLogWriter@CCoreList@@QEAA_NH@Z+83
	DD	00H
	DD	imagerel ?initLogWriter@CCoreList@@QEAA_NH@Z+127
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?initLogWriter@CCoreList@@QEAA_NH@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??initLogWriter@CCoreList@@QEAA_NH@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?initLogWriter@CCoreList@@QEAA_NH@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?initLogWriter@CCoreList@@QEAA_NH@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?initLogWriter@CCoreList@@QEAA_NH@Z
	DD	038H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?initLogWriter@CCoreList@@QEAA_NH@Z DD 022b19H
	DD	01b0110H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?initLogWriter@CCoreList@@QEAA_NH@Z
	DD	0c2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??initComThread@CCoreList@@QEAA_NH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?initComThread@CCoreList@@QEAA_NH@Z DD imagerel ?initComThread@CCoreList@@QEAA_NH@Z
	DD	0ffffffffH
	DD	imagerel ?initComThread@CCoreList@@QEAA_NH@Z+84
	DD	00H
	DD	imagerel ?initComThread@CCoreList@@QEAA_NH@Z+128
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?initComThread@CCoreList@@QEAA_NH@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??initComThread@CCoreList@@QEAA_NH@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?initComThread@CCoreList@@QEAA_NH@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?initComThread@CCoreList@@QEAA_NH@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?initComThread@CCoreList@@QEAA_NH@Z
	DD	038H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?initComThread@CCoreList@@QEAA_NH@Z DD 022b19H
	DD	01b0110H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?initComThread@CCoreList@@QEAA_NH@Z
	DD	0c2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0??initQueueThread@CCoreList@@QEAA_NPEAD0@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??initQueueThread@CCoreList@@QEAA_NPEAD0@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??initQueueThread@CCoreList@@QEAA_NPEAD0@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?initQueueThread@CCoreList@@QEAA_NPEAD0@Z DD imagerel ?initQueueThread@CCoreList@@QEAA_NPEAD0@Z
	DD	0ffffffffH
	DD	imagerel ?initQueueThread@CCoreList@@QEAA_NPEAD0@Z+114
	DD	00H
	DD	imagerel ?initQueueThread@CCoreList@@QEAA_NPEAD0@Z+173
	DD	0ffffffffH
	DD	imagerel ?initQueueThread@CCoreList@@QEAA_NPEAD0@Z+307
	DD	01H
	DD	imagerel ?initQueueThread@CCoreList@@QEAA_NPEAD0@Z+366
	DD	0ffffffffH
	DD	imagerel ?initQueueThread@CCoreList@@QEAA_NPEAD0@Z+493
	DD	02H
	DD	imagerel ?initQueueThread@CCoreList@@QEAA_NPEAD0@Z+540
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?initQueueThread@CCoreList@@QEAA_NPEAD0@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??initQueueThread@CCoreList@@QEAA_NPEAD0@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$1@?0??initQueueThread@CCoreList@@QEAA_NPEAD0@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$2@?0??initQueueThread@CCoreList@@QEAA_NPEAD0@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?initQueueThread@CCoreList@@QEAA_NPEAD0@Z DD 019930522H
	DD	03H
	DD	imagerel $stateUnwindMap$?initQueueThread@CCoreList@@QEAA_NPEAD0@Z
	DD	00H
	DD	00H
	DD	07H
	DD	imagerel $ip2state$?initQueueThread@CCoreList@@QEAA_NPEAD0@Z
	DD	088H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?initQueueThread@CCoreList@@QEAA_NPEAD0@Z DD 023419H
	DD	0150116H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?initQueueThread@CCoreList@@QEAA_NPEAD0@Z
	DD	09aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0??initScheduler@CCoreList@@QEAA_NPEAD0@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??initScheduler@CCoreList@@QEAA_NPEAD0@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??initScheduler@CCoreList@@QEAA_NPEAD0@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?initScheduler@CCoreList@@QEAA_NPEAD0@Z DD imagerel ?initScheduler@CCoreList@@QEAA_NPEAD0@Z
	DD	0ffffffffH
	DD	imagerel ?initScheduler@CCoreList@@QEAA_NPEAD0@Z+140
	DD	00H
	DD	imagerel ?initScheduler@CCoreList@@QEAA_NPEAD0@Z+184
	DD	0ffffffffH
	DD	imagerel ?initScheduler@CCoreList@@QEAA_NPEAD0@Z+426
	DD	01H
	DD	imagerel ?initScheduler@CCoreList@@QEAA_NPEAD0@Z+470
	DD	0ffffffffH
	DD	imagerel ?initScheduler@CCoreList@@QEAA_NPEAD0@Z+597
	DD	02H
	DD	imagerel ?initScheduler@CCoreList@@QEAA_NPEAD0@Z+641
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?initScheduler@CCoreList@@QEAA_NPEAD0@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??initScheduler@CCoreList@@QEAA_NPEAD0@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$1@?0??initScheduler@CCoreList@@QEAA_NPEAD0@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$2@?0??initScheduler@CCoreList@@QEAA_NPEAD0@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?initScheduler@CCoreList@@QEAA_NPEAD0@Z DD 019930522H
	DD	03H
	DD	imagerel $stateUnwindMap$?initScheduler@CCoreList@@QEAA_NPEAD0@Z
	DD	00H
	DD	00H
	DD	07H
	DD	imagerel $ip2state$?initScheduler@CCoreList@@QEAA_NPEAD0@Z
	DD	080H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?initScheduler@CCoreList@@QEAA_NPEAD0@Z DD 023419H
	DD	0250116H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?initScheduler@CCoreList@@QEAA_NPEAD0@Z
	DD	0112H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??initLogWriter@CCoreList@@QEAA_NPEAD0_N@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??initLogWriter@CCoreList@@QEAA_NPEAD0_N@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?initLogWriter@CCoreList@@QEAA_NPEAD0_N@Z DD imagerel ?initLogWriter@CCoreList@@QEAA_NPEAD0_N@Z
	DD	0ffffffffH
	DD	imagerel ?initLogWriter@CCoreList@@QEAA_NPEAD0_N@Z+137
	DD	00H
	DD	imagerel ?initLogWriter@CCoreList@@QEAA_NPEAD0_N@Z+196
	DD	0ffffffffH
	DD	imagerel ?initLogWriter@CCoreList@@QEAA_NPEAD0_N@Z+363
	DD	01H
	DD	imagerel ?initLogWriter@CCoreList@@QEAA_NPEAD0_N@Z+407
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?initLogWriter@CCoreList@@QEAA_NPEAD0_N@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??initLogWriter@CCoreList@@QEAA_NPEAD0_N@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$1@?0??initLogWriter@CCoreList@@QEAA_NPEAD0_N@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?initLogWriter@CCoreList@@QEAA_NPEAD0_N@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$?initLogWriter@CCoreList@@QEAA_NPEAD0_N@Z
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$?initLogWriter@CCoreList@@QEAA_NPEAD0_N@Z
	DD	068H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?initLogWriter@CCoreList@@QEAA_NPEAD0_N@Z DD 023619H
	DD	023011bH
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?initLogWriter@CCoreList@@QEAA_NPEAD0_N@Z
	DD	0102H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??initComThread@CCoreList@@QEAA_NPEAD0@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??initComThread@CCoreList@@QEAA_NPEAD0@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?initComThread@CCoreList@@QEAA_NPEAD0@Z DD imagerel ?initComThread@CCoreList@@QEAA_NPEAD0@Z
	DD	0ffffffffH
	DD	imagerel ?initComThread@CCoreList@@QEAA_NPEAD0@Z+127
	DD	00H
	DD	imagerel ?initComThread@CCoreList@@QEAA_NPEAD0@Z+186
	DD	0ffffffffH
	DD	imagerel ?initComThread@CCoreList@@QEAA_NPEAD0@Z+324
	DD	01H
	DD	imagerel ?initComThread@CCoreList@@QEAA_NPEAD0@Z+368
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?initComThread@CCoreList@@QEAA_NPEAD0@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??initComThread@CCoreList@@QEAA_NPEAD0@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$1@?0??initComThread@CCoreList@@QEAA_NPEAD0@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?initComThread@CCoreList@@QEAA_NPEAD0@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$?initComThread@CCoreList@@QEAA_NPEAD0@Z
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$?initComThread@CCoreList@@QEAA_NPEAD0@Z
	DD	060H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?initComThread@CCoreList@@QEAA_NPEAD0@Z DD 022e19H
	DD	0110116H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?initComThread@CCoreList@@QEAA_NPEAD0@Z
	DD	072H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??addQueueThread@CCoreList@@QEAAHH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?addQueueThread@CCoreList@@QEAAHH@Z DD imagerel ?addQueueThread@CCoreList@@QEAAHH@Z
	DD	0ffffffffH
	DD	imagerel ?addQueueThread@CCoreList@@QEAAHH@Z+112
	DD	00H
	DD	imagerel ?addQueueThread@CCoreList@@QEAAHH@Z+156
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?addQueueThread@CCoreList@@QEAAHH@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??addQueueThread@CCoreList@@QEAAHH@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?addQueueThread@CCoreList@@QEAAHH@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?addQueueThread@CCoreList@@QEAAHH@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?addQueueThread@CCoreList@@QEAAHH@Z
	DD	058H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?addQueueThread@CCoreList@@QEAAHH@Z DD 012519H
	DD	0e20dH
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?addQueueThread@CCoreList@@QEAAHH@Z
	DD	06aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??addScheduler@CCoreList@@QEAAHHH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?addScheduler@CCoreList@@QEAAHHH@Z DD imagerel ?addScheduler@CCoreList@@QEAAHHH@Z
	DD	0ffffffffH
	DD	imagerel ?addScheduler@CCoreList@@QEAAHHH@Z+120
	DD	00H
	DD	imagerel ?addScheduler@CCoreList@@QEAAHHH@Z+164
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?addScheduler@CCoreList@@QEAAHHH@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??addScheduler@CCoreList@@QEAAHHH@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?addScheduler@CCoreList@@QEAAHHH@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?addScheduler@CCoreList@@QEAAHHH@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?addScheduler@CCoreList@@QEAAHHH@Z
	DD	068H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?addScheduler@CCoreList@@QEAAHHH@Z DD 022d19H
	DD	0110115H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?addScheduler@CCoreList@@QEAAHHH@Z
	DD	07aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??addLogWriter@CCoreList@@QEAAHH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?addLogWriter@CCoreList@@QEAAHH@Z DD imagerel ?addLogWriter@CCoreList@@QEAAHH@Z
	DD	0ffffffffH
	DD	imagerel ?addLogWriter@CCoreList@@QEAAHH@Z+108
	DD	00H
	DD	imagerel ?addLogWriter@CCoreList@@QEAAHH@Z+152
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?addLogWriter@CCoreList@@QEAAHH@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??addLogWriter@CCoreList@@QEAAHH@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?addLogWriter@CCoreList@@QEAAHH@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?addLogWriter@CCoreList@@QEAAHH@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?addLogWriter@CCoreList@@QEAAHH@Z
	DD	058H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?addLogWriter@CCoreList@@QEAAHH@Z DD 012519H
	DD	0e20dH
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?addLogWriter@CCoreList@@QEAAHH@Z
	DD	06aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?delComThread@CCoreList@@QEAA_NH@Z DD 010d01H
	DD	0820dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??addComThread@CCoreList@@QEAAHP6AXPEAUSTThreadInfo@@@ZPEAXH2@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?addComThread@CCoreList@@QEAAHP6AXPEAUSTThreadInfo@@@ZPEAXH2@Z DD imagerel ?addComThread@CCoreList@@QEAAHP6AXPEAUSTThreadInfo@@@ZPEAXH2@Z
	DD	0ffffffffH
	DD	imagerel ?addComThread@CCoreList@@QEAAHP6AXPEAUSTThreadInfo@@@ZPEAXH2@Z+123
	DD	00H
	DD	imagerel ?addComThread@CCoreList@@QEAAHP6AXPEAUSTThreadInfo@@@ZPEAXH2@Z+167
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?addComThread@CCoreList@@QEAAHP6AXPEAUSTThreadInfo@@@ZPEAXH2@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??addComThread@CCoreList@@QEAAHP6AXPEAUSTThreadInfo@@@ZPEAXH2@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?addComThread@CCoreList@@QEAAHP6AXPEAUSTThreadInfo@@@ZPEAXH2@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?addComThread@CCoreList@@QEAAHP6AXPEAUSTThreadInfo@@@ZPEAXH2@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?addComThread@CCoreList@@QEAAHP6AXPEAUSTThreadInfo@@@ZPEAXH2@Z
	DD	068H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?addComThread@CCoreList@@QEAAHP6AXPEAUSTThreadInfo@@@ZPEAXH2@Z DD 023319H
	DD	011011bH
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?addComThread@CCoreList@@QEAAHP6AXPEAUSTThreadInfo@@@ZPEAXH2@Z
	DD	07aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?putTimer@CCoreList@@QEAA_NPEAUSTIntervalInfo@@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?putEvent@CCoreList@@QEAA_NPEAUSTEvent@@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?delEvent@CCoreList@@QEAA_NPEAUSTEvent@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?destroy@CCoreList@@QEAAXXZ DD 020c01H
	DD	017010cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??start@CCoreList@@QEAA_NXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?start@CCoreList@@QEAA_NXZ DD imagerel ?start@CCoreList@@QEAA_NXZ
	DD	0ffffffffH
	DD	imagerel ?start@CCoreList@@QEAA_NXZ+58
	DD	00H
	DD	imagerel ?start@CCoreList@@QEAA_NXZ+660
	DD	0ffffffffH
	DD	imagerel ?start@CCoreList@@QEAA_NXZ+677
	DD	00H
	DD	imagerel ?start@CCoreList@@QEAA_NXZ+695
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?start@CCoreList@@QEAA_NXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??start@CCoreList@@QEAA_NXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?start@CCoreList@@QEAA_NXZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?start@CCoreList@@QEAA_NXZ
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$?start@CCoreList@@QEAA_NXZ
	DD	050H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?start@CCoreList@@QEAA_NXZ DD 022719H
	DD	01d010cH
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?start@CCoreList@@QEAA_NXZ
	DD	0d2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setLoggerDisable@CCoreList@@QEAA_NPEAVCLogger@@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setLoggerEnable@CCoreList@@QEAA_NPEAVCLogger@@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?initLogger@CCoreList@@QEAA_NPEAVCLogger@@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?initLogger@CCoreList@@QEAA_NPEAVCLogger@@PEAD1@Z DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?initDefaultPool@CCoreList@@QEAA_NHHH@Z DD 032d19H
	DD	014011bH
	DD	07014H
	DD	imagerel __GSHandlerCheck
	DD	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?initSystemFile@CCoreList@@QEAA_NXZ DD 031f19H
	DD	01a010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	0c8H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1CCoreList@@QEAA@XZ DD imagerel ??1CCoreList@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1CCoreList@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1CCoreList@@QEAA@XZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1CCoreList@@QEAA@XZ DD 011219H
	DD	06209H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1CCoreList@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0CCoreList@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0CCoreList@@QEAA@XZ DD imagerel ??0CCoreList@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??0CCoreList@@QEAA@XZ+117
	DD	00H
	DD	imagerel ??0CCoreList@@QEAA@XZ+161
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0CCoreList@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0CCoreList@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0CCoreList@@QEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0CCoreList@@QEAA@XZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??0CCoreList@@QEAA@XZ
	DD	038H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0CCoreList@@QEAA@XZ DD 011211H
	DD	08209H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0CCoreList@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??_ECComQueueThread@@QEAAPEAXI@Z DD imagerel ??_ECComQueueThread@@QEAAPEAXI@Z
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??_ECComQueueThread@@QEAAPEAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??_ECComQueueThread@@QEAAPEAXI@Z
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_ECComQueueThread@@QEAAPEAXI@Z DD 011619H
	DD	0620dH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??_ECComQueueThread@@QEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GCComQueueThread@@QEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getEvent@CComQueueThread@@QEAAPEAUSTEvent@@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?putQueue@CComQueueThread@@QEAA_NPEAUSTEvent@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?quit@CComQueueThread@@QEAA_NXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?start@CComQueueThread@@QEAA_NXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?init@CComQueueThread@@QEAA_NHH@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?initConfig@CComQueueThread@@QEAA_NPEADH0@Z DD 012719H
	DD	0a218H
	DD	imagerel __GSHandlerCheck
	DD	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1CComQueueThread@@QEAA@XZ DD imagerel ??1CComQueueThread@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1CComQueueThread@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1CComQueueThread@@QEAA@XZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1CComQueueThread@@QEAA@XZ DD 011219H
	DD	06209H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1CComQueueThread@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0CComQueueThread@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0CComQueueThread@@QEAA@XZ DD imagerel ??0CComQueueThread@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??0CComQueueThread@@QEAA@XZ+32
	DD	00H
	DD	imagerel ??0CComQueueThread@@QEAA@XZ+50
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0CComQueueThread@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0CComQueueThread@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0CComQueueThread@@QEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0CComQueueThread@@QEAA@XZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??0CComQueueThread@@QEAA@XZ
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0CComQueueThread@@QEAA@XZ DD 011211H
	DD	06209H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0CComQueueThread@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?eventThreadLoop@@YAXPEAUSTThreadInfo@@@Z DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$CMemList@USTIntervalInfo@@@@QEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__autoclassinit2@?$CMemList@USTIntervalInfo@@@@QEAAX_K@Z DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_del@?$CMemList@USTIntervalInfo@@@@AEAAXH@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?del@?$CMemList@USTIntervalInfo@@@@QEAA_NPEAUSTIntervalInfo@@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?add@?$CMemList@USTIntervalInfo@@@@QEAAHPEAUSTIntervalInfo@@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getNext@?$CMemList@USTIntervalInfo@@@@QEAAPEAUSTIntervalInfo@@PEAH@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??alloc@?$CMemList@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?alloc@?$CMemList@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z DD imagerel ?alloc@?$CMemList@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z
	DD	0ffffffffH
	DD	imagerel ?alloc@?$CMemList@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z+138
	DD	00H
	DD	imagerel ?alloc@?$CMemList@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z+240
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?alloc@?$CMemList@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??alloc@?$CMemList@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?alloc@?$CMemList@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?alloc@?$CMemList@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?alloc@?$CMemList@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z
	DD	058H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?alloc@?$CMemList@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z DD 011b11H
	DD	0c212H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?alloc@?$CMemList@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$CMemList@USTIntervalInfo@@@@QEAA@XZ DD imagerel ??1?$CMemList@USTIntervalInfo@@@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1?$CMemList@USTIntervalInfo@@@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1?$CMemList@USTIntervalInfo@@@@QEAA@XZ
	DD	078H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$CMemList@USTIntervalInfo@@@@QEAA@XZ DD 022719H
	DD	013010cH
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$??1?$CMemList@USTIntervalInfo@@@@QEAA@XZ
	DD	08bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$CMemList@USTIntervalInfo@@@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$CMemList@USTIntervalInfo@@@@QEAA@XZ DD imagerel ??0?$CMemList@USTIntervalInfo@@@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??0?$CMemList@USTIntervalInfo@@@@QEAA@XZ+36
	DD	00H
	DD	imagerel ??0?$CMemList@USTIntervalInfo@@@@QEAA@XZ+91
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$CMemList@USTIntervalInfo@@@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0?$CMemList@USTIntervalInfo@@@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0?$CMemList@USTIntervalInfo@@@@QEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0?$CMemList@USTIntervalInfo@@@@QEAA@XZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??0?$CMemList@USTIntervalInfo@@@@QEAA@XZ
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$CMemList@USTIntervalInfo@@@@QEAA@XZ DD 011211H
	DD	06209H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0?$CMemList@USTIntervalInfo@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??_ECScheduler@@QEAAPEAXI@Z DD imagerel ??_ECScheduler@@QEAAPEAXI@Z
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??_ECScheduler@@QEAAPEAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??_ECScheduler@@QEAAPEAXI@Z
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_ECScheduler@@QEAAPEAXI@Z DD 011619H
	DD	0620dH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??_ECScheduler@@QEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GCScheduler@@QEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?addTime@CScheduler@@QEAAHPEAUSTIntervalInfo@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deleteTime@CScheduler@@QEAA_NPEAUSTIntervalInfo@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?timeNext@CScheduler@@QEAAPEAUSTIntervalInfo@@PEAH@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?quit@CScheduler@@QEAA_NXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?start@CScheduler@@QEAA_NXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??init@CScheduler@@QEAA_NHHH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?init@CScheduler@@QEAA_NHHH@Z DD imagerel ?init@CScheduler@@QEAA_NHHH@Z
	DD	0ffffffffH
	DD	imagerel ?init@CScheduler@@QEAA_NHHH@Z+105
	DD	00H
	DD	imagerel ?init@CScheduler@@QEAA_NHHH@Z+164
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?init@CScheduler@@QEAA_NHHH@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??init@CScheduler@@QEAA_NHHH@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?init@CScheduler@@QEAA_NHHH@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?init@CScheduler@@QEAA_NHHH@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?init@CScheduler@@QEAA_NHHH@Z
	DD	050H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?init@CScheduler@@QEAA_NHHH@Z DD 012011H
	DD	0c217H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?init@CScheduler@@QEAA_NHHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??initConfig@CScheduler@@QEAA_NPEADH0@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?initConfig@CScheduler@@QEAA_NPEADH0@Z DD imagerel ?initConfig@CScheduler@@QEAA_NPEADH0@Z
	DD	0ffffffffH
	DD	imagerel ?initConfig@CScheduler@@QEAA_NPEADH0@Z+244
	DD	00H
	DD	imagerel ?initConfig@CScheduler@@QEAA_NPEADH0@Z+303
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?initConfig@CScheduler@@QEAA_NPEADH0@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??initConfig@CScheduler@@QEAA_NPEADH0@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?initConfig@CScheduler@@QEAA_NPEADH0@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?initConfig@CScheduler@@QEAA_NPEADH0@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?initConfig@CScheduler@@QEAA_NPEADH0@Z
	DD	058H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?initConfig@CScheduler@@QEAA_NPEADH0@Z DD 023319H
	DD	011011bH
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?initConfig@CScheduler@@QEAA_NPEADH0@Z
	DD	07aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1CScheduler@@QEAA@XZ DD imagerel ??1CScheduler@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1CScheduler@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1CScheduler@@QEAA@XZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1CScheduler@@QEAA@XZ DD 011219H
	DD	06209H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1CScheduler@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0CScheduler@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?schedulerLoop@@YAXPEAUSTThreadInfo@@@Z DD 011819H
	DD	0a209H
	DD	imagerel __GSHandlerCheck
	DD	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??_ECSTLogger@@QEAAPEAXI@Z DD imagerel ??_ECSTLogger@@QEAAPEAXI@Z
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??_ECSTLogger@@QEAAPEAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??_ECSTLogger@@QEAAPEAXI@Z
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_ECSTLogger@@QEAAPEAXI@Z DD 011619H
	DD	0620dH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??_ECSTLogger@@QEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GCSTLogger@@QEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??_init@CSTLogger@@AEAA_NH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??_init@CSTLogger@@AEAA_NH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_init@CSTLogger@@AEAA_NH@Z DD imagerel ?_init@CSTLogger@@AEAA_NH@Z
	DD	0ffffffffH
	DD	imagerel ?_init@CSTLogger@@AEAA_NH@Z+37
	DD	00H
	DD	imagerel ?_init@CSTLogger@@AEAA_NH@Z+96
	DD	0ffffffffH
	DD	imagerel ?_init@CSTLogger@@AEAA_NH@Z+154
	DD	01H
	DD	imagerel ?_init@CSTLogger@@AEAA_NH@Z+213
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_init@CSTLogger@@AEAA_NH@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??_init@CSTLogger@@AEAA_NH@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$1@?0??_init@CSTLogger@@AEAA_NH@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?_init@CSTLogger@@AEAA_NH@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$?_init@CSTLogger@@AEAA_NH@Z
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$?_init@CSTLogger@@AEAA_NH@Z
	DD	050H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_init@CSTLogger@@AEAA_NH@Z DD 011611H
	DD	0c20dH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_init@CSTLogger@@AEAA_NH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pushCommand@CSTLogger@@QEAA_NPEAUSTLCommand@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?porcLoggerDisable@CSTLogger@@QEAAXPEAVCLogger@@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?procLoggerEnable@CSTLogger@@QEAAXPEAVCLogger@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??TimeProc@CSTLogger@@QEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?TimeProc@CSTLogger@@QEAAXXZ DD imagerel ?TimeProc@CSTLogger@@QEAAXXZ
	DD	0ffffffffH
	DD	imagerel ?TimeProc@CSTLogger@@QEAAXXZ+58
	DD	00H
	DD	imagerel ?TimeProc@CSTLogger@@QEAAXXZ+379
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?TimeProc@CSTLogger@@QEAAXXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??TimeProc@CSTLogger@@QEAAXXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?TimeProc@CSTLogger@@QEAAXXZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?TimeProc@CSTLogger@@QEAAXXZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?TimeProc@CSTLogger@@QEAAXXZ
	DD	030H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TimeProc@CSTLogger@@QEAAXXZ DD 022719H
	DD	019010cH
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?TimeProc@CSTLogger@@QEAAXXZ
	DD	0b2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetQueue@CSTLogger@@QEAAXXZ DD 011819H
	DD	0c209H
	DD	imagerel __GSHandlerCheck
	DD	050H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?IsCommand@CSTLogger@@QEAA_NXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?quit@CSTLogger@@QEAA_NXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?start@CSTLogger@@QEAA_NXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?init@CSTLogger@@QEAA_NHH@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?initConfig@CSTLogger@@QEAA_NPEADH0@Z DD 012719H
	DD	0a218H
	DD	imagerel __GSHandlerCheck
	DD	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1CSTLogger@@QEAA@XZ DD imagerel ??1CSTLogger@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1CSTLogger@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1CSTLogger@@QEAA@XZ
	DD	050H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1CSTLogger@@QEAA@XZ DD 011219H
	DD	0c209H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1CSTLogger@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0CSTLogger@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?loggerLoop@@YAXPEAUSTThreadInfo@@@Z DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??_ECComThread@@QEAAPEAXI@Z DD imagerel ??_ECComThread@@QEAAPEAXI@Z
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??_ECComThread@@QEAAPEAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??_ECComThread@@QEAAPEAXI@Z
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_ECComThread@@QEAAPEAXI@Z DD 011619H
	DD	0620dH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??_ECComThread@@QEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GCComThread@@QEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?sendSignal@CComThread@@QEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ProcThread@CComThread@@SAKPEAX@Z DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?quit@CComThread@@QEAA_NXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?start@CComThread@@QEAA_NXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1CComThread@@QEAA@XZ DD imagerel ??1CComThread@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1CComThread@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1CComThread@@QEAA@XZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1CComThread@@QEAA@XZ DD 011219H
	DD	06209H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1CComThread@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0CComThread@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1STThreadInfo@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0STThreadInfo@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??_ECLogger@@QEAAPEAXI@Z DD imagerel ??_ECLogger@@QEAAPEAXI@Z
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??_ECLogger@@QEAAPEAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??_ECLogger@@QEAAPEAXI@Z
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_ECLogger@@QEAAPEAXI@Z DD 011619H
	DD	0620dH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??_ECLogger@@QEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GCLogger@@QEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pop@CLogger@@QEAAPEADXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isLogFlag@CLogger@@QEAA_NW4E_LOG_FLAG@@@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?delBuf@CMemManager@@QEAAXPEADH@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?newBuf@CMemManager@@QEAAPEADH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getIndex@@YAHH@Z DD 010801H
	DD	04208H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GCQueueS@@QEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__autoclassinit2@CQueueS@@QEAAX_K@Z DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?comGlobalErrorProc@@YAXPEADPEBDH@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z DD imagerel ??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z DD 011619H
	DD	0620dH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?atomic_compare_exchange@win64_atomic@win32@common@@QEAA_J_J0@Z DD 011301H
	DD	02213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gcondition@win32@common@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?wait@condition@win32@common@@QEAA_NHPEAVcritical_section@23@@Z DD 011201H
	DD	06212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?signal_all@condition@win32@common@@UEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?signal@condition@win32@common@@UEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1condition@win32@common@@UEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0condition@win32@common@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gabstract_condition@common@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 012719H
	DD	08218H
	DD	imagerel __GSHandlerCheck
	DD	030H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 012719H
	DD	08218H
	DD	imagerel __GSHandlerCheck
	DD	030H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$CTList@VCComQueueThread@@@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$CTList@VCComQueueThread@@@@QEAAPEAXI@Z PROC	; CTList<CComQueueThread>::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00012	e8 00 00 00 00	 call	 ??1?$CTList@VCComQueueThread@@@@QEAA@XZ ; CTList<CComQueueThread>::~CTList<CComQueueThread>
  00017	8b 44 24 38	 mov	 eax, DWORD PTR __flags$[rsp]
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 0f		 je	 SHORT $LN2@scalar
  00022	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
??_G?$CTList@VCComQueueThread@@@@QEAAPEAXI@Z ENDP	; CTList<CComQueueThread>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit2@?$CTList@VCComQueueThread@@@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 16
classSize$ = 24
?__autoclassinit2@?$CTList@VCComQueueThread@@@@QEAAX_K@Z PROC ; CTList<CComQueueThread>::__autoclassinit2, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 8b 7c 24 10	 mov	 rdi, QWORD PTR this$[rsp]
  00010	33 c0		 xor	 eax, eax
  00012	48 8b 4c 24 18	 mov	 rcx, QWORD PTR classSize$[rsp]
  00017	f3 aa		 rep stosb
  00019	5f		 pop	 rdi
  0001a	c3		 ret	 0
?__autoclassinit2@?$CTList@VCComQueueThread@@@@QEAAX_K@Z ENDP ; CTList<CComQueueThread>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?_DEL@?$CTList@VCComQueueThread@@@@AEAAXH@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
?_DEL@?$CTList@VCComQueueThread@@@@AEAAXH@Z PROC	; CTList<CComQueueThread>::_DEL, COMDAT

; 360  : 	inline void _DEL(int i) { m_pArray[i] = 0; m_nUse--; m_nDelIdx = i; }

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 63 44 24 10	 movsxd	 rax, DWORD PTR i$[rsp]
  0000e	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  00013	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00016	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0
  0001e	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00023	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00026	ff c8		 dec	 eax
  00028	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  0002d	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  00030	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00035	8b 4c 24 10	 mov	 ecx, DWORD PTR i$[rsp]
  00039	89 48 10	 mov	 DWORD PTR [rax+16], ecx
  0003c	c3		 ret	 0
?_DEL@?$CTList@VCComQueueThread@@@@AEAAXH@Z ENDP	; CTList<CComQueueThread>::_DEL
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?__alloc@?$CTList@VCComQueueThread@@@@AEAAHH@Z
_TEXT	SEGMENT
pList$ = 32
this$ = 80
nMaxCount$ = 88
?__alloc@?$CTList@VCComQueueThread@@@@AEAAHH@Z PROC	; CTList<CComQueueThread>::__alloc, COMDAT

; 402  : {

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 403  : 	T** pList = (T**)calloc(nMaxCount, sizeof(T*));

  0000f	48 63 44 24 58	 movsxd	 rax, DWORD PTR nMaxCount$[rsp]
  00014	ba 08 00 00 00	 mov	 edx, 8
  00019	48 8b c8	 mov	 rcx, rax
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00022	48 89 44 24 20	 mov	 QWORD PTR pList$[rsp], rax

; 404  : 	if (!pList) {

  00027	48 83 7c 24 20
	00		 cmp	 QWORD PTR pList$[rsp], 0
  0002d	75 17		 jne	 SHORT $LN2@alloc

; 405  : 		_stprintf(g_szMessage, "pList calloc is NULL");

  0002f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG47140
  00036	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  0003d	e8 00 00 00 00	 call	 sprintf

; 406  : 		return 0;

  00042	33 c0		 xor	 eax, eax
  00044	eb 49		 jmp	 SHORT $LN1@alloc
$LN2@alloc:

; 407  : 	}
; 408  : 	//_stprintf(g_szMessage, _T("CTList::__alloc list m_nMaxCount[%d]"), nMaxCount);
; 409  : 	if (m_pArray) {

  00046	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0004b	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0004f	74 2d		 je	 SHORT $LN3@alloc

; 410  : 		memcpy(pList, m_pArray, m_nMax * sizeof(T*));

  00051	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00056	48 63 40 14	 movsxd	 rax, DWORD PTR [rax+20]
  0005a	48 c1 e0 03	 shl	 rax, 3
  0005e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00063	48 8b 7c 24 20	 mov	 rdi, QWORD PTR pList$[rsp]
  00068	48 8b 31	 mov	 rsi, QWORD PTR [rcx]
  0006b	48 8b c8	 mov	 rcx, rax
  0006e	f3 a4		 rep movsb

; 411  : 		free(m_pArray);

  00070	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00075	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN3@alloc:

; 412  : 	}
; 413  : 	m_pArray = pList;

  0007e	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00083	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pList$[rsp]
  00088	48 89 08	 mov	 QWORD PTR [rax], rcx

; 414  : 	return nMaxCount;

  0008b	8b 44 24 58	 mov	 eax, DWORD PTR nMaxCount$[rsp]
$LN1@alloc:

; 415  : }

  0008f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00093	5f		 pop	 rdi
  00094	5e		 pop	 rsi
  00095	c3		 ret	 0
?__alloc@?$CTList@VCComQueueThread@@@@AEAAHH@Z ENDP	; CTList<CComQueueThread>::__alloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?setObjAllocType@?$CTList@VCComQueueThread@@@@QEAAXW4E_ALLOC_TYPE@@@Z
_TEXT	SEGMENT
this$ = 8
type$ = 16
?setObjAllocType@?$CTList@VCComQueueThread@@@@QEAAXW4E_ALLOC_TYPE@@@Z PROC ; CTList<CComQueueThread>::setObjAllocType, COMDAT

; 350  : 	inline void setObjAllocType(E_ALLOC_TYPE type) { m_nObjAllocType = type; }

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR type$[rsp]
  00012	89 48 18	 mov	 DWORD PTR [rax+24], ecx
  00015	c3		 ret	 0
?setObjAllocType@?$CTList@VCComQueueThread@@@@QEAAXW4E_ALLOC_TYPE@@@Z ENDP ; CTList<CComQueueThread>::setObjAllocType
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?size@?$CTList@VCComQueueThread@@@@QEAAHXZ
_TEXT	SEGMENT
this$ = 8
?size@?$CTList@VCComQueueThread@@@@QEAAHXZ PROC		; CTList<CComQueueThread>::size, COMDAT

; 347  : 	inline int  size() { return m_nUse; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0000d	c3		 ret	 0
?size@?$CTList@VCComQueueThread@@@@QEAAHXZ ENDP		; CTList<CComQueueThread>::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?getNext@?$CTList@VCComQueueThread@@@@QEAAPEAVCComQueueThread@@PEAH@Z
_TEXT	SEGMENT
this$ = 8
pIdx$ = 16
?getNext@?$CTList@VCComQueueThread@@@@QEAAPEAVCComQueueThread@@PEAH@Z PROC ; CTList<CComQueueThread>::getNext, COMDAT

; 334  : 	inline T* getNext(int *pIdx) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 335  : 		for (*pIdx; *pIdx < m_nMax; (*pIdx)++) {

  0000a	eb 10		 jmp	 SHORT $LN4@getNext
$LN2@getNext:
  0000c	48 8b 44 24 10	 mov	 rax, QWORD PTR pIdx$[rsp]
  00011	8b 00		 mov	 eax, DWORD PTR [rax]
  00013	ff c0		 inc	 eax
  00015	48 8b 4c 24 10	 mov	 rcx, QWORD PTR pIdx$[rsp]
  0001a	89 01		 mov	 DWORD PTR [rcx], eax
$LN4@getNext:
  0001c	48 8b 44 24 10	 mov	 rax, QWORD PTR pIdx$[rsp]
  00021	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  00026	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  00029	39 08		 cmp	 DWORD PTR [rax], ecx
  0002b	7d 2f		 jge	 SHORT $LN3@getNext

; 336  : 			if (m_pArray[*pIdx]) { return m_pArray[*pIdx]; }

  0002d	48 8b 44 24 10	 mov	 rax, QWORD PTR pIdx$[rsp]
  00032	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  00035	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  0003a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0003d	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00042	74 16		 je	 SHORT $LN5@getNext
  00044	48 8b 44 24 10	 mov	 rax, QWORD PTR pIdx$[rsp]
  00049	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  0004c	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  00051	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00054	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00058	eb 04		 jmp	 SHORT $LN1@getNext
$LN5@getNext:

; 337  : 		}

  0005a	eb b0		 jmp	 SHORT $LN2@getNext
$LN3@getNext:

; 338  : 		return NULL;

  0005c	33 c0		 xor	 eax, eax
$LN1@getNext:

; 339  : 	}

  0005e	c3		 ret	 0
?getNext@?$CTList@VCComQueueThread@@@@QEAAPEAVCComQueueThread@@PEAH@Z ENDP ; CTList<CComQueueThread>::getNext
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?getObj@?$CTList@VCComQueueThread@@@@QEAAPEAVCComQueueThread@@H@Z
_TEXT	SEGMENT
this$ = 48
i$ = 56
?getObj@?$CTList@VCComQueueThread@@@@QEAAPEAVCComQueueThread@@H@Z PROC ; CTList<CComQueueThread>::getObj, COMDAT

; 332  : 	inline T* getObj(int i) { if (ISINCLUDE(i, m_nMax)) return m_pArray[i]; return NULL; }

$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00012	8b 50 14	 mov	 edx, DWORD PTR [rax+20]
  00015	8b 4c 24 38	 mov	 ecx, DWORD PTR i$[rsp]
  00019	e8 00 00 00 00	 call	 ?ISINCLUDE@@YA_NHH@Z	; ISINCLUDE
  0001e	0f b6 c0	 movzx	 eax, al
  00021	85 c0		 test	 eax, eax
  00023	74 13		 je	 SHORT $LN2@getObj
  00025	48 63 44 24 38	 movsxd	 rax, DWORD PTR i$[rsp]
  0002a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00032	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00036	eb 02		 jmp	 SHORT $LN1@getObj
$LN2@getObj:
  00038	33 c0		 xor	 eax, eax
$LN1@getObj:
  0003a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003e	c3		 ret	 0
?getObj@?$CTList@VCComQueueThread@@@@QEAAPEAVCComQueueThread@@H@Z ENDP ; CTList<CComQueueThread>::getObj
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?del@?$CTList@VCComQueueThread@@@@QEAA_NH@Z
_TEXT	SEGMENT
this$ = 48
i$ = 56
?del@?$CTList@VCComQueueThread@@@@QEAA_NH@Z PROC	; CTList<CComQueueThread>::del, COMDAT

; 523  : {

$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 524  : 	if (!ISINCLUDE(i, m_nMax)) {

  0000d	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00012	8b 50 14	 mov	 edx, DWORD PTR [rax+20]
  00015	8b 4c 24 38	 mov	 ecx, DWORD PTR i$[rsp]
  00019	e8 00 00 00 00	 call	 ?ISINCLUDE@@YA_NHH@Z	; ISINCLUDE
  0001e	0f b6 c0	 movzx	 eax, al
  00021	85 c0		 test	 eax, eax
  00023	75 25		 jne	 SHORT $LN2@del

; 525  : 		_stprintf(g_szMessage, "i[%d] m_nMax[%d]", i, m_nMax);

  00025	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0002a	44 8b 48 14	 mov	 r9d, DWORD PTR [rax+20]
  0002e	44 8b 44 24 38	 mov	 r8d, DWORD PTR i$[rsp]
  00033	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG47129
  0003a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  00041	e8 00 00 00 00	 call	 sprintf

; 526  : 		return false;

  00046	32 c0		 xor	 al, al
  00048	eb 10		 jmp	 SHORT $LN1@del
$LN2@del:

; 527  : 	}
; 528  : 	_DEL(i);

  0004a	8b 54 24 38	 mov	 edx, DWORD PTR i$[rsp]
  0004e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00053	e8 00 00 00 00	 call	 ?_DEL@?$CTList@VCComQueueThread@@@@AEAAXH@Z ; CTList<CComQueueThread>::_DEL

; 529  : 	//_stprintf(g_szMessage, _T("CMemList::del i[%d] m_nLast[%d] m_nCurCount[%d]"), i, m_nLast, m_nUse);
; 530  : 	return true;

  00058	b0 01		 mov	 al, 1
$LN1@del:

; 531  : }

  0005a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005e	c3		 ret	 0
?del@?$CTList@VCComQueueThread@@@@QEAA_NH@Z ENDP	; CTList<CComQueueThread>::del
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?push_back@?$CTList@VCComQueueThread@@@@QEAA_NPEAVCComQueueThread@@PEAH@Z
_TEXT	SEGMENT
nIdx$ = 32
i$ = 36
this$ = 64
Obj$ = 72
pIdx$ = 80
?push_back@?$CTList@VCComQueueThread@@@@QEAA_NPEAVCComQueueThread@@PEAH@Z PROC ; CTList<CComQueueThread>::push_back, COMDAT

; 472  : {

$LN15:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 473  : 	int nIdx, i;
; 474  : 
; 475  : 	if (m_nUse >= m_nMax) {

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00018	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0001d	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  00020	39 48 08	 cmp	 DWORD PTR [rax+8], ecx
  00023	7c 4b		 jl	 SHORT $LN5@push_back

; 476  : 		if (!__alloc(m_nMax + TLIST_ADD_SIZE)) return false;

  00025	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0002a	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0002d	83 c0 40	 add	 eax, 64			; 00000040H
  00030	8b d0		 mov	 edx, eax
  00032	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00037	e8 00 00 00 00	 call	 ?__alloc@?$CTList@VCComQueueThread@@@@AEAAHH@Z ; CTList<CComQueueThread>::__alloc
  0003c	85 c0		 test	 eax, eax
  0003e	75 07		 jne	 SHORT $LN6@push_back
  00040	32 c0		 xor	 al, al
  00042	e9 0c 01 00 00	 jmp	 $LN1@push_back
$LN6@push_back:

; 477  : 		nIdx = m_nMax;

  00047	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0004c	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0004f	89 44 24 20	 mov	 DWORD PTR nIdx$[rsp], eax

; 478  : 		m_nMax += TLIST_ADD_SIZE;

  00053	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00058	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0005b	83 c0 40	 add	 eax, 64			; 00000040H
  0005e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00063	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 479  : 		goto ADD_SUCCESS;

  00066	e9 99 00 00 00	 jmp	 $LN7@push_back
  0006b	e9 94 00 00 00	 jmp	 $ADD_SUCCESS$16
$LN5@push_back:

; 480  : 	}
; 481  : 
; 482  : 	if (!m_pArray[m_nLast]) { nIdx = m_nLast;  goto ADD_SUCCESS; }

  00070	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00075	48 63 40 0c	 movsxd	 rax, DWORD PTR [rax+12]
  00079	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0007e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00081	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00086	75 10		 jne	 SHORT $LN8@push_back
  00088	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0008d	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00090	89 44 24 20	 mov	 DWORD PTR nIdx$[rsp], eax
  00094	eb 6e		 jmp	 SHORT $LN9@push_back
  00096	eb 6c		 jmp	 SHORT $ADD_SUCCESS$16
$LN8@push_back:

; 483  : 
; 484  : 	nIdx = m_nLast;

  00098	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0009d	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  000a0	89 44 24 20	 mov	 DWORD PTR nIdx$[rsp], eax

; 485  : 	for (i = 0; i < m_nMax; i++)

  000a4	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000ac	eb 0a		 jmp	 SHORT $LN4@push_back
$LN2@push_back:
  000ae	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  000b2	ff c0		 inc	 eax
  000b4	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@push_back:
  000b8	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000bd	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000c0	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  000c4	7d 3a		 jge	 SHORT $LN3@push_back

; 486  : 	{
; 487  : 		if (nIdx >= m_nMax) nIdx = 0;

  000c6	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000cb	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000ce	39 44 24 20	 cmp	 DWORD PTR nIdx$[rsp], eax
  000d2	7c 08		 jl	 SHORT $LN10@push_back
  000d4	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR nIdx$[rsp], 0
$LN10@push_back:

; 488  : 		if (!m_pArray[nIdx]) {

  000dc	48 63 44 24 20	 movsxd	 rax, DWORD PTR nIdx$[rsp]
  000e1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000e6	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000e9	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  000ee	75 04		 jne	 SHORT $LN11@push_back

; 489  : 			goto ADD_SUCCESS;

  000f0	eb 12		 jmp	 SHORT $LN12@push_back
  000f2	eb 10		 jmp	 SHORT $ADD_SUCCESS$16
$LN11@push_back:

; 490  : 		}
; 491  : 		nIdx++;

  000f4	8b 44 24 20	 mov	 eax, DWORD PTR nIdx$[rsp]
  000f8	ff c0		 inc	 eax
  000fa	89 44 24 20	 mov	 DWORD PTR nIdx$[rsp], eax

; 492  : 	}

  000fe	eb ae		 jmp	 SHORT $LN2@push_back
$LN3@push_back:

; 493  : 	//_stprintf(m_szMessage, _T("add FAIL! m_nLast[%d] m_nCurCount[%d] m_nMax[%d]"), m_nLast, m_nUse, m_nMax);
; 494  : 	return false;

  00100	32 c0		 xor	 al, al
  00102	eb 4f		 jmp	 SHORT $LN1@push_back
$LN7@push_back:
$LN9@push_back:
$LN12@push_back:
$ADD_SUCCESS$16:

; 495  : 
; 496  : ADD_SUCCESS:
; 497  : 	m_nUse++;

  00104	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00109	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0010c	ff c0		 inc	 eax
  0010e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00113	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 498  : 	m_pArray[nIdx] = Obj;

  00116	48 63 44 24 20	 movsxd	 rax, DWORD PTR nIdx$[rsp]
  0011b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00120	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00123	48 8b 54 24 48	 mov	 rdx, QWORD PTR Obj$[rsp]
  00128	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx

; 499  : 	m_nLast++;

  0012c	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00131	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00134	ff c0		 inc	 eax
  00136	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0013b	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 500  : 	//_stprintf(g_szMessage, _T("CMemList::add i[%d] m_nLast[%d] m_nCurCount[%d]"), nIdx, m_nLast, m_nUse);
; 501  : 	if (pIdx) *pIdx = nIdx;

  0013e	48 83 7c 24 50
	00		 cmp	 QWORD PTR pIdx$[rsp], 0
  00144	74 0b		 je	 SHORT $LN13@push_back
  00146	48 8b 44 24 50	 mov	 rax, QWORD PTR pIdx$[rsp]
  0014b	8b 4c 24 20	 mov	 ecx, DWORD PTR nIdx$[rsp]
  0014f	89 08		 mov	 DWORD PTR [rax], ecx
$LN13@push_back:

; 502  : 	return true;

  00151	b0 01		 mov	 al, 1
$LN1@push_back:

; 503  : }

  00153	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00157	c3		 ret	 0
?push_back@?$CTList@VCComQueueThread@@@@QEAA_NPEAVCComQueueThread@@PEAH@Z ENDP ; CTList<CComQueueThread>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?alloc@?$CTList@VCComQueueThread@@@@QEAAHHW4E_ALLOC_TYPE@@@Z
_TEXT	SEGMENT
this$ = 48
nMaxCount$ = 56
type$ = 64
?alloc@?$CTList@VCComQueueThread@@@@QEAAHHW4E_ALLOC_TYPE@@@Z PROC ; CTList<CComQueueThread>::alloc, COMDAT

; 326  : 	int alloc(int nMaxCount, E_ALLOC_TYPE type = eAlloc_Type_new) { m_nObjAllocType = type;  m_nMax = __alloc(nMaxCount); return m_nMax; }

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00012	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00017	8b 4c 24 40	 mov	 ecx, DWORD PTR type$[rsp]
  0001b	89 48 18	 mov	 DWORD PTR [rax+24], ecx
  0001e	8b 54 24 38	 mov	 edx, DWORD PTR nMaxCount$[rsp]
  00022	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00027	e8 00 00 00 00	 call	 ?__alloc@?$CTList@VCComQueueThread@@@@AEAAHH@Z ; CTList<CComQueueThread>::__alloc
  0002c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00031	89 41 14	 mov	 DWORD PTR [rcx+20], eax
  00034	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00039	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0003c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00040	c3		 ret	 0
?alloc@?$CTList@VCComQueueThread@@@@QEAAHHW4E_ALLOC_TYPE@@@Z ENDP ; CTList<CComQueueThread>::alloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ??1?$CTList@VCComQueueThread@@@@QEAA@XZ
_TEXT	SEGMENT
tv77 = 32
p$1 = 40
tv144 = 48
$T2 = 56
$T3 = 64
$T4 = 72
tv82 = 80
tv143 = 88
$T5 = 96
tv95 = 104
$T6 = 112
idx$7 = 120
__$ArrayPad$ = 128
this$ = 160
??1?$CTList@VCComQueueThread@@@@QEAA@XZ PROC		; CTList<CComQueueThread>::~CTList<CComQueueThread>, COMDAT

; 376  : {

$LN21:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  0000c	48 c7 44 24 70
	fe ff ff ff	 mov	 QWORD PTR $T6[rsp], -2
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 377  : 	if (!m_pArray) return;

  00027	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0002f	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00033	75 05		 jne	 SHORT $LN6@CTList
  00035	e9 a7 01 00 00	 jmp	 $LN1@CTList
$LN6@CTList:

; 378  : 
; 379  : 	if (ISABLETODELETE(m_nObjAllocType)) {

  0003a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00042	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00045	e8 00 00 00 00	 call	 ?ISABLETODELETE@@YA_NW4E_ALLOC_TYPE@@@Z ; ISABLETODELETE
  0004a	90		 npad	 1
  0004b	0f b6 c0	 movzx	 eax, al
  0004e	85 c0		 test	 eax, eax
  00050	0f 84 5c 01 00
	00		 je	 $LN7@CTList

; 380  : 		int idx = 0;

  00056	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR idx$7[rsp], 0

; 381  : 		T *p = getNext(&idx);

  0005e	48 8d 54 24 78	 lea	 rdx, QWORD PTR idx$7[rsp]
  00063	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0006b	e8 00 00 00 00	 call	 ?getNext@?$CTList@VCComQueueThread@@@@QEAAPEAVCComQueueThread@@PEAH@Z ; CTList<CComQueueThread>::getNext
  00070	90		 npad	 1
  00071	48 89 44 24 28	 mov	 QWORD PTR p$1[rsp], rax
$LN2@CTList:

; 382  : 		while (p) {

  00076	48 83 7c 24 28
	00		 cmp	 QWORD PTR p$1[rsp], 0
  0007c	0f 84 30 01 00
	00		 je	 $LN7@CTList

; 383  : 			idx++;

  00082	8b 44 24 78	 mov	 eax, DWORD PTR idx$7[rsp]
  00086	ff c0		 inc	 eax
  00088	89 44 24 78	 mov	 DWORD PTR idx$7[rsp], eax

; 384  : 			switch (m_nObjAllocType) {

  0008c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00094	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00097	89 44 24 20	 mov	 DWORD PTR tv77[rsp], eax
  0009b	83 7c 24 20 02	 cmp	 DWORD PTR tv77[rsp], 2
  000a0	74 1e		 je	 SHORT $LN8@CTList
  000a2	83 7c 24 20 03	 cmp	 DWORD PTR tv77[rsp], 3
  000a7	74 58		 je	 SHORT $LN9@CTList
  000a9	83 7c 24 20 04	 cmp	 DWORD PTR tv77[rsp], 4
  000ae	74 62		 je	 SHORT $LN10@CTList
  000b0	83 7c 24 20 05	 cmp	 DWORD PTR tv77[rsp], 5
  000b5	0f 84 9e 00 00
	00		 je	 $LN11@CTList
  000bb	e9 d5 00 00 00	 jmp	 $LN4@CTList
$LN8@CTList:

; 385  : 				case eAlloc_Type_new		:	delete p; break;

  000c0	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  000c5	48 89 44 24 48	 mov	 QWORD PTR $T4[rsp], rax
  000ca	48 8b 44 24 48	 mov	 rax, QWORD PTR $T4[rsp]
  000cf	48 89 44 24 38	 mov	 QWORD PTR $T2[rsp], rax
  000d4	48 83 7c 24 38
	00		 cmp	 QWORD PTR $T2[rsp], 0
  000da	74 17		 je	 SHORT $LN16@CTList
  000dc	ba 01 00 00 00	 mov	 edx, 1
  000e1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR $T2[rsp]
  000e6	e8 00 00 00 00	 call	 ??_GCComQueueThread@@QEAAPEAXI@Z
  000eb	90		 npad	 1
  000ec	48 89 44 24 50	 mov	 QWORD PTR tv82[rsp], rax
  000f1	eb 09		 jmp	 SHORT $LN17@CTList
$LN16@CTList:
  000f3	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR tv82[rsp], 0
$LN17@CTList:
  000fc	e9 94 00 00 00	 jmp	 $LN4@CTList
$LN9@CTList:

; 386  : 				case eAlloc_Type_alloc		:	free(p); break;

  00101	48 8b 4c 24 28	 mov	 rcx, QWORD PTR p$1[rsp]
  00106	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  0010c	90		 npad	 1
  0010d	e9 83 00 00 00	 jmp	 $LN4@CTList
$LN10@CTList:

; 387  : 				case eAlloc_Type_BufPool	:	gs_pMMgr->delBuf((char *)p, STRING_SIZE((TCHAR *)p)); break;

  00112	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  00117	48 89 44 24 58	 mov	 QWORD PTR tv143[rsp], rax
  0011c	48 c7 44 24 30
	ff ff ff ff	 mov	 QWORD PTR tv144[rsp], -1
$LL20@CTList:
  00125	48 ff 44 24 30	 inc	 QWORD PTR tv144[rsp]
  0012a	48 8b 44 24 58	 mov	 rax, QWORD PTR tv143[rsp]
  0012f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv144[rsp]
  00134	80 3c 08 00	 cmp	 BYTE PTR [rax+rcx], 0
  00138	75 eb		 jne	 SHORT $LL20@CTList
  0013a	48 8b 44 24 30	 mov	 rax, QWORD PTR tv144[rsp]
  0013f	48 ff c0	 inc	 rax
  00142	44 8b c0	 mov	 r8d, eax
  00145	48 8b 54 24 28	 mov	 rdx, QWORD PTR p$1[rsp]
  0014a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  00151	e8 00 00 00 00	 call	 ?delBuf@CMemManager@@QEAAXPEADH@Z ; CMemManager::delBuf
  00156	90		 npad	 1
  00157	eb 3c		 jmp	 SHORT $LN4@CTList
$LN11@CTList:

; 388  : 				case eAlloc_Type_newArray	:	delete[] p; break;

  00159	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  0015e	48 89 44 24 60	 mov	 QWORD PTR $T5[rsp], rax
  00163	48 8b 44 24 60	 mov	 rax, QWORD PTR $T5[rsp]
  00168	48 89 44 24 40	 mov	 QWORD PTR $T3[rsp], rax
  0016d	48 83 7c 24 40
	00		 cmp	 QWORD PTR $T3[rsp], 0
  00173	74 17		 je	 SHORT $LN18@CTList
  00175	ba 03 00 00 00	 mov	 edx, 3
  0017a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR $T3[rsp]
  0017f	e8 00 00 00 00	 call	 ??_ECComQueueThread@@QEAAPEAXI@Z
  00184	90		 npad	 1
  00185	48 89 44 24 68	 mov	 QWORD PTR tv95[rsp], rax
  0018a	eb 09		 jmp	 SHORT $LN4@CTList
$LN18@CTList:
  0018c	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR tv95[rsp], 0
$LN4@CTList:

; 389  : 				case eAlloc_Type_none		:	break;
; 390  : 				case eAlloc_Type_MemPool	:	break;
; 391  : 			}
; 392  : 			p = getNext(&idx);

  00195	48 8d 54 24 78	 lea	 rdx, QWORD PTR idx$7[rsp]
  0019a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  001a2	e8 00 00 00 00	 call	 ?getNext@?$CTList@VCComQueueThread@@@@QEAAPEAVCComQueueThread@@PEAH@Z ; CTList<CComQueueThread>::getNext
  001a7	90		 npad	 1
  001a8	48 89 44 24 28	 mov	 QWORD PTR p$1[rsp], rax

; 393  : 		}

  001ad	e9 c4 fe ff ff	 jmp	 $LN2@CTList
$LN7@CTList:

; 394  : 	}
; 395  : 
; 396  : 	if (m_pArray)	free(m_pArray);

  001b2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001ba	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  001be	74 12		 je	 SHORT $LN14@CTList
  001c0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001c8	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  001cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  001d1	90		 npad	 1
$LN14@CTList:

; 397  : 	m_pArray = 0;

  001d2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001da	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN1@CTList:

; 398  : }

  001e1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001e9	48 33 cc	 xor	 rcx, rsp
  001ec	e8 00 00 00 00	 call	 __security_check_cookie
  001f1	90		 npad	 1
  001f2	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  001f9	c3		 ret	 0
??1?$CTList@VCComQueueThread@@@@QEAA@XZ ENDP		; CTList<CComQueueThread>::~CTList<CComQueueThread>
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ??0?$CTList@VCComQueueThread@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$CTList@VCComQueueThread@@@@QEAA@XZ PROC		; CTList<CComQueueThread>::CTList<CComQueueThread>, COMDAT

; 365  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 366  : 	m_pArray = NULL;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 367  : 	m_nUse = 0;

  00011	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00016	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0

; 368  : 	m_nLast = 0;

  0001d	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00022	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [rax+12], 0

; 369  : 	m_nDelIdx = 0;

  00029	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0002e	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 370  : 	m_nMax = 0;

  00035	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0003a	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0

; 371  : 	m_nObjAllocType = eAlloc_Type_none;

  00041	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00046	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0

; 372  : }

  0004d	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00052	c3		 ret	 0
??0?$CTList@VCComQueueThread@@@@QEAA@XZ ENDP		; CTList<CComQueueThread>::CTList<CComQueueThread>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$CTList@VCComThread@@@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$CTList@VCComThread@@@@QEAAPEAXI@Z PROC		; CTList<CComThread>::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00012	e8 00 00 00 00	 call	 ??1?$CTList@VCComThread@@@@QEAA@XZ ; CTList<CComThread>::~CTList<CComThread>
  00017	8b 44 24 38	 mov	 eax, DWORD PTR __flags$[rsp]
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 0f		 je	 SHORT $LN2@scalar
  00022	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
??_G?$CTList@VCComThread@@@@QEAAPEAXI@Z ENDP		; CTList<CComThread>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit2@?$CTList@VCComThread@@@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 16
classSize$ = 24
?__autoclassinit2@?$CTList@VCComThread@@@@QEAAX_K@Z PROC ; CTList<CComThread>::__autoclassinit2, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 8b 7c 24 10	 mov	 rdi, QWORD PTR this$[rsp]
  00010	33 c0		 xor	 eax, eax
  00012	48 8b 4c 24 18	 mov	 rcx, QWORD PTR classSize$[rsp]
  00017	f3 aa		 rep stosb
  00019	5f		 pop	 rdi
  0001a	c3		 ret	 0
?__autoclassinit2@?$CTList@VCComThread@@@@QEAAX_K@Z ENDP ; CTList<CComThread>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?_DEL@?$CTList@VCComThread@@@@AEAAXH@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
?_DEL@?$CTList@VCComThread@@@@AEAAXH@Z PROC		; CTList<CComThread>::_DEL, COMDAT

; 360  : 	inline void _DEL(int i) { m_pArray[i] = 0; m_nUse--; m_nDelIdx = i; }

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 63 44 24 10	 movsxd	 rax, DWORD PTR i$[rsp]
  0000e	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  00013	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00016	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0
  0001e	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00023	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00026	ff c8		 dec	 eax
  00028	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  0002d	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  00030	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00035	8b 4c 24 10	 mov	 ecx, DWORD PTR i$[rsp]
  00039	89 48 10	 mov	 DWORD PTR [rax+16], ecx
  0003c	c3		 ret	 0
?_DEL@?$CTList@VCComThread@@@@AEAAXH@Z ENDP		; CTList<CComThread>::_DEL
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?__alloc@?$CTList@VCComThread@@@@AEAAHH@Z
_TEXT	SEGMENT
pList$ = 32
this$ = 80
nMaxCount$ = 88
?__alloc@?$CTList@VCComThread@@@@AEAAHH@Z PROC		; CTList<CComThread>::__alloc, COMDAT

; 402  : {

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 403  : 	T** pList = (T**)calloc(nMaxCount, sizeof(T*));

  0000f	48 63 44 24 58	 movsxd	 rax, DWORD PTR nMaxCount$[rsp]
  00014	ba 08 00 00 00	 mov	 edx, 8
  00019	48 8b c8	 mov	 rcx, rax
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00022	48 89 44 24 20	 mov	 QWORD PTR pList$[rsp], rax

; 404  : 	if (!pList) {

  00027	48 83 7c 24 20
	00		 cmp	 QWORD PTR pList$[rsp], 0
  0002d	75 17		 jne	 SHORT $LN2@alloc

; 405  : 		_stprintf(g_szMessage, "pList calloc is NULL");

  0002f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG47069
  00036	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  0003d	e8 00 00 00 00	 call	 sprintf

; 406  : 		return 0;

  00042	33 c0		 xor	 eax, eax
  00044	eb 49		 jmp	 SHORT $LN1@alloc
$LN2@alloc:

; 407  : 	}
; 408  : 	//_stprintf(g_szMessage, _T("CTList::__alloc list m_nMaxCount[%d]"), nMaxCount);
; 409  : 	if (m_pArray) {

  00046	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0004b	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0004f	74 2d		 je	 SHORT $LN3@alloc

; 410  : 		memcpy(pList, m_pArray, m_nMax * sizeof(T*));

  00051	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00056	48 63 40 14	 movsxd	 rax, DWORD PTR [rax+20]
  0005a	48 c1 e0 03	 shl	 rax, 3
  0005e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00063	48 8b 7c 24 20	 mov	 rdi, QWORD PTR pList$[rsp]
  00068	48 8b 31	 mov	 rsi, QWORD PTR [rcx]
  0006b	48 8b c8	 mov	 rcx, rax
  0006e	f3 a4		 rep movsb

; 411  : 		free(m_pArray);

  00070	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00075	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN3@alloc:

; 412  : 	}
; 413  : 	m_pArray = pList;

  0007e	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00083	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pList$[rsp]
  00088	48 89 08	 mov	 QWORD PTR [rax], rcx

; 414  : 	return nMaxCount;

  0008b	8b 44 24 58	 mov	 eax, DWORD PTR nMaxCount$[rsp]
$LN1@alloc:

; 415  : }

  0008f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00093	5f		 pop	 rdi
  00094	5e		 pop	 rsi
  00095	c3		 ret	 0
?__alloc@?$CTList@VCComThread@@@@AEAAHH@Z ENDP		; CTList<CComThread>::__alloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?setObjAllocType@?$CTList@VCComThread@@@@QEAAXW4E_ALLOC_TYPE@@@Z
_TEXT	SEGMENT
this$ = 8
type$ = 16
?setObjAllocType@?$CTList@VCComThread@@@@QEAAXW4E_ALLOC_TYPE@@@Z PROC ; CTList<CComThread>::setObjAllocType, COMDAT

; 350  : 	inline void setObjAllocType(E_ALLOC_TYPE type) { m_nObjAllocType = type; }

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR type$[rsp]
  00012	89 48 18	 mov	 DWORD PTR [rax+24], ecx
  00015	c3		 ret	 0
?setObjAllocType@?$CTList@VCComThread@@@@QEAAXW4E_ALLOC_TYPE@@@Z ENDP ; CTList<CComThread>::setObjAllocType
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?lastIdx@?$CTList@VCComThread@@@@QEAAHXZ
_TEXT	SEGMENT
this$ = 8
?lastIdx@?$CTList@VCComThread@@@@QEAAHXZ PROC		; CTList<CComThread>::lastIdx, COMDAT

; 348  : 	inline int  lastIdx() { return m_nLast; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  0000d	c3		 ret	 0
?lastIdx@?$CTList@VCComThread@@@@QEAAHXZ ENDP		; CTList<CComThread>::lastIdx
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?size@?$CTList@VCComThread@@@@QEAAHXZ
_TEXT	SEGMENT
this$ = 8
?size@?$CTList@VCComThread@@@@QEAAHXZ PROC		; CTList<CComThread>::size, COMDAT

; 347  : 	inline int  size() { return m_nUse; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0000d	c3		 ret	 0
?size@?$CTList@VCComThread@@@@QEAAHXZ ENDP		; CTList<CComThread>::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?getNext@?$CTList@VCComThread@@@@QEAAPEAVCComThread@@PEAH@Z
_TEXT	SEGMENT
this$ = 8
pIdx$ = 16
?getNext@?$CTList@VCComThread@@@@QEAAPEAVCComThread@@PEAH@Z PROC ; CTList<CComThread>::getNext, COMDAT

; 334  : 	inline T* getNext(int *pIdx) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 335  : 		for (*pIdx; *pIdx < m_nMax; (*pIdx)++) {

  0000a	eb 10		 jmp	 SHORT $LN4@getNext
$LN2@getNext:
  0000c	48 8b 44 24 10	 mov	 rax, QWORD PTR pIdx$[rsp]
  00011	8b 00		 mov	 eax, DWORD PTR [rax]
  00013	ff c0		 inc	 eax
  00015	48 8b 4c 24 10	 mov	 rcx, QWORD PTR pIdx$[rsp]
  0001a	89 01		 mov	 DWORD PTR [rcx], eax
$LN4@getNext:
  0001c	48 8b 44 24 10	 mov	 rax, QWORD PTR pIdx$[rsp]
  00021	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  00026	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  00029	39 08		 cmp	 DWORD PTR [rax], ecx
  0002b	7d 2f		 jge	 SHORT $LN3@getNext

; 336  : 			if (m_pArray[*pIdx]) { return m_pArray[*pIdx]; }

  0002d	48 8b 44 24 10	 mov	 rax, QWORD PTR pIdx$[rsp]
  00032	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  00035	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  0003a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0003d	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00042	74 16		 je	 SHORT $LN5@getNext
  00044	48 8b 44 24 10	 mov	 rax, QWORD PTR pIdx$[rsp]
  00049	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  0004c	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  00051	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00054	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00058	eb 04		 jmp	 SHORT $LN1@getNext
$LN5@getNext:

; 337  : 		}

  0005a	eb b0		 jmp	 SHORT $LN2@getNext
$LN3@getNext:

; 338  : 		return NULL;

  0005c	33 c0		 xor	 eax, eax
$LN1@getNext:

; 339  : 	}

  0005e	c3		 ret	 0
?getNext@?$CTList@VCComThread@@@@QEAAPEAVCComThread@@PEAH@Z ENDP ; CTList<CComThread>::getNext
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?getObj@?$CTList@VCComThread@@@@QEAAPEAVCComThread@@H@Z
_TEXT	SEGMENT
this$ = 48
i$ = 56
?getObj@?$CTList@VCComThread@@@@QEAAPEAVCComThread@@H@Z PROC ; CTList<CComThread>::getObj, COMDAT

; 332  : 	inline T* getObj(int i) { if (ISINCLUDE(i, m_nMax)) return m_pArray[i]; return NULL; }

$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00012	8b 50 14	 mov	 edx, DWORD PTR [rax+20]
  00015	8b 4c 24 38	 mov	 ecx, DWORD PTR i$[rsp]
  00019	e8 00 00 00 00	 call	 ?ISINCLUDE@@YA_NHH@Z	; ISINCLUDE
  0001e	0f b6 c0	 movzx	 eax, al
  00021	85 c0		 test	 eax, eax
  00023	74 13		 je	 SHORT $LN2@getObj
  00025	48 63 44 24 38	 movsxd	 rax, DWORD PTR i$[rsp]
  0002a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00032	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00036	eb 02		 jmp	 SHORT $LN1@getObj
$LN2@getObj:
  00038	33 c0		 xor	 eax, eax
$LN1@getObj:
  0003a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003e	c3		 ret	 0
?getObj@?$CTList@VCComThread@@@@QEAAPEAVCComThread@@H@Z ENDP ; CTList<CComThread>::getObj
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?del@?$CTList@VCComThread@@@@QEAA_NH@Z
_TEXT	SEGMENT
this$ = 48
i$ = 56
?del@?$CTList@VCComThread@@@@QEAA_NH@Z PROC		; CTList<CComThread>::del, COMDAT

; 523  : {

$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 524  : 	if (!ISINCLUDE(i, m_nMax)) {

  0000d	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00012	8b 50 14	 mov	 edx, DWORD PTR [rax+20]
  00015	8b 4c 24 38	 mov	 ecx, DWORD PTR i$[rsp]
  00019	e8 00 00 00 00	 call	 ?ISINCLUDE@@YA_NHH@Z	; ISINCLUDE
  0001e	0f b6 c0	 movzx	 eax, al
  00021	85 c0		 test	 eax, eax
  00023	75 25		 jne	 SHORT $LN2@del

; 525  : 		_stprintf(g_szMessage, "i[%d] m_nMax[%d]", i, m_nMax);

  00025	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0002a	44 8b 48 14	 mov	 r9d, DWORD PTR [rax+20]
  0002e	44 8b 44 24 38	 mov	 r8d, DWORD PTR i$[rsp]
  00033	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG47058
  0003a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  00041	e8 00 00 00 00	 call	 sprintf

; 526  : 		return false;

  00046	32 c0		 xor	 al, al
  00048	eb 10		 jmp	 SHORT $LN1@del
$LN2@del:

; 527  : 	}
; 528  : 	_DEL(i);

  0004a	8b 54 24 38	 mov	 edx, DWORD PTR i$[rsp]
  0004e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00053	e8 00 00 00 00	 call	 ?_DEL@?$CTList@VCComThread@@@@AEAAXH@Z ; CTList<CComThread>::_DEL

; 529  : 	//_stprintf(g_szMessage, _T("CMemList::del i[%d] m_nLast[%d] m_nCurCount[%d]"), i, m_nLast, m_nUse);
; 530  : 	return true;

  00058	b0 01		 mov	 al, 1
$LN1@del:

; 531  : }

  0005a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005e	c3		 ret	 0
?del@?$CTList@VCComThread@@@@QEAA_NH@Z ENDP		; CTList<CComThread>::del
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?push_back@?$CTList@VCComThread@@@@QEAA_NPEAVCComThread@@PEAH@Z
_TEXT	SEGMENT
nIdx$ = 32
i$ = 36
this$ = 64
Obj$ = 72
pIdx$ = 80
?push_back@?$CTList@VCComThread@@@@QEAA_NPEAVCComThread@@PEAH@Z PROC ; CTList<CComThread>::push_back, COMDAT

; 472  : {

$LN15:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 473  : 	int nIdx, i;
; 474  : 
; 475  : 	if (m_nUse >= m_nMax) {

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00018	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0001d	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  00020	39 48 08	 cmp	 DWORD PTR [rax+8], ecx
  00023	7c 4b		 jl	 SHORT $LN5@push_back

; 476  : 		if (!__alloc(m_nMax + TLIST_ADD_SIZE)) return false;

  00025	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0002a	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0002d	83 c0 40	 add	 eax, 64			; 00000040H
  00030	8b d0		 mov	 edx, eax
  00032	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00037	e8 00 00 00 00	 call	 ?__alloc@?$CTList@VCComThread@@@@AEAAHH@Z ; CTList<CComThread>::__alloc
  0003c	85 c0		 test	 eax, eax
  0003e	75 07		 jne	 SHORT $LN6@push_back
  00040	32 c0		 xor	 al, al
  00042	e9 0c 01 00 00	 jmp	 $LN1@push_back
$LN6@push_back:

; 477  : 		nIdx = m_nMax;

  00047	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0004c	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0004f	89 44 24 20	 mov	 DWORD PTR nIdx$[rsp], eax

; 478  : 		m_nMax += TLIST_ADD_SIZE;

  00053	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00058	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0005b	83 c0 40	 add	 eax, 64			; 00000040H
  0005e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00063	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 479  : 		goto ADD_SUCCESS;

  00066	e9 99 00 00 00	 jmp	 $LN7@push_back
  0006b	e9 94 00 00 00	 jmp	 $ADD_SUCCESS$16
$LN5@push_back:

; 480  : 	}
; 481  : 
; 482  : 	if (!m_pArray[m_nLast]) { nIdx = m_nLast;  goto ADD_SUCCESS; }

  00070	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00075	48 63 40 0c	 movsxd	 rax, DWORD PTR [rax+12]
  00079	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0007e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00081	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00086	75 10		 jne	 SHORT $LN8@push_back
  00088	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0008d	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00090	89 44 24 20	 mov	 DWORD PTR nIdx$[rsp], eax
  00094	eb 6e		 jmp	 SHORT $LN9@push_back
  00096	eb 6c		 jmp	 SHORT $ADD_SUCCESS$16
$LN8@push_back:

; 483  : 
; 484  : 	nIdx = m_nLast;

  00098	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0009d	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  000a0	89 44 24 20	 mov	 DWORD PTR nIdx$[rsp], eax

; 485  : 	for (i = 0; i < m_nMax; i++)

  000a4	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000ac	eb 0a		 jmp	 SHORT $LN4@push_back
$LN2@push_back:
  000ae	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  000b2	ff c0		 inc	 eax
  000b4	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@push_back:
  000b8	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000bd	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000c0	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  000c4	7d 3a		 jge	 SHORT $LN3@push_back

; 486  : 	{
; 487  : 		if (nIdx >= m_nMax) nIdx = 0;

  000c6	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000cb	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000ce	39 44 24 20	 cmp	 DWORD PTR nIdx$[rsp], eax
  000d2	7c 08		 jl	 SHORT $LN10@push_back
  000d4	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR nIdx$[rsp], 0
$LN10@push_back:

; 488  : 		if (!m_pArray[nIdx]) {

  000dc	48 63 44 24 20	 movsxd	 rax, DWORD PTR nIdx$[rsp]
  000e1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000e6	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000e9	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  000ee	75 04		 jne	 SHORT $LN11@push_back

; 489  : 			goto ADD_SUCCESS;

  000f0	eb 12		 jmp	 SHORT $LN12@push_back
  000f2	eb 10		 jmp	 SHORT $ADD_SUCCESS$16
$LN11@push_back:

; 490  : 		}
; 491  : 		nIdx++;

  000f4	8b 44 24 20	 mov	 eax, DWORD PTR nIdx$[rsp]
  000f8	ff c0		 inc	 eax
  000fa	89 44 24 20	 mov	 DWORD PTR nIdx$[rsp], eax

; 492  : 	}

  000fe	eb ae		 jmp	 SHORT $LN2@push_back
$LN3@push_back:

; 493  : 	//_stprintf(m_szMessage, _T("add FAIL! m_nLast[%d] m_nCurCount[%d] m_nMax[%d]"), m_nLast, m_nUse, m_nMax);
; 494  : 	return false;

  00100	32 c0		 xor	 al, al
  00102	eb 4f		 jmp	 SHORT $LN1@push_back
$LN7@push_back:
$LN9@push_back:
$LN12@push_back:
$ADD_SUCCESS$16:

; 495  : 
; 496  : ADD_SUCCESS:
; 497  : 	m_nUse++;

  00104	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00109	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0010c	ff c0		 inc	 eax
  0010e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00113	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 498  : 	m_pArray[nIdx] = Obj;

  00116	48 63 44 24 20	 movsxd	 rax, DWORD PTR nIdx$[rsp]
  0011b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00120	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00123	48 8b 54 24 48	 mov	 rdx, QWORD PTR Obj$[rsp]
  00128	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx

; 499  : 	m_nLast++;

  0012c	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00131	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00134	ff c0		 inc	 eax
  00136	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0013b	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 500  : 	//_stprintf(g_szMessage, _T("CMemList::add i[%d] m_nLast[%d] m_nCurCount[%d]"), nIdx, m_nLast, m_nUse);
; 501  : 	if (pIdx) *pIdx = nIdx;

  0013e	48 83 7c 24 50
	00		 cmp	 QWORD PTR pIdx$[rsp], 0
  00144	74 0b		 je	 SHORT $LN13@push_back
  00146	48 8b 44 24 50	 mov	 rax, QWORD PTR pIdx$[rsp]
  0014b	8b 4c 24 20	 mov	 ecx, DWORD PTR nIdx$[rsp]
  0014f	89 08		 mov	 DWORD PTR [rax], ecx
$LN13@push_back:

; 502  : 	return true;

  00151	b0 01		 mov	 al, 1
$LN1@push_back:

; 503  : }

  00153	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00157	c3		 ret	 0
?push_back@?$CTList@VCComThread@@@@QEAA_NPEAVCComThread@@PEAH@Z ENDP ; CTList<CComThread>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?alloc@?$CTList@VCComThread@@@@QEAAHHW4E_ALLOC_TYPE@@@Z
_TEXT	SEGMENT
this$ = 48
nMaxCount$ = 56
type$ = 64
?alloc@?$CTList@VCComThread@@@@QEAAHHW4E_ALLOC_TYPE@@@Z PROC ; CTList<CComThread>::alloc, COMDAT

; 326  : 	int alloc(int nMaxCount, E_ALLOC_TYPE type = eAlloc_Type_new) { m_nObjAllocType = type;  m_nMax = __alloc(nMaxCount); return m_nMax; }

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00012	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00017	8b 4c 24 40	 mov	 ecx, DWORD PTR type$[rsp]
  0001b	89 48 18	 mov	 DWORD PTR [rax+24], ecx
  0001e	8b 54 24 38	 mov	 edx, DWORD PTR nMaxCount$[rsp]
  00022	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00027	e8 00 00 00 00	 call	 ?__alloc@?$CTList@VCComThread@@@@AEAAHH@Z ; CTList<CComThread>::__alloc
  0002c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00031	89 41 14	 mov	 DWORD PTR [rcx+20], eax
  00034	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00039	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0003c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00040	c3		 ret	 0
?alloc@?$CTList@VCComThread@@@@QEAAHHW4E_ALLOC_TYPE@@@Z ENDP ; CTList<CComThread>::alloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ??1?$CTList@VCComThread@@@@QEAA@XZ
_TEXT	SEGMENT
tv77 = 32
p$1 = 40
tv144 = 48
$T2 = 56
$T3 = 64
$T4 = 72
tv82 = 80
tv143 = 88
$T5 = 96
tv95 = 104
$T6 = 112
idx$7 = 120
__$ArrayPad$ = 128
this$ = 160
??1?$CTList@VCComThread@@@@QEAA@XZ PROC			; CTList<CComThread>::~CTList<CComThread>, COMDAT

; 376  : {

$LN21:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  0000c	48 c7 44 24 70
	fe ff ff ff	 mov	 QWORD PTR $T6[rsp], -2
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 377  : 	if (!m_pArray) return;

  00027	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0002f	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00033	75 05		 jne	 SHORT $LN6@CTList
  00035	e9 a7 01 00 00	 jmp	 $LN1@CTList
$LN6@CTList:

; 378  : 
; 379  : 	if (ISABLETODELETE(m_nObjAllocType)) {

  0003a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00042	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00045	e8 00 00 00 00	 call	 ?ISABLETODELETE@@YA_NW4E_ALLOC_TYPE@@@Z ; ISABLETODELETE
  0004a	90		 npad	 1
  0004b	0f b6 c0	 movzx	 eax, al
  0004e	85 c0		 test	 eax, eax
  00050	0f 84 5c 01 00
	00		 je	 $LN7@CTList

; 380  : 		int idx = 0;

  00056	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR idx$7[rsp], 0

; 381  : 		T *p = getNext(&idx);

  0005e	48 8d 54 24 78	 lea	 rdx, QWORD PTR idx$7[rsp]
  00063	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0006b	e8 00 00 00 00	 call	 ?getNext@?$CTList@VCComThread@@@@QEAAPEAVCComThread@@PEAH@Z ; CTList<CComThread>::getNext
  00070	90		 npad	 1
  00071	48 89 44 24 28	 mov	 QWORD PTR p$1[rsp], rax
$LN2@CTList:

; 382  : 		while (p) {

  00076	48 83 7c 24 28
	00		 cmp	 QWORD PTR p$1[rsp], 0
  0007c	0f 84 30 01 00
	00		 je	 $LN7@CTList

; 383  : 			idx++;

  00082	8b 44 24 78	 mov	 eax, DWORD PTR idx$7[rsp]
  00086	ff c0		 inc	 eax
  00088	89 44 24 78	 mov	 DWORD PTR idx$7[rsp], eax

; 384  : 			switch (m_nObjAllocType) {

  0008c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00094	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00097	89 44 24 20	 mov	 DWORD PTR tv77[rsp], eax
  0009b	83 7c 24 20 02	 cmp	 DWORD PTR tv77[rsp], 2
  000a0	74 1e		 je	 SHORT $LN8@CTList
  000a2	83 7c 24 20 03	 cmp	 DWORD PTR tv77[rsp], 3
  000a7	74 58		 je	 SHORT $LN9@CTList
  000a9	83 7c 24 20 04	 cmp	 DWORD PTR tv77[rsp], 4
  000ae	74 62		 je	 SHORT $LN10@CTList
  000b0	83 7c 24 20 05	 cmp	 DWORD PTR tv77[rsp], 5
  000b5	0f 84 9e 00 00
	00		 je	 $LN11@CTList
  000bb	e9 d5 00 00 00	 jmp	 $LN4@CTList
$LN8@CTList:

; 385  : 				case eAlloc_Type_new		:	delete p; break;

  000c0	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  000c5	48 89 44 24 48	 mov	 QWORD PTR $T4[rsp], rax
  000ca	48 8b 44 24 48	 mov	 rax, QWORD PTR $T4[rsp]
  000cf	48 89 44 24 38	 mov	 QWORD PTR $T2[rsp], rax
  000d4	48 83 7c 24 38
	00		 cmp	 QWORD PTR $T2[rsp], 0
  000da	74 17		 je	 SHORT $LN16@CTList
  000dc	ba 01 00 00 00	 mov	 edx, 1
  000e1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR $T2[rsp]
  000e6	e8 00 00 00 00	 call	 ??_GCComThread@@QEAAPEAXI@Z
  000eb	90		 npad	 1
  000ec	48 89 44 24 50	 mov	 QWORD PTR tv82[rsp], rax
  000f1	eb 09		 jmp	 SHORT $LN17@CTList
$LN16@CTList:
  000f3	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR tv82[rsp], 0
$LN17@CTList:
  000fc	e9 94 00 00 00	 jmp	 $LN4@CTList
$LN9@CTList:

; 386  : 				case eAlloc_Type_alloc		:	free(p); break;

  00101	48 8b 4c 24 28	 mov	 rcx, QWORD PTR p$1[rsp]
  00106	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  0010c	90		 npad	 1
  0010d	e9 83 00 00 00	 jmp	 $LN4@CTList
$LN10@CTList:

; 387  : 				case eAlloc_Type_BufPool	:	gs_pMMgr->delBuf((char *)p, STRING_SIZE((TCHAR *)p)); break;

  00112	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  00117	48 89 44 24 58	 mov	 QWORD PTR tv143[rsp], rax
  0011c	48 c7 44 24 30
	ff ff ff ff	 mov	 QWORD PTR tv144[rsp], -1
$LL20@CTList:
  00125	48 ff 44 24 30	 inc	 QWORD PTR tv144[rsp]
  0012a	48 8b 44 24 58	 mov	 rax, QWORD PTR tv143[rsp]
  0012f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv144[rsp]
  00134	80 3c 08 00	 cmp	 BYTE PTR [rax+rcx], 0
  00138	75 eb		 jne	 SHORT $LL20@CTList
  0013a	48 8b 44 24 30	 mov	 rax, QWORD PTR tv144[rsp]
  0013f	48 ff c0	 inc	 rax
  00142	44 8b c0	 mov	 r8d, eax
  00145	48 8b 54 24 28	 mov	 rdx, QWORD PTR p$1[rsp]
  0014a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  00151	e8 00 00 00 00	 call	 ?delBuf@CMemManager@@QEAAXPEADH@Z ; CMemManager::delBuf
  00156	90		 npad	 1
  00157	eb 3c		 jmp	 SHORT $LN4@CTList
$LN11@CTList:

; 388  : 				case eAlloc_Type_newArray	:	delete[] p; break;

  00159	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  0015e	48 89 44 24 60	 mov	 QWORD PTR $T5[rsp], rax
  00163	48 8b 44 24 60	 mov	 rax, QWORD PTR $T5[rsp]
  00168	48 89 44 24 40	 mov	 QWORD PTR $T3[rsp], rax
  0016d	48 83 7c 24 40
	00		 cmp	 QWORD PTR $T3[rsp], 0
  00173	74 17		 je	 SHORT $LN18@CTList
  00175	ba 03 00 00 00	 mov	 edx, 3
  0017a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR $T3[rsp]
  0017f	e8 00 00 00 00	 call	 ??_ECComThread@@QEAAPEAXI@Z
  00184	90		 npad	 1
  00185	48 89 44 24 68	 mov	 QWORD PTR tv95[rsp], rax
  0018a	eb 09		 jmp	 SHORT $LN4@CTList
$LN18@CTList:
  0018c	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR tv95[rsp], 0
$LN4@CTList:

; 389  : 				case eAlloc_Type_none		:	break;
; 390  : 				case eAlloc_Type_MemPool	:	break;
; 391  : 			}
; 392  : 			p = getNext(&idx);

  00195	48 8d 54 24 78	 lea	 rdx, QWORD PTR idx$7[rsp]
  0019a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  001a2	e8 00 00 00 00	 call	 ?getNext@?$CTList@VCComThread@@@@QEAAPEAVCComThread@@PEAH@Z ; CTList<CComThread>::getNext
  001a7	90		 npad	 1
  001a8	48 89 44 24 28	 mov	 QWORD PTR p$1[rsp], rax

; 393  : 		}

  001ad	e9 c4 fe ff ff	 jmp	 $LN2@CTList
$LN7@CTList:

; 394  : 	}
; 395  : 
; 396  : 	if (m_pArray)	free(m_pArray);

  001b2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001ba	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  001be	74 12		 je	 SHORT $LN14@CTList
  001c0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001c8	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  001cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  001d1	90		 npad	 1
$LN14@CTList:

; 397  : 	m_pArray = 0;

  001d2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001da	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN1@CTList:

; 398  : }

  001e1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001e9	48 33 cc	 xor	 rcx, rsp
  001ec	e8 00 00 00 00	 call	 __security_check_cookie
  001f1	90		 npad	 1
  001f2	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  001f9	c3		 ret	 0
??1?$CTList@VCComThread@@@@QEAA@XZ ENDP			; CTList<CComThread>::~CTList<CComThread>
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ??0?$CTList@VCComThread@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$CTList@VCComThread@@@@QEAA@XZ PROC			; CTList<CComThread>::CTList<CComThread>, COMDAT

; 365  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 366  : 	m_pArray = NULL;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 367  : 	m_nUse = 0;

  00011	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00016	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0

; 368  : 	m_nLast = 0;

  0001d	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00022	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [rax+12], 0

; 369  : 	m_nDelIdx = 0;

  00029	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0002e	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 370  : 	m_nMax = 0;

  00035	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0003a	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0

; 371  : 	m_nObjAllocType = eAlloc_Type_none;

  00041	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00046	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0

; 372  : }

  0004d	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00052	c3		 ret	 0
??0?$CTList@VCComThread@@@@QEAA@XZ ENDP			; CTList<CComThread>::CTList<CComThread>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$CTList@VCScheduler@@@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$CTList@VCScheduler@@@@QEAAPEAXI@Z PROC		; CTList<CScheduler>::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00012	e8 00 00 00 00	 call	 ??1?$CTList@VCScheduler@@@@QEAA@XZ ; CTList<CScheduler>::~CTList<CScheduler>
  00017	8b 44 24 38	 mov	 eax, DWORD PTR __flags$[rsp]
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 0f		 je	 SHORT $LN2@scalar
  00022	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
??_G?$CTList@VCScheduler@@@@QEAAPEAXI@Z ENDP		; CTList<CScheduler>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit2@?$CTList@VCScheduler@@@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 16
classSize$ = 24
?__autoclassinit2@?$CTList@VCScheduler@@@@QEAAX_K@Z PROC ; CTList<CScheduler>::__autoclassinit2, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 8b 7c 24 10	 mov	 rdi, QWORD PTR this$[rsp]
  00010	33 c0		 xor	 eax, eax
  00012	48 8b 4c 24 18	 mov	 rcx, QWORD PTR classSize$[rsp]
  00017	f3 aa		 rep stosb
  00019	5f		 pop	 rdi
  0001a	c3		 ret	 0
?__autoclassinit2@?$CTList@VCScheduler@@@@QEAAX_K@Z ENDP ; CTList<CScheduler>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?_DEL@?$CTList@VCScheduler@@@@AEAAXH@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
?_DEL@?$CTList@VCScheduler@@@@AEAAXH@Z PROC		; CTList<CScheduler>::_DEL, COMDAT

; 360  : 	inline void _DEL(int i) { m_pArray[i] = 0; m_nUse--; m_nDelIdx = i; }

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 63 44 24 10	 movsxd	 rax, DWORD PTR i$[rsp]
  0000e	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  00013	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00016	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0
  0001e	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00023	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00026	ff c8		 dec	 eax
  00028	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  0002d	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  00030	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00035	8b 4c 24 10	 mov	 ecx, DWORD PTR i$[rsp]
  00039	89 48 10	 mov	 DWORD PTR [rax+16], ecx
  0003c	c3		 ret	 0
?_DEL@?$CTList@VCScheduler@@@@AEAAXH@Z ENDP		; CTList<CScheduler>::_DEL
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?__alloc@?$CTList@VCScheduler@@@@AEAAHH@Z
_TEXT	SEGMENT
pList$ = 32
this$ = 80
nMaxCount$ = 88
?__alloc@?$CTList@VCScheduler@@@@AEAAHH@Z PROC		; CTList<CScheduler>::__alloc, COMDAT

; 402  : {

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 403  : 	T** pList = (T**)calloc(nMaxCount, sizeof(T*));

  0000f	48 63 44 24 58	 movsxd	 rax, DWORD PTR nMaxCount$[rsp]
  00014	ba 08 00 00 00	 mov	 edx, 8
  00019	48 8b c8	 mov	 rcx, rax
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00022	48 89 44 24 20	 mov	 QWORD PTR pList$[rsp], rax

; 404  : 	if (!pList) {

  00027	48 83 7c 24 20
	00		 cmp	 QWORD PTR pList$[rsp], 0
  0002d	75 17		 jne	 SHORT $LN2@alloc

; 405  : 		_stprintf(g_szMessage, "pList calloc is NULL");

  0002f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46998
  00036	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  0003d	e8 00 00 00 00	 call	 sprintf

; 406  : 		return 0;

  00042	33 c0		 xor	 eax, eax
  00044	eb 49		 jmp	 SHORT $LN1@alloc
$LN2@alloc:

; 407  : 	}
; 408  : 	//_stprintf(g_szMessage, _T("CTList::__alloc list m_nMaxCount[%d]"), nMaxCount);
; 409  : 	if (m_pArray) {

  00046	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0004b	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0004f	74 2d		 je	 SHORT $LN3@alloc

; 410  : 		memcpy(pList, m_pArray, m_nMax * sizeof(T*));

  00051	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00056	48 63 40 14	 movsxd	 rax, DWORD PTR [rax+20]
  0005a	48 c1 e0 03	 shl	 rax, 3
  0005e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00063	48 8b 7c 24 20	 mov	 rdi, QWORD PTR pList$[rsp]
  00068	48 8b 31	 mov	 rsi, QWORD PTR [rcx]
  0006b	48 8b c8	 mov	 rcx, rax
  0006e	f3 a4		 rep movsb

; 411  : 		free(m_pArray);

  00070	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00075	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN3@alloc:

; 412  : 	}
; 413  : 	m_pArray = pList;

  0007e	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00083	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pList$[rsp]
  00088	48 89 08	 mov	 QWORD PTR [rax], rcx

; 414  : 	return nMaxCount;

  0008b	8b 44 24 58	 mov	 eax, DWORD PTR nMaxCount$[rsp]
$LN1@alloc:

; 415  : }

  0008f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00093	5f		 pop	 rdi
  00094	5e		 pop	 rsi
  00095	c3		 ret	 0
?__alloc@?$CTList@VCScheduler@@@@AEAAHH@Z ENDP		; CTList<CScheduler>::__alloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?setObjAllocType@?$CTList@VCScheduler@@@@QEAAXW4E_ALLOC_TYPE@@@Z
_TEXT	SEGMENT
this$ = 8
type$ = 16
?setObjAllocType@?$CTList@VCScheduler@@@@QEAAXW4E_ALLOC_TYPE@@@Z PROC ; CTList<CScheduler>::setObjAllocType, COMDAT

; 350  : 	inline void setObjAllocType(E_ALLOC_TYPE type) { m_nObjAllocType = type; }

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR type$[rsp]
  00012	89 48 18	 mov	 DWORD PTR [rax+24], ecx
  00015	c3		 ret	 0
?setObjAllocType@?$CTList@VCScheduler@@@@QEAAXW4E_ALLOC_TYPE@@@Z ENDP ; CTList<CScheduler>::setObjAllocType
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?size@?$CTList@VCScheduler@@@@QEAAHXZ
_TEXT	SEGMENT
this$ = 8
?size@?$CTList@VCScheduler@@@@QEAAHXZ PROC		; CTList<CScheduler>::size, COMDAT

; 347  : 	inline int  size() { return m_nUse; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0000d	c3		 ret	 0
?size@?$CTList@VCScheduler@@@@QEAAHXZ ENDP		; CTList<CScheduler>::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?getNext@?$CTList@VCScheduler@@@@QEAAPEAVCScheduler@@PEAH@Z
_TEXT	SEGMENT
this$ = 8
pIdx$ = 16
?getNext@?$CTList@VCScheduler@@@@QEAAPEAVCScheduler@@PEAH@Z PROC ; CTList<CScheduler>::getNext, COMDAT

; 334  : 	inline T* getNext(int *pIdx) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 335  : 		for (*pIdx; *pIdx < m_nMax; (*pIdx)++) {

  0000a	eb 10		 jmp	 SHORT $LN4@getNext
$LN2@getNext:
  0000c	48 8b 44 24 10	 mov	 rax, QWORD PTR pIdx$[rsp]
  00011	8b 00		 mov	 eax, DWORD PTR [rax]
  00013	ff c0		 inc	 eax
  00015	48 8b 4c 24 10	 mov	 rcx, QWORD PTR pIdx$[rsp]
  0001a	89 01		 mov	 DWORD PTR [rcx], eax
$LN4@getNext:
  0001c	48 8b 44 24 10	 mov	 rax, QWORD PTR pIdx$[rsp]
  00021	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  00026	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  00029	39 08		 cmp	 DWORD PTR [rax], ecx
  0002b	7d 2f		 jge	 SHORT $LN3@getNext

; 336  : 			if (m_pArray[*pIdx]) { return m_pArray[*pIdx]; }

  0002d	48 8b 44 24 10	 mov	 rax, QWORD PTR pIdx$[rsp]
  00032	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  00035	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  0003a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0003d	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00042	74 16		 je	 SHORT $LN5@getNext
  00044	48 8b 44 24 10	 mov	 rax, QWORD PTR pIdx$[rsp]
  00049	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  0004c	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  00051	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00054	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00058	eb 04		 jmp	 SHORT $LN1@getNext
$LN5@getNext:

; 337  : 		}

  0005a	eb b0		 jmp	 SHORT $LN2@getNext
$LN3@getNext:

; 338  : 		return NULL;

  0005c	33 c0		 xor	 eax, eax
$LN1@getNext:

; 339  : 	}

  0005e	c3		 ret	 0
?getNext@?$CTList@VCScheduler@@@@QEAAPEAVCScheduler@@PEAH@Z ENDP ; CTList<CScheduler>::getNext
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?getObj@?$CTList@VCScheduler@@@@QEAAPEAVCScheduler@@H@Z
_TEXT	SEGMENT
this$ = 48
i$ = 56
?getObj@?$CTList@VCScheduler@@@@QEAAPEAVCScheduler@@H@Z PROC ; CTList<CScheduler>::getObj, COMDAT

; 332  : 	inline T* getObj(int i) { if (ISINCLUDE(i, m_nMax)) return m_pArray[i]; return NULL; }

$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00012	8b 50 14	 mov	 edx, DWORD PTR [rax+20]
  00015	8b 4c 24 38	 mov	 ecx, DWORD PTR i$[rsp]
  00019	e8 00 00 00 00	 call	 ?ISINCLUDE@@YA_NHH@Z	; ISINCLUDE
  0001e	0f b6 c0	 movzx	 eax, al
  00021	85 c0		 test	 eax, eax
  00023	74 13		 je	 SHORT $LN2@getObj
  00025	48 63 44 24 38	 movsxd	 rax, DWORD PTR i$[rsp]
  0002a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00032	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00036	eb 02		 jmp	 SHORT $LN1@getObj
$LN2@getObj:
  00038	33 c0		 xor	 eax, eax
$LN1@getObj:
  0003a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003e	c3		 ret	 0
?getObj@?$CTList@VCScheduler@@@@QEAAPEAVCScheduler@@H@Z ENDP ; CTList<CScheduler>::getObj
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?del@?$CTList@VCScheduler@@@@QEAA_NH@Z
_TEXT	SEGMENT
this$ = 48
i$ = 56
?del@?$CTList@VCScheduler@@@@QEAA_NH@Z PROC		; CTList<CScheduler>::del, COMDAT

; 523  : {

$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 524  : 	if (!ISINCLUDE(i, m_nMax)) {

  0000d	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00012	8b 50 14	 mov	 edx, DWORD PTR [rax+20]
  00015	8b 4c 24 38	 mov	 ecx, DWORD PTR i$[rsp]
  00019	e8 00 00 00 00	 call	 ?ISINCLUDE@@YA_NHH@Z	; ISINCLUDE
  0001e	0f b6 c0	 movzx	 eax, al
  00021	85 c0		 test	 eax, eax
  00023	75 25		 jne	 SHORT $LN2@del

; 525  : 		_stprintf(g_szMessage, "i[%d] m_nMax[%d]", i, m_nMax);

  00025	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0002a	44 8b 48 14	 mov	 r9d, DWORD PTR [rax+20]
  0002e	44 8b 44 24 38	 mov	 r8d, DWORD PTR i$[rsp]
  00033	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46987
  0003a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  00041	e8 00 00 00 00	 call	 sprintf

; 526  : 		return false;

  00046	32 c0		 xor	 al, al
  00048	eb 10		 jmp	 SHORT $LN1@del
$LN2@del:

; 527  : 	}
; 528  : 	_DEL(i);

  0004a	8b 54 24 38	 mov	 edx, DWORD PTR i$[rsp]
  0004e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00053	e8 00 00 00 00	 call	 ?_DEL@?$CTList@VCScheduler@@@@AEAAXH@Z ; CTList<CScheduler>::_DEL

; 529  : 	//_stprintf(g_szMessage, _T("CMemList::del i[%d] m_nLast[%d] m_nCurCount[%d]"), i, m_nLast, m_nUse);
; 530  : 	return true;

  00058	b0 01		 mov	 al, 1
$LN1@del:

; 531  : }

  0005a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005e	c3		 ret	 0
?del@?$CTList@VCScheduler@@@@QEAA_NH@Z ENDP		; CTList<CScheduler>::del
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?push_back@?$CTList@VCScheduler@@@@QEAA_NPEAVCScheduler@@PEAH@Z
_TEXT	SEGMENT
nIdx$ = 32
i$ = 36
this$ = 64
Obj$ = 72
pIdx$ = 80
?push_back@?$CTList@VCScheduler@@@@QEAA_NPEAVCScheduler@@PEAH@Z PROC ; CTList<CScheduler>::push_back, COMDAT

; 472  : {

$LN15:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 473  : 	int nIdx, i;
; 474  : 
; 475  : 	if (m_nUse >= m_nMax) {

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00018	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0001d	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  00020	39 48 08	 cmp	 DWORD PTR [rax+8], ecx
  00023	7c 4b		 jl	 SHORT $LN5@push_back

; 476  : 		if (!__alloc(m_nMax + TLIST_ADD_SIZE)) return false;

  00025	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0002a	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0002d	83 c0 40	 add	 eax, 64			; 00000040H
  00030	8b d0		 mov	 edx, eax
  00032	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00037	e8 00 00 00 00	 call	 ?__alloc@?$CTList@VCScheduler@@@@AEAAHH@Z ; CTList<CScheduler>::__alloc
  0003c	85 c0		 test	 eax, eax
  0003e	75 07		 jne	 SHORT $LN6@push_back
  00040	32 c0		 xor	 al, al
  00042	e9 0c 01 00 00	 jmp	 $LN1@push_back
$LN6@push_back:

; 477  : 		nIdx = m_nMax;

  00047	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0004c	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0004f	89 44 24 20	 mov	 DWORD PTR nIdx$[rsp], eax

; 478  : 		m_nMax += TLIST_ADD_SIZE;

  00053	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00058	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0005b	83 c0 40	 add	 eax, 64			; 00000040H
  0005e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00063	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 479  : 		goto ADD_SUCCESS;

  00066	e9 99 00 00 00	 jmp	 $LN7@push_back
  0006b	e9 94 00 00 00	 jmp	 $ADD_SUCCESS$16
$LN5@push_back:

; 480  : 	}
; 481  : 
; 482  : 	if (!m_pArray[m_nLast]) { nIdx = m_nLast;  goto ADD_SUCCESS; }

  00070	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00075	48 63 40 0c	 movsxd	 rax, DWORD PTR [rax+12]
  00079	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0007e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00081	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00086	75 10		 jne	 SHORT $LN8@push_back
  00088	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0008d	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00090	89 44 24 20	 mov	 DWORD PTR nIdx$[rsp], eax
  00094	eb 6e		 jmp	 SHORT $LN9@push_back
  00096	eb 6c		 jmp	 SHORT $ADD_SUCCESS$16
$LN8@push_back:

; 483  : 
; 484  : 	nIdx = m_nLast;

  00098	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0009d	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  000a0	89 44 24 20	 mov	 DWORD PTR nIdx$[rsp], eax

; 485  : 	for (i = 0; i < m_nMax; i++)

  000a4	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000ac	eb 0a		 jmp	 SHORT $LN4@push_back
$LN2@push_back:
  000ae	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  000b2	ff c0		 inc	 eax
  000b4	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@push_back:
  000b8	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000bd	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000c0	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  000c4	7d 3a		 jge	 SHORT $LN3@push_back

; 486  : 	{
; 487  : 		if (nIdx >= m_nMax) nIdx = 0;

  000c6	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000cb	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000ce	39 44 24 20	 cmp	 DWORD PTR nIdx$[rsp], eax
  000d2	7c 08		 jl	 SHORT $LN10@push_back
  000d4	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR nIdx$[rsp], 0
$LN10@push_back:

; 488  : 		if (!m_pArray[nIdx]) {

  000dc	48 63 44 24 20	 movsxd	 rax, DWORD PTR nIdx$[rsp]
  000e1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000e6	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000e9	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  000ee	75 04		 jne	 SHORT $LN11@push_back

; 489  : 			goto ADD_SUCCESS;

  000f0	eb 12		 jmp	 SHORT $LN12@push_back
  000f2	eb 10		 jmp	 SHORT $ADD_SUCCESS$16
$LN11@push_back:

; 490  : 		}
; 491  : 		nIdx++;

  000f4	8b 44 24 20	 mov	 eax, DWORD PTR nIdx$[rsp]
  000f8	ff c0		 inc	 eax
  000fa	89 44 24 20	 mov	 DWORD PTR nIdx$[rsp], eax

; 492  : 	}

  000fe	eb ae		 jmp	 SHORT $LN2@push_back
$LN3@push_back:

; 493  : 	//_stprintf(m_szMessage, _T("add FAIL! m_nLast[%d] m_nCurCount[%d] m_nMax[%d]"), m_nLast, m_nUse, m_nMax);
; 494  : 	return false;

  00100	32 c0		 xor	 al, al
  00102	eb 4f		 jmp	 SHORT $LN1@push_back
$LN7@push_back:
$LN9@push_back:
$LN12@push_back:
$ADD_SUCCESS$16:

; 495  : 
; 496  : ADD_SUCCESS:
; 497  : 	m_nUse++;

  00104	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00109	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0010c	ff c0		 inc	 eax
  0010e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00113	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 498  : 	m_pArray[nIdx] = Obj;

  00116	48 63 44 24 20	 movsxd	 rax, DWORD PTR nIdx$[rsp]
  0011b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00120	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00123	48 8b 54 24 48	 mov	 rdx, QWORD PTR Obj$[rsp]
  00128	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx

; 499  : 	m_nLast++;

  0012c	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00131	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00134	ff c0		 inc	 eax
  00136	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0013b	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 500  : 	//_stprintf(g_szMessage, _T("CMemList::add i[%d] m_nLast[%d] m_nCurCount[%d]"), nIdx, m_nLast, m_nUse);
; 501  : 	if (pIdx) *pIdx = nIdx;

  0013e	48 83 7c 24 50
	00		 cmp	 QWORD PTR pIdx$[rsp], 0
  00144	74 0b		 je	 SHORT $LN13@push_back
  00146	48 8b 44 24 50	 mov	 rax, QWORD PTR pIdx$[rsp]
  0014b	8b 4c 24 20	 mov	 ecx, DWORD PTR nIdx$[rsp]
  0014f	89 08		 mov	 DWORD PTR [rax], ecx
$LN13@push_back:

; 502  : 	return true;

  00151	b0 01		 mov	 al, 1
$LN1@push_back:

; 503  : }

  00153	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00157	c3		 ret	 0
?push_back@?$CTList@VCScheduler@@@@QEAA_NPEAVCScheduler@@PEAH@Z ENDP ; CTList<CScheduler>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?alloc@?$CTList@VCScheduler@@@@QEAAHHW4E_ALLOC_TYPE@@@Z
_TEXT	SEGMENT
this$ = 48
nMaxCount$ = 56
type$ = 64
?alloc@?$CTList@VCScheduler@@@@QEAAHHW4E_ALLOC_TYPE@@@Z PROC ; CTList<CScheduler>::alloc, COMDAT

; 326  : 	int alloc(int nMaxCount, E_ALLOC_TYPE type = eAlloc_Type_new) { m_nObjAllocType = type;  m_nMax = __alloc(nMaxCount); return m_nMax; }

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00012	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00017	8b 4c 24 40	 mov	 ecx, DWORD PTR type$[rsp]
  0001b	89 48 18	 mov	 DWORD PTR [rax+24], ecx
  0001e	8b 54 24 38	 mov	 edx, DWORD PTR nMaxCount$[rsp]
  00022	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00027	e8 00 00 00 00	 call	 ?__alloc@?$CTList@VCScheduler@@@@AEAAHH@Z ; CTList<CScheduler>::__alloc
  0002c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00031	89 41 14	 mov	 DWORD PTR [rcx+20], eax
  00034	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00039	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0003c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00040	c3		 ret	 0
?alloc@?$CTList@VCScheduler@@@@QEAAHHW4E_ALLOC_TYPE@@@Z ENDP ; CTList<CScheduler>::alloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ??1?$CTList@VCScheduler@@@@QEAA@XZ
_TEXT	SEGMENT
tv77 = 32
p$1 = 40
tv144 = 48
$T2 = 56
$T3 = 64
$T4 = 72
tv82 = 80
tv143 = 88
$T5 = 96
tv95 = 104
$T6 = 112
idx$7 = 120
__$ArrayPad$ = 128
this$ = 160
??1?$CTList@VCScheduler@@@@QEAA@XZ PROC			; CTList<CScheduler>::~CTList<CScheduler>, COMDAT

; 376  : {

$LN21:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  0000c	48 c7 44 24 70
	fe ff ff ff	 mov	 QWORD PTR $T6[rsp], -2
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 377  : 	if (!m_pArray) return;

  00027	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0002f	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00033	75 05		 jne	 SHORT $LN6@CTList
  00035	e9 a7 01 00 00	 jmp	 $LN1@CTList
$LN6@CTList:

; 378  : 
; 379  : 	if (ISABLETODELETE(m_nObjAllocType)) {

  0003a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00042	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00045	e8 00 00 00 00	 call	 ?ISABLETODELETE@@YA_NW4E_ALLOC_TYPE@@@Z ; ISABLETODELETE
  0004a	90		 npad	 1
  0004b	0f b6 c0	 movzx	 eax, al
  0004e	85 c0		 test	 eax, eax
  00050	0f 84 5c 01 00
	00		 je	 $LN7@CTList

; 380  : 		int idx = 0;

  00056	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR idx$7[rsp], 0

; 381  : 		T *p = getNext(&idx);

  0005e	48 8d 54 24 78	 lea	 rdx, QWORD PTR idx$7[rsp]
  00063	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0006b	e8 00 00 00 00	 call	 ?getNext@?$CTList@VCScheduler@@@@QEAAPEAVCScheduler@@PEAH@Z ; CTList<CScheduler>::getNext
  00070	90		 npad	 1
  00071	48 89 44 24 28	 mov	 QWORD PTR p$1[rsp], rax
$LN2@CTList:

; 382  : 		while (p) {

  00076	48 83 7c 24 28
	00		 cmp	 QWORD PTR p$1[rsp], 0
  0007c	0f 84 30 01 00
	00		 je	 $LN7@CTList

; 383  : 			idx++;

  00082	8b 44 24 78	 mov	 eax, DWORD PTR idx$7[rsp]
  00086	ff c0		 inc	 eax
  00088	89 44 24 78	 mov	 DWORD PTR idx$7[rsp], eax

; 384  : 			switch (m_nObjAllocType) {

  0008c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00094	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00097	89 44 24 20	 mov	 DWORD PTR tv77[rsp], eax
  0009b	83 7c 24 20 02	 cmp	 DWORD PTR tv77[rsp], 2
  000a0	74 1e		 je	 SHORT $LN8@CTList
  000a2	83 7c 24 20 03	 cmp	 DWORD PTR tv77[rsp], 3
  000a7	74 58		 je	 SHORT $LN9@CTList
  000a9	83 7c 24 20 04	 cmp	 DWORD PTR tv77[rsp], 4
  000ae	74 62		 je	 SHORT $LN10@CTList
  000b0	83 7c 24 20 05	 cmp	 DWORD PTR tv77[rsp], 5
  000b5	0f 84 9e 00 00
	00		 je	 $LN11@CTList
  000bb	e9 d5 00 00 00	 jmp	 $LN4@CTList
$LN8@CTList:

; 385  : 				case eAlloc_Type_new		:	delete p; break;

  000c0	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  000c5	48 89 44 24 48	 mov	 QWORD PTR $T4[rsp], rax
  000ca	48 8b 44 24 48	 mov	 rax, QWORD PTR $T4[rsp]
  000cf	48 89 44 24 38	 mov	 QWORD PTR $T2[rsp], rax
  000d4	48 83 7c 24 38
	00		 cmp	 QWORD PTR $T2[rsp], 0
  000da	74 17		 je	 SHORT $LN16@CTList
  000dc	ba 01 00 00 00	 mov	 edx, 1
  000e1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR $T2[rsp]
  000e6	e8 00 00 00 00	 call	 ??_GCScheduler@@QEAAPEAXI@Z
  000eb	90		 npad	 1
  000ec	48 89 44 24 50	 mov	 QWORD PTR tv82[rsp], rax
  000f1	eb 09		 jmp	 SHORT $LN17@CTList
$LN16@CTList:
  000f3	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR tv82[rsp], 0
$LN17@CTList:
  000fc	e9 94 00 00 00	 jmp	 $LN4@CTList
$LN9@CTList:

; 386  : 				case eAlloc_Type_alloc		:	free(p); break;

  00101	48 8b 4c 24 28	 mov	 rcx, QWORD PTR p$1[rsp]
  00106	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  0010c	90		 npad	 1
  0010d	e9 83 00 00 00	 jmp	 $LN4@CTList
$LN10@CTList:

; 387  : 				case eAlloc_Type_BufPool	:	gs_pMMgr->delBuf((char *)p, STRING_SIZE((TCHAR *)p)); break;

  00112	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  00117	48 89 44 24 58	 mov	 QWORD PTR tv143[rsp], rax
  0011c	48 c7 44 24 30
	ff ff ff ff	 mov	 QWORD PTR tv144[rsp], -1
$LL20@CTList:
  00125	48 ff 44 24 30	 inc	 QWORD PTR tv144[rsp]
  0012a	48 8b 44 24 58	 mov	 rax, QWORD PTR tv143[rsp]
  0012f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv144[rsp]
  00134	80 3c 08 00	 cmp	 BYTE PTR [rax+rcx], 0
  00138	75 eb		 jne	 SHORT $LL20@CTList
  0013a	48 8b 44 24 30	 mov	 rax, QWORD PTR tv144[rsp]
  0013f	48 ff c0	 inc	 rax
  00142	44 8b c0	 mov	 r8d, eax
  00145	48 8b 54 24 28	 mov	 rdx, QWORD PTR p$1[rsp]
  0014a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  00151	e8 00 00 00 00	 call	 ?delBuf@CMemManager@@QEAAXPEADH@Z ; CMemManager::delBuf
  00156	90		 npad	 1
  00157	eb 3c		 jmp	 SHORT $LN4@CTList
$LN11@CTList:

; 388  : 				case eAlloc_Type_newArray	:	delete[] p; break;

  00159	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  0015e	48 89 44 24 60	 mov	 QWORD PTR $T5[rsp], rax
  00163	48 8b 44 24 60	 mov	 rax, QWORD PTR $T5[rsp]
  00168	48 89 44 24 40	 mov	 QWORD PTR $T3[rsp], rax
  0016d	48 83 7c 24 40
	00		 cmp	 QWORD PTR $T3[rsp], 0
  00173	74 17		 je	 SHORT $LN18@CTList
  00175	ba 03 00 00 00	 mov	 edx, 3
  0017a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR $T3[rsp]
  0017f	e8 00 00 00 00	 call	 ??_ECScheduler@@QEAAPEAXI@Z
  00184	90		 npad	 1
  00185	48 89 44 24 68	 mov	 QWORD PTR tv95[rsp], rax
  0018a	eb 09		 jmp	 SHORT $LN4@CTList
$LN18@CTList:
  0018c	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR tv95[rsp], 0
$LN4@CTList:

; 389  : 				case eAlloc_Type_none		:	break;
; 390  : 				case eAlloc_Type_MemPool	:	break;
; 391  : 			}
; 392  : 			p = getNext(&idx);

  00195	48 8d 54 24 78	 lea	 rdx, QWORD PTR idx$7[rsp]
  0019a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  001a2	e8 00 00 00 00	 call	 ?getNext@?$CTList@VCScheduler@@@@QEAAPEAVCScheduler@@PEAH@Z ; CTList<CScheduler>::getNext
  001a7	90		 npad	 1
  001a8	48 89 44 24 28	 mov	 QWORD PTR p$1[rsp], rax

; 393  : 		}

  001ad	e9 c4 fe ff ff	 jmp	 $LN2@CTList
$LN7@CTList:

; 394  : 	}
; 395  : 
; 396  : 	if (m_pArray)	free(m_pArray);

  001b2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001ba	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  001be	74 12		 je	 SHORT $LN14@CTList
  001c0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001c8	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  001cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  001d1	90		 npad	 1
$LN14@CTList:

; 397  : 	m_pArray = 0;

  001d2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001da	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN1@CTList:

; 398  : }

  001e1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001e9	48 33 cc	 xor	 rcx, rsp
  001ec	e8 00 00 00 00	 call	 __security_check_cookie
  001f1	90		 npad	 1
  001f2	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  001f9	c3		 ret	 0
??1?$CTList@VCScheduler@@@@QEAA@XZ ENDP			; CTList<CScheduler>::~CTList<CScheduler>
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ??0?$CTList@VCScheduler@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$CTList@VCScheduler@@@@QEAA@XZ PROC			; CTList<CScheduler>::CTList<CScheduler>, COMDAT

; 365  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 366  : 	m_pArray = NULL;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 367  : 	m_nUse = 0;

  00011	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00016	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0

; 368  : 	m_nLast = 0;

  0001d	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00022	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [rax+12], 0

; 369  : 	m_nDelIdx = 0;

  00029	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0002e	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 370  : 	m_nMax = 0;

  00035	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0003a	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0

; 371  : 	m_nObjAllocType = eAlloc_Type_none;

  00041	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00046	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0

; 372  : }

  0004d	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00052	c3		 ret	 0
??0?$CTList@VCScheduler@@@@QEAA@XZ ENDP			; CTList<CScheduler>::CTList<CScheduler>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$CTList@VCSTLogger@@@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$CTList@VCSTLogger@@@@QEAAPEAXI@Z PROC		; CTList<CSTLogger>::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00012	e8 00 00 00 00	 call	 ??1?$CTList@VCSTLogger@@@@QEAA@XZ ; CTList<CSTLogger>::~CTList<CSTLogger>
  00017	8b 44 24 38	 mov	 eax, DWORD PTR __flags$[rsp]
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 0f		 je	 SHORT $LN2@scalar
  00022	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
??_G?$CTList@VCSTLogger@@@@QEAAPEAXI@Z ENDP		; CTList<CSTLogger>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit2@?$CTList@VCSTLogger@@@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 16
classSize$ = 24
?__autoclassinit2@?$CTList@VCSTLogger@@@@QEAAX_K@Z PROC	; CTList<CSTLogger>::__autoclassinit2, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 8b 7c 24 10	 mov	 rdi, QWORD PTR this$[rsp]
  00010	33 c0		 xor	 eax, eax
  00012	48 8b 4c 24 18	 mov	 rcx, QWORD PTR classSize$[rsp]
  00017	f3 aa		 rep stosb
  00019	5f		 pop	 rdi
  0001a	c3		 ret	 0
?__autoclassinit2@?$CTList@VCSTLogger@@@@QEAAX_K@Z ENDP	; CTList<CSTLogger>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?_DEL@?$CTList@VCSTLogger@@@@AEAAXH@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
?_DEL@?$CTList@VCSTLogger@@@@AEAAXH@Z PROC		; CTList<CSTLogger>::_DEL, COMDAT

; 360  : 	inline void _DEL(int i) { m_pArray[i] = 0; m_nUse--; m_nDelIdx = i; }

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 63 44 24 10	 movsxd	 rax, DWORD PTR i$[rsp]
  0000e	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  00013	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00016	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0
  0001e	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00023	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00026	ff c8		 dec	 eax
  00028	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  0002d	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  00030	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00035	8b 4c 24 10	 mov	 ecx, DWORD PTR i$[rsp]
  00039	89 48 10	 mov	 DWORD PTR [rax+16], ecx
  0003c	c3		 ret	 0
?_DEL@?$CTList@VCSTLogger@@@@AEAAXH@Z ENDP		; CTList<CSTLogger>::_DEL
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?__alloc@?$CTList@VCSTLogger@@@@AEAAHH@Z
_TEXT	SEGMENT
pList$ = 32
this$ = 80
nMaxCount$ = 88
?__alloc@?$CTList@VCSTLogger@@@@AEAAHH@Z PROC		; CTList<CSTLogger>::__alloc, COMDAT

; 402  : {

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 403  : 	T** pList = (T**)calloc(nMaxCount, sizeof(T*));

  0000f	48 63 44 24 58	 movsxd	 rax, DWORD PTR nMaxCount$[rsp]
  00014	ba 08 00 00 00	 mov	 edx, 8
  00019	48 8b c8	 mov	 rcx, rax
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00022	48 89 44 24 20	 mov	 QWORD PTR pList$[rsp], rax

; 404  : 	if (!pList) {

  00027	48 83 7c 24 20
	00		 cmp	 QWORD PTR pList$[rsp], 0
  0002d	75 17		 jne	 SHORT $LN2@alloc

; 405  : 		_stprintf(g_szMessage, "pList calloc is NULL");

  0002f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46927
  00036	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  0003d	e8 00 00 00 00	 call	 sprintf

; 406  : 		return 0;

  00042	33 c0		 xor	 eax, eax
  00044	eb 49		 jmp	 SHORT $LN1@alloc
$LN2@alloc:

; 407  : 	}
; 408  : 	//_stprintf(g_szMessage, _T("CTList::__alloc list m_nMaxCount[%d]"), nMaxCount);
; 409  : 	if (m_pArray) {

  00046	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0004b	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0004f	74 2d		 je	 SHORT $LN3@alloc

; 410  : 		memcpy(pList, m_pArray, m_nMax * sizeof(T*));

  00051	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00056	48 63 40 14	 movsxd	 rax, DWORD PTR [rax+20]
  0005a	48 c1 e0 03	 shl	 rax, 3
  0005e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00063	48 8b 7c 24 20	 mov	 rdi, QWORD PTR pList$[rsp]
  00068	48 8b 31	 mov	 rsi, QWORD PTR [rcx]
  0006b	48 8b c8	 mov	 rcx, rax
  0006e	f3 a4		 rep movsb

; 411  : 		free(m_pArray);

  00070	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00075	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN3@alloc:

; 412  : 	}
; 413  : 	m_pArray = pList;

  0007e	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00083	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pList$[rsp]
  00088	48 89 08	 mov	 QWORD PTR [rax], rcx

; 414  : 	return nMaxCount;

  0008b	8b 44 24 58	 mov	 eax, DWORD PTR nMaxCount$[rsp]
$LN1@alloc:

; 415  : }

  0008f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00093	5f		 pop	 rdi
  00094	5e		 pop	 rsi
  00095	c3		 ret	 0
?__alloc@?$CTList@VCSTLogger@@@@AEAAHH@Z ENDP		; CTList<CSTLogger>::__alloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?setObjAllocType@?$CTList@VCSTLogger@@@@QEAAXW4E_ALLOC_TYPE@@@Z
_TEXT	SEGMENT
this$ = 8
type$ = 16
?setObjAllocType@?$CTList@VCSTLogger@@@@QEAAXW4E_ALLOC_TYPE@@@Z PROC ; CTList<CSTLogger>::setObjAllocType, COMDAT

; 350  : 	inline void setObjAllocType(E_ALLOC_TYPE type) { m_nObjAllocType = type; }

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR type$[rsp]
  00012	89 48 18	 mov	 DWORD PTR [rax+24], ecx
  00015	c3		 ret	 0
?setObjAllocType@?$CTList@VCSTLogger@@@@QEAAXW4E_ALLOC_TYPE@@@Z ENDP ; CTList<CSTLogger>::setObjAllocType
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?size@?$CTList@VCSTLogger@@@@QEAAHXZ
_TEXT	SEGMENT
this$ = 8
?size@?$CTList@VCSTLogger@@@@QEAAHXZ PROC		; CTList<CSTLogger>::size, COMDAT

; 347  : 	inline int  size() { return m_nUse; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0000d	c3		 ret	 0
?size@?$CTList@VCSTLogger@@@@QEAAHXZ ENDP		; CTList<CSTLogger>::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?getNext@?$CTList@VCSTLogger@@@@QEAAPEAVCSTLogger@@PEAH@Z
_TEXT	SEGMENT
this$ = 8
pIdx$ = 16
?getNext@?$CTList@VCSTLogger@@@@QEAAPEAVCSTLogger@@PEAH@Z PROC ; CTList<CSTLogger>::getNext, COMDAT

; 334  : 	inline T* getNext(int *pIdx) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 335  : 		for (*pIdx; *pIdx < m_nMax; (*pIdx)++) {

  0000a	eb 10		 jmp	 SHORT $LN4@getNext
$LN2@getNext:
  0000c	48 8b 44 24 10	 mov	 rax, QWORD PTR pIdx$[rsp]
  00011	8b 00		 mov	 eax, DWORD PTR [rax]
  00013	ff c0		 inc	 eax
  00015	48 8b 4c 24 10	 mov	 rcx, QWORD PTR pIdx$[rsp]
  0001a	89 01		 mov	 DWORD PTR [rcx], eax
$LN4@getNext:
  0001c	48 8b 44 24 10	 mov	 rax, QWORD PTR pIdx$[rsp]
  00021	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  00026	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  00029	39 08		 cmp	 DWORD PTR [rax], ecx
  0002b	7d 2f		 jge	 SHORT $LN3@getNext

; 336  : 			if (m_pArray[*pIdx]) { return m_pArray[*pIdx]; }

  0002d	48 8b 44 24 10	 mov	 rax, QWORD PTR pIdx$[rsp]
  00032	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  00035	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  0003a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0003d	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00042	74 16		 je	 SHORT $LN5@getNext
  00044	48 8b 44 24 10	 mov	 rax, QWORD PTR pIdx$[rsp]
  00049	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  0004c	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  00051	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00054	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00058	eb 04		 jmp	 SHORT $LN1@getNext
$LN5@getNext:

; 337  : 		}

  0005a	eb b0		 jmp	 SHORT $LN2@getNext
$LN3@getNext:

; 338  : 		return NULL;

  0005c	33 c0		 xor	 eax, eax
$LN1@getNext:

; 339  : 	}

  0005e	c3		 ret	 0
?getNext@?$CTList@VCSTLogger@@@@QEAAPEAVCSTLogger@@PEAH@Z ENDP ; CTList<CSTLogger>::getNext
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?getObj@?$CTList@VCSTLogger@@@@QEAAPEAVCSTLogger@@H@Z
_TEXT	SEGMENT
this$ = 48
i$ = 56
?getObj@?$CTList@VCSTLogger@@@@QEAAPEAVCSTLogger@@H@Z PROC ; CTList<CSTLogger>::getObj, COMDAT

; 332  : 	inline T* getObj(int i) { if (ISINCLUDE(i, m_nMax)) return m_pArray[i]; return NULL; }

$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00012	8b 50 14	 mov	 edx, DWORD PTR [rax+20]
  00015	8b 4c 24 38	 mov	 ecx, DWORD PTR i$[rsp]
  00019	e8 00 00 00 00	 call	 ?ISINCLUDE@@YA_NHH@Z	; ISINCLUDE
  0001e	0f b6 c0	 movzx	 eax, al
  00021	85 c0		 test	 eax, eax
  00023	74 13		 je	 SHORT $LN2@getObj
  00025	48 63 44 24 38	 movsxd	 rax, DWORD PTR i$[rsp]
  0002a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00032	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00036	eb 02		 jmp	 SHORT $LN1@getObj
$LN2@getObj:
  00038	33 c0		 xor	 eax, eax
$LN1@getObj:
  0003a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003e	c3		 ret	 0
?getObj@?$CTList@VCSTLogger@@@@QEAAPEAVCSTLogger@@H@Z ENDP ; CTList<CSTLogger>::getObj
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?del@?$CTList@VCSTLogger@@@@QEAA_NH@Z
_TEXT	SEGMENT
this$ = 48
i$ = 56
?del@?$CTList@VCSTLogger@@@@QEAA_NH@Z PROC		; CTList<CSTLogger>::del, COMDAT

; 523  : {

$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 524  : 	if (!ISINCLUDE(i, m_nMax)) {

  0000d	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00012	8b 50 14	 mov	 edx, DWORD PTR [rax+20]
  00015	8b 4c 24 38	 mov	 ecx, DWORD PTR i$[rsp]
  00019	e8 00 00 00 00	 call	 ?ISINCLUDE@@YA_NHH@Z	; ISINCLUDE
  0001e	0f b6 c0	 movzx	 eax, al
  00021	85 c0		 test	 eax, eax
  00023	75 25		 jne	 SHORT $LN2@del

; 525  : 		_stprintf(g_szMessage, "i[%d] m_nMax[%d]", i, m_nMax);

  00025	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0002a	44 8b 48 14	 mov	 r9d, DWORD PTR [rax+20]
  0002e	44 8b 44 24 38	 mov	 r8d, DWORD PTR i$[rsp]
  00033	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46916
  0003a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  00041	e8 00 00 00 00	 call	 sprintf

; 526  : 		return false;

  00046	32 c0		 xor	 al, al
  00048	eb 10		 jmp	 SHORT $LN1@del
$LN2@del:

; 527  : 	}
; 528  : 	_DEL(i);

  0004a	8b 54 24 38	 mov	 edx, DWORD PTR i$[rsp]
  0004e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00053	e8 00 00 00 00	 call	 ?_DEL@?$CTList@VCSTLogger@@@@AEAAXH@Z ; CTList<CSTLogger>::_DEL

; 529  : 	//_stprintf(g_szMessage, _T("CMemList::del i[%d] m_nLast[%d] m_nCurCount[%d]"), i, m_nLast, m_nUse);
; 530  : 	return true;

  00058	b0 01		 mov	 al, 1
$LN1@del:

; 531  : }

  0005a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005e	c3		 ret	 0
?del@?$CTList@VCSTLogger@@@@QEAA_NH@Z ENDP		; CTList<CSTLogger>::del
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?push_back@?$CTList@VCSTLogger@@@@QEAA_NPEAVCSTLogger@@PEAH@Z
_TEXT	SEGMENT
nIdx$ = 32
i$ = 36
this$ = 64
Obj$ = 72
pIdx$ = 80
?push_back@?$CTList@VCSTLogger@@@@QEAA_NPEAVCSTLogger@@PEAH@Z PROC ; CTList<CSTLogger>::push_back, COMDAT

; 472  : {

$LN15:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 473  : 	int nIdx, i;
; 474  : 
; 475  : 	if (m_nUse >= m_nMax) {

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00018	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0001d	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  00020	39 48 08	 cmp	 DWORD PTR [rax+8], ecx
  00023	7c 4b		 jl	 SHORT $LN5@push_back

; 476  : 		if (!__alloc(m_nMax + TLIST_ADD_SIZE)) return false;

  00025	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0002a	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0002d	83 c0 40	 add	 eax, 64			; 00000040H
  00030	8b d0		 mov	 edx, eax
  00032	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00037	e8 00 00 00 00	 call	 ?__alloc@?$CTList@VCSTLogger@@@@AEAAHH@Z ; CTList<CSTLogger>::__alloc
  0003c	85 c0		 test	 eax, eax
  0003e	75 07		 jne	 SHORT $LN6@push_back
  00040	32 c0		 xor	 al, al
  00042	e9 0c 01 00 00	 jmp	 $LN1@push_back
$LN6@push_back:

; 477  : 		nIdx = m_nMax;

  00047	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0004c	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0004f	89 44 24 20	 mov	 DWORD PTR nIdx$[rsp], eax

; 478  : 		m_nMax += TLIST_ADD_SIZE;

  00053	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00058	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0005b	83 c0 40	 add	 eax, 64			; 00000040H
  0005e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00063	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 479  : 		goto ADD_SUCCESS;

  00066	e9 99 00 00 00	 jmp	 $LN7@push_back
  0006b	e9 94 00 00 00	 jmp	 $ADD_SUCCESS$16
$LN5@push_back:

; 480  : 	}
; 481  : 
; 482  : 	if (!m_pArray[m_nLast]) { nIdx = m_nLast;  goto ADD_SUCCESS; }

  00070	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00075	48 63 40 0c	 movsxd	 rax, DWORD PTR [rax+12]
  00079	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0007e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00081	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00086	75 10		 jne	 SHORT $LN8@push_back
  00088	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0008d	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00090	89 44 24 20	 mov	 DWORD PTR nIdx$[rsp], eax
  00094	eb 6e		 jmp	 SHORT $LN9@push_back
  00096	eb 6c		 jmp	 SHORT $ADD_SUCCESS$16
$LN8@push_back:

; 483  : 
; 484  : 	nIdx = m_nLast;

  00098	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0009d	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  000a0	89 44 24 20	 mov	 DWORD PTR nIdx$[rsp], eax

; 485  : 	for (i = 0; i < m_nMax; i++)

  000a4	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000ac	eb 0a		 jmp	 SHORT $LN4@push_back
$LN2@push_back:
  000ae	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  000b2	ff c0		 inc	 eax
  000b4	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@push_back:
  000b8	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000bd	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000c0	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  000c4	7d 3a		 jge	 SHORT $LN3@push_back

; 486  : 	{
; 487  : 		if (nIdx >= m_nMax) nIdx = 0;

  000c6	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000cb	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000ce	39 44 24 20	 cmp	 DWORD PTR nIdx$[rsp], eax
  000d2	7c 08		 jl	 SHORT $LN10@push_back
  000d4	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR nIdx$[rsp], 0
$LN10@push_back:

; 488  : 		if (!m_pArray[nIdx]) {

  000dc	48 63 44 24 20	 movsxd	 rax, DWORD PTR nIdx$[rsp]
  000e1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000e6	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000e9	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  000ee	75 04		 jne	 SHORT $LN11@push_back

; 489  : 			goto ADD_SUCCESS;

  000f0	eb 12		 jmp	 SHORT $LN12@push_back
  000f2	eb 10		 jmp	 SHORT $ADD_SUCCESS$16
$LN11@push_back:

; 490  : 		}
; 491  : 		nIdx++;

  000f4	8b 44 24 20	 mov	 eax, DWORD PTR nIdx$[rsp]
  000f8	ff c0		 inc	 eax
  000fa	89 44 24 20	 mov	 DWORD PTR nIdx$[rsp], eax

; 492  : 	}

  000fe	eb ae		 jmp	 SHORT $LN2@push_back
$LN3@push_back:

; 493  : 	//_stprintf(m_szMessage, _T("add FAIL! m_nLast[%d] m_nCurCount[%d] m_nMax[%d]"), m_nLast, m_nUse, m_nMax);
; 494  : 	return false;

  00100	32 c0		 xor	 al, al
  00102	eb 4f		 jmp	 SHORT $LN1@push_back
$LN7@push_back:
$LN9@push_back:
$LN12@push_back:
$ADD_SUCCESS$16:

; 495  : 
; 496  : ADD_SUCCESS:
; 497  : 	m_nUse++;

  00104	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00109	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0010c	ff c0		 inc	 eax
  0010e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00113	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 498  : 	m_pArray[nIdx] = Obj;

  00116	48 63 44 24 20	 movsxd	 rax, DWORD PTR nIdx$[rsp]
  0011b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00120	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00123	48 8b 54 24 48	 mov	 rdx, QWORD PTR Obj$[rsp]
  00128	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx

; 499  : 	m_nLast++;

  0012c	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00131	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00134	ff c0		 inc	 eax
  00136	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0013b	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 500  : 	//_stprintf(g_szMessage, _T("CMemList::add i[%d] m_nLast[%d] m_nCurCount[%d]"), nIdx, m_nLast, m_nUse);
; 501  : 	if (pIdx) *pIdx = nIdx;

  0013e	48 83 7c 24 50
	00		 cmp	 QWORD PTR pIdx$[rsp], 0
  00144	74 0b		 je	 SHORT $LN13@push_back
  00146	48 8b 44 24 50	 mov	 rax, QWORD PTR pIdx$[rsp]
  0014b	8b 4c 24 20	 mov	 ecx, DWORD PTR nIdx$[rsp]
  0014f	89 08		 mov	 DWORD PTR [rax], ecx
$LN13@push_back:

; 502  : 	return true;

  00151	b0 01		 mov	 al, 1
$LN1@push_back:

; 503  : }

  00153	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00157	c3		 ret	 0
?push_back@?$CTList@VCSTLogger@@@@QEAA_NPEAVCSTLogger@@PEAH@Z ENDP ; CTList<CSTLogger>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?alloc@?$CTList@VCSTLogger@@@@QEAAHHW4E_ALLOC_TYPE@@@Z
_TEXT	SEGMENT
this$ = 48
nMaxCount$ = 56
type$ = 64
?alloc@?$CTList@VCSTLogger@@@@QEAAHHW4E_ALLOC_TYPE@@@Z PROC ; CTList<CSTLogger>::alloc, COMDAT

; 326  : 	int alloc(int nMaxCount, E_ALLOC_TYPE type = eAlloc_Type_new) { m_nObjAllocType = type;  m_nMax = __alloc(nMaxCount); return m_nMax; }

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00012	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00017	8b 4c 24 40	 mov	 ecx, DWORD PTR type$[rsp]
  0001b	89 48 18	 mov	 DWORD PTR [rax+24], ecx
  0001e	8b 54 24 38	 mov	 edx, DWORD PTR nMaxCount$[rsp]
  00022	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00027	e8 00 00 00 00	 call	 ?__alloc@?$CTList@VCSTLogger@@@@AEAAHH@Z ; CTList<CSTLogger>::__alloc
  0002c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00031	89 41 14	 mov	 DWORD PTR [rcx+20], eax
  00034	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00039	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0003c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00040	c3		 ret	 0
?alloc@?$CTList@VCSTLogger@@@@QEAAHHW4E_ALLOC_TYPE@@@Z ENDP ; CTList<CSTLogger>::alloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ??1?$CTList@VCSTLogger@@@@QEAA@XZ
_TEXT	SEGMENT
tv77 = 32
p$1 = 40
tv144 = 48
$T2 = 56
$T3 = 64
$T4 = 72
tv82 = 80
tv143 = 88
$T5 = 96
tv95 = 104
$T6 = 112
idx$7 = 120
__$ArrayPad$ = 128
this$ = 160
??1?$CTList@VCSTLogger@@@@QEAA@XZ PROC			; CTList<CSTLogger>::~CTList<CSTLogger>, COMDAT

; 376  : {

$LN21:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  0000c	48 c7 44 24 70
	fe ff ff ff	 mov	 QWORD PTR $T6[rsp], -2
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 377  : 	if (!m_pArray) return;

  00027	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0002f	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00033	75 05		 jne	 SHORT $LN6@CTList
  00035	e9 a7 01 00 00	 jmp	 $LN1@CTList
$LN6@CTList:

; 378  : 
; 379  : 	if (ISABLETODELETE(m_nObjAllocType)) {

  0003a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00042	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00045	e8 00 00 00 00	 call	 ?ISABLETODELETE@@YA_NW4E_ALLOC_TYPE@@@Z ; ISABLETODELETE
  0004a	90		 npad	 1
  0004b	0f b6 c0	 movzx	 eax, al
  0004e	85 c0		 test	 eax, eax
  00050	0f 84 5c 01 00
	00		 je	 $LN7@CTList

; 380  : 		int idx = 0;

  00056	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR idx$7[rsp], 0

; 381  : 		T *p = getNext(&idx);

  0005e	48 8d 54 24 78	 lea	 rdx, QWORD PTR idx$7[rsp]
  00063	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0006b	e8 00 00 00 00	 call	 ?getNext@?$CTList@VCSTLogger@@@@QEAAPEAVCSTLogger@@PEAH@Z ; CTList<CSTLogger>::getNext
  00070	90		 npad	 1
  00071	48 89 44 24 28	 mov	 QWORD PTR p$1[rsp], rax
$LN2@CTList:

; 382  : 		while (p) {

  00076	48 83 7c 24 28
	00		 cmp	 QWORD PTR p$1[rsp], 0
  0007c	0f 84 30 01 00
	00		 je	 $LN7@CTList

; 383  : 			idx++;

  00082	8b 44 24 78	 mov	 eax, DWORD PTR idx$7[rsp]
  00086	ff c0		 inc	 eax
  00088	89 44 24 78	 mov	 DWORD PTR idx$7[rsp], eax

; 384  : 			switch (m_nObjAllocType) {

  0008c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00094	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00097	89 44 24 20	 mov	 DWORD PTR tv77[rsp], eax
  0009b	83 7c 24 20 02	 cmp	 DWORD PTR tv77[rsp], 2
  000a0	74 1e		 je	 SHORT $LN8@CTList
  000a2	83 7c 24 20 03	 cmp	 DWORD PTR tv77[rsp], 3
  000a7	74 58		 je	 SHORT $LN9@CTList
  000a9	83 7c 24 20 04	 cmp	 DWORD PTR tv77[rsp], 4
  000ae	74 62		 je	 SHORT $LN10@CTList
  000b0	83 7c 24 20 05	 cmp	 DWORD PTR tv77[rsp], 5
  000b5	0f 84 9e 00 00
	00		 je	 $LN11@CTList
  000bb	e9 d5 00 00 00	 jmp	 $LN4@CTList
$LN8@CTList:

; 385  : 				case eAlloc_Type_new		:	delete p; break;

  000c0	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  000c5	48 89 44 24 48	 mov	 QWORD PTR $T4[rsp], rax
  000ca	48 8b 44 24 48	 mov	 rax, QWORD PTR $T4[rsp]
  000cf	48 89 44 24 38	 mov	 QWORD PTR $T2[rsp], rax
  000d4	48 83 7c 24 38
	00		 cmp	 QWORD PTR $T2[rsp], 0
  000da	74 17		 je	 SHORT $LN16@CTList
  000dc	ba 01 00 00 00	 mov	 edx, 1
  000e1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR $T2[rsp]
  000e6	e8 00 00 00 00	 call	 ??_GCSTLogger@@QEAAPEAXI@Z
  000eb	90		 npad	 1
  000ec	48 89 44 24 50	 mov	 QWORD PTR tv82[rsp], rax
  000f1	eb 09		 jmp	 SHORT $LN17@CTList
$LN16@CTList:
  000f3	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR tv82[rsp], 0
$LN17@CTList:
  000fc	e9 94 00 00 00	 jmp	 $LN4@CTList
$LN9@CTList:

; 386  : 				case eAlloc_Type_alloc		:	free(p); break;

  00101	48 8b 4c 24 28	 mov	 rcx, QWORD PTR p$1[rsp]
  00106	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  0010c	90		 npad	 1
  0010d	e9 83 00 00 00	 jmp	 $LN4@CTList
$LN10@CTList:

; 387  : 				case eAlloc_Type_BufPool	:	gs_pMMgr->delBuf((char *)p, STRING_SIZE((TCHAR *)p)); break;

  00112	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  00117	48 89 44 24 58	 mov	 QWORD PTR tv143[rsp], rax
  0011c	48 c7 44 24 30
	ff ff ff ff	 mov	 QWORD PTR tv144[rsp], -1
$LL20@CTList:
  00125	48 ff 44 24 30	 inc	 QWORD PTR tv144[rsp]
  0012a	48 8b 44 24 58	 mov	 rax, QWORD PTR tv143[rsp]
  0012f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv144[rsp]
  00134	80 3c 08 00	 cmp	 BYTE PTR [rax+rcx], 0
  00138	75 eb		 jne	 SHORT $LL20@CTList
  0013a	48 8b 44 24 30	 mov	 rax, QWORD PTR tv144[rsp]
  0013f	48 ff c0	 inc	 rax
  00142	44 8b c0	 mov	 r8d, eax
  00145	48 8b 54 24 28	 mov	 rdx, QWORD PTR p$1[rsp]
  0014a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  00151	e8 00 00 00 00	 call	 ?delBuf@CMemManager@@QEAAXPEADH@Z ; CMemManager::delBuf
  00156	90		 npad	 1
  00157	eb 3c		 jmp	 SHORT $LN4@CTList
$LN11@CTList:

; 388  : 				case eAlloc_Type_newArray	:	delete[] p; break;

  00159	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  0015e	48 89 44 24 60	 mov	 QWORD PTR $T5[rsp], rax
  00163	48 8b 44 24 60	 mov	 rax, QWORD PTR $T5[rsp]
  00168	48 89 44 24 40	 mov	 QWORD PTR $T3[rsp], rax
  0016d	48 83 7c 24 40
	00		 cmp	 QWORD PTR $T3[rsp], 0
  00173	74 17		 je	 SHORT $LN18@CTList
  00175	ba 03 00 00 00	 mov	 edx, 3
  0017a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR $T3[rsp]
  0017f	e8 00 00 00 00	 call	 ??_ECSTLogger@@QEAAPEAXI@Z
  00184	90		 npad	 1
  00185	48 89 44 24 68	 mov	 QWORD PTR tv95[rsp], rax
  0018a	eb 09		 jmp	 SHORT $LN4@CTList
$LN18@CTList:
  0018c	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR tv95[rsp], 0
$LN4@CTList:

; 389  : 				case eAlloc_Type_none		:	break;
; 390  : 				case eAlloc_Type_MemPool	:	break;
; 391  : 			}
; 392  : 			p = getNext(&idx);

  00195	48 8d 54 24 78	 lea	 rdx, QWORD PTR idx$7[rsp]
  0019a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  001a2	e8 00 00 00 00	 call	 ?getNext@?$CTList@VCSTLogger@@@@QEAAPEAVCSTLogger@@PEAH@Z ; CTList<CSTLogger>::getNext
  001a7	90		 npad	 1
  001a8	48 89 44 24 28	 mov	 QWORD PTR p$1[rsp], rax

; 393  : 		}

  001ad	e9 c4 fe ff ff	 jmp	 $LN2@CTList
$LN7@CTList:

; 394  : 	}
; 395  : 
; 396  : 	if (m_pArray)	free(m_pArray);

  001b2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001ba	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  001be	74 12		 je	 SHORT $LN14@CTList
  001c0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001c8	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  001cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  001d1	90		 npad	 1
$LN14@CTList:

; 397  : 	m_pArray = 0;

  001d2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001da	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN1@CTList:

; 398  : }

  001e1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001e9	48 33 cc	 xor	 rcx, rsp
  001ec	e8 00 00 00 00	 call	 __security_check_cookie
  001f1	90		 npad	 1
  001f2	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  001f9	c3		 ret	 0
??1?$CTList@VCSTLogger@@@@QEAA@XZ ENDP			; CTList<CSTLogger>::~CTList<CSTLogger>
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ??0?$CTList@VCSTLogger@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$CTList@VCSTLogger@@@@QEAA@XZ PROC			; CTList<CSTLogger>::CTList<CSTLogger>, COMDAT

; 365  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 366  : 	m_pArray = NULL;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 367  : 	m_nUse = 0;

  00011	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00016	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0

; 368  : 	m_nLast = 0;

  0001d	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00022	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [rax+12], 0

; 369  : 	m_nDelIdx = 0;

  00029	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0002e	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 370  : 	m_nMax = 0;

  00035	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0003a	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0

; 371  : 	m_nObjAllocType = eAlloc_Type_none;

  00041	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00046	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0

; 372  : }

  0004d	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00052	c3		 ret	 0
??0?$CTList@VCSTLogger@@@@QEAA@XZ ENDP			; CTList<CSTLogger>::CTList<CSTLogger>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$CTList@VCLogger@@@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$CTList@VCLogger@@@@QEAAPEAXI@Z PROC		; CTList<CLogger>::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00012	e8 00 00 00 00	 call	 ??1?$CTList@VCLogger@@@@QEAA@XZ ; CTList<CLogger>::~CTList<CLogger>
  00017	8b 44 24 38	 mov	 eax, DWORD PTR __flags$[rsp]
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 0f		 je	 SHORT $LN2@scalar
  00022	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
??_G?$CTList@VCLogger@@@@QEAAPEAXI@Z ENDP		; CTList<CLogger>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit2@?$CTList@VCLogger@@@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 16
classSize$ = 24
?__autoclassinit2@?$CTList@VCLogger@@@@QEAAX_K@Z PROC	; CTList<CLogger>::__autoclassinit2, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 8b 7c 24 10	 mov	 rdi, QWORD PTR this$[rsp]
  00010	33 c0		 xor	 eax, eax
  00012	48 8b 4c 24 18	 mov	 rcx, QWORD PTR classSize$[rsp]
  00017	f3 aa		 rep stosb
  00019	5f		 pop	 rdi
  0001a	c3		 ret	 0
?__autoclassinit2@?$CTList@VCLogger@@@@QEAAX_K@Z ENDP	; CTList<CLogger>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?_DEL@?$CTList@VCLogger@@@@AEAAXH@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
?_DEL@?$CTList@VCLogger@@@@AEAAXH@Z PROC		; CTList<CLogger>::_DEL, COMDAT

; 360  : 	inline void _DEL(int i) { m_pArray[i] = 0; m_nUse--; m_nDelIdx = i; }

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 63 44 24 10	 movsxd	 rax, DWORD PTR i$[rsp]
  0000e	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  00013	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00016	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0
  0001e	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00023	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00026	ff c8		 dec	 eax
  00028	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  0002d	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  00030	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00035	8b 4c 24 10	 mov	 ecx, DWORD PTR i$[rsp]
  00039	89 48 10	 mov	 DWORD PTR [rax+16], ecx
  0003c	c3		 ret	 0
?_DEL@?$CTList@VCLogger@@@@AEAAXH@Z ENDP		; CTList<CLogger>::_DEL
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?__alloc@?$CTList@VCLogger@@@@AEAAHH@Z
_TEXT	SEGMENT
pList$ = 32
this$ = 80
nMaxCount$ = 88
?__alloc@?$CTList@VCLogger@@@@AEAAHH@Z PROC		; CTList<CLogger>::__alloc, COMDAT

; 402  : {

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 403  : 	T** pList = (T**)calloc(nMaxCount, sizeof(T*));

  0000f	48 63 44 24 58	 movsxd	 rax, DWORD PTR nMaxCount$[rsp]
  00014	ba 08 00 00 00	 mov	 edx, 8
  00019	48 8b c8	 mov	 rcx, rax
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00022	48 89 44 24 20	 mov	 QWORD PTR pList$[rsp], rax

; 404  : 	if (!pList) {

  00027	48 83 7c 24 20
	00		 cmp	 QWORD PTR pList$[rsp], 0
  0002d	75 17		 jne	 SHORT $LN2@alloc

; 405  : 		_stprintf(g_szMessage, "pList calloc is NULL");

  0002f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46749
  00036	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  0003d	e8 00 00 00 00	 call	 sprintf

; 406  : 		return 0;

  00042	33 c0		 xor	 eax, eax
  00044	eb 49		 jmp	 SHORT $LN1@alloc
$LN2@alloc:

; 407  : 	}
; 408  : 	//_stprintf(g_szMessage, _T("CTList::__alloc list m_nMaxCount[%d]"), nMaxCount);
; 409  : 	if (m_pArray) {

  00046	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0004b	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0004f	74 2d		 je	 SHORT $LN3@alloc

; 410  : 		memcpy(pList, m_pArray, m_nMax * sizeof(T*));

  00051	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00056	48 63 40 14	 movsxd	 rax, DWORD PTR [rax+20]
  0005a	48 c1 e0 03	 shl	 rax, 3
  0005e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00063	48 8b 7c 24 20	 mov	 rdi, QWORD PTR pList$[rsp]
  00068	48 8b 31	 mov	 rsi, QWORD PTR [rcx]
  0006b	48 8b c8	 mov	 rcx, rax
  0006e	f3 a4		 rep movsb

; 411  : 		free(m_pArray);

  00070	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00075	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN3@alloc:

; 412  : 	}
; 413  : 	m_pArray = pList;

  0007e	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00083	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pList$[rsp]
  00088	48 89 08	 mov	 QWORD PTR [rax], rcx

; 414  : 	return nMaxCount;

  0008b	8b 44 24 58	 mov	 eax, DWORD PTR nMaxCount$[rsp]
$LN1@alloc:

; 415  : }

  0008f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00093	5f		 pop	 rdi
  00094	5e		 pop	 rsi
  00095	c3		 ret	 0
?__alloc@?$CTList@VCLogger@@@@AEAAHH@Z ENDP		; CTList<CLogger>::__alloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?getNext@?$CTList@VCLogger@@@@QEAAPEAVCLogger@@PEAH@Z
_TEXT	SEGMENT
this$ = 8
pIdx$ = 16
?getNext@?$CTList@VCLogger@@@@QEAAPEAVCLogger@@PEAH@Z PROC ; CTList<CLogger>::getNext, COMDAT

; 334  : 	inline T* getNext(int *pIdx) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 335  : 		for (*pIdx; *pIdx < m_nMax; (*pIdx)++) {

  0000a	eb 10		 jmp	 SHORT $LN4@getNext
$LN2@getNext:
  0000c	48 8b 44 24 10	 mov	 rax, QWORD PTR pIdx$[rsp]
  00011	8b 00		 mov	 eax, DWORD PTR [rax]
  00013	ff c0		 inc	 eax
  00015	48 8b 4c 24 10	 mov	 rcx, QWORD PTR pIdx$[rsp]
  0001a	89 01		 mov	 DWORD PTR [rcx], eax
$LN4@getNext:
  0001c	48 8b 44 24 10	 mov	 rax, QWORD PTR pIdx$[rsp]
  00021	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  00026	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  00029	39 08		 cmp	 DWORD PTR [rax], ecx
  0002b	7d 2f		 jge	 SHORT $LN3@getNext

; 336  : 			if (m_pArray[*pIdx]) { return m_pArray[*pIdx]; }

  0002d	48 8b 44 24 10	 mov	 rax, QWORD PTR pIdx$[rsp]
  00032	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  00035	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  0003a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0003d	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00042	74 16		 je	 SHORT $LN5@getNext
  00044	48 8b 44 24 10	 mov	 rax, QWORD PTR pIdx$[rsp]
  00049	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  0004c	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  00051	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00054	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00058	eb 04		 jmp	 SHORT $LN1@getNext
$LN5@getNext:

; 337  : 		}

  0005a	eb b0		 jmp	 SHORT $LN2@getNext
$LN3@getNext:

; 338  : 		return NULL;

  0005c	33 c0		 xor	 eax, eax
$LN1@getNext:

; 339  : 	}

  0005e	c3		 ret	 0
?getNext@?$CTList@VCLogger@@@@QEAAPEAVCLogger@@PEAH@Z ENDP ; CTList<CLogger>::getNext
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?del@?$CTList@VCLogger@@@@QEAA_NPEAVCLogger@@@Z
_TEXT	SEGMENT
i$ = 32
this$ = 64
p$ = 72
?del@?$CTList@VCLogger@@@@QEAA_NPEAVCLogger@@@Z PROC	; CTList<CLogger>::del, COMDAT

; 508  : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 509  : 	int i;
; 510  : 	for (i = 0; i < m_nMax; i++) {

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00016	eb 0a		 jmp	 SHORT $LN4@del
$LN2@del:
  00018	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0001c	ff c0		 inc	 eax
  0001e	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@del:
  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00027	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0002a	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0002e	7d 2c		 jge	 SHORT $LN3@del

; 511  : 		if (m_pArray[i] == p) {

  00030	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00035	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0003a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0003d	48 8b 54 24 48	 mov	 rdx, QWORD PTR p$[rsp]
  00042	48 39 14 c1	 cmp	 QWORD PTR [rcx+rax*8], rdx
  00046	75 12		 jne	 SHORT $LN5@del

; 512  : 			_DEL(i);

  00048	8b 54 24 20	 mov	 edx, DWORD PTR i$[rsp]
  0004c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00051	e8 00 00 00 00	 call	 ?_DEL@?$CTList@VCLogger@@@@AEAAXH@Z ; CTList<CLogger>::_DEL

; 513  : 			//_stprintf(g_szMessage, _T("CMemList::del i[%d] m_nLast[%d] m_nCurCount[%d]"), i, m_nLast, m_nUse);
; 514  : 			return true;

  00056	b0 01		 mov	 al, 1
  00058	eb 25		 jmp	 SHORT $LN1@del
$LN5@del:

; 515  : 		}
; 516  : 	}

  0005a	eb bc		 jmp	 SHORT $LN2@del
$LN3@del:

; 517  : 	_stprintf(g_szMessage, " del FAIL! i[%d] m_nMax[%d]", i, m_nMax);

  0005c	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00061	44 8b 48 14	 mov	 r9d, DWORD PTR [rax+20]
  00065	44 8b 44 24 20	 mov	 r8d, DWORD PTR i$[rsp]
  0006a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46738
  00071	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  00078	e8 00 00 00 00	 call	 sprintf

; 518  : 	return false;

  0007d	32 c0		 xor	 al, al
$LN1@del:

; 519  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
?del@?$CTList@VCLogger@@@@QEAA_NPEAVCLogger@@@Z ENDP	; CTList<CLogger>::del
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?IsExist@?$CTList@VCLogger@@@@QEAA_NPEAVCLogger@@@Z
_TEXT	SEGMENT
i$ = 0
this$ = 32
p$ = 40
?IsExist@?$CTList@VCLogger@@@@QEAA_NPEAVCLogger@@@Z PROC ; CTList<CLogger>::IsExist, COMDAT

; 457  : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 458  : 	int i;
; 459  : 	for (i = 0; i < m_nMax; i++)

  0000e	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  00015	eb 08		 jmp	 SHORT $LN4@IsExist
$LN2@IsExist:
  00017	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  0001a	ff c0		 inc	 eax
  0001c	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@IsExist:
  0001f	48 8b 44 24 20	 mov	 rax, QWORD PTR this$[rsp]
  00024	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00027	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  0002a	7d 30		 jge	 SHORT $LN3@IsExist

; 460  : 	{
; 461  : 		if (m_pArray[i]) {

  0002c	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00030	48 8b 4c 24 20	 mov	 rcx, QWORD PTR this$[rsp]
  00035	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00038	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  0003d	74 1b		 je	 SHORT $LN5@IsExist

; 462  : 			if (m_pArray[i] == p) {

  0003f	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00043	48 8b 4c 24 20	 mov	 rcx, QWORD PTR this$[rsp]
  00048	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0004b	48 8b 54 24 28	 mov	 rdx, QWORD PTR p$[rsp]
  00050	48 39 14 c1	 cmp	 QWORD PTR [rcx+rax*8], rdx
  00054	75 04		 jne	 SHORT $LN6@IsExist

; 463  : 				return true;

  00056	b0 01		 mov	 al, 1
  00058	eb 04		 jmp	 SHORT $LN1@IsExist
$LN6@IsExist:
$LN5@IsExist:

; 464  : 			}
; 465  : 		}
; 466  : 	}

  0005a	eb bb		 jmp	 SHORT $LN2@IsExist
$LN3@IsExist:

; 467  : 	return false;

  0005c	32 c0		 xor	 al, al
$LN1@IsExist:

; 468  : }

  0005e	48 83 c4 18	 add	 rsp, 24
  00062	c3		 ret	 0
?IsExist@?$CTList@VCLogger@@@@QEAA_NPEAVCLogger@@@Z ENDP ; CTList<CLogger>::IsExist
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?push_back@?$CTList@VCLogger@@@@QEAA_NPEAVCLogger@@PEAH@Z
_TEXT	SEGMENT
nIdx$ = 32
i$ = 36
this$ = 64
Obj$ = 72
pIdx$ = 80
?push_back@?$CTList@VCLogger@@@@QEAA_NPEAVCLogger@@PEAH@Z PROC ; CTList<CLogger>::push_back, COMDAT

; 472  : {

$LN15:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 473  : 	int nIdx, i;
; 474  : 
; 475  : 	if (m_nUse >= m_nMax) {

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00018	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0001d	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  00020	39 48 08	 cmp	 DWORD PTR [rax+8], ecx
  00023	7c 4b		 jl	 SHORT $LN5@push_back

; 476  : 		if (!__alloc(m_nMax + TLIST_ADD_SIZE)) return false;

  00025	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0002a	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0002d	83 c0 40	 add	 eax, 64			; 00000040H
  00030	8b d0		 mov	 edx, eax
  00032	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00037	e8 00 00 00 00	 call	 ?__alloc@?$CTList@VCLogger@@@@AEAAHH@Z ; CTList<CLogger>::__alloc
  0003c	85 c0		 test	 eax, eax
  0003e	75 07		 jne	 SHORT $LN6@push_back
  00040	32 c0		 xor	 al, al
  00042	e9 0c 01 00 00	 jmp	 $LN1@push_back
$LN6@push_back:

; 477  : 		nIdx = m_nMax;

  00047	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0004c	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0004f	89 44 24 20	 mov	 DWORD PTR nIdx$[rsp], eax

; 478  : 		m_nMax += TLIST_ADD_SIZE;

  00053	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00058	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0005b	83 c0 40	 add	 eax, 64			; 00000040H
  0005e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00063	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 479  : 		goto ADD_SUCCESS;

  00066	e9 99 00 00 00	 jmp	 $LN7@push_back
  0006b	e9 94 00 00 00	 jmp	 $ADD_SUCCESS$16
$LN5@push_back:

; 480  : 	}
; 481  : 
; 482  : 	if (!m_pArray[m_nLast]) { nIdx = m_nLast;  goto ADD_SUCCESS; }

  00070	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00075	48 63 40 0c	 movsxd	 rax, DWORD PTR [rax+12]
  00079	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0007e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00081	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00086	75 10		 jne	 SHORT $LN8@push_back
  00088	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0008d	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00090	89 44 24 20	 mov	 DWORD PTR nIdx$[rsp], eax
  00094	eb 6e		 jmp	 SHORT $LN9@push_back
  00096	eb 6c		 jmp	 SHORT $ADD_SUCCESS$16
$LN8@push_back:

; 483  : 
; 484  : 	nIdx = m_nLast;

  00098	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0009d	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  000a0	89 44 24 20	 mov	 DWORD PTR nIdx$[rsp], eax

; 485  : 	for (i = 0; i < m_nMax; i++)

  000a4	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000ac	eb 0a		 jmp	 SHORT $LN4@push_back
$LN2@push_back:
  000ae	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  000b2	ff c0		 inc	 eax
  000b4	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@push_back:
  000b8	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000bd	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000c0	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  000c4	7d 3a		 jge	 SHORT $LN3@push_back

; 486  : 	{
; 487  : 		if (nIdx >= m_nMax) nIdx = 0;

  000c6	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000cb	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000ce	39 44 24 20	 cmp	 DWORD PTR nIdx$[rsp], eax
  000d2	7c 08		 jl	 SHORT $LN10@push_back
  000d4	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR nIdx$[rsp], 0
$LN10@push_back:

; 488  : 		if (!m_pArray[nIdx]) {

  000dc	48 63 44 24 20	 movsxd	 rax, DWORD PTR nIdx$[rsp]
  000e1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000e6	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000e9	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  000ee	75 04		 jne	 SHORT $LN11@push_back

; 489  : 			goto ADD_SUCCESS;

  000f0	eb 12		 jmp	 SHORT $LN12@push_back
  000f2	eb 10		 jmp	 SHORT $ADD_SUCCESS$16
$LN11@push_back:

; 490  : 		}
; 491  : 		nIdx++;

  000f4	8b 44 24 20	 mov	 eax, DWORD PTR nIdx$[rsp]
  000f8	ff c0		 inc	 eax
  000fa	89 44 24 20	 mov	 DWORD PTR nIdx$[rsp], eax

; 492  : 	}

  000fe	eb ae		 jmp	 SHORT $LN2@push_back
$LN3@push_back:

; 493  : 	//_stprintf(m_szMessage, _T("add FAIL! m_nLast[%d] m_nCurCount[%d] m_nMax[%d]"), m_nLast, m_nUse, m_nMax);
; 494  : 	return false;

  00100	32 c0		 xor	 al, al
  00102	eb 4f		 jmp	 SHORT $LN1@push_back
$LN7@push_back:
$LN9@push_back:
$LN12@push_back:
$ADD_SUCCESS$16:

; 495  : 
; 496  : ADD_SUCCESS:
; 497  : 	m_nUse++;

  00104	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00109	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0010c	ff c0		 inc	 eax
  0010e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00113	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 498  : 	m_pArray[nIdx] = Obj;

  00116	48 63 44 24 20	 movsxd	 rax, DWORD PTR nIdx$[rsp]
  0011b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00120	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00123	48 8b 54 24 48	 mov	 rdx, QWORD PTR Obj$[rsp]
  00128	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx

; 499  : 	m_nLast++;

  0012c	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00131	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00134	ff c0		 inc	 eax
  00136	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0013b	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 500  : 	//_stprintf(g_szMessage, _T("CMemList::add i[%d] m_nLast[%d] m_nCurCount[%d]"), nIdx, m_nLast, m_nUse);
; 501  : 	if (pIdx) *pIdx = nIdx;

  0013e	48 83 7c 24 50
	00		 cmp	 QWORD PTR pIdx$[rsp], 0
  00144	74 0b		 je	 SHORT $LN13@push_back
  00146	48 8b 44 24 50	 mov	 rax, QWORD PTR pIdx$[rsp]
  0014b	8b 4c 24 20	 mov	 ecx, DWORD PTR nIdx$[rsp]
  0014f	89 08		 mov	 DWORD PTR [rax], ecx
$LN13@push_back:

; 502  : 	return true;

  00151	b0 01		 mov	 al, 1
$LN1@push_back:

; 503  : }

  00153	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00157	c3		 ret	 0
?push_back@?$CTList@VCLogger@@@@QEAA_NPEAVCLogger@@PEAH@Z ENDP ; CTList<CLogger>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?alloc@?$CTList@VCLogger@@@@QEAAHHW4E_ALLOC_TYPE@@@Z
_TEXT	SEGMENT
this$ = 48
nMaxCount$ = 56
type$ = 64
?alloc@?$CTList@VCLogger@@@@QEAAHHW4E_ALLOC_TYPE@@@Z PROC ; CTList<CLogger>::alloc, COMDAT

; 326  : 	int alloc(int nMaxCount, E_ALLOC_TYPE type = eAlloc_Type_new) { m_nObjAllocType = type;  m_nMax = __alloc(nMaxCount); return m_nMax; }

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00012	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00017	8b 4c 24 40	 mov	 ecx, DWORD PTR type$[rsp]
  0001b	89 48 18	 mov	 DWORD PTR [rax+24], ecx
  0001e	8b 54 24 38	 mov	 edx, DWORD PTR nMaxCount$[rsp]
  00022	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00027	e8 00 00 00 00	 call	 ?__alloc@?$CTList@VCLogger@@@@AEAAHH@Z ; CTList<CLogger>::__alloc
  0002c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00031	89 41 14	 mov	 DWORD PTR [rcx+20], eax
  00034	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00039	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0003c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00040	c3		 ret	 0
?alloc@?$CTList@VCLogger@@@@QEAAHHW4E_ALLOC_TYPE@@@Z ENDP ; CTList<CLogger>::alloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ??1?$CTList@VCLogger@@@@QEAA@XZ
_TEXT	SEGMENT
tv77 = 32
p$1 = 40
tv144 = 48
$T2 = 56
$T3 = 64
$T4 = 72
tv82 = 80
tv143 = 88
$T5 = 96
tv95 = 104
$T6 = 112
idx$7 = 120
__$ArrayPad$ = 128
this$ = 160
??1?$CTList@VCLogger@@@@QEAA@XZ PROC			; CTList<CLogger>::~CTList<CLogger>, COMDAT

; 376  : {

$LN21:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  0000c	48 c7 44 24 70
	fe ff ff ff	 mov	 QWORD PTR $T6[rsp], -2
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 377  : 	if (!m_pArray) return;

  00027	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0002f	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00033	75 05		 jne	 SHORT $LN6@CTList
  00035	e9 a7 01 00 00	 jmp	 $LN1@CTList
$LN6@CTList:

; 378  : 
; 379  : 	if (ISABLETODELETE(m_nObjAllocType)) {

  0003a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00042	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00045	e8 00 00 00 00	 call	 ?ISABLETODELETE@@YA_NW4E_ALLOC_TYPE@@@Z ; ISABLETODELETE
  0004a	90		 npad	 1
  0004b	0f b6 c0	 movzx	 eax, al
  0004e	85 c0		 test	 eax, eax
  00050	0f 84 5c 01 00
	00		 je	 $LN7@CTList

; 380  : 		int idx = 0;

  00056	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR idx$7[rsp], 0

; 381  : 		T *p = getNext(&idx);

  0005e	48 8d 54 24 78	 lea	 rdx, QWORD PTR idx$7[rsp]
  00063	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0006b	e8 00 00 00 00	 call	 ?getNext@?$CTList@VCLogger@@@@QEAAPEAVCLogger@@PEAH@Z ; CTList<CLogger>::getNext
  00070	90		 npad	 1
  00071	48 89 44 24 28	 mov	 QWORD PTR p$1[rsp], rax
$LN2@CTList:

; 382  : 		while (p) {

  00076	48 83 7c 24 28
	00		 cmp	 QWORD PTR p$1[rsp], 0
  0007c	0f 84 30 01 00
	00		 je	 $LN7@CTList

; 383  : 			idx++;

  00082	8b 44 24 78	 mov	 eax, DWORD PTR idx$7[rsp]
  00086	ff c0		 inc	 eax
  00088	89 44 24 78	 mov	 DWORD PTR idx$7[rsp], eax

; 384  : 			switch (m_nObjAllocType) {

  0008c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00094	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00097	89 44 24 20	 mov	 DWORD PTR tv77[rsp], eax
  0009b	83 7c 24 20 02	 cmp	 DWORD PTR tv77[rsp], 2
  000a0	74 1e		 je	 SHORT $LN8@CTList
  000a2	83 7c 24 20 03	 cmp	 DWORD PTR tv77[rsp], 3
  000a7	74 58		 je	 SHORT $LN9@CTList
  000a9	83 7c 24 20 04	 cmp	 DWORD PTR tv77[rsp], 4
  000ae	74 62		 je	 SHORT $LN10@CTList
  000b0	83 7c 24 20 05	 cmp	 DWORD PTR tv77[rsp], 5
  000b5	0f 84 9e 00 00
	00		 je	 $LN11@CTList
  000bb	e9 d5 00 00 00	 jmp	 $LN4@CTList
$LN8@CTList:

; 385  : 				case eAlloc_Type_new		:	delete p; break;

  000c0	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  000c5	48 89 44 24 48	 mov	 QWORD PTR $T4[rsp], rax
  000ca	48 8b 44 24 48	 mov	 rax, QWORD PTR $T4[rsp]
  000cf	48 89 44 24 38	 mov	 QWORD PTR $T2[rsp], rax
  000d4	48 83 7c 24 38
	00		 cmp	 QWORD PTR $T2[rsp], 0
  000da	74 17		 je	 SHORT $LN16@CTList
  000dc	ba 01 00 00 00	 mov	 edx, 1
  000e1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR $T2[rsp]
  000e6	e8 00 00 00 00	 call	 ??_GCLogger@@QEAAPEAXI@Z
  000eb	90		 npad	 1
  000ec	48 89 44 24 50	 mov	 QWORD PTR tv82[rsp], rax
  000f1	eb 09		 jmp	 SHORT $LN17@CTList
$LN16@CTList:
  000f3	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR tv82[rsp], 0
$LN17@CTList:
  000fc	e9 94 00 00 00	 jmp	 $LN4@CTList
$LN9@CTList:

; 386  : 				case eAlloc_Type_alloc		:	free(p); break;

  00101	48 8b 4c 24 28	 mov	 rcx, QWORD PTR p$1[rsp]
  00106	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  0010c	90		 npad	 1
  0010d	e9 83 00 00 00	 jmp	 $LN4@CTList
$LN10@CTList:

; 387  : 				case eAlloc_Type_BufPool	:	gs_pMMgr->delBuf((char *)p, STRING_SIZE((TCHAR *)p)); break;

  00112	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  00117	48 89 44 24 58	 mov	 QWORD PTR tv143[rsp], rax
  0011c	48 c7 44 24 30
	ff ff ff ff	 mov	 QWORD PTR tv144[rsp], -1
$LL20@CTList:
  00125	48 ff 44 24 30	 inc	 QWORD PTR tv144[rsp]
  0012a	48 8b 44 24 58	 mov	 rax, QWORD PTR tv143[rsp]
  0012f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv144[rsp]
  00134	80 3c 08 00	 cmp	 BYTE PTR [rax+rcx], 0
  00138	75 eb		 jne	 SHORT $LL20@CTList
  0013a	48 8b 44 24 30	 mov	 rax, QWORD PTR tv144[rsp]
  0013f	48 ff c0	 inc	 rax
  00142	44 8b c0	 mov	 r8d, eax
  00145	48 8b 54 24 28	 mov	 rdx, QWORD PTR p$1[rsp]
  0014a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  00151	e8 00 00 00 00	 call	 ?delBuf@CMemManager@@QEAAXPEADH@Z ; CMemManager::delBuf
  00156	90		 npad	 1
  00157	eb 3c		 jmp	 SHORT $LN4@CTList
$LN11@CTList:

; 388  : 				case eAlloc_Type_newArray	:	delete[] p; break;

  00159	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  0015e	48 89 44 24 60	 mov	 QWORD PTR $T5[rsp], rax
  00163	48 8b 44 24 60	 mov	 rax, QWORD PTR $T5[rsp]
  00168	48 89 44 24 40	 mov	 QWORD PTR $T3[rsp], rax
  0016d	48 83 7c 24 40
	00		 cmp	 QWORD PTR $T3[rsp], 0
  00173	74 17		 je	 SHORT $LN18@CTList
  00175	ba 03 00 00 00	 mov	 edx, 3
  0017a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR $T3[rsp]
  0017f	e8 00 00 00 00	 call	 ??_ECLogger@@QEAAPEAXI@Z
  00184	90		 npad	 1
  00185	48 89 44 24 68	 mov	 QWORD PTR tv95[rsp], rax
  0018a	eb 09		 jmp	 SHORT $LN4@CTList
$LN18@CTList:
  0018c	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR tv95[rsp], 0
$LN4@CTList:

; 389  : 				case eAlloc_Type_none		:	break;
; 390  : 				case eAlloc_Type_MemPool	:	break;
; 391  : 			}
; 392  : 			p = getNext(&idx);

  00195	48 8d 54 24 78	 lea	 rdx, QWORD PTR idx$7[rsp]
  0019a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  001a2	e8 00 00 00 00	 call	 ?getNext@?$CTList@VCLogger@@@@QEAAPEAVCLogger@@PEAH@Z ; CTList<CLogger>::getNext
  001a7	90		 npad	 1
  001a8	48 89 44 24 28	 mov	 QWORD PTR p$1[rsp], rax

; 393  : 		}

  001ad	e9 c4 fe ff ff	 jmp	 $LN2@CTList
$LN7@CTList:

; 394  : 	}
; 395  : 
; 396  : 	if (m_pArray)	free(m_pArray);

  001b2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001ba	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  001be	74 12		 je	 SHORT $LN14@CTList
  001c0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001c8	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  001cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  001d1	90		 npad	 1
$LN14@CTList:

; 397  : 	m_pArray = 0;

  001d2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001da	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN1@CTList:

; 398  : }

  001e1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001e9	48 33 cc	 xor	 rcx, rsp
  001ec	e8 00 00 00 00	 call	 __security_check_cookie
  001f1	90		 npad	 1
  001f2	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  001f9	c3		 ret	 0
??1?$CTList@VCLogger@@@@QEAA@XZ ENDP			; CTList<CLogger>::~CTList<CLogger>
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ??0?$CTList@VCLogger@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$CTList@VCLogger@@@@QEAA@XZ PROC			; CTList<CLogger>::CTList<CLogger>, COMDAT

; 365  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 366  : 	m_pArray = NULL;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 367  : 	m_nUse = 0;

  00011	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00016	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0

; 368  : 	m_nLast = 0;

  0001d	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00022	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [rax+12], 0

; 369  : 	m_nDelIdx = 0;

  00029	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0002e	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 370  : 	m_nMax = 0;

  00035	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0003a	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0

; 371  : 	m_nObjAllocType = eAlloc_Type_none;

  00041	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00046	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0

; 372  : }

  0004d	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00052	c3		 ret	 0
??0?$CTList@VCLogger@@@@QEAA@XZ ENDP			; CTList<CLogger>::CTList<CLogger>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$CMemPool@USTEvent@@@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$CMemPool@USTEvent@@@@QEAAPEAXI@Z PROC		; CMemPool<STEvent>::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00012	e8 00 00 00 00	 call	 ??1?$CMemPool@USTEvent@@@@QEAA@XZ ; CMemPool<STEvent>::~CMemPool<STEvent>
  00017	8b 44 24 38	 mov	 eax, DWORD PTR __flags$[rsp]
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 0f		 je	 SHORT $LN2@scalar
  00022	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
??_G?$CMemPool@USTEvent@@@@QEAAPEAXI@Z ENDP		; CMemPool<STEvent>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit2@?$CMemPool@USTEvent@@@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 16
classSize$ = 24
?__autoclassinit2@?$CMemPool@USTEvent@@@@QEAAX_K@Z PROC	; CMemPool<STEvent>::__autoclassinit2, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 8b 7c 24 10	 mov	 rdi, QWORD PTR this$[rsp]
  00010	33 c0		 xor	 eax, eax
  00012	48 8b 4c 24 18	 mov	 rcx, QWORD PTR classSize$[rsp]
  00017	f3 aa		 rep stosb
  00019	5f		 pop	 rdi
  0001a	c3		 ret	 0
?__autoclassinit2@?$CMemPool@USTEvent@@@@QEAAX_K@Z ENDP	; CMemPool<STEvent>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\commempool.h
;	COMDAT ?delMem@?$CMemPool@USTEvent@@@@QEAA_NPEAUSTEvent@@@Z
_TEXT	SEGMENT
tv82 = 32
nIdx$ = 36
$T1 = 40
tv86 = 48
this$ = 80
pUsedMem$ = 88
?delMem@?$CMemPool@USTEvent@@@@QEAA_NPEAUSTEvent@@@Z PROC ; CMemPool<STEvent>::delMem, COMDAT

; 207  : {

$LN10:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 208  : 	int nIdx = int(pUsedMem - m_pChunk);

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00013	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00017	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pUsedMem$[rsp]
  0001c	48 2b c8	 sub	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 c1 f8 05	 sar	 rax, 5
  00026	89 44 24 24	 mov	 DWORD PTR nIdx$[rsp], eax

; 209  : 
; 210  : 	if (ISINCLUDE(nIdx, m_nAllocCount)) {

  0002a	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0002f	8b 50 14	 mov	 edx, DWORD PTR [rax+20]
  00032	8b 4c 24 24	 mov	 ecx, DWORD PTR nIdx$[rsp]
  00036	e8 00 00 00 00	 call	 ?ISINCLUDE@@YA_NHH@Z	; ISINCLUDE
  0003b	0f b6 c0	 movzx	 eax, al
  0003e	85 c0		 test	 eax, eax
  00040	74 2e		 je	 SHORT $LN4@delMem

; 211  : 		m_nFlagArray[nIdx].init();

  00042	48 63 44 24 24	 movsxd	 rax, DWORD PTR nIdx$[rsp]
  00047	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  0004c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0004f	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  00053	48 8b c8	 mov	 rcx, rax
  00056	e8 00 00 00 00	 call	 ?init@win64_atomic@win32@common@@QEAAXXZ ; common::win32::win64_atomic::init

; 212  : 		m_nUseCnt.atomic_decrement();

  0005b	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00060	48 83 c0 08	 add	 rax, 8
  00064	48 8b c8	 mov	 rcx, rax
  00067	e8 00 00 00 00	 call	 ?atomic_decrement@win64_atomic@win32@common@@QEAA_JXZ ; common::win32::win64_atomic::atomic_decrement

; 213  : 		return true;

  0006c	b0 01		 mov	 al, 1
  0006e	eb 71		 jmp	 SHORT $LN1@delMem
$LN4@delMem:

; 214  : 	}
; 215  : 	switch (m_nObjAllocType) {

  00070	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00075	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00078	89 44 24 20	 mov	 DWORD PTR tv82[rsp], eax
  0007c	83 7c 24 20 02	 cmp	 DWORD PTR tv82[rsp], 2
  00081	74 10		 je	 SHORT $LN5@delMem
  00083	83 7c 24 20 03	 cmp	 DWORD PTR tv82[rsp], 3
  00088	74 4a		 je	 SHORT $LN6@delMem
  0008a	83 7c 24 20 05	 cmp	 DWORD PTR tv82[rsp], 5
  0008f	74 02		 je	 SHORT $LN5@delMem
  00091	eb 4c		 jmp	 SHORT $LN2@delMem
$LN5@delMem:

; 216  : 	case eAlloc_Type_new:
; 217  : 	case eAlloc_Type_newArray:	delete pUsedMem; break;

  00093	48 8b 44 24 58	 mov	 rax, QWORD PTR pUsedMem$[rsp]
  00098	48 89 44 24 28	 mov	 QWORD PTR $T1[rsp], rax
  0009d	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  000a2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T1[rsp]
  000a7	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  000ac	48 83 7c 24 28
	00		 cmp	 QWORD PTR $T1[rsp], 0
  000b2	75 0b		 jne	 SHORT $LN8@delMem
  000b4	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tv86[rsp], 0
  000bd	eb 13		 jmp	 SHORT $LN9@delMem
$LN8@delMem:
  000bf	48 c7 44 24 58
	23 81 00 00	 mov	 QWORD PTR pUsedMem$[rsp], 33059 ; 00008123H
  000c8	48 8b 44 24 58	 mov	 rax, QWORD PTR pUsedMem$[rsp]
  000cd	48 89 44 24 30	 mov	 QWORD PTR tv86[rsp], rax
$LN9@delMem:
  000d2	eb 0b		 jmp	 SHORT $LN2@delMem
$LN6@delMem:

; 218  : 	case eAlloc_Type_alloc:	free(pUsedMem); break;

  000d4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pUsedMem$[rsp]
  000d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN2@delMem:

; 219  : 	}
; 220  : 	return false;

  000df	32 c0		 xor	 al, al
$LN1@delMem:

; 221  : }

  000e1	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000e5	c3		 ret	 0
?delMem@?$CMemPool@USTEvent@@@@QEAA_NPEAUSTEvent@@@Z ENDP ; CMemPool<STEvent>::delMem
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\commempool.h
;	COMDAT ?alloc@?$CMemPool@USTEvent@@@@QEAAHHW4E_ALLOC_TYPE@@@Z
_TEXT	SEGMENT
tv132 = 48
$T1 = 56
$T2 = 64
tv93 = 72
$T3 = 80
$T4 = 88
tv138 = 96
$T5 = 104
$T6 = 112
tv167 = 120
$T7 = 128
this$ = 160
nMaxCount$ = 168
Alloc_Type$ = 176
?alloc@?$CMemPool@USTEvent@@@@QEAAHHW4E_ALLOC_TYPE@@@Z PROC ; CMemPool<STEvent>::alloc, COMDAT

; 95   : {

$LN15:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  00015	48 c7 84 24 80
	00 00 00 fe ff
	ff ff		 mov	 QWORD PTR $T7[rsp], -2

; 96   : 	m_nFlagArray = new (std::nothrow) atomic_nr[nMaxCount];

  00021	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR nMaxCount$[rsp]
  00029	48 89 44 24 40	 mov	 QWORD PTR $T2[rsp], rax
  0002e	b8 08 00 00 00	 mov	 eax, 8
  00033	48 f7 64 24 40	 mul	 QWORD PTR $T2[rsp]
  00038	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  0003f	48 0f 40 c1	 cmovo	 rax, rcx
  00043	48 83 c0 08	 add	 rax, 8
  00047	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  0004e	48 0f 42 c1	 cmovb	 rax, rcx
  00052	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00059	48 8b c8	 mov	 rcx, rax
  0005c	e8 00 00 00 00	 call	 ??_U@YAPEAX_KAEBUnothrow_t@std@@@Z ; operator new[]
  00061	48 89 44 24 38	 mov	 QWORD PTR $T1[rsp], rax
  00066	48 83 7c 24 38
	00		 cmp	 QWORD PTR $T1[rsp], 0
  0006c	74 4b		 je	 SHORT $LN10@alloc
  0006e	48 8b 44 24 38	 mov	 rax, QWORD PTR $T1[rsp]
  00073	48 8b 4c 24 40	 mov	 rcx, QWORD PTR $T2[rsp]
  00078	48 89 08	 mov	 QWORD PTR [rax], rcx
  0007b	48 8b 44 24 38	 mov	 rax, QWORD PTR $T1[rsp]
  00080	48 83 c0 08	 add	 rax, 8
  00084	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??1win64_atomic@win32@common@@QEAA@XZ ; common::win32::win64_atomic::~win64_atomic
  0008b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00090	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??0win64_atomic@win32@common@@QEAA@XZ ; common::win32::win64_atomic::win64_atomic
  00097	4c 8b 44 24 40	 mov	 r8, QWORD PTR $T2[rsp]
  0009c	ba 08 00 00 00	 mov	 edx, 8
  000a1	48 8b c8	 mov	 rcx, rax
  000a4	e8 00 00 00 00	 call	 ??_L@YAXPEAX_K1P6AX0@Z2@Z
  000a9	48 8b 44 24 38	 mov	 rax, QWORD PTR $T1[rsp]
  000ae	48 83 c0 08	 add	 rax, 8
  000b2	48 89 44 24 48	 mov	 QWORD PTR tv93[rsp], rax
  000b7	eb 09		 jmp	 SHORT $LN11@alloc
$LN10@alloc:
  000b9	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR tv93[rsp], 0
$LN11@alloc:
  000c2	48 8b 44 24 48	 mov	 rax, QWORD PTR tv93[rsp]
  000c7	48 89 44 24 58	 mov	 QWORD PTR $T4[rsp], rax
  000cc	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000d4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR $T4[rsp]
  000d9	48 89 08	 mov	 QWORD PTR [rax], rcx

; 97   : 	
; 98   : 	if(!m_nFlagArray) {

  000dc	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000e4	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  000e8	75 22		 jne	 SHORT $LN4@alloc

; 99   : 		_stprintf(g_szMessage, _T("atomic_nr[%d] is NULL"), nMaxCount);

  000ea	44 8b 84 24 a8
	00 00 00	 mov	 r8d, DWORD PTR nMaxCount$[rsp]
  000f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG47263
  000f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  00100	e8 00 00 00 00	 call	 sprintf

; 100  : 		return 0;

  00105	33 c0		 xor	 eax, eax
  00107	e9 48 01 00 00	 jmp	 $LN1@alloc
$LN4@alloc:

; 101  : 	}
; 102  : 
; 103  : 	m_nObjAllocType = Alloc_Type;

  0010c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00114	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR Alloc_Type$[rsp]
  0011b	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 104  : 
; 105  : 	switch (m_nObjAllocType) {

  0011e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00126	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00129	89 44 24 30	 mov	 DWORD PTR tv132[rsp], eax
  0012d	83 7c 24 30 02	 cmp	 DWORD PTR tv132[rsp], 2
  00132	74 10		 je	 SHORT $LN5@alloc
  00134	83 7c 24 30 03	 cmp	 DWORD PTR tv132[rsp], 3
  00139	74 55		 je	 SHORT $LN6@alloc
  0013b	83 7c 24 30 05	 cmp	 DWORD PTR tv132[rsp], 5
  00140	74 02		 je	 SHORT $LN5@alloc
  00142	eb 6e		 jmp	 SHORT $LN2@alloc
$LN5@alloc:

; 106  : 	case eAlloc_Type_new		:
; 107  : 	case eAlloc_Type_newArray	:	m_pChunk = new (std::nothrow) MEMTYPE[nMaxCount]; break;

  00144	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR nMaxCount$[rsp]
  0014c	48 89 44 24 60	 mov	 QWORD PTR tv138[rsp], rax
  00151	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00156	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv138[rsp]
  0015b	48 f7 e1	 mul	 rcx
  0015e	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  00165	48 0f 40 c1	 cmovo	 rax, rcx
  00169	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00170	48 8b c8	 mov	 rcx, rax
  00173	e8 00 00 00 00	 call	 ??_U@YAPEAX_KAEBUnothrow_t@std@@@Z ; operator new[]
  00178	48 89 44 24 68	 mov	 QWORD PTR $T5[rsp], rax
  0017d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00185	48 8b 4c 24 68	 mov	 rcx, QWORD PTR $T5[rsp]
  0018a	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx
  0018e	eb 22		 jmp	 SHORT $LN2@alloc
$LN6@alloc:

; 108  : 	case eAlloc_Type_alloc		:	m_pChunk = (MEMTYPE *)calloc(nMaxCount, sizeof(MEMTYPE)); break;

  00190	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR nMaxCount$[rsp]
  00198	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0019d	48 8b c8	 mov	 rcx, rax
  001a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  001a6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  001ae	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax
$LN2@alloc:

; 109  : 	default: break;
; 110  : 	}
; 111  : 
; 112  : 
; 113  :     if(!m_pChunk) {

  001b2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001ba	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  001bf	75 6f		 jne	 SHORT $LN8@alloc

; 114  : 		_stprintf(g_szMessage, _T("m_pChunk is NULL [%d]"), nMaxCount);

  001c1	44 8b 84 24 a8
	00 00 00	 mov	 r8d, DWORD PTR nMaxCount$[rsp]
  001c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG47268
  001d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  001d7	e8 00 00 00 00	 call	 sprintf

; 115  : 		delete[] m_nFlagArray;

  001dc	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001e4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001e7	48 89 44 24 70	 mov	 QWORD PTR $T6[rsp], rax
  001ec	48 8b 44 24 70	 mov	 rax, QWORD PTR $T6[rsp]
  001f1	48 89 44 24 50	 mov	 QWORD PTR $T3[rsp], rax
  001f6	48 83 7c 24 50
	00		 cmp	 QWORD PTR $T3[rsp], 0
  001fc	74 16		 je	 SHORT $LN12@alloc
  001fe	ba 03 00 00 00	 mov	 edx, 3
  00203	48 8b 4c 24 50	 mov	 rcx, QWORD PTR $T3[rsp]
  00208	e8 00 00 00 00	 call	 ??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z
  0020d	48 89 44 24 78	 mov	 QWORD PTR tv167[rsp], rax
  00212	eb 09		 jmp	 SHORT $LN13@alloc
$LN12@alloc:
  00214	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR tv167[rsp], 0
$LN13@alloc:

; 116  : 		m_nFlagArray = NULL;

  0021d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00225	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 117  : 		return 0;

  0022c	33 c0		 xor	 eax, eax
  0022e	eb 24		 jmp	 SHORT $LN1@alloc
$LN8@alloc:

; 118  :     }
; 119  : 
; 120  :     m_nAllocCount   = nMaxCount;

  00230	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00238	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR nMaxCount$[rsp]
  0023f	89 48 14	 mov	 DWORD PTR [rax+20], ecx

; 121  : 	clear();

  00242	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0024a	e8 00 00 00 00	 call	 ?clear@?$CMemPool@USTEvent@@@@QEAAXXZ ; CMemPool<STEvent>::clear

; 122  : 	//_stprintf(m_szMessage, _T("mem allock list m_nAllocCount[%d]"), m_nAllocCount);
; 123  : 	return 1;

  0024f	b8 01 00 00 00	 mov	 eax, 1
$LN1@alloc:

; 124  : }

  00254	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0025b	c3		 ret	 0
?alloc@?$CMemPool@USTEvent@@@@QEAAHHW4E_ALLOC_TYPE@@@Z ENDP ; CMemPool<STEvent>::alloc
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
tv132 = 48
$T1 = 56
$T2 = 64
tv93 = 72
$T3 = 80
$T4 = 88
tv138 = 96
$T5 = 104
$T6 = 112
tv167 = 120
$T7 = 128
this$ = 160
nMaxCount$ = 168
Alloc_Type$ = 176
?dtor$0@?0??alloc@?$CMemPool@USTEvent@@@@QEAAHHW4E_ALLOC_TYPE@@@Z@4HA PROC ; `CMemPool<STEvent>::alloc'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00010	48 8b 4d 38	 mov	 rcx, QWORD PTR $T1[rbp]
  00014	e8 00 00 00 00	 call	 ??_V@YAXPEAXAEBUnothrow_t@std@@@Z ; operator delete[]
  00019	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001d	5d		 pop	 rbp
  0001e	c3		 ret	 0
?dtor$0@?0??alloc@?$CMemPool@USTEvent@@@@QEAAHHW4E_ALLOC_TYPE@@@Z@4HA ENDP ; `CMemPool<STEvent>::alloc'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv132 = 48
$T1 = 56
$T2 = 64
tv93 = 72
$T3 = 80
$T4 = 88
tv138 = 96
$T5 = 104
$T6 = 112
tv167 = 120
$T7 = 128
this$ = 160
nMaxCount$ = 168
Alloc_Type$ = 176
?dtor$0@?0??alloc@?$CMemPool@USTEvent@@@@QEAAHHW4E_ALLOC_TYPE@@@Z@4HA PROC ; `CMemPool<STEvent>::alloc'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00010	48 8b 4d 38	 mov	 rcx, QWORD PTR $T1[rbp]
  00014	e8 00 00 00 00	 call	 ??_V@YAXPEAXAEBUnothrow_t@std@@@Z ; operator delete[]
  00019	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001d	5d		 pop	 rbp
  0001e	c3		 ret	 0
?dtor$0@?0??alloc@?$CMemPool@USTEvent@@@@QEAAHHW4E_ALLOC_TYPE@@@Z@4HA ENDP ; `CMemPool<STEvent>::alloc'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\commempool.h
;	COMDAT ?clear@?$CMemPool@USTEvent@@@@QEAAXXZ
_TEXT	SEGMENT
i$ = 32
this$ = 64
?clear@?$CMemPool@USTEvent@@@@QEAAXXZ PROC		; CMemPool<STEvent>::clear, COMDAT

; 130  : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 131  : 	int i;
; 132  : 	m_nUseCnt.init();

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 83 c0 08	 add	 rax, 8
  00012	48 8b c8	 mov	 rcx, rax
  00015	e8 00 00 00 00	 call	 ?init@win64_atomic@win32@common@@QEAAXXZ ; common::win32::win64_atomic::init

; 133  : 	m_nLastCount = 0;

  0001a	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0001f	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 134  : 	for(i = 0; i < m_nAllocCount; i++)

  00026	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0002e	eb 0a		 jmp	 SHORT $LN4@clear
$LN2@clear:
  00030	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00034	ff c0		 inc	 eax
  00036	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@clear:
  0003a	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0003f	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00042	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00046	7d 1b		 jge	 SHORT $LN3@clear

; 135  : 	{
; 136  : 		m_nFlagArray[i].init();

  00048	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0004d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00052	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00055	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  00059	48 8b c8	 mov	 rcx, rax
  0005c	e8 00 00 00 00	 call	 ?init@win64_atomic@win32@common@@QEAAXXZ ; common::win32::win64_atomic::init

; 137  : 	}

  00061	eb cd		 jmp	 SHORT $LN2@clear
$LN3@clear:

; 138  : }

  00063	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00067	c3		 ret	 0
?clear@?$CMemPool@USTEvent@@@@QEAAXXZ ENDP		; CMemPool<STEvent>::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\commempool.h
;	COMDAT ??1?$CMemPool@USTEvent@@@@QEAA@XZ
_TEXT	SEGMENT
tv78 = 32
$T1 = 40
$T2 = 48
tv73 = 56
$T3 = 64
this$ = 96
??1?$CMemPool@USTEvent@@@@QEAA@XZ PROC			; CMemPool<STEvent>::~CMemPool<STEvent>, COMDAT

; 75   : {

$LN11:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 76   : 	if (m_nFlagArray) {

  00009	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00012	74 4a		 je	 SHORT $LN4@CMemPool

; 77   : 		delete[] m_nFlagArray;

  00014	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00019	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001c	48 89 44 24 30	 mov	 QWORD PTR $T2[rsp], rax
  00021	48 8b 44 24 30	 mov	 rax, QWORD PTR $T2[rsp]
  00026	48 89 44 24 28	 mov	 QWORD PTR $T1[rsp], rax
  0002b	48 83 7c 24 28
	00		 cmp	 QWORD PTR $T1[rsp], 0
  00031	74 16		 je	 SHORT $LN9@CMemPool
  00033	ba 03 00 00 00	 mov	 edx, 3
  00038	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T1[rsp]
  0003d	e8 00 00 00 00	 call	 ??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z
  00042	48 89 44 24 38	 mov	 QWORD PTR tv73[rsp], rax
  00047	eb 09		 jmp	 SHORT $LN10@CMemPool
$LN9@CMemPool:
  00049	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tv73[rsp], 0
$LN10@CMemPool:

; 78   : 		m_nFlagArray = NULL;

  00052	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00057	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN4@CMemPool:

; 79   : 	}
; 80   : 	
; 81   : 	if(m_pChunk) {

  0005e	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00063	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00068	74 59		 je	 SHORT $LN5@CMemPool

; 82   : 		switch (m_nObjAllocType) {

  0006a	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  0006f	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00072	89 44 24 20	 mov	 DWORD PTR tv78[rsp], eax
  00076	83 7c 24 20 02	 cmp	 DWORD PTR tv78[rsp], 2
  0007b	74 10		 je	 SHORT $LN6@CMemPool
  0007d	83 7c 24 20 03	 cmp	 DWORD PTR tv78[rsp], 3
  00082	74 23		 je	 SHORT $LN7@CMemPool
  00084	83 7c 24 20 05	 cmp	 DWORD PTR tv78[rsp], 5
  00089	74 02		 je	 SHORT $LN6@CMemPool
  0008b	eb 29		 jmp	 SHORT $LN2@CMemPool
$LN6@CMemPool:

; 83   : 		case eAlloc_Type_new:		
; 84   : 		case eAlloc_Type_newArray:	delete[] m_pChunk; break;

  0008d	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00092	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00096	48 89 44 24 40	 mov	 QWORD PTR $T3[rsp], rax
  0009b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR $T3[rsp]
  000a0	e8 00 00 00 00	 call	 ??_V@YAXPEAX@Z		; operator delete[]
  000a5	eb 0f		 jmp	 SHORT $LN2@CMemPool
$LN7@CMemPool:

; 85   : 		case eAlloc_Type_alloc:		free(m_pChunk); break;

  000a7	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  000ac	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  000b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN2@CMemPool:

; 86   : 		}
; 87   : 		
; 88   : 		m_pChunk = NULL;

  000b6	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  000bb	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0
$LN5@CMemPool:

; 89   : 	}
; 90   : 
; 91   : }

  000c3	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  000c8	48 83 c0 08	 add	 rax, 8
  000cc	48 8b c8	 mov	 rcx, rax
  000cf	e8 00 00 00 00	 call	 ??1win64_atomic@win32@common@@QEAA@XZ ; common::win32::win64_atomic::~win64_atomic
  000d4	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000d8	c3		 ret	 0
??1?$CMemPool@USTEvent@@@@QEAA@XZ ENDP			; CMemPool<STEvent>::~CMemPool<STEvent>
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\commempool.h
;	COMDAT ??0?$CMemPool@USTEvent@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0?$CMemPool@USTEvent@@@@QEAA@XZ PROC			; CMemPool<STEvent>::CMemPool<STEvent>, COMDAT

; 64   : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 83 c0 08	 add	 rax, 8
  00012	48 8b c8	 mov	 rcx, rax
  00015	e8 00 00 00 00	 call	 ??0win64_atomic@win32@common@@QEAA@XZ ; common::win32::win64_atomic::win64_atomic

; 65   : 	m_nAllocCount = 0;

  0001a	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0001f	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0

; 66   : 	m_nLastCount = 0;

  00026	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0002b	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 67   : 	//memset(m_szMessage, 0 ,LEN_MEM_MESSAGE);
; 68   : 	m_pChunk = NULL;

  00032	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00037	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 69   : 	m_nFlagArray = NULL;

  0003f	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00044	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 70   : 	m_nObjAllocType = eAlloc_Type_none;

  0004b	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00050	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0

; 71   : }

  00057	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0005c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00060	c3		 ret	 0
??0?$CMemPool@USTEvent@@@@QEAA@XZ ENDP			; CMemPool<STEvent>::CMemPool<STEvent>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$CMemPool@USTIntervalInfo@@@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$CMemPool@USTIntervalInfo@@@@QEAAPEAXI@Z PROC	; CMemPool<STIntervalInfo>::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00012	e8 00 00 00 00	 call	 ??1?$CMemPool@USTIntervalInfo@@@@QEAA@XZ ; CMemPool<STIntervalInfo>::~CMemPool<STIntervalInfo>
  00017	8b 44 24 38	 mov	 eax, DWORD PTR __flags$[rsp]
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 0f		 je	 SHORT $LN2@scalar
  00022	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
??_G?$CMemPool@USTIntervalInfo@@@@QEAAPEAXI@Z ENDP	; CMemPool<STIntervalInfo>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit2@?$CMemPool@USTIntervalInfo@@@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 16
classSize$ = 24
?__autoclassinit2@?$CMemPool@USTIntervalInfo@@@@QEAAX_K@Z PROC ; CMemPool<STIntervalInfo>::__autoclassinit2, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 8b 7c 24 10	 mov	 rdi, QWORD PTR this$[rsp]
  00010	33 c0		 xor	 eax, eax
  00012	48 8b 4c 24 18	 mov	 rcx, QWORD PTR classSize$[rsp]
  00017	f3 aa		 rep stosb
  00019	5f		 pop	 rdi
  0001a	c3		 ret	 0
?__autoclassinit2@?$CMemPool@USTIntervalInfo@@@@QEAAX_K@Z ENDP ; CMemPool<STIntervalInfo>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\commempool.h
;	COMDAT ?alloc@?$CMemPool@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z
_TEXT	SEGMENT
tv132 = 48
$T1 = 56
$T2 = 64
tv93 = 72
$T3 = 80
$T4 = 88
tv138 = 96
$T5 = 104
$T6 = 112
tv167 = 120
$T7 = 128
this$ = 160
nMaxCount$ = 168
Alloc_Type$ = 176
?alloc@?$CMemPool@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z PROC ; CMemPool<STIntervalInfo>::alloc, COMDAT

; 95   : {

$LN15:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  00015	48 c7 84 24 80
	00 00 00 fe ff
	ff ff		 mov	 QWORD PTR $T7[rsp], -2

; 96   : 	m_nFlagArray = new (std::nothrow) atomic_nr[nMaxCount];

  00021	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR nMaxCount$[rsp]
  00029	48 89 44 24 40	 mov	 QWORD PTR $T2[rsp], rax
  0002e	b8 08 00 00 00	 mov	 eax, 8
  00033	48 f7 64 24 40	 mul	 QWORD PTR $T2[rsp]
  00038	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  0003f	48 0f 40 c1	 cmovo	 rax, rcx
  00043	48 83 c0 08	 add	 rax, 8
  00047	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  0004e	48 0f 42 c1	 cmovb	 rax, rcx
  00052	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00059	48 8b c8	 mov	 rcx, rax
  0005c	e8 00 00 00 00	 call	 ??_U@YAPEAX_KAEBUnothrow_t@std@@@Z ; operator new[]
  00061	48 89 44 24 38	 mov	 QWORD PTR $T1[rsp], rax
  00066	48 83 7c 24 38
	00		 cmp	 QWORD PTR $T1[rsp], 0
  0006c	74 4b		 je	 SHORT $LN10@alloc
  0006e	48 8b 44 24 38	 mov	 rax, QWORD PTR $T1[rsp]
  00073	48 8b 4c 24 40	 mov	 rcx, QWORD PTR $T2[rsp]
  00078	48 89 08	 mov	 QWORD PTR [rax], rcx
  0007b	48 8b 44 24 38	 mov	 rax, QWORD PTR $T1[rsp]
  00080	48 83 c0 08	 add	 rax, 8
  00084	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??1win64_atomic@win32@common@@QEAA@XZ ; common::win32::win64_atomic::~win64_atomic
  0008b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00090	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??0win64_atomic@win32@common@@QEAA@XZ ; common::win32::win64_atomic::win64_atomic
  00097	4c 8b 44 24 40	 mov	 r8, QWORD PTR $T2[rsp]
  0009c	ba 08 00 00 00	 mov	 edx, 8
  000a1	48 8b c8	 mov	 rcx, rax
  000a4	e8 00 00 00 00	 call	 ??_L@YAXPEAX_K1P6AX0@Z2@Z
  000a9	48 8b 44 24 38	 mov	 rax, QWORD PTR $T1[rsp]
  000ae	48 83 c0 08	 add	 rax, 8
  000b2	48 89 44 24 48	 mov	 QWORD PTR tv93[rsp], rax
  000b7	eb 09		 jmp	 SHORT $LN11@alloc
$LN10@alloc:
  000b9	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR tv93[rsp], 0
$LN11@alloc:
  000c2	48 8b 44 24 48	 mov	 rax, QWORD PTR tv93[rsp]
  000c7	48 89 44 24 58	 mov	 QWORD PTR $T4[rsp], rax
  000cc	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000d4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR $T4[rsp]
  000d9	48 89 08	 mov	 QWORD PTR [rax], rcx

; 97   : 	
; 98   : 	if(!m_nFlagArray) {

  000dc	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000e4	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  000e8	75 22		 jne	 SHORT $LN4@alloc

; 99   : 		_stprintf(g_szMessage, _T("atomic_nr[%d] is NULL"), nMaxCount);

  000ea	44 8b 84 24 a8
	00 00 00	 mov	 r8d, DWORD PTR nMaxCount$[rsp]
  000f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG47187
  000f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  00100	e8 00 00 00 00	 call	 sprintf

; 100  : 		return 0;

  00105	33 c0		 xor	 eax, eax
  00107	e9 48 01 00 00	 jmp	 $LN1@alloc
$LN4@alloc:

; 101  : 	}
; 102  : 
; 103  : 	m_nObjAllocType = Alloc_Type;

  0010c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00114	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR Alloc_Type$[rsp]
  0011b	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 104  : 
; 105  : 	switch (m_nObjAllocType) {

  0011e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00126	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00129	89 44 24 30	 mov	 DWORD PTR tv132[rsp], eax
  0012d	83 7c 24 30 02	 cmp	 DWORD PTR tv132[rsp], 2
  00132	74 10		 je	 SHORT $LN5@alloc
  00134	83 7c 24 30 03	 cmp	 DWORD PTR tv132[rsp], 3
  00139	74 55		 je	 SHORT $LN6@alloc
  0013b	83 7c 24 30 05	 cmp	 DWORD PTR tv132[rsp], 5
  00140	74 02		 je	 SHORT $LN5@alloc
  00142	eb 6e		 jmp	 SHORT $LN2@alloc
$LN5@alloc:

; 106  : 	case eAlloc_Type_new		:
; 107  : 	case eAlloc_Type_newArray	:	m_pChunk = new (std::nothrow) MEMTYPE[nMaxCount]; break;

  00144	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR nMaxCount$[rsp]
  0014c	48 89 44 24 60	 mov	 QWORD PTR tv138[rsp], rax
  00151	b8 28 00 00 00	 mov	 eax, 40			; 00000028H
  00156	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv138[rsp]
  0015b	48 f7 e1	 mul	 rcx
  0015e	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  00165	48 0f 40 c1	 cmovo	 rax, rcx
  00169	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00170	48 8b c8	 mov	 rcx, rax
  00173	e8 00 00 00 00	 call	 ??_U@YAPEAX_KAEBUnothrow_t@std@@@Z ; operator new[]
  00178	48 89 44 24 68	 mov	 QWORD PTR $T5[rsp], rax
  0017d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00185	48 8b 4c 24 68	 mov	 rcx, QWORD PTR $T5[rsp]
  0018a	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx
  0018e	eb 22		 jmp	 SHORT $LN2@alloc
$LN6@alloc:

; 108  : 	case eAlloc_Type_alloc		:	m_pChunk = (MEMTYPE *)calloc(nMaxCount, sizeof(MEMTYPE)); break;

  00190	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR nMaxCount$[rsp]
  00198	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  0019d	48 8b c8	 mov	 rcx, rax
  001a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  001a6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  001ae	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax
$LN2@alloc:

; 109  : 	default: break;
; 110  : 	}
; 111  : 
; 112  : 
; 113  :     if(!m_pChunk) {

  001b2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001ba	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  001bf	75 6f		 jne	 SHORT $LN8@alloc

; 114  : 		_stprintf(g_szMessage, _T("m_pChunk is NULL [%d]"), nMaxCount);

  001c1	44 8b 84 24 a8
	00 00 00	 mov	 r8d, DWORD PTR nMaxCount$[rsp]
  001c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG47192
  001d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  001d7	e8 00 00 00 00	 call	 sprintf

; 115  : 		delete[] m_nFlagArray;

  001dc	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001e4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001e7	48 89 44 24 70	 mov	 QWORD PTR $T6[rsp], rax
  001ec	48 8b 44 24 70	 mov	 rax, QWORD PTR $T6[rsp]
  001f1	48 89 44 24 50	 mov	 QWORD PTR $T3[rsp], rax
  001f6	48 83 7c 24 50
	00		 cmp	 QWORD PTR $T3[rsp], 0
  001fc	74 16		 je	 SHORT $LN12@alloc
  001fe	ba 03 00 00 00	 mov	 edx, 3
  00203	48 8b 4c 24 50	 mov	 rcx, QWORD PTR $T3[rsp]
  00208	e8 00 00 00 00	 call	 ??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z
  0020d	48 89 44 24 78	 mov	 QWORD PTR tv167[rsp], rax
  00212	eb 09		 jmp	 SHORT $LN13@alloc
$LN12@alloc:
  00214	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR tv167[rsp], 0
$LN13@alloc:

; 116  : 		m_nFlagArray = NULL;

  0021d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00225	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 117  : 		return 0;

  0022c	33 c0		 xor	 eax, eax
  0022e	eb 24		 jmp	 SHORT $LN1@alloc
$LN8@alloc:

; 118  :     }
; 119  : 
; 120  :     m_nAllocCount   = nMaxCount;

  00230	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00238	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR nMaxCount$[rsp]
  0023f	89 48 14	 mov	 DWORD PTR [rax+20], ecx

; 121  : 	clear();

  00242	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0024a	e8 00 00 00 00	 call	 ?clear@?$CMemPool@USTIntervalInfo@@@@QEAAXXZ ; CMemPool<STIntervalInfo>::clear

; 122  : 	//_stprintf(m_szMessage, _T("mem allock list m_nAllocCount[%d]"), m_nAllocCount);
; 123  : 	return 1;

  0024f	b8 01 00 00 00	 mov	 eax, 1
$LN1@alloc:

; 124  : }

  00254	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0025b	c3		 ret	 0
?alloc@?$CMemPool@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z ENDP ; CMemPool<STIntervalInfo>::alloc
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
tv132 = 48
$T1 = 56
$T2 = 64
tv93 = 72
$T3 = 80
$T4 = 88
tv138 = 96
$T5 = 104
$T6 = 112
tv167 = 120
$T7 = 128
this$ = 160
nMaxCount$ = 168
Alloc_Type$ = 176
?dtor$0@?0??alloc@?$CMemPool@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z@4HA PROC ; `CMemPool<STIntervalInfo>::alloc'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00010	48 8b 4d 38	 mov	 rcx, QWORD PTR $T1[rbp]
  00014	e8 00 00 00 00	 call	 ??_V@YAXPEAXAEBUnothrow_t@std@@@Z ; operator delete[]
  00019	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001d	5d		 pop	 rbp
  0001e	c3		 ret	 0
?dtor$0@?0??alloc@?$CMemPool@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z@4HA ENDP ; `CMemPool<STIntervalInfo>::alloc'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv132 = 48
$T1 = 56
$T2 = 64
tv93 = 72
$T3 = 80
$T4 = 88
tv138 = 96
$T5 = 104
$T6 = 112
tv167 = 120
$T7 = 128
this$ = 160
nMaxCount$ = 168
Alloc_Type$ = 176
?dtor$0@?0??alloc@?$CMemPool@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z@4HA PROC ; `CMemPool<STIntervalInfo>::alloc'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00010	48 8b 4d 38	 mov	 rcx, QWORD PTR $T1[rbp]
  00014	e8 00 00 00 00	 call	 ??_V@YAXPEAXAEBUnothrow_t@std@@@Z ; operator delete[]
  00019	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001d	5d		 pop	 rbp
  0001e	c3		 ret	 0
?dtor$0@?0??alloc@?$CMemPool@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z@4HA ENDP ; `CMemPool<STIntervalInfo>::alloc'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\commempool.h
;	COMDAT ?clear@?$CMemPool@USTIntervalInfo@@@@QEAAXXZ
_TEXT	SEGMENT
i$ = 32
this$ = 64
?clear@?$CMemPool@USTIntervalInfo@@@@QEAAXXZ PROC	; CMemPool<STIntervalInfo>::clear, COMDAT

; 130  : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 131  : 	int i;
; 132  : 	m_nUseCnt.init();

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 83 c0 08	 add	 rax, 8
  00012	48 8b c8	 mov	 rcx, rax
  00015	e8 00 00 00 00	 call	 ?init@win64_atomic@win32@common@@QEAAXXZ ; common::win32::win64_atomic::init

; 133  : 	m_nLastCount = 0;

  0001a	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0001f	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 134  : 	for(i = 0; i < m_nAllocCount; i++)

  00026	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0002e	eb 0a		 jmp	 SHORT $LN4@clear
$LN2@clear:
  00030	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00034	ff c0		 inc	 eax
  00036	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@clear:
  0003a	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0003f	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00042	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00046	7d 1b		 jge	 SHORT $LN3@clear

; 135  : 	{
; 136  : 		m_nFlagArray[i].init();

  00048	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0004d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00052	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00055	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  00059	48 8b c8	 mov	 rcx, rax
  0005c	e8 00 00 00 00	 call	 ?init@win64_atomic@win32@common@@QEAAXXZ ; common::win32::win64_atomic::init

; 137  : 	}

  00061	eb cd		 jmp	 SHORT $LN2@clear
$LN3@clear:

; 138  : }

  00063	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00067	c3		 ret	 0
?clear@?$CMemPool@USTIntervalInfo@@@@QEAAXXZ ENDP	; CMemPool<STIntervalInfo>::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\commempool.h
;	COMDAT ??1?$CMemPool@USTIntervalInfo@@@@QEAA@XZ
_TEXT	SEGMENT
tv78 = 32
$T1 = 40
$T2 = 48
tv73 = 56
$T3 = 64
this$ = 96
??1?$CMemPool@USTIntervalInfo@@@@QEAA@XZ PROC		; CMemPool<STIntervalInfo>::~CMemPool<STIntervalInfo>, COMDAT

; 75   : {

$LN11:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 76   : 	if (m_nFlagArray) {

  00009	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00012	74 4a		 je	 SHORT $LN4@CMemPool

; 77   : 		delete[] m_nFlagArray;

  00014	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00019	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001c	48 89 44 24 30	 mov	 QWORD PTR $T2[rsp], rax
  00021	48 8b 44 24 30	 mov	 rax, QWORD PTR $T2[rsp]
  00026	48 89 44 24 28	 mov	 QWORD PTR $T1[rsp], rax
  0002b	48 83 7c 24 28
	00		 cmp	 QWORD PTR $T1[rsp], 0
  00031	74 16		 je	 SHORT $LN9@CMemPool
  00033	ba 03 00 00 00	 mov	 edx, 3
  00038	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T1[rsp]
  0003d	e8 00 00 00 00	 call	 ??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z
  00042	48 89 44 24 38	 mov	 QWORD PTR tv73[rsp], rax
  00047	eb 09		 jmp	 SHORT $LN10@CMemPool
$LN9@CMemPool:
  00049	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tv73[rsp], 0
$LN10@CMemPool:

; 78   : 		m_nFlagArray = NULL;

  00052	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00057	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN4@CMemPool:

; 79   : 	}
; 80   : 	
; 81   : 	if(m_pChunk) {

  0005e	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00063	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00068	74 59		 je	 SHORT $LN5@CMemPool

; 82   : 		switch (m_nObjAllocType) {

  0006a	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  0006f	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00072	89 44 24 20	 mov	 DWORD PTR tv78[rsp], eax
  00076	83 7c 24 20 02	 cmp	 DWORD PTR tv78[rsp], 2
  0007b	74 10		 je	 SHORT $LN6@CMemPool
  0007d	83 7c 24 20 03	 cmp	 DWORD PTR tv78[rsp], 3
  00082	74 23		 je	 SHORT $LN7@CMemPool
  00084	83 7c 24 20 05	 cmp	 DWORD PTR tv78[rsp], 5
  00089	74 02		 je	 SHORT $LN6@CMemPool
  0008b	eb 29		 jmp	 SHORT $LN2@CMemPool
$LN6@CMemPool:

; 83   : 		case eAlloc_Type_new:		
; 84   : 		case eAlloc_Type_newArray:	delete[] m_pChunk; break;

  0008d	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00092	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00096	48 89 44 24 40	 mov	 QWORD PTR $T3[rsp], rax
  0009b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR $T3[rsp]
  000a0	e8 00 00 00 00	 call	 ??_V@YAXPEAX@Z		; operator delete[]
  000a5	eb 0f		 jmp	 SHORT $LN2@CMemPool
$LN7@CMemPool:

; 85   : 		case eAlloc_Type_alloc:		free(m_pChunk); break;

  000a7	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  000ac	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  000b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN2@CMemPool:

; 86   : 		}
; 87   : 		
; 88   : 		m_pChunk = NULL;

  000b6	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  000bb	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0
$LN5@CMemPool:

; 89   : 	}
; 90   : 
; 91   : }

  000c3	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  000c8	48 83 c0 08	 add	 rax, 8
  000cc	48 8b c8	 mov	 rcx, rax
  000cf	e8 00 00 00 00	 call	 ??1win64_atomic@win32@common@@QEAA@XZ ; common::win32::win64_atomic::~win64_atomic
  000d4	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000d8	c3		 ret	 0
??1?$CMemPool@USTIntervalInfo@@@@QEAA@XZ ENDP		; CMemPool<STIntervalInfo>::~CMemPool<STIntervalInfo>
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\commempool.h
;	COMDAT ??0?$CMemPool@USTIntervalInfo@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0?$CMemPool@USTIntervalInfo@@@@QEAA@XZ PROC		; CMemPool<STIntervalInfo>::CMemPool<STIntervalInfo>, COMDAT

; 64   : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 83 c0 08	 add	 rax, 8
  00012	48 8b c8	 mov	 rcx, rax
  00015	e8 00 00 00 00	 call	 ??0win64_atomic@win32@common@@QEAA@XZ ; common::win32::win64_atomic::win64_atomic

; 65   : 	m_nAllocCount = 0;

  0001a	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0001f	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0

; 66   : 	m_nLastCount = 0;

  00026	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0002b	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 67   : 	//memset(m_szMessage, 0 ,LEN_MEM_MESSAGE);
; 68   : 	m_pChunk = NULL;

  00032	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00037	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 69   : 	m_nFlagArray = NULL;

  0003f	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00044	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 70   : 	m_nObjAllocType = eAlloc_Type_none;

  0004b	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00050	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0

; 71   : }

  00057	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0005c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00060	c3		 ret	 0
??0?$CMemPool@USTIntervalInfo@@@@QEAA@XZ ENDP		; CMemPool<STIntervalInfo>::CMemPool<STIntervalInfo>
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?setListAllocType@CCoreList@@QEAAXW4E_ALLOC_TYPE@@W4E_SYS_LIST_TYPE@@@Z
_TEXT	SEGMENT
tv64 = 32
this$ = 64
type$ = 72
eListType$ = 80
?setListAllocType@CCoreList@@QEAAXW4E_ALLOC_TYPE@@W4E_SYS_LIST_TYPE@@@Z PROC ; CCoreList::setListAllocType, COMDAT

; 640  : {

$LN9:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 641  : 	switch (eListType)

  00012	8b 44 24 50	 mov	 eax, DWORD PTR eListType$[rsp]
  00016	89 44 24 20	 mov	 DWORD PTR tv64[rsp], eax
  0001a	83 7c 24 20 01	 cmp	 DWORD PTR tv64[rsp], 1
  0001f	74 17		 je	 SHORT $LN4@setListAll
  00021	83 7c 24 20 02	 cmp	 DWORD PTR tv64[rsp], 2
  00026	74 24		 je	 SHORT $LN5@setListAll
  00028	83 7c 24 20 03	 cmp	 DWORD PTR tv64[rsp], 3
  0002d	74 31		 je	 SHORT $LN6@setListAll
  0002f	83 7c 24 20 04	 cmp	 DWORD PTR tv64[rsp], 4
  00034	74 3e		 je	 SHORT $LN7@setListAll
  00036	eb 4d		 jmp	 SHORT $LN2@setListAll
$LN4@setListAll:

; 642  : 	{
; 643  : 	case e_TYPE_THREAD: m_pThreadList->setObjAllocType(type);

  00038	8b 54 24 48	 mov	 edx, DWORD PTR type$[rsp]
  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00041	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00045	e8 00 00 00 00	 call	 ?setObjAllocType@?$CTList@VCComThread@@@@QEAAXW4E_ALLOC_TYPE@@@Z ; CTList<CComThread>::setObjAllocType

; 644  : 		break;

  0004a	eb 39		 jmp	 SHORT $LN2@setListAll
$LN5@setListAll:

; 645  : 	case e_TYPE_THREADQUEUE: m_pEventThreadList->setObjAllocType(type);

  0004c	8b 54 24 48	 mov	 edx, DWORD PTR type$[rsp]
  00050	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00055	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00059	e8 00 00 00 00	 call	 ?setObjAllocType@?$CTList@VCComQueueThread@@@@QEAAXW4E_ALLOC_TYPE@@@Z ; CTList<CComQueueThread>::setObjAllocType

; 646  : 		break;

  0005e	eb 25		 jmp	 SHORT $LN2@setListAll
$LN6@setListAll:

; 647  : 	case e_TYPE_THREADSCHEDULER: m_pSchedulerList->setObjAllocType(type);

  00060	8b 54 24 48	 mov	 edx, DWORD PTR type$[rsp]
  00064	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00069	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0006d	e8 00 00 00 00	 call	 ?setObjAllocType@?$CTList@VCScheduler@@@@QEAAXW4E_ALLOC_TYPE@@@Z ; CTList<CScheduler>::setObjAllocType

; 648  : 		break;

  00072	eb 11		 jmp	 SHORT $LN2@setListAll
$LN7@setListAll:

; 649  : 	case e_TYPE_THREADWRITER: m_pWriterList->setObjAllocType(type);

  00074	8b 54 24 48	 mov	 edx, DWORD PTR type$[rsp]
  00078	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0007d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00080	e8 00 00 00 00	 call	 ?setObjAllocType@?$CTList@VCSTLogger@@@@QEAAXW4E_ALLOC_TYPE@@@Z ; CTList<CSTLogger>::setObjAllocType
$LN2@setListAll:

; 650  : 		break;
; 651  : 	}
; 652  : }

  00085	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00089	c3		 ret	 0
?setListAllocType@CCoreList@@QEAAXW4E_ALLOC_TYPE@@W4E_SYS_LIST_TYPE@@@Z ENDP ; CCoreList::setListAllocType
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?initQueueThread@CCoreList@@QEAA_NHH@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
tv80 = 48
tv143 = 56
$T3 = 64
$T4 = 72
$T5 = 80
szErrorMsg$ = 96
__$ArrayPad$ = 224
this$ = 256
nThreadCount$ = 264
nQueuePoolCount$ = 272
?initQueueThread@CCoreList@@QEAA_NHH@Z PROC		; CCoreList::initQueueThread, COMDAT

; 1237 : {

$LN14:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00015	48 c7 44 24 50
	fe ff ff ff	 mov	 QWORD PTR $T5[rsp], -2
  0001e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00025	48 33 c4	 xor	 rax, rsp
  00028	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1238 : 	char szErrorMsg[128];
; 1239 : 	if (!m_pEventThreadList) {

  00030	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00038	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  0003d	0f 85 bb 00 00
	00		 jne	 $LN2@initQueueT

; 1240 : 		m_pEventThreadList = new CTList<CComQueueThread>();

  00043	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00048	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0004d	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax
  00052	48 83 7c 24 20
	00		 cmp	 QWORD PTR $T1[rsp], 0
  00058	74 20		 je	 SHORT $LN8@initQueueT
  0005a	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0005f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR $T1[rsp]
  00064	e8 00 00 00 00	 call	 ?__autoclassinit2@?$CTList@VCComQueueThread@@@@QEAAX_K@Z
  00069	48 8b 4c 24 20	 mov	 rcx, QWORD PTR $T1[rsp]
  0006e	e8 00 00 00 00	 call	 ??0?$CTList@VCComQueueThread@@@@QEAA@XZ ; CTList<CComQueueThread>::CTList<CComQueueThread>
  00073	48 89 44 24 30	 mov	 QWORD PTR tv80[rsp], rax
  00078	eb 09		 jmp	 SHORT $LN9@initQueueT
$LN8@initQueueT:
  0007a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tv80[rsp], 0
$LN9@initQueueT:
  00083	48 8b 44 24 30	 mov	 rax, QWORD PTR tv80[rsp]
  00088	48 89 44 24 40	 mov	 QWORD PTR $T3[rsp], rax
  0008d	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00095	48 8b 4c 24 40	 mov	 rcx, QWORD PTR $T3[rsp]
  0009a	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 1241 : 		if (!m_pEventThreadList->alloc(nThreadCount+LIST_ADD_COUNT, eAlloc_Type_none)) {

  0009e	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR nThreadCount$[rsp]
  000a5	83 c0 0a	 add	 eax, 10
  000a8	45 33 c0	 xor	 r8d, r8d
  000ab	8b d0		 mov	 edx, eax
  000ad	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000b5	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  000b9	e8 00 00 00 00	 call	 ?alloc@?$CTList@VCComQueueThread@@@@QEAAHHW4E_ALLOC_TYPE@@@Z ; CTList<CComQueueThread>::alloc
  000be	85 c0		 test	 eax, eax
  000c0	75 3c		 jne	 SHORT $LN2@initQueueT

; 1242 : 			sprintf(szErrorMsg, "m_pEventThreadList->alloc(%d)", nThreadCount + LIST_ADD_COUNT);

  000c2	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR nThreadCount$[rsp]
  000c9	83 c0 0a	 add	 eax, 10
  000cc	44 8b c0	 mov	 r8d, eax
  000cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46524
  000d6	48 8d 4c 24 60	 lea	 rcx, QWORD PTR szErrorMsg$[rsp]
  000db	e8 00 00 00 00	 call	 sprintf

; 1243 : 			comErrorPrint(szErrorMsg);

  000e0	41 b8 db 04 00
	00		 mov	 r8d, 1243		; 000004dbH
  000e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46525
  000ed	48 8d 4c 24 60	 lea	 rcx, QWORD PTR szErrorMsg$[rsp]
  000f2	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 1244 : 			return false;

  000f7	32 c0		 xor	 al, al
  000f9	e9 d4 00 00 00	 jmp	 $LN1@initQueueT
$LN2@initQueueT:

; 1245 : 		}
; 1246 : 	}
; 1247 : 	if (nQueuePoolCount)

  000fe	83 bc 24 10 01
	00 00 00	 cmp	 DWORD PTR nQueuePoolCount$[rsp], 0
  00106	0f 84 c4 00 00
	00		 je	 $LN4@initQueueT

; 1248 : 	{
; 1249 : 		if (!m_pEventPool) {

  0010c	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00114	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00119	0f 85 b1 00 00
	00		 jne	 $LN4@initQueueT

; 1250 : 			m_pEventPool = new CMemPool<STEvent>();

  0011f	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00124	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00129	48 89 44 24 28	 mov	 QWORD PTR $T2[rsp], rax
  0012e	48 83 7c 24 28
	00		 cmp	 QWORD PTR $T2[rsp], 0
  00134	74 20		 je	 SHORT $LN10@initQueueT
  00136	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  0013b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T2[rsp]
  00140	e8 00 00 00 00	 call	 ?__autoclassinit2@?$CMemPool@USTEvent@@@@QEAAX_K@Z
  00145	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T2[rsp]
  0014a	e8 00 00 00 00	 call	 ??0?$CMemPool@USTEvent@@@@QEAA@XZ ; CMemPool<STEvent>::CMemPool<STEvent>
  0014f	48 89 44 24 38	 mov	 QWORD PTR tv143[rsp], rax
  00154	eb 09		 jmp	 SHORT $LN11@initQueueT
$LN10@initQueueT:
  00156	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tv143[rsp], 0
$LN11@initQueueT:
  0015f	48 8b 44 24 38	 mov	 rax, QWORD PTR tv143[rsp]
  00164	48 89 44 24 48	 mov	 QWORD PTR $T4[rsp], rax
  00169	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00171	48 8b 4c 24 48	 mov	 rcx, QWORD PTR $T4[rsp]
  00176	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 1251 : 			if (!m_pEventPool->alloc(nQueuePoolCount, eAlloc_Type_alloc)) {

  0017a	41 b8 03 00 00
	00		 mov	 r8d, 3
  00180	8b 94 24 10 01
	00 00		 mov	 edx, DWORD PTR nQueuePoolCount$[rsp]
  00187	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0018f	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00193	e8 00 00 00 00	 call	 ?alloc@?$CMemPool@USTEvent@@@@QEAAHHW4E_ALLOC_TYPE@@@Z ; CMemPool<STEvent>::alloc
  00198	85 c0		 test	 eax, eax
  0019a	75 34		 jne	 SHORT $LN4@initQueueT

; 1252 : 				sprintf(szErrorMsg, "has Failed!! m_pEventPool->alloc(%d)\n", nQueuePoolCount);

  0019c	44 8b 84 24 10
	01 00 00	 mov	 r8d, DWORD PTR nQueuePoolCount$[rsp]
  001a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46530
  001ab	48 8d 4c 24 60	 lea	 rcx, QWORD PTR szErrorMsg$[rsp]
  001b0	e8 00 00 00 00	 call	 sprintf

; 1253 : 				comErrorPrint(szErrorMsg);

  001b5	41 b8 e5 04 00
	00		 mov	 r8d, 1253		; 000004e5H
  001bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46531
  001c2	48 8d 4c 24 60	 lea	 rcx, QWORD PTR szErrorMsg$[rsp]
  001c7	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 1254 : 				return false;

  001cc	32 c0		 xor	 al, al
  001ce	eb 02		 jmp	 SHORT $LN1@initQueueT
$LN4@initQueueT:

; 1255 : 			}
; 1256 : 		}
; 1257 : 
; 1258 : 	}
; 1259 : 	return true;

  001d0	b0 01		 mov	 al, 1
$LN1@initQueueT:

; 1260 : }

  001d2	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001da	48 33 cc	 xor	 rcx, rsp
  001dd	e8 00 00 00 00	 call	 __security_check_cookie
  001e2	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  001e9	c3		 ret	 0
?initQueueThread@CCoreList@@QEAA_NHH@Z ENDP		; CCoreList::initQueueThread
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
tv80 = 48
tv143 = 56
$T3 = 64
$T4 = 72
$T5 = 80
szErrorMsg$ = 96
__$ArrayPad$ = 224
this$ = 256
nThreadCount$ = 264
nQueuePoolCount$ = 272
?dtor$0@?0??initQueueThread@CCoreList@@QEAA_NHH@Z@4HA PROC ; `CCoreList::initQueueThread'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0000e	48 8b 4d 20	 mov	 rcx, QWORD PTR $T1[rbp]
  00012	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5d		 pop	 rbp
  0001c	c3		 ret	 0
?dtor$0@?0??initQueueThread@CCoreList@@QEAA_NHH@Z@4HA ENDP ; `CCoreList::initQueueThread'::`1'::dtor$0
$T1 = 32
$T2 = 40
tv80 = 48
tv143 = 56
$T3 = 64
$T4 = 72
$T5 = 80
szErrorMsg$ = 96
__$ArrayPad$ = 224
this$ = 256
nThreadCount$ = 264
nQueuePoolCount$ = 272
?dtor$1@?0??initQueueThread@CCoreList@@QEAA_NHH@Z@4HA PROC ; `CCoreList::initQueueThread'::`1'::dtor$1
  0001d	40 55		 push	 rbp
  0001f	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00023	48 8b ea	 mov	 rbp, rdx
  00026	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  0002b	48 8b 4d 28	 mov	 rcx, QWORD PTR $T2[rbp]
  0002f	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5d		 pop	 rbp
  00039	c3		 ret	 0
?dtor$1@?0??initQueueThread@CCoreList@@QEAA_NHH@Z@4HA ENDP ; `CCoreList::initQueueThread'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
tv80 = 48
tv143 = 56
$T3 = 64
$T4 = 72
$T5 = 80
szErrorMsg$ = 96
__$ArrayPad$ = 224
this$ = 256
nThreadCount$ = 264
nQueuePoolCount$ = 272
?dtor$0@?0??initQueueThread@CCoreList@@QEAA_NHH@Z@4HA PROC ; `CCoreList::initQueueThread'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0000e	48 8b 4d 20	 mov	 rcx, QWORD PTR $T1[rbp]
  00012	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5d		 pop	 rbp
  0001c	c3		 ret	 0
?dtor$0@?0??initQueueThread@CCoreList@@QEAA_NHH@Z@4HA ENDP ; `CCoreList::initQueueThread'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
tv80 = 48
tv143 = 56
$T3 = 64
$T4 = 72
$T5 = 80
szErrorMsg$ = 96
__$ArrayPad$ = 224
this$ = 256
nThreadCount$ = 264
nQueuePoolCount$ = 272
?dtor$1@?0??initQueueThread@CCoreList@@QEAA_NHH@Z@4HA PROC ; `CCoreList::initQueueThread'::`1'::dtor$1
  0001d	40 55		 push	 rbp
  0001f	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00023	48 8b ea	 mov	 rbp, rdx
  00026	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  0002b	48 8b 4d 28	 mov	 rcx, QWORD PTR $T2[rbp]
  0002f	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5d		 pop	 rbp
  00039	c3		 ret	 0
?dtor$1@?0??initQueueThread@CCoreList@@QEAA_NHH@Z@4HA ENDP ; `CCoreList::initQueueThread'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?initScheduler@CCoreList@@QEAA_NHH@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
tv80 = 48
tv143 = 56
$T3 = 64
$T4 = 72
$T5 = 80
szErrorMsg$ = 96
__$ArrayPad$ = 224
this$ = 256
nThreadCount$ = 264
nSchedulerPoolCount$ = 272
?initScheduler@CCoreList@@QEAA_NHH@Z PROC		; CCoreList::initScheduler, COMDAT

; 1213 : {

$LN14:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00015	48 c7 44 24 50
	fe ff ff ff	 mov	 QWORD PTR $T5[rsp], -2
  0001e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00025	48 33 c4	 xor	 rax, rsp
  00028	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1214 : 	char szErrorMsg[128];
; 1215 : 	if (!m_pSchedulerList) {

  00030	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00038	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0003d	0f 85 bb 00 00
	00		 jne	 $LN2@initSchedu

; 1216 : 		m_pSchedulerList = new CTList<CScheduler>();

  00043	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00048	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0004d	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax
  00052	48 83 7c 24 20
	00		 cmp	 QWORD PTR $T1[rsp], 0
  00058	74 20		 je	 SHORT $LN8@initSchedu
  0005a	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0005f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR $T1[rsp]
  00064	e8 00 00 00 00	 call	 ?__autoclassinit2@?$CTList@VCScheduler@@@@QEAAX_K@Z
  00069	48 8b 4c 24 20	 mov	 rcx, QWORD PTR $T1[rsp]
  0006e	e8 00 00 00 00	 call	 ??0?$CTList@VCScheduler@@@@QEAA@XZ ; CTList<CScheduler>::CTList<CScheduler>
  00073	48 89 44 24 30	 mov	 QWORD PTR tv80[rsp], rax
  00078	eb 09		 jmp	 SHORT $LN9@initSchedu
$LN8@initSchedu:
  0007a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tv80[rsp], 0
$LN9@initSchedu:
  00083	48 8b 44 24 30	 mov	 rax, QWORD PTR tv80[rsp]
  00088	48 89 44 24 40	 mov	 QWORD PTR $T3[rsp], rax
  0008d	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00095	48 8b 4c 24 40	 mov	 rcx, QWORD PTR $T3[rsp]
  0009a	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1217 : 		if (!m_pSchedulerList->alloc(nThreadCount + LIST_ADD_COUNT, eAlloc_Type_none)) {

  0009e	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR nThreadCount$[rsp]
  000a5	83 c0 0a	 add	 eax, 10
  000a8	45 33 c0	 xor	 r8d, r8d
  000ab	8b d0		 mov	 edx, eax
  000ad	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000b5	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  000b9	e8 00 00 00 00	 call	 ?alloc@?$CTList@VCScheduler@@@@QEAAHHW4E_ALLOC_TYPE@@@Z ; CTList<CScheduler>::alloc
  000be	85 c0		 test	 eax, eax
  000c0	75 3c		 jne	 SHORT $LN2@initSchedu

; 1218 : 			sprintf(szErrorMsg, "m_pSchedulerList->alloc(%d)", nThreadCount + LIST_ADD_COUNT);

  000c2	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR nThreadCount$[rsp]
  000c9	83 c0 0a	 add	 eax, 10
  000cc	44 8b c0	 mov	 r8d, eax
  000cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46493
  000d6	48 8d 4c 24 60	 lea	 rcx, QWORD PTR szErrorMsg$[rsp]
  000db	e8 00 00 00 00	 call	 sprintf

; 1219 : 			comErrorPrint(szErrorMsg);

  000e0	41 b8 c3 04 00
	00		 mov	 r8d, 1219		; 000004c3H
  000e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46494
  000ed	48 8d 4c 24 60	 lea	 rcx, QWORD PTR szErrorMsg$[rsp]
  000f2	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 1220 : 			return false;

  000f7	32 c0		 xor	 al, al
  000f9	e9 d4 00 00 00	 jmp	 $LN1@initSchedu
$LN2@initSchedu:

; 1221 : 		}
; 1222 : 	}
; 1223 : 	if (nSchedulerPoolCount) {

  000fe	83 bc 24 10 01
	00 00 00	 cmp	 DWORD PTR nSchedulerPoolCount$[rsp], 0
  00106	0f 84 c4 00 00
	00		 je	 $LN4@initSchedu

; 1224 : 		if (!m_pIntervalPool) {

  0010c	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00114	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00119	0f 85 b1 00 00
	00		 jne	 $LN4@initSchedu

; 1225 : 			m_pIntervalPool = new CMemPool<STIntervalInfo>();

  0011f	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00124	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00129	48 89 44 24 28	 mov	 QWORD PTR $T2[rsp], rax
  0012e	48 83 7c 24 28
	00		 cmp	 QWORD PTR $T2[rsp], 0
  00134	74 20		 je	 SHORT $LN10@initSchedu
  00136	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  0013b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T2[rsp]
  00140	e8 00 00 00 00	 call	 ?__autoclassinit2@?$CMemPool@USTIntervalInfo@@@@QEAAX_K@Z
  00145	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T2[rsp]
  0014a	e8 00 00 00 00	 call	 ??0?$CMemPool@USTIntervalInfo@@@@QEAA@XZ ; CMemPool<STIntervalInfo>::CMemPool<STIntervalInfo>
  0014f	48 89 44 24 38	 mov	 QWORD PTR tv143[rsp], rax
  00154	eb 09		 jmp	 SHORT $LN11@initSchedu
$LN10@initSchedu:
  00156	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tv143[rsp], 0
$LN11@initSchedu:
  0015f	48 8b 44 24 38	 mov	 rax, QWORD PTR tv143[rsp]
  00164	48 89 44 24 48	 mov	 QWORD PTR $T4[rsp], rax
  00169	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00171	48 8b 4c 24 48	 mov	 rcx, QWORD PTR $T4[rsp]
  00176	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 1226 : 			if (!m_pIntervalPool->alloc(nSchedulerPoolCount, eAlloc_Type_alloc)) {

  0017a	41 b8 03 00 00
	00		 mov	 r8d, 3
  00180	8b 94 24 10 01
	00 00		 mov	 edx, DWORD PTR nSchedulerPoolCount$[rsp]
  00187	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0018f	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  00193	e8 00 00 00 00	 call	 ?alloc@?$CMemPool@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z ; CMemPool<STIntervalInfo>::alloc
  00198	85 c0		 test	 eax, eax
  0019a	75 34		 jne	 SHORT $LN4@initSchedu

; 1227 : 				sprintf(szErrorMsg, "has Failed!! m_pIntervalPool->alloc(%d)\n", nSchedulerPoolCount);

  0019c	44 8b 84 24 10
	01 00 00	 mov	 r8d, DWORD PTR nSchedulerPoolCount$[rsp]
  001a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46499
  001ab	48 8d 4c 24 60	 lea	 rcx, QWORD PTR szErrorMsg$[rsp]
  001b0	e8 00 00 00 00	 call	 sprintf

; 1228 : 				comErrorPrint(szErrorMsg);

  001b5	41 b8 cc 04 00
	00		 mov	 r8d, 1228		; 000004ccH
  001bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46500
  001c2	48 8d 4c 24 60	 lea	 rcx, QWORD PTR szErrorMsg$[rsp]
  001c7	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 1229 : 				return false;

  001cc	32 c0		 xor	 al, al
  001ce	eb 02		 jmp	 SHORT $LN1@initSchedu
$LN4@initSchedu:

; 1230 : 			}
; 1231 : 		}
; 1232 : 	}
; 1233 : 	return true;

  001d0	b0 01		 mov	 al, 1
$LN1@initSchedu:

; 1234 : }

  001d2	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001da	48 33 cc	 xor	 rcx, rsp
  001dd	e8 00 00 00 00	 call	 __security_check_cookie
  001e2	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  001e9	c3		 ret	 0
?initScheduler@CCoreList@@QEAA_NHH@Z ENDP		; CCoreList::initScheduler
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
tv80 = 48
tv143 = 56
$T3 = 64
$T4 = 72
$T5 = 80
szErrorMsg$ = 96
__$ArrayPad$ = 224
this$ = 256
nThreadCount$ = 264
nSchedulerPoolCount$ = 272
?dtor$0@?0??initScheduler@CCoreList@@QEAA_NHH@Z@4HA PROC ; `CCoreList::initScheduler'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0000e	48 8b 4d 20	 mov	 rcx, QWORD PTR $T1[rbp]
  00012	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5d		 pop	 rbp
  0001c	c3		 ret	 0
?dtor$0@?0??initScheduler@CCoreList@@QEAA_NHH@Z@4HA ENDP ; `CCoreList::initScheduler'::`1'::dtor$0
$T1 = 32
$T2 = 40
tv80 = 48
tv143 = 56
$T3 = 64
$T4 = 72
$T5 = 80
szErrorMsg$ = 96
__$ArrayPad$ = 224
this$ = 256
nThreadCount$ = 264
nSchedulerPoolCount$ = 272
?dtor$1@?0??initScheduler@CCoreList@@QEAA_NHH@Z@4HA PROC ; `CCoreList::initScheduler'::`1'::dtor$1
  0001d	40 55		 push	 rbp
  0001f	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00023	48 8b ea	 mov	 rbp, rdx
  00026	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  0002b	48 8b 4d 28	 mov	 rcx, QWORD PTR $T2[rbp]
  0002f	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5d		 pop	 rbp
  00039	c3		 ret	 0
?dtor$1@?0??initScheduler@CCoreList@@QEAA_NHH@Z@4HA ENDP ; `CCoreList::initScheduler'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
tv80 = 48
tv143 = 56
$T3 = 64
$T4 = 72
$T5 = 80
szErrorMsg$ = 96
__$ArrayPad$ = 224
this$ = 256
nThreadCount$ = 264
nSchedulerPoolCount$ = 272
?dtor$0@?0??initScheduler@CCoreList@@QEAA_NHH@Z@4HA PROC ; `CCoreList::initScheduler'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0000e	48 8b 4d 20	 mov	 rcx, QWORD PTR $T1[rbp]
  00012	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5d		 pop	 rbp
  0001c	c3		 ret	 0
?dtor$0@?0??initScheduler@CCoreList@@QEAA_NHH@Z@4HA ENDP ; `CCoreList::initScheduler'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
tv80 = 48
tv143 = 56
$T3 = 64
$T4 = 72
$T5 = 80
szErrorMsg$ = 96
__$ArrayPad$ = 224
this$ = 256
nThreadCount$ = 264
nSchedulerPoolCount$ = 272
?dtor$1@?0??initScheduler@CCoreList@@QEAA_NHH@Z@4HA PROC ; `CCoreList::initScheduler'::`1'::dtor$1
  0001d	40 55		 push	 rbp
  0001f	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00023	48 8b ea	 mov	 rbp, rdx
  00026	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  0002b	48 8b 4d 28	 mov	 rcx, QWORD PTR $T2[rbp]
  0002f	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5d		 pop	 rbp
  00039	c3		 ret	 0
?dtor$1@?0??initScheduler@CCoreList@@QEAA_NHH@Z@4HA ENDP ; `CCoreList::initScheduler'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?initLogWriter@CCoreList@@QEAA_NH@Z
_TEXT	SEGMENT
$T1 = 32
tv79 = 40
$T2 = 48
$T3 = 56
szErrorMsg$ = 64
__$ArrayPad$ = 192
this$ = 224
nThreadCount$ = 232
?initLogWriter@CCoreList@@QEAA_NH@Z PROC		; CCoreList::initLogWriter, COMDAT

; 1200 : {

$LN8:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00010	48 c7 44 24 38
	fe ff ff ff	 mov	 QWORD PTR $T3[rsp], -2
  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00020	48 33 c4	 xor	 rax, rsp
  00023	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1201 : 	char szErrorMsg[128];
; 1202 : 	if (!m_pWriterList) {

  0002b	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00033	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00037	0f 85 ae 00 00
	00		 jne	 $LN2@initLogWri

; 1203 : 		m_pWriterList = new (std::nothrow) CTList<CSTLogger>();

  0003d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00044	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00049	e8 00 00 00 00	 call	 ??2@YAPEAX_KAEBUnothrow_t@std@@@Z ; operator new
  0004e	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax
  00053	48 83 7c 24 20
	00		 cmp	 QWORD PTR $T1[rsp], 0
  00059	74 11		 je	 SHORT $LN5@initLogWri
  0005b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR $T1[rsp]
  00060	e8 00 00 00 00	 call	 ??0?$CTList@VCSTLogger@@@@QEAA@XZ ; CTList<CSTLogger>::CTList<CSTLogger>
  00065	48 89 44 24 28	 mov	 QWORD PTR tv79[rsp], rax
  0006a	eb 09		 jmp	 SHORT $LN6@initLogWri
$LN5@initLogWri:
  0006c	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR tv79[rsp], 0
$LN6@initLogWri:
  00075	48 8b 44 24 28	 mov	 rax, QWORD PTR tv79[rsp]
  0007a	48 89 44 24 30	 mov	 QWORD PTR $T2[rsp], rax
  0007f	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00087	48 8b 4c 24 30	 mov	 rcx, QWORD PTR $T2[rsp]
  0008c	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1204 : 		if (!m_pWriterList->alloc(nThreadCount + LIST_ADD_COUNT, eAlloc_Type_none)) {

  0008f	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR nThreadCount$[rsp]
  00096	83 c0 0a	 add	 eax, 10
  00099	45 33 c0	 xor	 r8d, r8d
  0009c	8b d0		 mov	 edx, eax
  0009e	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000a6	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000a9	e8 00 00 00 00	 call	 ?alloc@?$CTList@VCSTLogger@@@@QEAAHHW4E_ALLOC_TYPE@@@Z ; CTList<CSTLogger>::alloc
  000ae	85 c0		 test	 eax, eax
  000b0	75 39		 jne	 SHORT $LN2@initLogWri

; 1205 : 			sprintf(szErrorMsg, "m_pWriterList->alloc(%d)", nThreadCount + LIST_ADD_COUNT);

  000b2	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR nThreadCount$[rsp]
  000b9	83 c0 0a	 add	 eax, 10
  000bc	44 8b c0	 mov	 r8d, eax
  000bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46474
  000c6	48 8d 4c 24 40	 lea	 rcx, QWORD PTR szErrorMsg$[rsp]
  000cb	e8 00 00 00 00	 call	 sprintf

; 1206 : 			comErrorPrint(szErrorMsg);

  000d0	41 b8 b6 04 00
	00		 mov	 r8d, 1206		; 000004b6H
  000d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46475
  000dd	48 8d 4c 24 40	 lea	 rcx, QWORD PTR szErrorMsg$[rsp]
  000e2	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 1207 : 			return false;

  000e7	32 c0		 xor	 al, al
  000e9	eb 02		 jmp	 SHORT $LN1@initLogWri
$LN2@initLogWri:

; 1208 : 		}
; 1209 : 	}
; 1210 : 	return true;

  000eb	b0 01		 mov	 al, 1
$LN1@initLogWri:

; 1211 : }

  000ed	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000f5	48 33 cc	 xor	 rcx, rsp
  000f8	e8 00 00 00 00	 call	 __security_check_cookie
  000fd	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  00104	c3		 ret	 0
?initLogWriter@CCoreList@@QEAA_NH@Z ENDP		; CCoreList::initLogWriter
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv79 = 40
$T2 = 48
$T3 = 56
szErrorMsg$ = 64
__$ArrayPad$ = 192
this$ = 224
nThreadCount$ = 232
?dtor$0@?0??initLogWriter@CCoreList@@QEAA_NH@Z@4HA PROC	; `CCoreList::initLogWriter'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00010	48 8b 4d 20	 mov	 rcx, QWORD PTR $T1[rbp]
  00014	e8 00 00 00 00	 call	 ??3@YAXPEAXAEBUnothrow_t@std@@@Z ; operator delete
  00019	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001d	5d		 pop	 rbp
  0001e	c3		 ret	 0
?dtor$0@?0??initLogWriter@CCoreList@@QEAA_NH@Z@4HA ENDP	; `CCoreList::initLogWriter'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv79 = 40
$T2 = 48
$T3 = 56
szErrorMsg$ = 64
__$ArrayPad$ = 192
this$ = 224
nThreadCount$ = 232
?dtor$0@?0??initLogWriter@CCoreList@@QEAA_NH@Z@4HA PROC	; `CCoreList::initLogWriter'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00010	48 8b 4d 20	 mov	 rcx, QWORD PTR $T1[rbp]
  00014	e8 00 00 00 00	 call	 ??3@YAXPEAXAEBUnothrow_t@std@@@Z ; operator delete
  00019	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001d	5d		 pop	 rbp
  0001e	c3		 ret	 0
?dtor$0@?0??initLogWriter@CCoreList@@QEAA_NH@Z@4HA ENDP	; `CCoreList::initLogWriter'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?initComThread@CCoreList@@QEAA_NH@Z
_TEXT	SEGMENT
$T1 = 32
tv79 = 40
$T2 = 48
$T3 = 56
szErrorMsg$ = 64
__$ArrayPad$ = 192
this$ = 224
nThreadCount$ = 232
?initComThread@CCoreList@@QEAA_NH@Z PROC		; CCoreList::initComThread, COMDAT

; 1186 : {

$LN8:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00010	48 c7 44 24 38
	fe ff ff ff	 mov	 QWORD PTR $T3[rsp], -2
  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00020	48 33 c4	 xor	 rax, rsp
  00023	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1187 : 	char szErrorMsg[128];
; 1188 : 
; 1189 : 	if (!m_pThreadList) {

  0002b	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00033	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00038	0f 85 b0 00 00
	00		 jne	 $LN2@initComThr

; 1190 : 		m_pThreadList = new (std::nothrow) CTList<CComThread>();

  0003e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00045	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0004a	e8 00 00 00 00	 call	 ??2@YAPEAX_KAEBUnothrow_t@std@@@Z ; operator new
  0004f	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax
  00054	48 83 7c 24 20
	00		 cmp	 QWORD PTR $T1[rsp], 0
  0005a	74 11		 je	 SHORT $LN5@initComThr
  0005c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR $T1[rsp]
  00061	e8 00 00 00 00	 call	 ??0?$CTList@VCComThread@@@@QEAA@XZ ; CTList<CComThread>::CTList<CComThread>
  00066	48 89 44 24 28	 mov	 QWORD PTR tv79[rsp], rax
  0006b	eb 09		 jmp	 SHORT $LN6@initComThr
$LN5@initComThr:
  0006d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR tv79[rsp], 0
$LN6@initComThr:
  00076	48 8b 44 24 28	 mov	 rax, QWORD PTR tv79[rsp]
  0007b	48 89 44 24 30	 mov	 QWORD PTR $T2[rsp], rax
  00080	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00088	48 8b 4c 24 30	 mov	 rcx, QWORD PTR $T2[rsp]
  0008d	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 1191 : 		if (!m_pThreadList->alloc(nThreadCount + LIST_ADD_COUNT, eAlloc_Type_none)) {

  00091	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR nThreadCount$[rsp]
  00098	83 c0 0a	 add	 eax, 10
  0009b	45 33 c0	 xor	 r8d, r8d
  0009e	8b d0		 mov	 edx, eax
  000a0	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000a8	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  000ac	e8 00 00 00 00	 call	 ?alloc@?$CTList@VCComThread@@@@QEAAHHW4E_ALLOC_TYPE@@@Z ; CTList<CComThread>::alloc
  000b1	85 c0		 test	 eax, eax
  000b3	75 39		 jne	 SHORT $LN2@initComThr

; 1192 : 			sprintf(szErrorMsg, "m_pThreadList->alloc(%d)", nThreadCount + LIST_ADD_COUNT);

  000b5	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR nThreadCount$[rsp]
  000bc	83 c0 0a	 add	 eax, 10
  000bf	44 8b c0	 mov	 r8d, eax
  000c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46458
  000c9	48 8d 4c 24 40	 lea	 rcx, QWORD PTR szErrorMsg$[rsp]
  000ce	e8 00 00 00 00	 call	 sprintf

; 1193 : 			comErrorPrint(szErrorMsg);

  000d3	41 b8 a9 04 00
	00		 mov	 r8d, 1193		; 000004a9H
  000d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46459
  000e0	48 8d 4c 24 40	 lea	 rcx, QWORD PTR szErrorMsg$[rsp]
  000e5	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 1194 : 			return false;

  000ea	32 c0		 xor	 al, al
  000ec	eb 02		 jmp	 SHORT $LN1@initComThr
$LN2@initComThr:

; 1195 : 		}
; 1196 : 	}
; 1197 : 	return true;

  000ee	b0 01		 mov	 al, 1
$LN1@initComThr:

; 1198 : }

  000f0	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000f8	48 33 cc	 xor	 rcx, rsp
  000fb	e8 00 00 00 00	 call	 __security_check_cookie
  00100	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  00107	c3		 ret	 0
?initComThread@CCoreList@@QEAA_NH@Z ENDP		; CCoreList::initComThread
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv79 = 40
$T2 = 48
$T3 = 56
szErrorMsg$ = 64
__$ArrayPad$ = 192
this$ = 224
nThreadCount$ = 232
?dtor$0@?0??initComThread@CCoreList@@QEAA_NH@Z@4HA PROC	; `CCoreList::initComThread'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00010	48 8b 4d 20	 mov	 rcx, QWORD PTR $T1[rbp]
  00014	e8 00 00 00 00	 call	 ??3@YAXPEAXAEBUnothrow_t@std@@@Z ; operator delete
  00019	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001d	5d		 pop	 rbp
  0001e	c3		 ret	 0
?dtor$0@?0??initComThread@CCoreList@@QEAA_NH@Z@4HA ENDP	; `CCoreList::initComThread'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv79 = 40
$T2 = 48
$T3 = 56
szErrorMsg$ = 64
__$ArrayPad$ = 192
this$ = 224
nThreadCount$ = 232
?dtor$0@?0??initComThread@CCoreList@@QEAA_NH@Z@4HA PROC	; `CCoreList::initComThread'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00010	48 8b 4d 20	 mov	 rcx, QWORD PTR $T1[rbp]
  00014	e8 00 00 00 00	 call	 ??3@YAXPEAXAEBUnothrow_t@std@@@Z ; operator delete
  00019	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001d	5d		 pop	 rbp
  0001e	c3		 ret	 0
?dtor$0@?0??initComThread@CCoreList@@QEAA_NH@Z@4HA ENDP	; `CCoreList::initComThread'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?initQueueThread@CCoreList@@QEAA_NPEAD0@Z
_TEXT	SEGMENT
i$ = 32
nCount$ = 36
nMax$ = 40
pEventThread$ = 48
nTmp$ = 56
$T1 = 64
$T2 = 72
tv84 = 80
tv145 = 88
$T3 = 96
tv167 = 104
$T4 = 112
$T5 = 120
$T6 = 128
$T7 = 136
idx$ = 144
__$ArrayPad$ = 152
this$ = 176
pConfigFile$ = 184
pSection$ = 192
?initQueueThread@CCoreList@@QEAA_NPEAD0@Z PROC		; CCoreList::initQueueThread, COMDAT

; 787  : {

$LN21:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00016	48 c7 84 24 88
	00 00 00 fe ff
	ff ff		 mov	 QWORD PTR $T7[rsp], -2
  00022	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00029	48 33 c4	 xor	 rax, rsp
  0002c	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 788  : 	int nCount, i, nMax, idx, nTmp;
; 789  : 	CComQueueThread *pEventThread;
; 790  : 	nCount = GetPrivateProfileInt(pSection, _T("LIST_COUNT"), 0, pConfigFile);

  00034	4c 8b 8c 24 b8
	00 00 00	 mov	 r9, QWORD PTR pConfigFile$[rsp]
  0003c	45 33 c0	 xor	 r8d, r8d
  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46153
  00046	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pSection$[rsp]
  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetPrivateProfileIntA
  00054	89 44 24 24	 mov	 DWORD PTR nCount$[rsp], eax

; 791  : 	if (nCount)

  00058	83 7c 24 24 00	 cmp	 DWORD PTR nCount$[rsp], 0
  0005d	0f 84 71 02 00
	00		 je	 $LN5@initQueueT

; 792  : 	{
; 793  : 		m_pEventThreadList = new CTList<CComQueueThread>();

  00063	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00068	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0006d	48 89 44 24 40	 mov	 QWORD PTR $T1[rsp], rax
  00072	48 83 7c 24 40
	00		 cmp	 QWORD PTR $T1[rsp], 0
  00078	74 20		 je	 SHORT $LN12@initQueueT
  0007a	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0007f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR $T1[rsp]
  00084	e8 00 00 00 00	 call	 ?__autoclassinit2@?$CTList@VCComQueueThread@@@@QEAAX_K@Z
  00089	48 8b 4c 24 40	 mov	 rcx, QWORD PTR $T1[rsp]
  0008e	e8 00 00 00 00	 call	 ??0?$CTList@VCComQueueThread@@@@QEAA@XZ ; CTList<CComQueueThread>::CTList<CComQueueThread>
  00093	48 89 44 24 50	 mov	 QWORD PTR tv84[rsp], rax
  00098	eb 09		 jmp	 SHORT $LN13@initQueueT
$LN12@initQueueT:
  0009a	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR tv84[rsp], 0
$LN13@initQueueT:
  000a3	48 8b 44 24 50	 mov	 rax, QWORD PTR tv84[rsp]
  000a8	48 89 44 24 70	 mov	 QWORD PTR $T4[rsp], rax
  000ad	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000b5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR $T4[rsp]
  000ba	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 794  : 		if (!m_pEventThreadList->alloc(nCount + LIST_ADD_COUNT, eAlloc_Type_none)) {

  000be	8b 44 24 24	 mov	 eax, DWORD PTR nCount$[rsp]
  000c2	83 c0 0a	 add	 eax, 10
  000c5	45 33 c0	 xor	 r8d, r8d
  000c8	8b d0		 mov	 edx, eax
  000ca	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000d2	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  000d6	e8 00 00 00 00	 call	 ?alloc@?$CTList@VCComQueueThread@@@@QEAAHHW4E_ALLOC_TYPE@@@Z ; CTList<CComQueueThread>::alloc
  000db	85 c0		 test	 eax, eax
  000dd	75 13		 jne	 SHORT $LN6@initQueueT

; 795  : 			printf("has Failed!! m_pEventThreadList = new CTList<CComQueueThread>()\n");

  000df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG46157
  000e6	e8 00 00 00 00	 call	 printf

; 796  : 			return false;

  000eb	32 c0		 xor	 al, al
  000ed	e9 e4 01 00 00	 jmp	 $LN1@initQueueT
$LN6@initQueueT:

; 797  : 		}
; 798  : 		nTmp = nCount * 20;

  000f2	6b 44 24 24 14	 imul	 eax, DWORD PTR nCount$[rsp], 20
  000f7	89 44 24 38	 mov	 DWORD PTR nTmp$[rsp], eax

; 799  : 		nMax = GetPrivateProfileInt(pSection, _T("EVENT_POOL_MAX"), nTmp, pConfigFile) + CORE_PLUS_POOL_COUNT;

  000fb	4c 8b 8c 24 b8
	00 00 00	 mov	 r9, QWORD PTR pConfigFile$[rsp]
  00103	44 8b 44 24 38	 mov	 r8d, DWORD PTR nTmp$[rsp]
  00108	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46158
  0010f	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pSection$[rsp]
  00117	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetPrivateProfileIntA
  0011d	83 c0 0a	 add	 eax, 10
  00120	89 44 24 28	 mov	 DWORD PTR nMax$[rsp], eax

; 800  : 		m_pEventPool = new CMemPool<STEvent>();

  00124	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00129	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0012e	48 89 44 24 48	 mov	 QWORD PTR $T2[rsp], rax
  00133	48 83 7c 24 48
	00		 cmp	 QWORD PTR $T2[rsp], 0
  00139	74 20		 je	 SHORT $LN14@initQueueT
  0013b	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  00140	48 8b 4c 24 48	 mov	 rcx, QWORD PTR $T2[rsp]
  00145	e8 00 00 00 00	 call	 ?__autoclassinit2@?$CMemPool@USTEvent@@@@QEAAX_K@Z
  0014a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR $T2[rsp]
  0014f	e8 00 00 00 00	 call	 ??0?$CMemPool@USTEvent@@@@QEAA@XZ ; CMemPool<STEvent>::CMemPool<STEvent>
  00154	48 89 44 24 58	 mov	 QWORD PTR tv145[rsp], rax
  00159	eb 09		 jmp	 SHORT $LN15@initQueueT
$LN14@initQueueT:
  0015b	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR tv145[rsp], 0
$LN15@initQueueT:
  00164	48 8b 44 24 58	 mov	 rax, QWORD PTR tv145[rsp]
  00169	48 89 44 24 78	 mov	 QWORD PTR $T5[rsp], rax
  0016e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00176	48 8b 4c 24 78	 mov	 rcx, QWORD PTR $T5[rsp]
  0017b	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 801  : 		if (!m_pEventPool->alloc(nMax, eAlloc_Type_alloc)) {

  0017f	41 b8 03 00 00
	00		 mov	 r8d, 3
  00185	8b 54 24 28	 mov	 edx, DWORD PTR nMax$[rsp]
  00189	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00191	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00195	e8 00 00 00 00	 call	 ?alloc@?$CMemPool@USTEvent@@@@QEAAHHW4E_ALLOC_TYPE@@@Z ; CMemPool<STEvent>::alloc
  0019a	85 c0		 test	 eax, eax
  0019c	75 17		 jne	 SHORT $LN7@initQueueT

; 802  : 			printf("has Failed!! m_pEventPool.alloc(%d)\n", nMax);

  0019e	8b 54 24 28	 mov	 edx, DWORD PTR nMax$[rsp]
  001a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG46161
  001a9	e8 00 00 00 00	 call	 printf

; 803  : 			return false;

  001ae	32 c0		 xor	 al, al
  001b0	e9 21 01 00 00	 jmp	 $LN1@initQueueT
$LN7@initQueueT:

; 804  : 		}
; 805  : 		for (i = 0; i < nCount; i++) {

  001b5	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001bd	eb 0a		 jmp	 SHORT $LN4@initQueueT
$LN2@initQueueT:
  001bf	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  001c3	ff c0		 inc	 eax
  001c5	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@initQueueT:
  001c9	8b 44 24 24	 mov	 eax, DWORD PTR nCount$[rsp]
  001cd	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  001d1	0f 8d fd 00 00
	00		 jge	 $LN5@initQueueT

; 806  : 			pEventThread = new (std::nothrow) CComQueueThread();

  001d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  001de	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  001e3	e8 00 00 00 00	 call	 ??2@YAPEAX_KAEBUnothrow_t@std@@@Z ; operator new
  001e8	48 89 44 24 60	 mov	 QWORD PTR $T3[rsp], rax
  001ed	48 83 7c 24 60
	00		 cmp	 QWORD PTR $T3[rsp], 0
  001f3	74 11		 je	 SHORT $LN16@initQueueT
  001f5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR $T3[rsp]
  001fa	e8 00 00 00 00	 call	 ??0CComQueueThread@@QEAA@XZ ; CComQueueThread::CComQueueThread
  001ff	48 89 44 24 68	 mov	 QWORD PTR tv167[rsp], rax
  00204	eb 09		 jmp	 SHORT $LN17@initQueueT
$LN16@initQueueT:
  00206	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR tv167[rsp], 0
$LN17@initQueueT:
  0020f	48 8b 44 24 68	 mov	 rax, QWORD PTR tv167[rsp]
  00214	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR $T6[rsp], rax
  0021c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR $T6[rsp]
  00224	48 89 44 24 30	 mov	 QWORD PTR pEventThread$[rsp], rax

; 807  : 			if (!pEventThread) {

  00229	48 83 7c 24 30
	00		 cmp	 QWORD PTR pEventThread$[rsp], 0
  0022f	75 17		 jne	 SHORT $LN8@initQueueT

; 808  : 				printf("has Failed!! [seq:%d] pEventThread = new (std::nothrow) CComQueueThread()\n", i);

  00231	8b 54 24 20	 mov	 edx, DWORD PTR i$[rsp]
  00235	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG46164
  0023c	e8 00 00 00 00	 call	 printf

; 809  : 				return false;

  00241	32 c0		 xor	 al, al
  00243	e9 8e 00 00 00	 jmp	 $LN1@initQueueT
$LN8@initQueueT:

; 810  : 			}
; 811  : 			if (!pEventThread->initConfig(pConfigFile, i, pSection)) {

  00248	4c 8b 8c 24 c0
	00 00 00	 mov	 r9, QWORD PTR pSection$[rsp]
  00250	44 8b 44 24 20	 mov	 r8d, DWORD PTR i$[rsp]
  00255	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR pConfigFile$[rsp]
  0025d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pEventThread$[rsp]
  00262	e8 00 00 00 00	 call	 ?initConfig@CComQueueThread@@QEAA_NPEADH0@Z ; CComQueueThread::initConfig
  00267	0f b6 c0	 movzx	 eax, al
  0026a	85 c0		 test	 eax, eax
  0026c	75 14		 jne	 SHORT $LN9@initQueueT

; 812  : 				printf("has Failed!! [seq:%d] pEventThread->init()\n", i);

  0026e	8b 54 24 20	 mov	 edx, DWORD PTR i$[rsp]
  00272	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG46166
  00279	e8 00 00 00 00	 call	 printf

; 813  : 				return false;

  0027e	32 c0		 xor	 al, al
  00280	eb 54		 jmp	 SHORT $LN1@initQueueT
$LN9@initQueueT:

; 814  : 			}
; 815  : 
; 816  : 			if (!m_pEventThreadList->push_back(pEventThread, &idx)) {

  00282	4c 8d 84 24 90
	00 00 00	 lea	 r8, QWORD PTR idx$[rsp]
  0028a	48 8b 54 24 30	 mov	 rdx, QWORD PTR pEventThread$[rsp]
  0028f	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00297	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  0029b	e8 00 00 00 00	 call	 ?push_back@?$CTList@VCComQueueThread@@@@QEAA_NPEAVCComQueueThread@@PEAH@Z ; CTList<CComQueueThread>::push_back
  002a0	0f b6 c0	 movzx	 eax, al
  002a3	85 c0		 test	 eax, eax
  002a5	75 14		 jne	 SHORT $LN10@initQueueT

; 817  : 				printf("has Failed!! [seq:%d] m_pEventThreadList->setNewObj(pScheduler)\n", i);

  002a7	8b 54 24 20	 mov	 edx, DWORD PTR i$[rsp]
  002ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG46168
  002b2	e8 00 00 00 00	 call	 printf

; 818  : 				return false;

  002b7	32 c0		 xor	 al, al
  002b9	eb 1b		 jmp	 SHORT $LN1@initQueueT
$LN10@initQueueT:

; 819  : 			}
; 820  : 			pEventThread->m_cThread.setIdx(idx);

  002bb	48 8b 44 24 30	 mov	 rax, QWORD PTR pEventThread$[rsp]
  002c0	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR idx$[rsp]
  002c7	48 8b c8	 mov	 rcx, rax
  002ca	e8 00 00 00 00	 call	 ?setIdx@CComThread@@QEAAXH@Z ; CComThread::setIdx

; 821  : 		}

  002cf	e9 eb fe ff ff	 jmp	 $LN2@initQueueT
$LN5@initQueueT:

; 822  : 	}
; 823  : 	return true;

  002d4	b0 01		 mov	 al, 1
$LN1@initQueueT:

; 824  : }

  002d6	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002de	48 33 cc	 xor	 rcx, rsp
  002e1	e8 00 00 00 00	 call	 __security_check_cookie
  002e6	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  002ed	c3		 ret	 0
?initQueueThread@CCoreList@@QEAA_NPEAD0@Z ENDP		; CCoreList::initQueueThread
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
i$ = 32
nCount$ = 36
nMax$ = 40
pEventThread$ = 48
nTmp$ = 56
$T1 = 64
$T2 = 72
tv84 = 80
tv145 = 88
$T3 = 96
tv167 = 104
$T4 = 112
$T5 = 120
$T6 = 128
$T7 = 136
idx$ = 144
__$ArrayPad$ = 152
this$ = 176
pConfigFile$ = 184
pSection$ = 192
?dtor$0@?0??initQueueThread@CCoreList@@QEAA_NPEAD0@Z@4HA PROC ; `CCoreList::initQueueThread'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0000e	48 8b 4d 40	 mov	 rcx, QWORD PTR $T1[rbp]
  00012	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5d		 pop	 rbp
  0001c	c3		 ret	 0
?dtor$0@?0??initQueueThread@CCoreList@@QEAA_NPEAD0@Z@4HA ENDP ; `CCoreList::initQueueThread'::`1'::dtor$0
i$ = 32
nCount$ = 36
nMax$ = 40
pEventThread$ = 48
nTmp$ = 56
$T1 = 64
$T2 = 72
tv84 = 80
tv145 = 88
$T3 = 96
tv167 = 104
$T4 = 112
$T5 = 120
$T6 = 128
$T7 = 136
idx$ = 144
__$ArrayPad$ = 152
this$ = 176
pConfigFile$ = 184
pSection$ = 192
?dtor$1@?0??initQueueThread@CCoreList@@QEAA_NPEAD0@Z@4HA PROC ; `CCoreList::initQueueThread'::`1'::dtor$1
  0001d	40 55		 push	 rbp
  0001f	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00023	48 8b ea	 mov	 rbp, rdx
  00026	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  0002b	48 8b 4d 48	 mov	 rcx, QWORD PTR $T2[rbp]
  0002f	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5d		 pop	 rbp
  00039	c3		 ret	 0
?dtor$1@?0??initQueueThread@CCoreList@@QEAA_NPEAD0@Z@4HA ENDP ; `CCoreList::initQueueThread'::`1'::dtor$1
i$ = 32
nCount$ = 36
nMax$ = 40
pEventThread$ = 48
nTmp$ = 56
$T1 = 64
$T2 = 72
tv84 = 80
tv145 = 88
$T3 = 96
tv167 = 104
$T4 = 112
$T5 = 120
$T6 = 128
$T7 = 136
idx$ = 144
__$ArrayPad$ = 152
this$ = 176
pConfigFile$ = 184
pSection$ = 192
?dtor$2@?0??initQueueThread@CCoreList@@QEAA_NPEAD0@Z@4HA PROC ; `CCoreList::initQueueThread'::`1'::dtor$2
  0003a	40 55		 push	 rbp
  0003c	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00040	48 8b ea	 mov	 rbp, rdx
  00043	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  0004a	48 8b 4d 60	 mov	 rcx, QWORD PTR $T3[rbp]
  0004e	e8 00 00 00 00	 call	 ??3@YAXPEAXAEBUnothrow_t@std@@@Z ; operator delete
  00053	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00057	5d		 pop	 rbp
  00058	c3		 ret	 0
?dtor$2@?0??initQueueThread@CCoreList@@QEAA_NPEAD0@Z@4HA ENDP ; `CCoreList::initQueueThread'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
i$ = 32
nCount$ = 36
nMax$ = 40
pEventThread$ = 48
nTmp$ = 56
$T1 = 64
$T2 = 72
tv84 = 80
tv145 = 88
$T3 = 96
tv167 = 104
$T4 = 112
$T5 = 120
$T6 = 128
$T7 = 136
idx$ = 144
__$ArrayPad$ = 152
this$ = 176
pConfigFile$ = 184
pSection$ = 192
?dtor$0@?0??initQueueThread@CCoreList@@QEAA_NPEAD0@Z@4HA PROC ; `CCoreList::initQueueThread'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0000e	48 8b 4d 40	 mov	 rcx, QWORD PTR $T1[rbp]
  00012	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5d		 pop	 rbp
  0001c	c3		 ret	 0
?dtor$0@?0??initQueueThread@CCoreList@@QEAA_NPEAD0@Z@4HA ENDP ; `CCoreList::initQueueThread'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
i$ = 32
nCount$ = 36
nMax$ = 40
pEventThread$ = 48
nTmp$ = 56
$T1 = 64
$T2 = 72
tv84 = 80
tv145 = 88
$T3 = 96
tv167 = 104
$T4 = 112
$T5 = 120
$T6 = 128
$T7 = 136
idx$ = 144
__$ArrayPad$ = 152
this$ = 176
pConfigFile$ = 184
pSection$ = 192
?dtor$1@?0??initQueueThread@CCoreList@@QEAA_NPEAD0@Z@4HA PROC ; `CCoreList::initQueueThread'::`1'::dtor$1
  0001d	40 55		 push	 rbp
  0001f	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00023	48 8b ea	 mov	 rbp, rdx
  00026	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  0002b	48 8b 4d 48	 mov	 rcx, QWORD PTR $T2[rbp]
  0002f	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5d		 pop	 rbp
  00039	c3		 ret	 0
?dtor$1@?0??initQueueThread@CCoreList@@QEAA_NPEAD0@Z@4HA ENDP ; `CCoreList::initQueueThread'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
i$ = 32
nCount$ = 36
nMax$ = 40
pEventThread$ = 48
nTmp$ = 56
$T1 = 64
$T2 = 72
tv84 = 80
tv145 = 88
$T3 = 96
tv167 = 104
$T4 = 112
$T5 = 120
$T6 = 128
$T7 = 136
idx$ = 144
__$ArrayPad$ = 152
this$ = 176
pConfigFile$ = 184
pSection$ = 192
?dtor$2@?0??initQueueThread@CCoreList@@QEAA_NPEAD0@Z@4HA PROC ; `CCoreList::initQueueThread'::`1'::dtor$2
  0003a	40 55		 push	 rbp
  0003c	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00040	48 8b ea	 mov	 rbp, rdx
  00043	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  0004a	48 8b 4d 60	 mov	 rcx, QWORD PTR $T3[rbp]
  0004e	e8 00 00 00 00	 call	 ??3@YAXPEAXAEBUnothrow_t@std@@@Z ; operator delete
  00053	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00057	5d		 pop	 rbp
  00058	c3		 ret	 0
?dtor$2@?0??initQueueThread@CCoreList@@QEAA_NPEAD0@Z@4HA ENDP ; `CCoreList::initQueueThread'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?initScheduler@CCoreList@@QEAA_NPEAD0@Z
_TEXT	SEGMENT
i$ = 32
nCount$ = 36
nMax$ = 40
pScheduler$ = 48
$T1 = 56
tv85 = 64
$T2 = 72
tv157 = 80
$T3 = 88
tv179 = 96
$T4 = 104
$T5 = 112
$T6 = 120
$T7 = 128
idx$ = 136
szErrorMsg$ = 144
__$ArrayPad$ = 272
this$ = 304
pConfigFile$ = 312
pSection$ = 320
?initScheduler@CCoreList@@QEAA_NPEAD0@Z PROC		; CCoreList::initScheduler, COMDAT

; 734  : {

$LN23:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  00016	48 c7 84 24 80
	00 00 00 fe ff
	ff ff		 mov	 QWORD PTR $T7[rsp], -2
  00022	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00029	48 33 c4	 xor	 rax, rsp
  0002c	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 735  : 	int nCount, i, nMax, idx;
; 736  : 	CScheduler *pScheduler;
; 737  : 	char szErrorMsg[128];
; 738  : 	// scheduler
; 739  : 	nCount = GetPrivateProfileInt(pSection, _T("LIST_COUNT"), 0, pConfigFile);

  00034	4c 8b 8c 24 38
	01 00 00	 mov	 r9, QWORD PTR pConfigFile$[rsp]
  0003c	45 33 c0	 xor	 r8d, r8d
  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46101
  00046	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR pSection$[rsp]
  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetPrivateProfileIntA
  00054	89 44 24 24	 mov	 DWORD PTR nCount$[rsp], eax

; 740  : 	if (nCount) {

  00058	83 7c 24 24 00	 cmp	 DWORD PTR nCount$[rsp], 0
  0005d	0f 84 3f 03 00
	00		 je	 $LN5@initSchedu

; 741  : 		if (!m_pSchedulerList) {

  00063	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0006b	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00070	0f 85 f7 00 00
	00		 jne	 $LN6@initSchedu

; 742  : 			m_pSchedulerList = new (std::nothrow) CTList<CScheduler>();

  00076	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  0007d	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00082	e8 00 00 00 00	 call	 ??2@YAPEAX_KAEBUnothrow_t@std@@@Z ; operator new
  00087	48 89 44 24 38	 mov	 QWORD PTR $T1[rsp], rax
  0008c	48 83 7c 24 38
	00		 cmp	 QWORD PTR $T1[rsp], 0
  00092	74 11		 je	 SHORT $LN14@initSchedu
  00094	48 8b 4c 24 38	 mov	 rcx, QWORD PTR $T1[rsp]
  00099	e8 00 00 00 00	 call	 ??0?$CTList@VCScheduler@@@@QEAA@XZ ; CTList<CScheduler>::CTList<CScheduler>
  0009e	48 89 44 24 40	 mov	 QWORD PTR tv85[rsp], rax
  000a3	eb 09		 jmp	 SHORT $LN15@initSchedu
$LN14@initSchedu:
  000a5	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv85[rsp], 0
$LN15@initSchedu:
  000ae	48 8b 44 24 40	 mov	 rax, QWORD PTR tv85[rsp]
  000b3	48 89 44 24 68	 mov	 QWORD PTR $T4[rsp], rax
  000b8	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000c0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR $T4[rsp]
  000c5	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 743  : 			if (!m_pSchedulerList) {

  000c9	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000d1	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  000d6	75 35		 jne	 SHORT $LN7@initSchedu

; 744  : 				sprintf(szErrorMsg, "new (std::nothrow) CTList<CScheduler>() is NULL");

  000d8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46106
  000df	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR szErrorMsg$[rsp]
  000e7	e8 00 00 00 00	 call	 sprintf

; 745  : 				comErrorPrint(szErrorMsg);

  000ec	41 b8 e9 02 00
	00		 mov	 r8d, 745		; 000002e9H
  000f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46107
  000f9	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR szErrorMsg$[rsp]
  00101	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 746  : 				return false;

  00106	32 c0		 xor	 al, al
  00108	e9 97 02 00 00	 jmp	 $LN1@initSchedu
$LN7@initSchedu:

; 747  : 			}
; 748  : 			if (!m_pSchedulerList->alloc(nCount + LIST_ADD_COUNT, eAlloc_Type_none)) {

  0010d	8b 44 24 24	 mov	 eax, DWORD PTR nCount$[rsp]
  00111	83 c0 0a	 add	 eax, 10
  00114	45 33 c0	 xor	 r8d, r8d
  00117	8b d0		 mov	 edx, eax
  00119	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00121	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00125	e8 00 00 00 00	 call	 ?alloc@?$CTList@VCScheduler@@@@QEAAHHW4E_ALLOC_TYPE@@@Z ; CTList<CScheduler>::alloc
  0012a	85 c0		 test	 eax, eax
  0012c	75 3f		 jne	 SHORT $LN6@initSchedu

; 749  : 				sprintf(szErrorMsg, "m_pSchedulerList->alloc nCnt[%d]", nCount + LIST_ADD_COUNT);

  0012e	8b 44 24 24	 mov	 eax, DWORD PTR nCount$[rsp]
  00132	83 c0 0a	 add	 eax, 10
  00135	44 8b c0	 mov	 r8d, eax
  00138	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46109
  0013f	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR szErrorMsg$[rsp]
  00147	e8 00 00 00 00	 call	 sprintf

; 750  : 				comErrorPrint(szErrorMsg);

  0014c	41 b8 ee 02 00
	00		 mov	 r8d, 750		; 000002eeH
  00152	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46110
  00159	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR szErrorMsg$[rsp]
  00161	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 751  : 				return false;

  00166	32 c0		 xor	 al, al
  00168	e9 37 02 00 00	 jmp	 $LN1@initSchedu
$LN6@initSchedu:

; 752  : 			}
; 753  : 		}
; 754  : 
; 755  : 		nMax = GetPrivateProfileInt(pSection, _T("TIME_POOL_MAX"), 0, pConfigFile) + CORE_PLUS_POOL_COUNT;

  0016d	4c 8b 8c 24 38
	01 00 00	 mov	 r9, QWORD PTR pConfigFile$[rsp]
  00175	45 33 c0	 xor	 r8d, r8d
  00178	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46111
  0017f	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR pSection$[rsp]
  00187	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetPrivateProfileIntA
  0018d	83 c0 0a	 add	 eax, 10
  00190	89 44 24 28	 mov	 DWORD PTR nMax$[rsp], eax

; 756  : 		m_pIntervalPool = new (std::nothrow) CMemPool<STIntervalInfo>();

  00194	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  0019b	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  001a0	e8 00 00 00 00	 call	 ??2@YAPEAX_KAEBUnothrow_t@std@@@Z ; operator new
  001a5	48 89 44 24 48	 mov	 QWORD PTR $T2[rsp], rax
  001aa	48 83 7c 24 48
	00		 cmp	 QWORD PTR $T2[rsp], 0
  001b0	74 11		 je	 SHORT $LN16@initSchedu
  001b2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR $T2[rsp]
  001b7	e8 00 00 00 00	 call	 ??0?$CMemPool@USTIntervalInfo@@@@QEAA@XZ ; CMemPool<STIntervalInfo>::CMemPool<STIntervalInfo>
  001bc	48 89 44 24 50	 mov	 QWORD PTR tv157[rsp], rax
  001c1	eb 09		 jmp	 SHORT $LN17@initSchedu
$LN16@initSchedu:
  001c3	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR tv157[rsp], 0
$LN17@initSchedu:
  001cc	48 8b 44 24 50	 mov	 rax, QWORD PTR tv157[rsp]
  001d1	48 89 44 24 70	 mov	 QWORD PTR $T5[rsp], rax
  001d6	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001de	48 8b 4c 24 70	 mov	 rcx, QWORD PTR $T5[rsp]
  001e3	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 757  : 		if (!m_pIntervalPool->alloc(nMax, eAlloc_Type_alloc)) {

  001e7	41 b8 03 00 00
	00		 mov	 r8d, 3
  001ed	8b 54 24 28	 mov	 edx, DWORD PTR nMax$[rsp]
  001f1	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001f9	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  001fd	e8 00 00 00 00	 call	 ?alloc@?$CMemPool@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z ; CMemPool<STIntervalInfo>::alloc
  00202	85 c0		 test	 eax, eax
  00204	75 17		 jne	 SHORT $LN9@initSchedu

; 758  : 			printf("has Failed!! m_pIntervalPool.alloc(%d)\n", nMax);

  00206	8b 54 24 28	 mov	 edx, DWORD PTR nMax$[rsp]
  0020a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG46114
  00211	e8 00 00 00 00	 call	 printf

; 759  : 			return false;

  00216	32 c0		 xor	 al, al
  00218	e9 87 01 00 00	 jmp	 $LN1@initSchedu
$LN9@initSchedu:

; 760  : 		}
; 761  : 
; 762  : 		for (i = 0; i < nCount; i++) {

  0021d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00225	eb 0a		 jmp	 SHORT $LN4@initSchedu
$LN2@initSchedu:
  00227	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0022b	ff c0		 inc	 eax
  0022d	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@initSchedu:
  00231	8b 44 24 24	 mov	 eax, DWORD PTR nCount$[rsp]
  00235	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00239	0f 8d 63 01 00
	00		 jge	 $LN5@initSchedu

; 763  : 			pScheduler = new (std::nothrow) CScheduler();

  0023f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00246	b9 60 00 00 00	 mov	 ecx, 96			; 00000060H
  0024b	e8 00 00 00 00	 call	 ??2@YAPEAX_KAEBUnothrow_t@std@@@Z ; operator new
  00250	48 89 44 24 58	 mov	 QWORD PTR $T3[rsp], rax
  00255	48 83 7c 24 58
	00		 cmp	 QWORD PTR $T3[rsp], 0
  0025b	74 11		 je	 SHORT $LN18@initSchedu
  0025d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR $T3[rsp]
  00262	e8 00 00 00 00	 call	 ??0CScheduler@@QEAA@XZ	; CScheduler::CScheduler
  00267	48 89 44 24 60	 mov	 QWORD PTR tv179[rsp], rax
  0026c	eb 09		 jmp	 SHORT $LN19@initSchedu
$LN18@initSchedu:
  0026e	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR tv179[rsp], 0
$LN19@initSchedu:
  00277	48 8b 44 24 60	 mov	 rax, QWORD PTR tv179[rsp]
  0027c	48 89 44 24 78	 mov	 QWORD PTR $T6[rsp], rax
  00281	48 8b 44 24 78	 mov	 rax, QWORD PTR $T6[rsp]
  00286	48 89 44 24 30	 mov	 QWORD PTR pScheduler$[rsp], rax

; 764  : 			if (!pScheduler) {

  0028b	48 83 7c 24 30
	00		 cmp	 QWORD PTR pScheduler$[rsp], 0
  00291	75 3a		 jne	 SHORT $LN10@initSchedu

; 765  : 				sprintf(szErrorMsg, "[seq:%d] new (std::nothrow) CScheduler() is NULL", i);

  00293	44 8b 44 24 20	 mov	 r8d, DWORD PTR i$[rsp]
  00298	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46117
  0029f	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR szErrorMsg$[rsp]
  002a7	e8 00 00 00 00	 call	 sprintf

; 766  : 				comErrorPrint(szErrorMsg);

  002ac	41 b8 fe 02 00
	00		 mov	 r8d, 766		; 000002feH
  002b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46118
  002b9	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR szErrorMsg$[rsp]
  002c1	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 767  : 				return false;

  002c6	32 c0		 xor	 al, al
  002c8	e9 d7 00 00 00	 jmp	 $LN1@initSchedu
$LN10@initSchedu:

; 768  : 			}
; 769  : 			if (!pScheduler->initConfig(pConfigFile, i, pSection)) {

  002cd	4c 8b 8c 24 40
	01 00 00	 mov	 r9, QWORD PTR pSection$[rsp]
  002d5	44 8b 44 24 20	 mov	 r8d, DWORD PTR i$[rsp]
  002da	48 8b 94 24 38
	01 00 00	 mov	 rdx, QWORD PTR pConfigFile$[rsp]
  002e2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pScheduler$[rsp]
  002e7	e8 00 00 00 00	 call	 ?initConfig@CScheduler@@QEAA_NPEADH0@Z ; CScheduler::initConfig
  002ec	0f b6 c0	 movzx	 eax, al
  002ef	85 c0		 test	 eax, eax
  002f1	75 37		 jne	 SHORT $LN11@initSchedu

; 770  : 				sprintf(szErrorMsg, "[seq:%d] pScheduler->init", i);

  002f3	44 8b 44 24 20	 mov	 r8d, DWORD PTR i$[rsp]
  002f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46120
  002ff	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR szErrorMsg$[rsp]
  00307	e8 00 00 00 00	 call	 sprintf

; 771  : 				comErrorPrint(szErrorMsg);

  0030c	41 b8 03 03 00
	00		 mov	 r8d, 771		; 00000303H
  00312	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46121
  00319	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR szErrorMsg$[rsp]
  00321	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 772  : 				return false;

  00326	32 c0		 xor	 al, al
  00328	eb 7a		 jmp	 SHORT $LN1@initSchedu
$LN11@initSchedu:

; 773  : 			}
; 774  : 			if (!m_pSchedulerList->push_back(pScheduler, &idx)) {

  0032a	4c 8d 84 24 88
	00 00 00	 lea	 r8, QWORD PTR idx$[rsp]
  00332	48 8b 54 24 30	 mov	 rdx, QWORD PTR pScheduler$[rsp]
  00337	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0033f	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00343	e8 00 00 00 00	 call	 ?push_back@?$CTList@VCScheduler@@@@QEAA_NPEAVCScheduler@@PEAH@Z ; CTList<CScheduler>::push_back
  00348	0f b6 c0	 movzx	 eax, al
  0034b	85 c0		 test	 eax, eax
  0034d	75 3a		 jne	 SHORT $LN12@initSchedu

; 775  : 				sprintf(szErrorMsg, "[seq:%d] pScheduler->push_back", idx);

  0034f	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR idx$[rsp]
  00357	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46123
  0035e	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR szErrorMsg$[rsp]
  00366	e8 00 00 00 00	 call	 sprintf

; 776  : 				comErrorPrint(szErrorMsg);

  0036b	41 b8 08 03 00
	00		 mov	 r8d, 776		; 00000308H
  00371	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46124
  00378	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR szErrorMsg$[rsp]
  00380	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 777  : 				return false;

  00385	32 c0		 xor	 al, al
  00387	eb 1b		 jmp	 SHORT $LN1@initSchedu
$LN12@initSchedu:

; 778  : 			}
; 779  : 			pScheduler->m_cThread.setIdx(idx);

  00389	48 8b 44 24 30	 mov	 rax, QWORD PTR pScheduler$[rsp]
  0038e	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR idx$[rsp]
  00395	48 8b c8	 mov	 rcx, rax
  00398	e8 00 00 00 00	 call	 ?setIdx@CComThread@@QEAAXH@Z ; CComThread::setIdx

; 780  : 		}

  0039d	e9 85 fe ff ff	 jmp	 $LN2@initSchedu
$LN5@initSchedu:

; 781  : 	}
; 782  : 	return true;

  003a2	b0 01		 mov	 al, 1
$LN1@initSchedu:

; 783  : }

  003a4	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003ac	48 33 cc	 xor	 rcx, rsp
  003af	e8 00 00 00 00	 call	 __security_check_cookie
  003b4	48 81 c4 28 01
	00 00		 add	 rsp, 296		; 00000128H
  003bb	c3		 ret	 0
?initScheduler@CCoreList@@QEAA_NPEAD0@Z ENDP		; CCoreList::initScheduler
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
i$ = 32
nCount$ = 36
nMax$ = 40
pScheduler$ = 48
$T1 = 56
tv85 = 64
$T2 = 72
tv157 = 80
$T3 = 88
tv179 = 96
$T4 = 104
$T5 = 112
$T6 = 120
$T7 = 128
idx$ = 136
szErrorMsg$ = 144
__$ArrayPad$ = 272
this$ = 304
pConfigFile$ = 312
pSection$ = 320
?dtor$0@?0??initScheduler@CCoreList@@QEAA_NPEAD0@Z@4HA PROC ; `CCoreList::initScheduler'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00010	48 8b 4d 38	 mov	 rcx, QWORD PTR $T1[rbp]
  00014	e8 00 00 00 00	 call	 ??3@YAXPEAXAEBUnothrow_t@std@@@Z ; operator delete
  00019	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001d	5d		 pop	 rbp
  0001e	c3		 ret	 0
?dtor$0@?0??initScheduler@CCoreList@@QEAA_NPEAD0@Z@4HA ENDP ; `CCoreList::initScheduler'::`1'::dtor$0
i$ = 32
nCount$ = 36
nMax$ = 40
pScheduler$ = 48
$T1 = 56
tv85 = 64
$T2 = 72
tv157 = 80
$T3 = 88
tv179 = 96
$T4 = 104
$T5 = 112
$T6 = 120
$T7 = 128
idx$ = 136
szErrorMsg$ = 144
__$ArrayPad$ = 272
this$ = 304
pConfigFile$ = 312
pSection$ = 320
?dtor$1@?0??initScheduler@CCoreList@@QEAA_NPEAD0@Z@4HA PROC ; `CCoreList::initScheduler'::`1'::dtor$1
  0001f	40 55		 push	 rbp
  00021	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00025	48 8b ea	 mov	 rbp, rdx
  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  0002f	48 8b 4d 48	 mov	 rcx, QWORD PTR $T2[rbp]
  00033	e8 00 00 00 00	 call	 ??3@YAXPEAXAEBUnothrow_t@std@@@Z ; operator delete
  00038	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003c	5d		 pop	 rbp
  0003d	c3		 ret	 0
?dtor$1@?0??initScheduler@CCoreList@@QEAA_NPEAD0@Z@4HA ENDP ; `CCoreList::initScheduler'::`1'::dtor$1
i$ = 32
nCount$ = 36
nMax$ = 40
pScheduler$ = 48
$T1 = 56
tv85 = 64
$T2 = 72
tv157 = 80
$T3 = 88
tv179 = 96
$T4 = 104
$T5 = 112
$T6 = 120
$T7 = 128
idx$ = 136
szErrorMsg$ = 144
__$ArrayPad$ = 272
this$ = 304
pConfigFile$ = 312
pSection$ = 320
?dtor$2@?0??initScheduler@CCoreList@@QEAA_NPEAD0@Z@4HA PROC ; `CCoreList::initScheduler'::`1'::dtor$2
  0003e	40 55		 push	 rbp
  00040	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00044	48 8b ea	 mov	 rbp, rdx
  00047	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  0004e	48 8b 4d 58	 mov	 rcx, QWORD PTR $T3[rbp]
  00052	e8 00 00 00 00	 call	 ??3@YAXPEAXAEBUnothrow_t@std@@@Z ; operator delete
  00057	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005b	5d		 pop	 rbp
  0005c	c3		 ret	 0
?dtor$2@?0??initScheduler@CCoreList@@QEAA_NPEAD0@Z@4HA ENDP ; `CCoreList::initScheduler'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
i$ = 32
nCount$ = 36
nMax$ = 40
pScheduler$ = 48
$T1 = 56
tv85 = 64
$T2 = 72
tv157 = 80
$T3 = 88
tv179 = 96
$T4 = 104
$T5 = 112
$T6 = 120
$T7 = 128
idx$ = 136
szErrorMsg$ = 144
__$ArrayPad$ = 272
this$ = 304
pConfigFile$ = 312
pSection$ = 320
?dtor$0@?0??initScheduler@CCoreList@@QEAA_NPEAD0@Z@4HA PROC ; `CCoreList::initScheduler'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00010	48 8b 4d 38	 mov	 rcx, QWORD PTR $T1[rbp]
  00014	e8 00 00 00 00	 call	 ??3@YAXPEAXAEBUnothrow_t@std@@@Z ; operator delete
  00019	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001d	5d		 pop	 rbp
  0001e	c3		 ret	 0
?dtor$0@?0??initScheduler@CCoreList@@QEAA_NPEAD0@Z@4HA ENDP ; `CCoreList::initScheduler'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
i$ = 32
nCount$ = 36
nMax$ = 40
pScheduler$ = 48
$T1 = 56
tv85 = 64
$T2 = 72
tv157 = 80
$T3 = 88
tv179 = 96
$T4 = 104
$T5 = 112
$T6 = 120
$T7 = 128
idx$ = 136
szErrorMsg$ = 144
__$ArrayPad$ = 272
this$ = 304
pConfigFile$ = 312
pSection$ = 320
?dtor$1@?0??initScheduler@CCoreList@@QEAA_NPEAD0@Z@4HA PROC ; `CCoreList::initScheduler'::`1'::dtor$1
  0001f	40 55		 push	 rbp
  00021	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00025	48 8b ea	 mov	 rbp, rdx
  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  0002f	48 8b 4d 48	 mov	 rcx, QWORD PTR $T2[rbp]
  00033	e8 00 00 00 00	 call	 ??3@YAXPEAXAEBUnothrow_t@std@@@Z ; operator delete
  00038	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003c	5d		 pop	 rbp
  0003d	c3		 ret	 0
?dtor$1@?0??initScheduler@CCoreList@@QEAA_NPEAD0@Z@4HA ENDP ; `CCoreList::initScheduler'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
i$ = 32
nCount$ = 36
nMax$ = 40
pScheduler$ = 48
$T1 = 56
tv85 = 64
$T2 = 72
tv157 = 80
$T3 = 88
tv179 = 96
$T4 = 104
$T5 = 112
$T6 = 120
$T7 = 128
idx$ = 136
szErrorMsg$ = 144
__$ArrayPad$ = 272
this$ = 304
pConfigFile$ = 312
pSection$ = 320
?dtor$2@?0??initScheduler@CCoreList@@QEAA_NPEAD0@Z@4HA PROC ; `CCoreList::initScheduler'::`1'::dtor$2
  0003e	40 55		 push	 rbp
  00040	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00044	48 8b ea	 mov	 rbp, rdx
  00047	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  0004e	48 8b 4d 58	 mov	 rcx, QWORD PTR $T3[rbp]
  00052	e8 00 00 00 00	 call	 ??3@YAXPEAXAEBUnothrow_t@std@@@Z ; operator delete
  00057	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005b	5d		 pop	 rbp
  0005c	c3		 ret	 0
?dtor$2@?0??initScheduler@CCoreList@@QEAA_NPEAD0@Z@4HA ENDP ; `CCoreList::initScheduler'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?initLogWriter@CCoreList@@QEAA_NPEAD0_N@Z
_TEXT	SEGMENT
bRes$ = 32
i$ = 36
nCount$ = 40
pWriter$ = 48
$T1 = 56
tv86 = 64
$T2 = 72
tv146 = 80
$T3 = 88
$T4 = 96
$T5 = 104
idx$ = 112
szErrorMsg$ = 128
__$ArrayPad$ = 256
this$ = 288
pConfigFile$ = 296
pSection$ = 304
bSystem$ = 312
?initLogWriter@CCoreList@@QEAA_NPEAD0_N@Z PROC		; CCoreList::initLogWriter, COMDAT

; 687  : {

$LN20:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  0001b	48 c7 44 24 68
	fe ff ff ff	 mov	 QWORD PTR $T5[rsp], -2
  00024	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002b	48 33 c4	 xor	 rax, rsp
  0002e	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 688  : 	int nCount, i, idx;
; 689  : 	CSTLogger *pWriter;
; 690  : 	char szErrorMsg[128];
; 691  : 	bool bRes;
; 692  : 
; 693  : 	nCount = GetPrivateProfileInt(pSection, _T("LIST_COUNT"), 1, pConfigFile);

  00036	4c 8b 8c 24 28
	01 00 00	 mov	 r9, QWORD PTR pConfigFile$[rsp]
  0003e	41 b8 01 00 00
	00		 mov	 r8d, 1
  00044	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46047
  0004b	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR pSection$[rsp]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetPrivateProfileIntA
  00059	89 44 24 28	 mov	 DWORD PTR nCount$[rsp], eax

; 694  : 	if (nCount) {

  0005d	83 7c 24 28 00	 cmp	 DWORD PTR nCount$[rsp], 0
  00062	0f 84 71 02 00
	00		 je	 $LN5@initLogWri

; 695  : 		if (!m_pWriterList) {

  00068	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00070	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00074	0f 85 b9 00 00
	00		 jne	 $LN6@initLogWri

; 696  : 			m_pWriterList = new CTList<CSTLogger>();

  0007a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0007f	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00084	48 89 44 24 38	 mov	 QWORD PTR $T1[rsp], rax
  00089	48 83 7c 24 38
	00		 cmp	 QWORD PTR $T1[rsp], 0
  0008f	74 20		 je	 SHORT $LN14@initLogWri
  00091	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00096	48 8b 4c 24 38	 mov	 rcx, QWORD PTR $T1[rsp]
  0009b	e8 00 00 00 00	 call	 ?__autoclassinit2@?$CTList@VCSTLogger@@@@QEAAX_K@Z
  000a0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR $T1[rsp]
  000a5	e8 00 00 00 00	 call	 ??0?$CTList@VCSTLogger@@@@QEAA@XZ ; CTList<CSTLogger>::CTList<CSTLogger>
  000aa	48 89 44 24 40	 mov	 QWORD PTR tv86[rsp], rax
  000af	eb 09		 jmp	 SHORT $LN15@initLogWri
$LN14@initLogWri:
  000b1	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv86[rsp], 0
$LN15@initLogWri:
  000ba	48 8b 44 24 40	 mov	 rax, QWORD PTR tv86[rsp]
  000bf	48 89 44 24 58	 mov	 QWORD PTR $T3[rsp], rax
  000c4	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000cc	48 8b 4c 24 58	 mov	 rcx, QWORD PTR $T3[rsp]
  000d1	48 89 08	 mov	 QWORD PTR [rax], rcx

; 697  : 			if (!m_pWriterList->alloc(nCount + LIST_ADD_COUNT, eAlloc_Type_none)) {

  000d4	8b 44 24 28	 mov	 eax, DWORD PTR nCount$[rsp]
  000d8	83 c0 0a	 add	 eax, 10
  000db	45 33 c0	 xor	 r8d, r8d
  000de	8b d0		 mov	 edx, eax
  000e0	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000e8	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000eb	e8 00 00 00 00	 call	 ?alloc@?$CTList@VCSTLogger@@@@QEAAHHW4E_ALLOC_TYPE@@@Z ; CTList<CSTLogger>::alloc
  000f0	85 c0		 test	 eax, eax
  000f2	75 3f		 jne	 SHORT $LN6@initLogWri

; 698  : 				sprintf(szErrorMsg, "m_pWriterList->alloc nCnt[%d]", nCount + LIST_ADD_COUNT);

  000f4	8b 44 24 28	 mov	 eax, DWORD PTR nCount$[rsp]
  000f8	83 c0 0a	 add	 eax, 10
  000fb	44 8b c0	 mov	 r8d, eax
  000fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46052
  00105	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR szErrorMsg$[rsp]
  0010d	e8 00 00 00 00	 call	 sprintf

; 699  : 				comErrorPrint(szErrorMsg);

  00112	41 b8 bb 02 00
	00		 mov	 r8d, 699		; 000002bbH
  00118	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46053
  0011f	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR szErrorMsg$[rsp]
  00127	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 700  : 				return false;

  0012c	32 c0		 xor	 al, al
  0012e	e9 a8 01 00 00	 jmp	 $LN1@initLogWri
$LN6@initLogWri:

; 701  : 			}
; 702  : 		}
; 703  : 
; 704  : 		for (i = 0; i < nCount; i++) {

  00133	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0013b	eb 0a		 jmp	 SHORT $LN4@initLogWri
$LN2@initLogWri:
  0013d	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  00141	ff c0		 inc	 eax
  00143	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@initLogWri:
  00147	8b 44 24 28	 mov	 eax, DWORD PTR nCount$[rsp]
  0014b	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  0014f	0f 8d 84 01 00
	00		 jge	 $LN5@initLogWri

; 705  : 			pWriter = new (std::nothrow) CSTLogger();

  00155	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  0015c	b9 58 00 00 00	 mov	 ecx, 88			; 00000058H
  00161	e8 00 00 00 00	 call	 ??2@YAPEAX_KAEBUnothrow_t@std@@@Z ; operator new
  00166	48 89 44 24 48	 mov	 QWORD PTR $T2[rsp], rax
  0016b	48 83 7c 24 48
	00		 cmp	 QWORD PTR $T2[rsp], 0
  00171	74 11		 je	 SHORT $LN16@initLogWri
  00173	48 8b 4c 24 48	 mov	 rcx, QWORD PTR $T2[rsp]
  00178	e8 00 00 00 00	 call	 ??0CSTLogger@@QEAA@XZ	; CSTLogger::CSTLogger
  0017d	48 89 44 24 50	 mov	 QWORD PTR tv146[rsp], rax
  00182	eb 09		 jmp	 SHORT $LN17@initLogWri
$LN16@initLogWri:
  00184	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR tv146[rsp], 0
$LN17@initLogWri:
  0018d	48 8b 44 24 50	 mov	 rax, QWORD PTR tv146[rsp]
  00192	48 89 44 24 60	 mov	 QWORD PTR $T4[rsp], rax
  00197	48 8b 44 24 60	 mov	 rax, QWORD PTR $T4[rsp]
  0019c	48 89 44 24 30	 mov	 QWORD PTR pWriter$[rsp], rax

; 706  : 			if (!pWriter) {

  001a1	48 83 7c 24 30
	00		 cmp	 QWORD PTR pWriter$[rsp], 0
  001a7	75 3a		 jne	 SHORT $LN8@initLogWri

; 707  : 				sprintf(szErrorMsg, "[seq:%d] new (std::nothrow) CSTLogger() is NULL", i);

  001a9	44 8b 44 24 24	 mov	 r8d, DWORD PTR i$[rsp]
  001ae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46056
  001b5	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR szErrorMsg$[rsp]
  001bd	e8 00 00 00 00	 call	 sprintf

; 708  : 				comErrorPrint(szErrorMsg);

  001c2	41 b8 c4 02 00
	00		 mov	 r8d, 708		; 000002c4H
  001c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46057
  001cf	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR szErrorMsg$[rsp]
  001d7	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 709  : 				return false;

  001dc	32 c0		 xor	 al, al
  001de	e9 f8 00 00 00	 jmp	 $LN1@initLogWri
$LN8@initLogWri:

; 710  : 			}
; 711  : 			if (!pWriter->initConfig(pConfigFile, i, pSection)) {

  001e3	4c 8b 8c 24 30
	01 00 00	 mov	 r9, QWORD PTR pSection$[rsp]
  001eb	44 8b 44 24 24	 mov	 r8d, DWORD PTR i$[rsp]
  001f0	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR pConfigFile$[rsp]
  001f8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pWriter$[rsp]
  001fd	e8 00 00 00 00	 call	 ?initConfig@CSTLogger@@QEAA_NPEADH0@Z ; CSTLogger::initConfig
  00202	0f b6 c0	 movzx	 eax, al
  00205	85 c0		 test	 eax, eax
  00207	75 62		 jne	 SHORT $LN9@initLogWri

; 712  : 				if (bSystem) {

  00209	0f b6 84 24 38
	01 00 00	 movzx	 eax, BYTE PTR bSystem$[rsp]
  00211	85 c0		 test	 eax, eax
  00213	74 16		 je	 SHORT $LN10@initLogWri

; 713  : 					bRes = pWriter->init(LIST_ADD_COUNT, 0);

  00215	45 33 c0	 xor	 r8d, r8d
  00218	ba 0a 00 00 00	 mov	 edx, 10
  0021d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pWriter$[rsp]
  00222	e8 00 00 00 00	 call	 ?init@CSTLogger@@QEAA_NHH@Z ; CSTLogger::init
  00227	88 44 24 20	 mov	 BYTE PTR bRes$[rsp], al
$LN10@initLogWri:

; 714  : 				}
; 715  : 				if(!bRes) {

  0022b	0f b6 44 24 20	 movzx	 eax, BYTE PTR bRes$[rsp]
  00230	85 c0		 test	 eax, eax
  00232	75 37		 jne	 SHORT $LN9@initLogWri

; 716  : 					sprintf(szErrorMsg, "[seq:%d] pWriter->init", i);

  00234	44 8b 44 24 24	 mov	 r8d, DWORD PTR i$[rsp]
  00239	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46061
  00240	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR szErrorMsg$[rsp]
  00248	e8 00 00 00 00	 call	 sprintf

; 717  : 					comErrorPrint(szErrorMsg);

  0024d	41 b8 cd 02 00
	00		 mov	 r8d, 717		; 000002cdH
  00253	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46062
  0025a	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR szErrorMsg$[rsp]
  00262	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 718  : 					return false;

  00267	32 c0		 xor	 al, al
  00269	eb 70		 jmp	 SHORT $LN1@initLogWri
$LN9@initLogWri:

; 719  : 				}
; 720  : 			}
; 721  : 			if (!m_pWriterList->push_back(pWriter, &idx)) {

  0026b	4c 8d 44 24 70	 lea	 r8, QWORD PTR idx$[rsp]
  00270	48 8b 54 24 30	 mov	 rdx, QWORD PTR pWriter$[rsp]
  00275	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0027d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00280	e8 00 00 00 00	 call	 ?push_back@?$CTList@VCSTLogger@@@@QEAA_NPEAVCSTLogger@@PEAH@Z ; CTList<CSTLogger>::push_back
  00285	0f b6 c0	 movzx	 eax, al
  00288	85 c0		 test	 eax, eax
  0028a	75 37		 jne	 SHORT $LN12@initLogWri

; 722  : 				sprintf(szErrorMsg, "[seq:%d] pWriter->push_back", idx);

  0028c	44 8b 44 24 70	 mov	 r8d, DWORD PTR idx$[rsp]
  00291	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46064
  00298	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR szErrorMsg$[rsp]
  002a0	e8 00 00 00 00	 call	 sprintf

; 723  : 				comErrorPrint(szErrorMsg);

  002a5	41 b8 d3 02 00
	00		 mov	 r8d, 723		; 000002d3H
  002ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46065
  002b2	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR szErrorMsg$[rsp]
  002ba	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 724  : 				return false;

  002bf	32 c0		 xor	 al, al
  002c1	eb 18		 jmp	 SHORT $LN1@initLogWri
$LN12@initLogWri:

; 725  : 			}
; 726  : 			pWriter->m_cThread.setIdx(idx);

  002c3	48 8b 44 24 30	 mov	 rax, QWORD PTR pWriter$[rsp]
  002c8	8b 54 24 70	 mov	 edx, DWORD PTR idx$[rsp]
  002cc	48 8b c8	 mov	 rcx, rax
  002cf	e8 00 00 00 00	 call	 ?setIdx@CComThread@@QEAAXH@Z ; CComThread::setIdx

; 727  : 		}

  002d4	e9 64 fe ff ff	 jmp	 $LN2@initLogWri
$LN5@initLogWri:

; 728  : 	}
; 729  : 	return true;

  002d9	b0 01		 mov	 al, 1
$LN1@initLogWri:

; 730  : }

  002db	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002e3	48 33 cc	 xor	 rcx, rsp
  002e6	e8 00 00 00 00	 call	 __security_check_cookie
  002eb	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  002f2	c3		 ret	 0
?initLogWriter@CCoreList@@QEAA_NPEAD0_N@Z ENDP		; CCoreList::initLogWriter
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
bRes$ = 32
i$ = 36
nCount$ = 40
pWriter$ = 48
$T1 = 56
tv86 = 64
$T2 = 72
tv146 = 80
$T3 = 88
$T4 = 96
$T5 = 104
idx$ = 112
szErrorMsg$ = 128
__$ArrayPad$ = 256
this$ = 288
pConfigFile$ = 296
pSection$ = 304
bSystem$ = 312
?dtor$0@?0??initLogWriter@CCoreList@@QEAA_NPEAD0_N@Z@4HA PROC ; `CCoreList::initLogWriter'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0000e	48 8b 4d 38	 mov	 rcx, QWORD PTR $T1[rbp]
  00012	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5d		 pop	 rbp
  0001c	c3		 ret	 0
?dtor$0@?0??initLogWriter@CCoreList@@QEAA_NPEAD0_N@Z@4HA ENDP ; `CCoreList::initLogWriter'::`1'::dtor$0
bRes$ = 32
i$ = 36
nCount$ = 40
pWriter$ = 48
$T1 = 56
tv86 = 64
$T2 = 72
tv146 = 80
$T3 = 88
$T4 = 96
$T5 = 104
idx$ = 112
szErrorMsg$ = 128
__$ArrayPad$ = 256
this$ = 288
pConfigFile$ = 296
pSection$ = 304
bSystem$ = 312
?dtor$1@?0??initLogWriter@CCoreList@@QEAA_NPEAD0_N@Z@4HA PROC ; `CCoreList::initLogWriter'::`1'::dtor$1
  0001d	40 55		 push	 rbp
  0001f	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00023	48 8b ea	 mov	 rbp, rdx
  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  0002d	48 8b 4d 48	 mov	 rcx, QWORD PTR $T2[rbp]
  00031	e8 00 00 00 00	 call	 ??3@YAXPEAXAEBUnothrow_t@std@@@Z ; operator delete
  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5d		 pop	 rbp
  0003b	c3		 ret	 0
?dtor$1@?0??initLogWriter@CCoreList@@QEAA_NPEAD0_N@Z@4HA ENDP ; `CCoreList::initLogWriter'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
bRes$ = 32
i$ = 36
nCount$ = 40
pWriter$ = 48
$T1 = 56
tv86 = 64
$T2 = 72
tv146 = 80
$T3 = 88
$T4 = 96
$T5 = 104
idx$ = 112
szErrorMsg$ = 128
__$ArrayPad$ = 256
this$ = 288
pConfigFile$ = 296
pSection$ = 304
bSystem$ = 312
?dtor$0@?0??initLogWriter@CCoreList@@QEAA_NPEAD0_N@Z@4HA PROC ; `CCoreList::initLogWriter'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0000e	48 8b 4d 38	 mov	 rcx, QWORD PTR $T1[rbp]
  00012	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5d		 pop	 rbp
  0001c	c3		 ret	 0
?dtor$0@?0??initLogWriter@CCoreList@@QEAA_NPEAD0_N@Z@4HA ENDP ; `CCoreList::initLogWriter'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
bRes$ = 32
i$ = 36
nCount$ = 40
pWriter$ = 48
$T1 = 56
tv86 = 64
$T2 = 72
tv146 = 80
$T3 = 88
$T4 = 96
$T5 = 104
idx$ = 112
szErrorMsg$ = 128
__$ArrayPad$ = 256
this$ = 288
pConfigFile$ = 296
pSection$ = 304
bSystem$ = 312
?dtor$1@?0??initLogWriter@CCoreList@@QEAA_NPEAD0_N@Z@4HA PROC ; `CCoreList::initLogWriter'::`1'::dtor$1
  0001d	40 55		 push	 rbp
  0001f	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00023	48 8b ea	 mov	 rbp, rdx
  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  0002d	48 8b 4d 48	 mov	 rcx, QWORD PTR $T2[rbp]
  00031	e8 00 00 00 00	 call	 ??3@YAXPEAXAEBUnothrow_t@std@@@Z ; operator delete
  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5d		 pop	 rbp
  0003b	c3		 ret	 0
?dtor$1@?0??initLogWriter@CCoreList@@QEAA_NPEAD0_N@Z@4HA ENDP ; `CCoreList::initLogWriter'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?initComThread@CCoreList@@QEAA_NPEAD0@Z
_TEXT	SEGMENT
nCount$ = 32
i$ = 36
$T1 = 40
pComThread$ = 48
tv86 = 56
$T2 = 64
tv142 = 72
$T3 = 80
$T4 = 88
$T5 = 96
idx$ = 104
__$ArrayPad$ = 112
this$ = 144
pConfigFile$ = 152
pSection$ = 160
?initComThread@CCoreList@@QEAA_NPEAD0@Z PROC		; CCoreList::initComThread, COMDAT

; 655  : {

$LN17:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  00016	48 c7 44 24 60
	fe ff ff ff	 mov	 QWORD PTR $T5[rsp], -2
  0001f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00026	48 33 c4	 xor	 rax, rsp
  00029	48 89 44 24 70	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 656  : 	int nCount, i, idx;
; 657  : 	CComThread *pComThread;
; 658  : 	nCount = GetPrivateProfileInt(pSection, _T("LIST_COUNT"), 0, pConfigFile);

  0002e	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR pConfigFile$[rsp]
  00036	45 33 c0	 xor	 r8d, r8d
  00039	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46005
  00040	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pSection$[rsp]
  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetPrivateProfileIntA
  0004e	89 44 24 20	 mov	 DWORD PTR nCount$[rsp], eax

; 659  : 	if (nCount)

  00052	83 7c 24 20 00	 cmp	 DWORD PTR nCount$[rsp], 0
  00057	0f 84 94 01 00
	00		 je	 $LN5@initComThr

; 660  : 	{
; 661  : 		if (!m_pThreadList) {

  0005d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00065	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0006a	0f 85 9c 00 00
	00		 jne	 $LN6@initComThr

; 662  : 			m_pThreadList = new CTList<CComThread>();

  00070	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00075	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0007a	48 89 44 24 28	 mov	 QWORD PTR $T1[rsp], rax
  0007f	48 83 7c 24 28
	00		 cmp	 QWORD PTR $T1[rsp], 0
  00085	74 20		 je	 SHORT $LN11@initComThr
  00087	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0008c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T1[rsp]
  00091	e8 00 00 00 00	 call	 ?__autoclassinit2@?$CTList@VCComThread@@@@QEAAX_K@Z
  00096	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T1[rsp]
  0009b	e8 00 00 00 00	 call	 ??0?$CTList@VCComThread@@@@QEAA@XZ ; CTList<CComThread>::CTList<CComThread>
  000a0	48 89 44 24 38	 mov	 QWORD PTR tv86[rsp], rax
  000a5	eb 09		 jmp	 SHORT $LN12@initComThr
$LN11@initComThr:
  000a7	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tv86[rsp], 0
$LN12@initComThr:
  000b0	48 8b 44 24 38	 mov	 rax, QWORD PTR tv86[rsp]
  000b5	48 89 44 24 50	 mov	 QWORD PTR $T3[rsp], rax
  000ba	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000c2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR $T3[rsp]
  000c7	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 663  : 			if (!m_pThreadList->alloc(nCount + LIST_ADD_COUNT, eAlloc_Type_none)) {

  000cb	8b 44 24 20	 mov	 eax, DWORD PTR nCount$[rsp]
  000cf	83 c0 0a	 add	 eax, 10
  000d2	45 33 c0	 xor	 r8d, r8d
  000d5	8b d0		 mov	 edx, eax
  000d7	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000df	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  000e3	e8 00 00 00 00	 call	 ?alloc@?$CTList@VCComThread@@@@QEAAHHW4E_ALLOC_TYPE@@@Z ; CTList<CComThread>::alloc
  000e8	85 c0		 test	 eax, eax
  000ea	75 20		 jne	 SHORT $LN6@initComThr

; 664  : 				comErrorPrint("m_pThreadList = new CTList<CComThread>() is NULL");

  000ec	41 b8 98 02 00
	00		 mov	 r8d, 664		; 00000298H
  000f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46010
  000f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG46011
  00100	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 665  : 				return false;

  00105	32 c0		 xor	 al, al
  00107	e9 e7 00 00 00	 jmp	 $LN1@initComThr
$LN6@initComThr:

; 666  : 			}
; 667  : 		}
; 668  : 
; 669  : 		for (i = 0; i < nCount; i++) {

  0010c	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00114	eb 0a		 jmp	 SHORT $LN4@initComThr
$LN2@initComThr:
  00116	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  0011a	ff c0		 inc	 eax
  0011c	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@initComThr:
  00120	8b 44 24 20	 mov	 eax, DWORD PTR nCount$[rsp]
  00124	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  00128	0f 8d c3 00 00
	00		 jge	 $LN5@initComThr

; 670  : 			pComThread = new (std::nothrow) CComThread();

  0012e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00135	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  0013a	e8 00 00 00 00	 call	 ??2@YAPEAX_KAEBUnothrow_t@std@@@Z ; operator new
  0013f	48 89 44 24 40	 mov	 QWORD PTR $T2[rsp], rax
  00144	48 83 7c 24 40
	00		 cmp	 QWORD PTR $T2[rsp], 0
  0014a	74 11		 je	 SHORT $LN13@initComThr
  0014c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR $T2[rsp]
  00151	e8 00 00 00 00	 call	 ??0CComThread@@QEAA@XZ	; CComThread::CComThread
  00156	48 89 44 24 48	 mov	 QWORD PTR tv142[rsp], rax
  0015b	eb 09		 jmp	 SHORT $LN14@initComThr
$LN13@initComThr:
  0015d	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR tv142[rsp], 0
$LN14@initComThr:
  00166	48 8b 44 24 48	 mov	 rax, QWORD PTR tv142[rsp]
  0016b	48 89 44 24 58	 mov	 QWORD PTR $T4[rsp], rax
  00170	48 8b 44 24 58	 mov	 rax, QWORD PTR $T4[rsp]
  00175	48 89 44 24 30	 mov	 QWORD PTR pComThread$[rsp], rax

; 671  : 			if (!pComThread) {

  0017a	48 83 7c 24 30
	00		 cmp	 QWORD PTR pComThread$[rsp], 0
  00180	75 1d		 jne	 SHORT $LN8@initComThr

; 672  : 				comErrorPrint("new (std::nothrow) CComThread() is NULL");

  00182	41 b8 a0 02 00
	00		 mov	 r8d, 672		; 000002a0H
  00188	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46014
  0018f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG46015
  00196	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 673  : 				return false;

  0019b	32 c0		 xor	 al, al
  0019d	eb 54		 jmp	 SHORT $LN1@initComThr
$LN8@initComThr:

; 674  : 			}
; 675  : 			if (!m_pThreadList->push_back(pComThread, &idx)) {

  0019f	4c 8d 44 24 68	 lea	 r8, QWORD PTR idx$[rsp]
  001a4	48 8b 54 24 30	 mov	 rdx, QWORD PTR pComThread$[rsp]
  001a9	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001b1	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  001b5	e8 00 00 00 00	 call	 ?push_back@?$CTList@VCComThread@@@@QEAA_NPEAVCComThread@@PEAH@Z ; CTList<CComThread>::push_back
  001ba	0f b6 c0	 movzx	 eax, al
  001bd	85 c0		 test	 eax, eax
  001bf	75 1d		 jne	 SHORT $LN9@initComThr

; 676  : 				comErrorPrint("m_pThreadList->push_back");

  001c1	41 b8 a4 02 00
	00		 mov	 r8d, 676		; 000002a4H
  001c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46017
  001ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG46018
  001d5	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 677  : 				return false;

  001da	32 c0		 xor	 al, al
  001dc	eb 15		 jmp	 SHORT $LN1@initComThr
$LN9@initComThr:

; 678  : 			}
; 679  : 			pComThread->setIdx(idx);

  001de	8b 54 24 68	 mov	 edx, DWORD PTR idx$[rsp]
  001e2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pComThread$[rsp]
  001e7	e8 00 00 00 00	 call	 ?setIdx@CComThread@@QEAAXH@Z ; CComThread::setIdx

; 680  : 		}

  001ec	e9 25 ff ff ff	 jmp	 $LN2@initComThr
$LN5@initComThr:

; 681  : 	}
; 682  : 	return true;

  001f1	b0 01		 mov	 al, 1
$LN1@initComThr:

; 683  : }

  001f3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001f8	48 33 cc	 xor	 rcx, rsp
  001fb	e8 00 00 00 00	 call	 __security_check_cookie
  00200	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00207	c3		 ret	 0
?initComThread@CCoreList@@QEAA_NPEAD0@Z ENDP		; CCoreList::initComThread
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
nCount$ = 32
i$ = 36
$T1 = 40
pComThread$ = 48
tv86 = 56
$T2 = 64
tv142 = 72
$T3 = 80
$T4 = 88
$T5 = 96
idx$ = 104
__$ArrayPad$ = 112
this$ = 144
pConfigFile$ = 152
pSection$ = 160
?dtor$0@?0??initComThread@CCoreList@@QEAA_NPEAD0@Z@4HA PROC ; `CCoreList::initComThread'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0000e	48 8b 4d 28	 mov	 rcx, QWORD PTR $T1[rbp]
  00012	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5d		 pop	 rbp
  0001c	c3		 ret	 0
?dtor$0@?0??initComThread@CCoreList@@QEAA_NPEAD0@Z@4HA ENDP ; `CCoreList::initComThread'::`1'::dtor$0
nCount$ = 32
i$ = 36
$T1 = 40
pComThread$ = 48
tv86 = 56
$T2 = 64
tv142 = 72
$T3 = 80
$T4 = 88
$T5 = 96
idx$ = 104
__$ArrayPad$ = 112
this$ = 144
pConfigFile$ = 152
pSection$ = 160
?dtor$1@?0??initComThread@CCoreList@@QEAA_NPEAD0@Z@4HA PROC ; `CCoreList::initComThread'::`1'::dtor$1
  0001d	40 55		 push	 rbp
  0001f	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00023	48 8b ea	 mov	 rbp, rdx
  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  0002d	48 8b 4d 40	 mov	 rcx, QWORD PTR $T2[rbp]
  00031	e8 00 00 00 00	 call	 ??3@YAXPEAXAEBUnothrow_t@std@@@Z ; operator delete
  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5d		 pop	 rbp
  0003b	c3		 ret	 0
?dtor$1@?0??initComThread@CCoreList@@QEAA_NPEAD0@Z@4HA ENDP ; `CCoreList::initComThread'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
nCount$ = 32
i$ = 36
$T1 = 40
pComThread$ = 48
tv86 = 56
$T2 = 64
tv142 = 72
$T3 = 80
$T4 = 88
$T5 = 96
idx$ = 104
__$ArrayPad$ = 112
this$ = 144
pConfigFile$ = 152
pSection$ = 160
?dtor$0@?0??initComThread@CCoreList@@QEAA_NPEAD0@Z@4HA PROC ; `CCoreList::initComThread'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0000e	48 8b 4d 28	 mov	 rcx, QWORD PTR $T1[rbp]
  00012	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5d		 pop	 rbp
  0001c	c3		 ret	 0
?dtor$0@?0??initComThread@CCoreList@@QEAA_NPEAD0@Z@4HA ENDP ; `CCoreList::initComThread'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
nCount$ = 32
i$ = 36
$T1 = 40
pComThread$ = 48
tv86 = 56
$T2 = 64
tv142 = 72
$T3 = 80
$T4 = 88
$T5 = 96
idx$ = 104
__$ArrayPad$ = 112
this$ = 144
pConfigFile$ = 152
pSection$ = 160
?dtor$1@?0??initComThread@CCoreList@@QEAA_NPEAD0@Z@4HA PROC ; `CCoreList::initComThread'::`1'::dtor$1
  0001d	40 55		 push	 rbp
  0001f	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00023	48 8b ea	 mov	 rbp, rdx
  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  0002d	48 8b 4d 40	 mov	 rcx, QWORD PTR $T2[rbp]
  00031	e8 00 00 00 00	 call	 ??3@YAXPEAXAEBUnothrow_t@std@@@Z ; operator delete
  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5d		 pop	 rbp
  0003b	c3		 ret	 0
?dtor$1@?0??initComThread@CCoreList@@QEAA_NPEAD0@Z@4HA ENDP ; `CCoreList::initComThread'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?addQueueThread@CCoreList@@QEAAHH@Z
_TEXT	SEGMENT
pEventThread$ = 32
$T1 = 40
tv84 = 48
$T2 = 56
$T3 = 64
$T4 = 72
tv166 = 80
$T5 = 88
idx$ = 96
__$ArrayPad$ = 104
this$ = 128
nCount$ = 136
?addQueueThread@CCoreList@@QEAAHH@Z PROC		; CCoreList::addQueueThread, COMDAT

; 1149 : {

$LN17:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  0000d	48 c7 44 24 58
	fe ff ff ff	 mov	 QWORD PTR $T5[rsp], -2
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 44 24 68	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1150 : 	int idx;
; 1151 : 
; 1152 : 	if (!m_pEventThreadList) {

  00025	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0002d	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00032	75 26		 jne	 SHORT $LN2@addQueueTh

; 1153 : 		if (!initQueueThread(LIST_ADD_COUNT)) return -1;

  00034	45 33 c0	 xor	 r8d, r8d
  00037	ba 0a 00 00 00	 mov	 edx, 10
  0003c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00044	e8 00 00 00 00	 call	 ?initQueueThread@CCoreList@@QEAA_NHH@Z ; CCoreList::initQueueThread
  00049	0f b6 c0	 movzx	 eax, al
  0004c	85 c0		 test	 eax, eax
  0004e	75 0a		 jne	 SHORT $LN2@addQueueTh
  00050	b8 ff ff ff ff	 mov	 eax, -1
  00055	e9 db 01 00 00	 jmp	 $LN1@addQueueTh
$LN2@addQueueTh:

; 1154 : 	}
; 1155 : 
; 1156 : 	CComQueueThread *pEventThread = new (std::nothrow) CComQueueThread();

  0005a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00061	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  00066	e8 00 00 00 00	 call	 ??2@YAPEAX_KAEBUnothrow_t@std@@@Z ; operator new
  0006b	48 89 44 24 28	 mov	 QWORD PTR $T1[rsp], rax
  00070	48 83 7c 24 28
	00		 cmp	 QWORD PTR $T1[rsp], 0
  00076	74 11		 je	 SHORT $LN12@addQueueTh
  00078	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T1[rsp]
  0007d	e8 00 00 00 00	 call	 ??0CComQueueThread@@QEAA@XZ ; CComQueueThread::CComQueueThread
  00082	48 89 44 24 30	 mov	 QWORD PTR tv84[rsp], rax
  00087	eb 09		 jmp	 SHORT $LN13@addQueueTh
$LN12@addQueueTh:
  00089	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tv84[rsp], 0
$LN13@addQueueTh:
  00092	48 8b 44 24 30	 mov	 rax, QWORD PTR tv84[rsp]
  00097	48 89 44 24 40	 mov	 QWORD PTR $T3[rsp], rax
  0009c	48 8b 44 24 40	 mov	 rax, QWORD PTR $T3[rsp]
  000a1	48 89 44 24 20	 mov	 QWORD PTR pEventThread$[rsp], rax

; 1157 : 	if (!pEventThread) {

  000a6	48 83 7c 24 20
	00		 cmp	 QWORD PTR pEventThread$[rsp], 0
  000ac	75 23		 jne	 SHORT $LN4@addQueueTh

; 1158 : 		comErrorPrint("FAIL! pEventThread = new (std::nothrow) CComQueueThread()");

  000ae	41 b8 86 04 00
	00		 mov	 r8d, 1158		; 00000486H
  000b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46426
  000bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG46427
  000c2	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 1159 : 		return -1;

  000c7	b8 ff ff ff ff	 mov	 eax, -1
  000cc	e9 64 01 00 00	 jmp	 $LN1@addQueueTh
$LN4@addQueueTh:

; 1160 : 	}
; 1161 : 	if (!m_pEventThreadList->push_back(pEventThread, &idx)) {

  000d1	4c 8d 44 24 60	 lea	 r8, QWORD PTR idx$[rsp]
  000d6	48 8b 54 24 20	 mov	 rdx, QWORD PTR pEventThread$[rsp]
  000db	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000e3	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  000e7	e8 00 00 00 00	 call	 ?push_back@?$CTList@VCComQueueThread@@@@QEAA_NPEAVCComQueueThread@@PEAH@Z ; CTList<CComQueueThread>::push_back
  000ec	0f b6 c0	 movzx	 eax, al
  000ef	85 c0		 test	 eax, eax
  000f1	75 36		 jne	 SHORT $LN5@addQueueTh

; 1162 : 		_stprintf(g_szMessage, _T("[idx:%d] m_pEventThreadList->push_back(pEventThread)"), idx);

  000f3	44 8b 44 24 60	 mov	 r8d, DWORD PTR idx$[rsp]
  000f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46429
  000ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  00106	e8 00 00 00 00	 call	 sprintf

; 1163 : 		comErrorPrint(g_szMessage);

  0010b	41 b8 8b 04 00
	00		 mov	 r8d, 1163		; 0000048bH
  00111	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46430
  00118	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  0011f	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 1164 : 		goto ERROR_ADDEvent;

  00124	e9 cc 00 00 00	 jmp	 $ERROR_ADDEvent$18
$LN5@addQueueTh:

; 1165 : 	}
; 1166 : 	if (!pEventThread->init(nCount, idx)) {

  00129	44 8b 44 24 60	 mov	 r8d, DWORD PTR idx$[rsp]
  0012e	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR nCount$[rsp]
  00135	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pEventThread$[rsp]
  0013a	e8 00 00 00 00	 call	 ?init@CComQueueThread@@QEAA_NHH@Z ; CComQueueThread::init
  0013f	0f b6 c0	 movzx	 eax, al
  00142	85 c0		 test	 eax, eax
  00144	75 50		 jne	 SHORT $LN7@addQueueTh

; 1167 : 		m_pEventThreadList->del(idx);

  00146	8b 54 24 60	 mov	 edx, DWORD PTR idx$[rsp]
  0014a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00152	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00156	e8 00 00 00 00	 call	 ?del@?$CTList@VCComQueueThread@@@@QEAA_NH@Z ; CTList<CComQueueThread>::del

; 1168 : 		_stprintf(g_szMessage, _T("pEventThread->init(nCount:%d, idx:%d)"), nCount,idx);

  0015b	44 8b 4c 24 60	 mov	 r9d, DWORD PTR idx$[rsp]
  00160	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR nCount$[rsp]
  00168	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46433
  0016f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  00176	e8 00 00 00 00	 call	 sprintf

; 1169 : 		comErrorPrint(g_szMessage);

  0017b	41 b8 91 04 00
	00		 mov	 r8d, 1169		; 00000491H
  00181	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46434
  00188	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  0018f	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 1170 : 		goto ERROR_ADDEvent;

  00194	eb 5f		 jmp	 SHORT $ERROR_ADDEvent$18
$LN7@addQueueTh:

; 1171 : 	}
; 1172 : 	if (!pEventThread->start()) {

  00196	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pEventThread$[rsp]
  0019b	e8 00 00 00 00	 call	 ?start@CComQueueThread@@QEAA_NXZ ; CComQueueThread::start
  001a0	0f b6 c0	 movzx	 eax, al
  001a3	85 c0		 test	 eax, eax
  001a5	75 48		 jne	 SHORT $LN9@addQueueTh

; 1173 : 		m_pEventThreadList->del(idx);

  001a7	8b 54 24 60	 mov	 edx, DWORD PTR idx$[rsp]
  001ab	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001b3	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  001b7	e8 00 00 00 00	 call	 ?del@?$CTList@VCComQueueThread@@@@QEAA_NH@Z ; CTList<CComQueueThread>::del

; 1174 : 		_stprintf(g_szMessage, _T("[idx:%d] pEventThread->start()! "), idx);

  001bc	44 8b 44 24 60	 mov	 r8d, DWORD PTR idx$[rsp]
  001c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46437
  001c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  001cf	e8 00 00 00 00	 call	 sprintf

; 1175 : 		comErrorPrint(g_szMessage);

  001d4	41 b8 97 04 00
	00		 mov	 r8d, 1175		; 00000497H
  001da	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46438
  001e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  001e8	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 1176 : 		goto ERROR_ADDEvent;

  001ed	eb 06		 jmp	 SHORT $ERROR_ADDEvent$18
$LN9@addQueueTh:

; 1177 : 	}
; 1178 : 	return idx;

  001ef	8b 44 24 60	 mov	 eax, DWORD PTR idx$[rsp]
  001f3	eb 40		 jmp	 SHORT $LN1@addQueueTh
$ERROR_ADDEvent$18:

; 1179 : 
; 1180 : ERROR_ADDEvent:
; 1181 : 	delete pEventThread;

  001f5	48 8b 44 24 20	 mov	 rax, QWORD PTR pEventThread$[rsp]
  001fa	48 89 44 24 48	 mov	 QWORD PTR $T4[rsp], rax
  001ff	48 8b 44 24 48	 mov	 rax, QWORD PTR $T4[rsp]
  00204	48 89 44 24 38	 mov	 QWORD PTR $T2[rsp], rax
  00209	48 83 7c 24 38
	00		 cmp	 QWORD PTR $T2[rsp], 0
  0020f	74 16		 je	 SHORT $LN14@addQueueTh
  00211	ba 01 00 00 00	 mov	 edx, 1
  00216	48 8b 4c 24 38	 mov	 rcx, QWORD PTR $T2[rsp]
  0021b	e8 00 00 00 00	 call	 ??_GCComQueueThread@@QEAAPEAXI@Z
  00220	48 89 44 24 50	 mov	 QWORD PTR tv166[rsp], rax
  00225	eb 09		 jmp	 SHORT $LN15@addQueueTh
$LN14@addQueueTh:
  00227	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR tv166[rsp], 0
$LN15@addQueueTh:

; 1182 : 	return -1;

  00230	b8 ff ff ff ff	 mov	 eax, -1
$LN1@addQueueTh:

; 1183 : }

  00235	48 8b 4c 24 68	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0023a	48 33 cc	 xor	 rcx, rsp
  0023d	e8 00 00 00 00	 call	 __security_check_cookie
  00242	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00246	c3		 ret	 0
?addQueueThread@CCoreList@@QEAAHH@Z ENDP		; CCoreList::addQueueThread
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
pEventThread$ = 32
$T1 = 40
tv84 = 48
$T2 = 56
$T3 = 64
$T4 = 72
tv166 = 80
$T5 = 88
idx$ = 96
__$ArrayPad$ = 104
this$ = 128
nCount$ = 136
?dtor$0@?0??addQueueThread@CCoreList@@QEAAHH@Z@4HA PROC	; `CCoreList::addQueueThread'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00010	48 8b 4d 28	 mov	 rcx, QWORD PTR $T1[rbp]
  00014	e8 00 00 00 00	 call	 ??3@YAXPEAXAEBUnothrow_t@std@@@Z ; operator delete
  00019	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001d	5d		 pop	 rbp
  0001e	c3		 ret	 0
?dtor$0@?0??addQueueThread@CCoreList@@QEAAHH@Z@4HA ENDP	; `CCoreList::addQueueThread'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
pEventThread$ = 32
$T1 = 40
tv84 = 48
$T2 = 56
$T3 = 64
$T4 = 72
tv166 = 80
$T5 = 88
idx$ = 96
__$ArrayPad$ = 104
this$ = 128
nCount$ = 136
?dtor$0@?0??addQueueThread@CCoreList@@QEAAHH@Z@4HA PROC	; `CCoreList::addQueueThread'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00010	48 8b 4d 28	 mov	 rcx, QWORD PTR $T1[rbp]
  00014	e8 00 00 00 00	 call	 ??3@YAXPEAXAEBUnothrow_t@std@@@Z ; operator delete
  00019	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001d	5d		 pop	 rbp
  0001e	c3		 ret	 0
?dtor$0@?0??addQueueThread@CCoreList@@QEAAHH@Z@4HA ENDP	; `CCoreList::addQueueThread'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?addScheduler@CCoreList@@QEAAHHH@Z
_TEXT	SEGMENT
pScheduler$ = 48
$T1 = 56
tv84 = 64
$T2 = 72
$T3 = 80
$T4 = 88
tv168 = 96
$T5 = 104
idx$ = 112
__$ArrayPad$ = 120
this$ = 144
nCount$ = 152
millisecWait$ = 160
?addScheduler@CCoreList@@QEAAHHH@Z PROC			; CCoreList::addScheduler, COMDAT

; 1110 : {

$LN17:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  00015	48 c7 44 24 68
	fe ff ff ff	 mov	 QWORD PTR $T5[rsp], -2
  0001e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00025	48 33 c4	 xor	 rax, rsp
  00028	48 89 44 24 78	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1111 : 	int idx;
; 1112 : 
; 1113 : 	if (!m_pSchedulerList) {

  0002d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00035	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0003a	75 26		 jne	 SHORT $LN2@addSchedul

; 1114 : 		if (!initScheduler(LIST_ADD_COUNT)) {

  0003c	45 33 c0	 xor	 r8d, r8d
  0003f	ba 0a 00 00 00	 mov	 edx, 10
  00044	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0004c	e8 00 00 00 00	 call	 ?initScheduler@CCoreList@@QEAA_NHH@Z ; CCoreList::initScheduler
  00051	0f b6 c0	 movzx	 eax, al
  00054	85 c0		 test	 eax, eax
  00056	75 0a		 jne	 SHORT $LN2@addSchedul

; 1115 : 			return -1;

  00058	b8 ff ff ff ff	 mov	 eax, -1
  0005d	e9 ee 01 00 00	 jmp	 $LN1@addSchedul
$LN2@addSchedul:

; 1116 : 		}
; 1117 : 	}
; 1118 : 
; 1119 : 	CScheduler *pScheduler = new (std::nothrow) CScheduler();

  00062	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00069	b9 60 00 00 00	 mov	 ecx, 96			; 00000060H
  0006e	e8 00 00 00 00	 call	 ??2@YAPEAX_KAEBUnothrow_t@std@@@Z ; operator new
  00073	48 89 44 24 38	 mov	 QWORD PTR $T1[rsp], rax
  00078	48 83 7c 24 38
	00		 cmp	 QWORD PTR $T1[rsp], 0
  0007e	74 11		 je	 SHORT $LN12@addSchedul
  00080	48 8b 4c 24 38	 mov	 rcx, QWORD PTR $T1[rsp]
  00085	e8 00 00 00 00	 call	 ??0CScheduler@@QEAA@XZ	; CScheduler::CScheduler
  0008a	48 89 44 24 40	 mov	 QWORD PTR tv84[rsp], rax
  0008f	eb 09		 jmp	 SHORT $LN13@addSchedul
$LN12@addSchedul:
  00091	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv84[rsp], 0
$LN13@addSchedul:
  0009a	48 8b 44 24 40	 mov	 rax, QWORD PTR tv84[rsp]
  0009f	48 89 44 24 50	 mov	 QWORD PTR $T3[rsp], rax
  000a4	48 8b 44 24 50	 mov	 rax, QWORD PTR $T3[rsp]
  000a9	48 89 44 24 30	 mov	 QWORD PTR pScheduler$[rsp], rax

; 1120 : 	if (!pScheduler) {

  000ae	48 83 7c 24 30
	00		 cmp	 QWORD PTR pScheduler$[rsp], 0
  000b4	75 23		 jne	 SHORT $LN4@addSchedul

; 1121 : 		comErrorPrint("pScheduler = new (std::nothrow) CScheduler()");

  000b6	41 b8 61 04 00
	00		 mov	 r8d, 1121		; 00000461H
  000bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46389
  000c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG46390
  000ca	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 1122 : 		return -1;

  000cf	b8 ff ff ff ff	 mov	 eax, -1
  000d4	e9 77 01 00 00	 jmp	 $LN1@addSchedul
$LN4@addSchedul:

; 1123 : 	}
; 1124 : 	if (!m_pSchedulerList->push_back(pScheduler, &idx)) {

  000d9	4c 8d 44 24 70	 lea	 r8, QWORD PTR idx$[rsp]
  000de	48 8b 54 24 30	 mov	 rdx, QWORD PTR pScheduler$[rsp]
  000e3	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000eb	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  000ef	e8 00 00 00 00	 call	 ?push_back@?$CTList@VCScheduler@@@@QEAA_NPEAVCScheduler@@PEAH@Z ; CTList<CScheduler>::push_back
  000f4	0f b6 c0	 movzx	 eax, al
  000f7	85 c0		 test	 eax, eax
  000f9	75 36		 jne	 SHORT $LN5@addSchedul

; 1125 : 		_stprintf(g_szMessage, _T("[idx:%d] pScheduler->push_back(pWriter)"), idx);

  000fb	44 8b 44 24 70	 mov	 r8d, DWORD PTR idx$[rsp]
  00100	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46392
  00107	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  0010e	e8 00 00 00 00	 call	 sprintf

; 1126 : 		comErrorPrint(g_szMessage);

  00113	41 b8 66 04 00
	00		 mov	 r8d, 1126		; 00000466H
  00119	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46393
  00120	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  00127	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 1127 : 		goto ERROR_ADDScheduler;

  0012c	e9 df 00 00 00	 jmp	 $ERROR_ADDScheduler$18
$LN5@addSchedul:

; 1128 : 	}
; 1129 : 	if (!pScheduler->init(nCount, millisecWait, idx)) {

  00131	44 8b 4c 24 70	 mov	 r9d, DWORD PTR idx$[rsp]
  00136	44 8b 84 24 a0
	00 00 00	 mov	 r8d, DWORD PTR millisecWait$[rsp]
  0013e	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR nCount$[rsp]
  00145	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pScheduler$[rsp]
  0014a	e8 00 00 00 00	 call	 ?init@CScheduler@@QEAA_NHHH@Z ; CScheduler::init
  0014f	0f b6 c0	 movzx	 eax, al
  00152	85 c0		 test	 eax, eax
  00154	75 5b		 jne	 SHORT $LN7@addSchedul

; 1130 : 		m_pSchedulerList->del(idx);

  00156	8b 54 24 70	 mov	 edx, DWORD PTR idx$[rsp]
  0015a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00162	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00166	e8 00 00 00 00	 call	 ?del@?$CTList@VCScheduler@@@@QEAA_NH@Z ; CTList<CScheduler>::del

; 1131 : 		_stprintf(g_szMessage, _T("pScheduler->init(nCount:%d, millisecWait:%d, idx:%d)"), nCount, millisecWait, idx);

  0016b	8b 44 24 70	 mov	 eax, DWORD PTR idx$[rsp]
  0016f	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00173	44 8b 8c 24 a0
	00 00 00	 mov	 r9d, DWORD PTR millisecWait$[rsp]
  0017b	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR nCount$[rsp]
  00183	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46396
  0018a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  00191	e8 00 00 00 00	 call	 sprintf

; 1132 : 		comErrorPrint(g_szMessage);

  00196	41 b8 6c 04 00
	00		 mov	 r8d, 1132		; 0000046cH
  0019c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46397
  001a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  001aa	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 1133 : 		goto ERROR_ADDScheduler;

  001af	eb 5f		 jmp	 SHORT $ERROR_ADDScheduler$18
$LN7@addSchedul:

; 1134 : 	}
; 1135 : 	if (!pScheduler->start()) {

  001b1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pScheduler$[rsp]
  001b6	e8 00 00 00 00	 call	 ?start@CScheduler@@QEAA_NXZ ; CScheduler::start
  001bb	0f b6 c0	 movzx	 eax, al
  001be	85 c0		 test	 eax, eax
  001c0	75 48		 jne	 SHORT $LN9@addSchedul

; 1136 : 		m_pSchedulerList->del(idx);

  001c2	8b 54 24 70	 mov	 edx, DWORD PTR idx$[rsp]
  001c6	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001ce	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  001d2	e8 00 00 00 00	 call	 ?del@?$CTList@VCScheduler@@@@QEAA_NH@Z ; CTList<CScheduler>::del

; 1137 : 		_stprintf(g_szMessage, _T("[idx:%d] pScheduler->start()"), idx);

  001d7	44 8b 44 24 70	 mov	 r8d, DWORD PTR idx$[rsp]
  001dc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46400
  001e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  001ea	e8 00 00 00 00	 call	 sprintf

; 1138 : 		comErrorPrint(g_szMessage);

  001ef	41 b8 72 04 00
	00		 mov	 r8d, 1138		; 00000472H
  001f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46401
  001fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  00203	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 1139 : 		goto ERROR_ADDScheduler;

  00208	eb 06		 jmp	 SHORT $ERROR_ADDScheduler$18
$LN9@addSchedul:

; 1140 : 	}
; 1141 : 	return idx;

  0020a	8b 44 24 70	 mov	 eax, DWORD PTR idx$[rsp]
  0020e	eb 40		 jmp	 SHORT $LN1@addSchedul
$ERROR_ADDScheduler$18:

; 1142 : 
; 1143 : ERROR_ADDScheduler:
; 1144 : 	delete pScheduler;

  00210	48 8b 44 24 30	 mov	 rax, QWORD PTR pScheduler$[rsp]
  00215	48 89 44 24 58	 mov	 QWORD PTR $T4[rsp], rax
  0021a	48 8b 44 24 58	 mov	 rax, QWORD PTR $T4[rsp]
  0021f	48 89 44 24 48	 mov	 QWORD PTR $T2[rsp], rax
  00224	48 83 7c 24 48
	00		 cmp	 QWORD PTR $T2[rsp], 0
  0022a	74 16		 je	 SHORT $LN14@addSchedul
  0022c	ba 01 00 00 00	 mov	 edx, 1
  00231	48 8b 4c 24 48	 mov	 rcx, QWORD PTR $T2[rsp]
  00236	e8 00 00 00 00	 call	 ??_GCScheduler@@QEAAPEAXI@Z
  0023b	48 89 44 24 60	 mov	 QWORD PTR tv168[rsp], rax
  00240	eb 09		 jmp	 SHORT $LN15@addSchedul
$LN14@addSchedul:
  00242	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR tv168[rsp], 0
$LN15@addSchedul:

; 1145 : 	return -1;

  0024b	b8 ff ff ff ff	 mov	 eax, -1
$LN1@addSchedul:

; 1146 : }

  00250	48 8b 4c 24 78	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00255	48 33 cc	 xor	 rcx, rsp
  00258	e8 00 00 00 00	 call	 __security_check_cookie
  0025d	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00264	c3		 ret	 0
?addScheduler@CCoreList@@QEAAHHH@Z ENDP			; CCoreList::addScheduler
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
pScheduler$ = 48
$T1 = 56
tv84 = 64
$T2 = 72
$T3 = 80
$T4 = 88
tv168 = 96
$T5 = 104
idx$ = 112
__$ArrayPad$ = 120
this$ = 144
nCount$ = 152
millisecWait$ = 160
?dtor$0@?0??addScheduler@CCoreList@@QEAAHHH@Z@4HA PROC	; `CCoreList::addScheduler'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00010	48 8b 4d 38	 mov	 rcx, QWORD PTR $T1[rbp]
  00014	e8 00 00 00 00	 call	 ??3@YAXPEAXAEBUnothrow_t@std@@@Z ; operator delete
  00019	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001d	5d		 pop	 rbp
  0001e	c3		 ret	 0
?dtor$0@?0??addScheduler@CCoreList@@QEAAHHH@Z@4HA ENDP	; `CCoreList::addScheduler'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
pScheduler$ = 48
$T1 = 56
tv84 = 64
$T2 = 72
$T3 = 80
$T4 = 88
tv168 = 96
$T5 = 104
idx$ = 112
__$ArrayPad$ = 120
this$ = 144
nCount$ = 152
millisecWait$ = 160
?dtor$0@?0??addScheduler@CCoreList@@QEAAHHH@Z@4HA PROC	; `CCoreList::addScheduler'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00010	48 8b 4d 38	 mov	 rcx, QWORD PTR $T1[rbp]
  00014	e8 00 00 00 00	 call	 ??3@YAXPEAXAEBUnothrow_t@std@@@Z ; operator delete
  00019	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001d	5d		 pop	 rbp
  0001e	c3		 ret	 0
?dtor$0@?0??addScheduler@CCoreList@@QEAAHHH@Z@4HA ENDP	; `CCoreList::addScheduler'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?addLogWriter@CCoreList@@QEAAHH@Z
_TEXT	SEGMENT
pWriter$ = 32
$T1 = 40
tv83 = 48
$T2 = 56
$T3 = 64
$T4 = 72
tv165 = 80
$T5 = 88
idx$ = 96
__$ArrayPad$ = 104
this$ = 128
nCount$ = 136
?addLogWriter@CCoreList@@QEAAHH@Z PROC			; CCoreList::addLogWriter, COMDAT

; 1073 : {

$LN17:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  0000d	48 c7 44 24 58
	fe ff ff ff	 mov	 QWORD PTR $T5[rsp], -2
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 44 24 68	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1074 : 	int idx;
; 1075 : 
; 1076 : 	if (!m_pWriterList) {

  00025	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0002d	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00031	75 23		 jne	 SHORT $LN2@addLogWrit

; 1077 : 		if (!initLogWriter(LIST_ADD_COUNT)) return -1;

  00033	ba 0a 00 00 00	 mov	 edx, 10
  00038	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00040	e8 00 00 00 00	 call	 ?initLogWriter@CCoreList@@QEAA_NH@Z ; CCoreList::initLogWriter
  00045	0f b6 c0	 movzx	 eax, al
  00048	85 c0		 test	 eax, eax
  0004a	75 0a		 jne	 SHORT $LN2@addLogWrit
  0004c	b8 ff ff ff ff	 mov	 eax, -1
  00051	e9 d8 01 00 00	 jmp	 $LN1@addLogWrit
$LN2@addLogWrit:

; 1078 : 	}
; 1079 : 
; 1080 : 	CSTLogger *pWriter = new (std::nothrow) CSTLogger();

  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  0005d	b9 58 00 00 00	 mov	 ecx, 88			; 00000058H
  00062	e8 00 00 00 00	 call	 ??2@YAPEAX_KAEBUnothrow_t@std@@@Z ; operator new
  00067	48 89 44 24 28	 mov	 QWORD PTR $T1[rsp], rax
  0006c	48 83 7c 24 28
	00		 cmp	 QWORD PTR $T1[rsp], 0
  00072	74 11		 je	 SHORT $LN12@addLogWrit
  00074	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T1[rsp]
  00079	e8 00 00 00 00	 call	 ??0CSTLogger@@QEAA@XZ	; CSTLogger::CSTLogger
  0007e	48 89 44 24 30	 mov	 QWORD PTR tv83[rsp], rax
  00083	eb 09		 jmp	 SHORT $LN13@addLogWrit
$LN12@addLogWrit:
  00085	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tv83[rsp], 0
$LN13@addLogWrit:
  0008e	48 8b 44 24 30	 mov	 rax, QWORD PTR tv83[rsp]
  00093	48 89 44 24 40	 mov	 QWORD PTR $T3[rsp], rax
  00098	48 8b 44 24 40	 mov	 rax, QWORD PTR $T3[rsp]
  0009d	48 89 44 24 20	 mov	 QWORD PTR pWriter$[rsp], rax

; 1081 : 	if (!pWriter) {

  000a2	48 83 7c 24 20
	00		 cmp	 QWORD PTR pWriter$[rsp], 0
  000a8	75 23		 jne	 SHORT $LN4@addLogWrit

; 1082 : 		comErrorPrint("pWriter = new (std::nothrow) CSTLogger()");

  000aa	41 b8 3a 04 00
	00		 mov	 r8d, 1082		; 0000043aH
  000b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46351
  000b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG46352
  000be	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 1083 : 		return -1;

  000c3	b8 ff ff ff ff	 mov	 eax, -1
  000c8	e9 61 01 00 00	 jmp	 $LN1@addLogWrit
$LN4@addLogWrit:

; 1084 : 	}
; 1085 : 	if (!m_pWriterList->push_back(pWriter, &idx)) {

  000cd	4c 8d 44 24 60	 lea	 r8, QWORD PTR idx$[rsp]
  000d2	48 8b 54 24 20	 mov	 rdx, QWORD PTR pWriter$[rsp]
  000d7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000df	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000e2	e8 00 00 00 00	 call	 ?push_back@?$CTList@VCSTLogger@@@@QEAA_NPEAVCSTLogger@@PEAH@Z ; CTList<CSTLogger>::push_back
  000e7	0f b6 c0	 movzx	 eax, al
  000ea	85 c0		 test	 eax, eax
  000ec	75 36		 jne	 SHORT $LN5@addLogWrit

; 1086 : 		_stprintf(g_szMessage, _T("[idx:%d] pWriter->push_back(pWriter)"), idx);

  000ee	44 8b 44 24 60	 mov	 r8d, DWORD PTR idx$[rsp]
  000f3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46354
  000fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  00101	e8 00 00 00 00	 call	 sprintf

; 1087 : 		comErrorPrint(g_szMessage);

  00106	41 b8 3f 04 00
	00		 mov	 r8d, 1087		; 0000043fH
  0010c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46355
  00113	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  0011a	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 1088 : 		goto ERROR_ADDWRITER;

  0011f	e9 ca 00 00 00	 jmp	 $ERROR_ADDWRITER$18
$LN5@addLogWrit:

; 1089 : 	}
; 1090 : 	if (!pWriter->init(nCount, idx)) {

  00124	44 8b 44 24 60	 mov	 r8d, DWORD PTR idx$[rsp]
  00129	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR nCount$[rsp]
  00130	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pWriter$[rsp]
  00135	e8 00 00 00 00	 call	 ?init@CSTLogger@@QEAA_NHH@Z ; CSTLogger::init
  0013a	0f b6 c0	 movzx	 eax, al
  0013d	85 c0		 test	 eax, eax
  0013f	75 4f		 jne	 SHORT $LN7@addLogWrit

; 1091 : 		m_pWriterList->del(idx);

  00141	8b 54 24 60	 mov	 edx, DWORD PTR idx$[rsp]
  00145	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0014d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00150	e8 00 00 00 00	 call	 ?del@?$CTList@VCSTLogger@@@@QEAA_NH@Z ; CTList<CSTLogger>::del

; 1092 : 		_stprintf(g_szMessage, _T("pWriter->init(nCount:%d, idx:%d)"), nCount, idx);

  00155	44 8b 4c 24 60	 mov	 r9d, DWORD PTR idx$[rsp]
  0015a	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR nCount$[rsp]
  00162	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46358
  00169	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  00170	e8 00 00 00 00	 call	 sprintf

; 1093 : 		comErrorPrint(g_szMessage);

  00175	41 b8 45 04 00
	00		 mov	 r8d, 1093		; 00000445H
  0017b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46359
  00182	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  00189	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 1094 : 		goto ERROR_ADDWRITER;

  0018e	eb 5e		 jmp	 SHORT $ERROR_ADDWRITER$18
$LN7@addLogWrit:

; 1095 : 	}
; 1096 : 	if (!pWriter->start()) {

  00190	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pWriter$[rsp]
  00195	e8 00 00 00 00	 call	 ?start@CSTLogger@@QEAA_NXZ ; CSTLogger::start
  0019a	0f b6 c0	 movzx	 eax, al
  0019d	85 c0		 test	 eax, eax
  0019f	75 47		 jne	 SHORT $LN9@addLogWrit

; 1097 : 		m_pWriterList->del(idx);

  001a1	8b 54 24 60	 mov	 edx, DWORD PTR idx$[rsp]
  001a5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001ad	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  001b0	e8 00 00 00 00	 call	 ?del@?$CTList@VCSTLogger@@@@QEAA_NH@Z ; CTList<CSTLogger>::del

; 1098 : 		_stprintf(g_szMessage, _T("[idx:%d] pWriter->start()!"), idx);

  001b5	44 8b 44 24 60	 mov	 r8d, DWORD PTR idx$[rsp]
  001ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46362
  001c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  001c8	e8 00 00 00 00	 call	 sprintf

; 1099 : 		comErrorPrint(g_szMessage);

  001cd	41 b8 4b 04 00
	00		 mov	 r8d, 1099		; 0000044bH
  001d3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46363
  001da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  001e1	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 1100 : 		goto ERROR_ADDWRITER;

  001e6	eb 06		 jmp	 SHORT $ERROR_ADDWRITER$18
$LN9@addLogWrit:

; 1101 : 	}
; 1102 : 	return idx;

  001e8	8b 44 24 60	 mov	 eax, DWORD PTR idx$[rsp]
  001ec	eb 40		 jmp	 SHORT $LN1@addLogWrit
$ERROR_ADDWRITER$18:

; 1103 : 
; 1104 : ERROR_ADDWRITER:
; 1105 : 	delete pWriter;

  001ee	48 8b 44 24 20	 mov	 rax, QWORD PTR pWriter$[rsp]
  001f3	48 89 44 24 48	 mov	 QWORD PTR $T4[rsp], rax
  001f8	48 8b 44 24 48	 mov	 rax, QWORD PTR $T4[rsp]
  001fd	48 89 44 24 38	 mov	 QWORD PTR $T2[rsp], rax
  00202	48 83 7c 24 38
	00		 cmp	 QWORD PTR $T2[rsp], 0
  00208	74 16		 je	 SHORT $LN14@addLogWrit
  0020a	ba 01 00 00 00	 mov	 edx, 1
  0020f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR $T2[rsp]
  00214	e8 00 00 00 00	 call	 ??_GCSTLogger@@QEAAPEAXI@Z
  00219	48 89 44 24 50	 mov	 QWORD PTR tv165[rsp], rax
  0021e	eb 09		 jmp	 SHORT $LN15@addLogWrit
$LN14@addLogWrit:
  00220	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR tv165[rsp], 0
$LN15@addLogWrit:

; 1106 : 	return -1;

  00229	b8 ff ff ff ff	 mov	 eax, -1
$LN1@addLogWrit:

; 1107 : }

  0022e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00233	48 33 cc	 xor	 rcx, rsp
  00236	e8 00 00 00 00	 call	 __security_check_cookie
  0023b	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0023f	c3		 ret	 0
?addLogWriter@CCoreList@@QEAAHH@Z ENDP			; CCoreList::addLogWriter
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
pWriter$ = 32
$T1 = 40
tv83 = 48
$T2 = 56
$T3 = 64
$T4 = 72
tv165 = 80
$T5 = 88
idx$ = 96
__$ArrayPad$ = 104
this$ = 128
nCount$ = 136
?dtor$0@?0??addLogWriter@CCoreList@@QEAAHH@Z@4HA PROC	; `CCoreList::addLogWriter'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00010	48 8b 4d 28	 mov	 rcx, QWORD PTR $T1[rbp]
  00014	e8 00 00 00 00	 call	 ??3@YAXPEAXAEBUnothrow_t@std@@@Z ; operator delete
  00019	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001d	5d		 pop	 rbp
  0001e	c3		 ret	 0
?dtor$0@?0??addLogWriter@CCoreList@@QEAAHH@Z@4HA ENDP	; `CCoreList::addLogWriter'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
pWriter$ = 32
$T1 = 40
tv83 = 48
$T2 = 56
$T3 = 64
$T4 = 72
tv165 = 80
$T5 = 88
idx$ = 96
__$ArrayPad$ = 104
this$ = 128
nCount$ = 136
?dtor$0@?0??addLogWriter@CCoreList@@QEAAHH@Z@4HA PROC	; `CCoreList::addLogWriter'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00010	48 8b 4d 28	 mov	 rcx, QWORD PTR $T1[rbp]
  00014	e8 00 00 00 00	 call	 ??3@YAXPEAXAEBUnothrow_t@std@@@Z ; operator delete
  00019	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001d	5d		 pop	 rbp
  0001e	c3		 ret	 0
?dtor$0@?0??addLogWriter@CCoreList@@QEAAHH@Z@4HA ENDP	; `CCoreList::addLogWriter'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?delComThread@CCoreList@@QEAA_NH@Z
_TEXT	SEGMENT
pThread$ = 32
$T1 = 40
$T2 = 48
tv76 = 56
this$ = 80
nSeq$ = 88
?delComThread@CCoreList@@QEAA_NH@Z PROC			; CCoreList::delComThread, COMDAT

; 1062 : {

$LN6:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1063 : 	CComThread *pThread = m_pThreadList->getObj(nSeq);

  0000d	8b 54 24 58	 mov	 edx, DWORD PTR nSeq$[rsp]
  00011	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00016	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0001a	e8 00 00 00 00	 call	 ?getObj@?$CTList@VCComThread@@@@QEAAPEAVCComThread@@H@Z ; CTList<CComThread>::getObj
  0001f	48 89 44 24 20	 mov	 QWORD PTR pThread$[rsp], rax

; 1064 : 	if (pThread) {

  00024	48 83 7c 24 20
	00		 cmp	 QWORD PTR pThread$[rsp], 0
  0002a	74 51		 je	 SHORT $LN2@delComThre

; 1065 : 		m_pThreadList->del(nSeq);

  0002c	8b 54 24 58	 mov	 edx, DWORD PTR nSeq$[rsp]
  00030	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00035	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00039	e8 00 00 00 00	 call	 ?del@?$CTList@VCComThread@@@@QEAA_NH@Z ; CTList<CComThread>::del

; 1066 : 		delete pThread;

  0003e	48 8b 44 24 20	 mov	 rax, QWORD PTR pThread$[rsp]
  00043	48 89 44 24 30	 mov	 QWORD PTR $T2[rsp], rax
  00048	48 8b 44 24 30	 mov	 rax, QWORD PTR $T2[rsp]
  0004d	48 89 44 24 28	 mov	 QWORD PTR $T1[rsp], rax
  00052	48 83 7c 24 28
	00		 cmp	 QWORD PTR $T1[rsp], 0
  00058	74 16		 je	 SHORT $LN4@delComThre
  0005a	ba 01 00 00 00	 mov	 edx, 1
  0005f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T1[rsp]
  00064	e8 00 00 00 00	 call	 ??_GCComThread@@QEAAPEAXI@Z
  00069	48 89 44 24 38	 mov	 QWORD PTR tv76[rsp], rax
  0006e	eb 09		 jmp	 SHORT $LN5@delComThre
$LN4@delComThre:
  00070	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tv76[rsp], 0
$LN5@delComThre:

; 1067 : 		return true;

  00079	b0 01		 mov	 al, 1
  0007b	eb 02		 jmp	 SHORT $LN1@delComThre
$LN2@delComThre:

; 1068 : 	}
; 1069 : 	return false;

  0007d	32 c0		 xor	 al, al
$LN1@delComThre:

; 1070 : }

  0007f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00083	c3		 ret	 0
?delComThread@CCoreList@@QEAA_NH@Z ENDP			; CCoreList::delComThread
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?addComThread@CCoreList@@QEAAHP6AXPEAUSTThreadInfo@@@ZPEAXH2@Z
_TEXT	SEGMENT
pThread$ = 48
$T1 = 56
tv83 = 64
$T2 = 72
$T3 = 80
$T4 = 88
tv174 = 96
$T5 = 104
idx$ = 112
__$ArrayPad$ = 120
this$ = 144
fpProc$ = 152
pClass$ = 160
millisec$ = 168
pObj$ = 176
?addComThread@CCoreList@@QEAAHP6AXPEAUSTThreadInfo@@@ZPEAXH2@Z PROC ; CCoreList::addComThread, COMDAT

; 1022 : {

$LN18:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  0001b	48 c7 44 24 68
	fe ff ff ff	 mov	 QWORD PTR $T5[rsp], -2
  00024	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002b	48 33 c4	 xor	 rax, rsp
  0002e	48 89 44 24 78	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1023 : 	CComThread *pThread;
; 1024 : 	int idx;
; 1025 : 	if (!m_pThreadList) {

  00033	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0003b	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00040	75 23		 jne	 SHORT $LN2@addComThre

; 1026 : 		if (!initComThread(LIST_ADD_COUNT)) return -1;

  00042	ba 0a 00 00 00	 mov	 edx, 10
  00047	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0004f	e8 00 00 00 00	 call	 ?initComThread@CCoreList@@QEAA_NH@Z ; CCoreList::initComThread
  00054	0f b6 c0	 movzx	 eax, al
  00057	85 c0		 test	 eax, eax
  00059	75 0a		 jne	 SHORT $LN2@addComThre
  0005b	b8 ff ff ff ff	 mov	 eax, -1
  00060	e9 16 02 00 00	 jmp	 $LN1@addComThre
$LN2@addComThre:

; 1027 : 	}
; 1028 : 
; 1029 : 	pThread = new (std::nothrow) CComThread();

  00065	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  0006c	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00071	e8 00 00 00 00	 call	 ??2@YAPEAX_KAEBUnothrow_t@std@@@Z ; operator new
  00076	48 89 44 24 38	 mov	 QWORD PTR $T1[rsp], rax
  0007b	48 83 7c 24 38
	00		 cmp	 QWORD PTR $T1[rsp], 0
  00081	74 11		 je	 SHORT $LN13@addComThre
  00083	48 8b 4c 24 38	 mov	 rcx, QWORD PTR $T1[rsp]
  00088	e8 00 00 00 00	 call	 ??0CComThread@@QEAA@XZ	; CComThread::CComThread
  0008d	48 89 44 24 40	 mov	 QWORD PTR tv83[rsp], rax
  00092	eb 09		 jmp	 SHORT $LN14@addComThre
$LN13@addComThre:
  00094	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv83[rsp], 0
$LN14@addComThre:
  0009d	48 8b 44 24 40	 mov	 rax, QWORD PTR tv83[rsp]
  000a2	48 89 44 24 50	 mov	 QWORD PTR $T3[rsp], rax
  000a7	48 8b 44 24 50	 mov	 rax, QWORD PTR $T3[rsp]
  000ac	48 89 44 24 30	 mov	 QWORD PTR pThread$[rsp], rax

; 1030 : 	if (!pThread) {

  000b1	48 83 7c 24 30
	00		 cmp	 QWORD PTR pThread$[rsp], 0
  000b7	75 45		 jne	 SHORT $LN4@addComThre

; 1031 : 		_stprintf(g_szMessage, _T("[lastIdx:%d] new CComThread"), m_pThreadList->lastIdx());

  000b9	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000c1	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  000c5	e8 00 00 00 00	 call	 ?lastIdx@?$CTList@VCComThread@@@@QEAAHXZ ; CTList<CComThread>::lastIdx
  000ca	44 8b c0	 mov	 r8d, eax
  000cd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46305
  000d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  000db	e8 00 00 00 00	 call	 sprintf

; 1032 : 		comErrorPrint(g_szMessage);

  000e0	41 b8 08 04 00
	00		 mov	 r8d, 1032		; 00000408H
  000e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46306
  000ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  000f4	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 1033 : 		goto ERROR_ADDCOMTHREAD;

  000f9	e9 3d 01 00 00	 jmp	 $ERROR_ADDCOMTHREAD$19
$LN4@addComThre:

; 1034 : 	}
; 1035 : 
; 1036 : 	if (!pThread->init(fpProc, pClass, millisec, pObj)) {

  000fe	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pObj$[rsp]
  00106	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0010b	44 8b 8c 24 a8
	00 00 00	 mov	 r9d, DWORD PTR millisec$[rsp]
  00113	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR pClass$[rsp]
  0011b	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR fpProc$[rsp]
  00123	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pThread$[rsp]
  00128	e8 00 00 00 00	 call	 ?init@CComThread@@QEAA_NP6AXPEAUSTThreadInfo@@@ZPEAXH2@Z ; CComThread::init
  0012d	0f b6 c0	 movzx	 eax, al
  00130	85 c0		 test	 eax, eax
  00132	75 45		 jne	 SHORT $LN6@addComThre

; 1037 : 		_stprintf(g_szMessage, _T("[lastIdx:%d] pComThread->init()"), m_pThreadList->lastIdx());

  00134	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0013c	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00140	e8 00 00 00 00	 call	 ?lastIdx@?$CTList@VCComThread@@@@QEAAHXZ ; CTList<CComThread>::lastIdx
  00145	44 8b c0	 mov	 r8d, eax
  00148	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46309
  0014f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  00156	e8 00 00 00 00	 call	 sprintf

; 1038 : 		comErrorPrint(g_szMessage);

  0015b	41 b8 0e 04 00
	00		 mov	 r8d, 1038		; 0000040eH
  00161	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46310
  00168	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  0016f	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 1039 : 		goto ERROR_ADDCOMTHREAD;

  00174	e9 c2 00 00 00	 jmp	 $ERROR_ADDCOMTHREAD$19
$LN6@addComThre:

; 1040 : 	}
; 1041 : 
; 1042 : 	if (!m_pThreadList->push_back(pThread, &idx)) {

  00179	4c 8d 44 24 70	 lea	 r8, QWORD PTR idx$[rsp]
  0017e	48 8b 54 24 30	 mov	 rdx, QWORD PTR pThread$[rsp]
  00183	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0018b	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0018f	e8 00 00 00 00	 call	 ?push_back@?$CTList@VCComThread@@@@QEAA_NPEAVCComThread@@PEAH@Z ; CTList<CComThread>::push_back
  00194	0f b6 c0	 movzx	 eax, al
  00197	85 c0		 test	 eax, eax
  00199	75 33		 jne	 SHORT $LN8@addComThre

; 1043 : 		_stprintf(g_szMessage, _T("[idx:%d] m_pThreadList->push_back()"), idx);

  0019b	44 8b 44 24 70	 mov	 r8d, DWORD PTR idx$[rsp]
  001a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46313
  001a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  001ae	e8 00 00 00 00	 call	 sprintf

; 1044 : 		comErrorPrint(g_szMessage);

  001b3	41 b8 14 04 00
	00		 mov	 r8d, 1044		; 00000414H
  001b9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46314
  001c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  001c7	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 1045 : 		goto ERROR_ADDCOMTHREAD;

  001cc	eb 6d		 jmp	 SHORT $ERROR_ADDCOMTHREAD$19
$LN8@addComThre:

; 1046 : 	}
; 1047 : 	pThread->setIdx(idx);

  001ce	8b 54 24 70	 mov	 edx, DWORD PTR idx$[rsp]
  001d2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pThread$[rsp]
  001d7	e8 00 00 00 00	 call	 ?setIdx@CComThread@@QEAAXH@Z ; CComThread::setIdx

; 1048 : 	if (!pThread->start()) {

  001dc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pThread$[rsp]
  001e1	e8 00 00 00 00	 call	 ?start@CComThread@@QEAA_NXZ ; CComThread::start
  001e6	0f b6 c0	 movzx	 eax, al
  001e9	85 c0		 test	 eax, eax
  001eb	75 48		 jne	 SHORT $LN10@addComThre

; 1049 : 		m_pThreadList->del(idx);

  001ed	8b 54 24 70	 mov	 edx, DWORD PTR idx$[rsp]
  001f1	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001f9	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  001fd	e8 00 00 00 00	 call	 ?del@?$CTList@VCComThread@@@@QEAA_NH@Z ; CTList<CComThread>::del

; 1050 : 		_stprintf(g_szMessage, _T("[idx:%d] pComThread->start()"), idx);

  00202	44 8b 44 24 70	 mov	 r8d, DWORD PTR idx$[rsp]
  00207	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46317
  0020e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  00215	e8 00 00 00 00	 call	 sprintf

; 1051 : 		comErrorPrint(g_szMessage);

  0021a	41 b8 1b 04 00
	00		 mov	 r8d, 1051		; 0000041bH
  00220	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46318
  00227	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  0022e	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 1052 : 		goto ERROR_ADDCOMTHREAD;

  00233	eb 06		 jmp	 SHORT $ERROR_ADDCOMTHREAD$19
$LN10@addComThre:

; 1053 : 	}
; 1054 : 	return idx;

  00235	8b 44 24 70	 mov	 eax, DWORD PTR idx$[rsp]
  00239	eb 40		 jmp	 SHORT $LN1@addComThre
$ERROR_ADDCOMTHREAD$19:

; 1055 : 
; 1056 : ERROR_ADDCOMTHREAD:
; 1057 : 	delete pThread;

  0023b	48 8b 44 24 30	 mov	 rax, QWORD PTR pThread$[rsp]
  00240	48 89 44 24 58	 mov	 QWORD PTR $T4[rsp], rax
  00245	48 8b 44 24 58	 mov	 rax, QWORD PTR $T4[rsp]
  0024a	48 89 44 24 48	 mov	 QWORD PTR $T2[rsp], rax
  0024f	48 83 7c 24 48
	00		 cmp	 QWORD PTR $T2[rsp], 0
  00255	74 16		 je	 SHORT $LN15@addComThre
  00257	ba 01 00 00 00	 mov	 edx, 1
  0025c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR $T2[rsp]
  00261	e8 00 00 00 00	 call	 ??_GCComThread@@QEAAPEAXI@Z
  00266	48 89 44 24 60	 mov	 QWORD PTR tv174[rsp], rax
  0026b	eb 09		 jmp	 SHORT $LN16@addComThre
$LN15@addComThre:
  0026d	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR tv174[rsp], 0
$LN16@addComThre:

; 1058 : 	return -1;

  00276	b8 ff ff ff ff	 mov	 eax, -1
$LN1@addComThre:

; 1059 : }

  0027b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00280	48 33 cc	 xor	 rcx, rsp
  00283	e8 00 00 00 00	 call	 __security_check_cookie
  00288	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0028f	c3		 ret	 0
?addComThread@CCoreList@@QEAAHP6AXPEAUSTThreadInfo@@@ZPEAXH2@Z ENDP ; CCoreList::addComThread
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
pThread$ = 48
$T1 = 56
tv83 = 64
$T2 = 72
$T3 = 80
$T4 = 88
tv174 = 96
$T5 = 104
idx$ = 112
__$ArrayPad$ = 120
this$ = 144
fpProc$ = 152
pClass$ = 160
millisec$ = 168
pObj$ = 176
?dtor$0@?0??addComThread@CCoreList@@QEAAHP6AXPEAUSTThreadInfo@@@ZPEAXH2@Z@4HA PROC ; `CCoreList::addComThread'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00010	48 8b 4d 38	 mov	 rcx, QWORD PTR $T1[rbp]
  00014	e8 00 00 00 00	 call	 ??3@YAXPEAXAEBUnothrow_t@std@@@Z ; operator delete
  00019	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001d	5d		 pop	 rbp
  0001e	c3		 ret	 0
?dtor$0@?0??addComThread@CCoreList@@QEAAHP6AXPEAUSTThreadInfo@@@ZPEAXH2@Z@4HA ENDP ; `CCoreList::addComThread'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
pThread$ = 48
$T1 = 56
tv83 = 64
$T2 = 72
$T3 = 80
$T4 = 88
tv174 = 96
$T5 = 104
idx$ = 112
__$ArrayPad$ = 120
this$ = 144
fpProc$ = 152
pClass$ = 160
millisec$ = 168
pObj$ = 176
?dtor$0@?0??addComThread@CCoreList@@QEAAHP6AXPEAUSTThreadInfo@@@ZPEAXH2@Z@4HA PROC ; `CCoreList::addComThread'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00010	48 8b 4d 38	 mov	 rcx, QWORD PTR $T1[rbp]
  00014	e8 00 00 00 00	 call	 ??3@YAXPEAXAEBUnothrow_t@std@@@Z ; operator delete
  00019	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001d	5d		 pop	 rbp
  0001e	c3		 ret	 0
?dtor$0@?0??addComThread@CCoreList@@QEAAHP6AXPEAUSTThreadInfo@@@ZPEAXH2@Z@4HA ENDP ; `CCoreList::addComThread'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?putTimer@CCoreList@@QEAA_NPEAUSTIntervalInfo@@@Z
_TEXT	SEGMENT
pSchedulerThread$ = 32
this$ = 64
p$ = 72
?putTimer@CCoreList@@QEAA_NPEAUSTIntervalInfo@@@Z PROC	; CCoreList::putTimer, COMDAT

; 1009 : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1010 : 	CScheduler *pSchedulerThread = m_pSchedulerList->getObj(p->nThreadIdx);

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR p$[rsp]
  00013	8b 10		 mov	 edx, DWORD PTR [rax]
  00015	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0001a	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0001e	e8 00 00 00 00	 call	 ?getObj@?$CTList@VCScheduler@@@@QEAAPEAVCScheduler@@H@Z ; CTList<CScheduler>::getObj
  00023	48 89 44 24 20	 mov	 QWORD PTR pSchedulerThread$[rsp], rax

; 1011 : 	if (!pSchedulerThread) {

  00028	48 83 7c 24 20
	00		 cmp	 QWORD PTR pSchedulerThread$[rsp], 0
  0002e	75 04		 jne	 SHORT $LN2@putTimer

; 1012 : 		return false;

  00030	32 c0		 xor	 al, al
  00032	eb 19		 jmp	 SHORT $LN1@putTimer
$LN2@putTimer:

; 1013 : 	}
; 1014 : 	if (!pSchedulerThread->addTime(p)) {

  00034	48 8b 54 24 48	 mov	 rdx, QWORD PTR p$[rsp]
  00039	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pSchedulerThread$[rsp]
  0003e	e8 00 00 00 00	 call	 ?addTime@CScheduler@@QEAAHPEAUSTIntervalInfo@@@Z ; CScheduler::addTime
  00043	85 c0		 test	 eax, eax
  00045	75 04		 jne	 SHORT $LN3@putTimer

; 1015 : 		return false;

  00047	32 c0		 xor	 al, al
  00049	eb 02		 jmp	 SHORT $LN1@putTimer
$LN3@putTimer:

; 1016 : 	}
; 1017 : 	return true;

  0004b	b0 01		 mov	 al, 1
$LN1@putTimer:

; 1018 : }

  0004d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00051	c3		 ret	 0
?putTimer@CCoreList@@QEAA_NPEAUSTIntervalInfo@@@Z ENDP	; CCoreList::putTimer
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?putEvent@CCoreList@@QEAA_NPEAUSTEvent@@@Z
_TEXT	SEGMENT
pQueueThread$ = 32
this$ = 64
p$ = 72
?putEvent@CCoreList@@QEAA_NPEAUSTEvent@@@Z PROC		; CCoreList::putEvent, COMDAT

; 997  : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 998  : 	CComQueueThread *pQueueThread = m_pEventThreadList->getObj(p->nThreadIdx);

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR p$[rsp]
  00013	8b 10		 mov	 edx, DWORD PTR [rax]
  00015	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0001a	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  0001e	e8 00 00 00 00	 call	 ?getObj@?$CTList@VCComQueueThread@@@@QEAAPEAVCComQueueThread@@H@Z ; CTList<CComQueueThread>::getObj
  00023	48 89 44 24 20	 mov	 QWORD PTR pQueueThread$[rsp], rax

; 999  : 	if (!pQueueThread) {

  00028	48 83 7c 24 20
	00		 cmp	 QWORD PTR pQueueThread$[rsp], 0
  0002e	75 04		 jne	 SHORT $LN2@putEvent

; 1000 : 		return false;

  00030	32 c0		 xor	 al, al
  00032	eb 1c		 jmp	 SHORT $LN1@putEvent
$LN2@putEvent:

; 1001 : 	}
; 1002 : 	if (!pQueueThread->putQueue(p)) {

  00034	48 8b 54 24 48	 mov	 rdx, QWORD PTR p$[rsp]
  00039	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pQueueThread$[rsp]
  0003e	e8 00 00 00 00	 call	 ?putQueue@CComQueueThread@@QEAA_NPEAUSTEvent@@@Z ; CComQueueThread::putQueue
  00043	0f b6 c0	 movzx	 eax, al
  00046	85 c0		 test	 eax, eax
  00048	75 04		 jne	 SHORT $LN3@putEvent

; 1003 : 		return false;

  0004a	32 c0		 xor	 al, al
  0004c	eb 02		 jmp	 SHORT $LN1@putEvent
$LN3@putEvent:

; 1004 : 	}
; 1005 : 	return true;

  0004e	b0 01		 mov	 al, 1
$LN1@putEvent:

; 1006 : }

  00050	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00054	c3		 ret	 0
?putEvent@CCoreList@@QEAA_NPEAUSTEvent@@@Z ENDP		; CCoreList::putEvent
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comcore.h
;	COMDAT ?delEvent@CCoreList@@QEAA_NPEAUSTEvent@@@Z
_TEXT	SEGMENT
this$ = 48
p$ = 56
?delEvent@CCoreList@@QEAA_NPEAUSTEvent@@@Z PROC		; CCoreList::delEvent, COMDAT

; 196  : 	inline bool delEvent(STEvent *p) { return m_pEventPool->delMem(p); }

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR p$[rsp]
  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00018	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  0001c	e8 00 00 00 00	 call	 ?delMem@?$CMemPool@USTEvent@@@@QEAA_NPEAUSTEvent@@@Z ; CMemPool<STEvent>::delMem
  00021	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00025	c3		 ret	 0
?delEvent@CCoreList@@QEAA_NPEAUSTEvent@@@Z ENDP		; CCoreList::delEvent
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?destroy@CCoreList@@QEAAXXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 48
$T4 = 56
$T5 = 64
$T6 = 72
$T7 = 80
tv71 = 88
$T8 = 96
tv80 = 104
$T9 = 112
tv89 = 120
$T10 = 128
tv130 = 136
$T11 = 144
tv139 = 152
$T12 = 160
tv148 = 168
this$ = 192
?destroy@CCoreList@@QEAAXXZ PROC			; CCoreList::destroy, COMDAT

; 495  : {

$LN21:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 496  : 	if (m_pWriterList) {

  0000c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00014	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00018	74 50		 je	 SHORT $LN2@destroy

; 497  : 		delete m_pWriterList; 

  0001a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00022	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00025	48 89 44 24 50	 mov	 QWORD PTR $T7[rsp], rax
  0002a	48 8b 44 24 50	 mov	 rax, QWORD PTR $T7[rsp]
  0002f	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax
  00034	48 83 7c 24 20
	00		 cmp	 QWORD PTR $T1[rsp], 0
  0003a	74 16		 je	 SHORT $LN9@destroy
  0003c	ba 01 00 00 00	 mov	 edx, 1
  00041	48 8b 4c 24 20	 mov	 rcx, QWORD PTR $T1[rsp]
  00046	e8 00 00 00 00	 call	 ??_G?$CTList@VCSTLogger@@@@QEAAPEAXI@Z
  0004b	48 89 44 24 58	 mov	 QWORD PTR tv71[rsp], rax
  00050	eb 09		 jmp	 SHORT $LN10@destroy
$LN9@destroy:
  00052	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR tv71[rsp], 0
$LN10@destroy:

; 498  : 		m_pWriterList = NULL;

  0005b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00063	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN2@destroy:

; 499  : 	}
; 500  : 	if (m_pSchedulerList) {

  0006a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00072	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00077	74 52		 je	 SHORT $LN3@destroy

; 501  : 		delete m_pSchedulerList;

  00079	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00081	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00085	48 89 44 24 60	 mov	 QWORD PTR $T8[rsp], rax
  0008a	48 8b 44 24 60	 mov	 rax, QWORD PTR $T8[rsp]
  0008f	48 89 44 24 28	 mov	 QWORD PTR $T2[rsp], rax
  00094	48 83 7c 24 28
	00		 cmp	 QWORD PTR $T2[rsp], 0
  0009a	74 16		 je	 SHORT $LN11@destroy
  0009c	ba 01 00 00 00	 mov	 edx, 1
  000a1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T2[rsp]
  000a6	e8 00 00 00 00	 call	 ??_G?$CTList@VCScheduler@@@@QEAAPEAXI@Z
  000ab	48 89 44 24 68	 mov	 QWORD PTR tv80[rsp], rax
  000b0	eb 09		 jmp	 SHORT $LN12@destroy
$LN11@destroy:
  000b2	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR tv80[rsp], 0
$LN12@destroy:

; 502  : 		m_pSchedulerList = NULL;

  000bb	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000c3	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
$LN3@destroy:

; 503  : 	}
; 504  : 	if (m_pThreadList) {

  000cb	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000d3	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  000d8	74 52		 je	 SHORT $LN4@destroy

; 505  : 		delete m_pThreadList;

  000da	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000e2	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000e6	48 89 44 24 70	 mov	 QWORD PTR $T9[rsp], rax
  000eb	48 8b 44 24 70	 mov	 rax, QWORD PTR $T9[rsp]
  000f0	48 89 44 24 30	 mov	 QWORD PTR $T3[rsp], rax
  000f5	48 83 7c 24 30
	00		 cmp	 QWORD PTR $T3[rsp], 0
  000fb	74 16		 je	 SHORT $LN13@destroy
  000fd	ba 01 00 00 00	 mov	 edx, 1
  00102	48 8b 4c 24 30	 mov	 rcx, QWORD PTR $T3[rsp]
  00107	e8 00 00 00 00	 call	 ??_G?$CTList@VCComThread@@@@QEAAPEAXI@Z
  0010c	48 89 44 24 78	 mov	 QWORD PTR tv89[rsp], rax
  00111	eb 09		 jmp	 SHORT $LN14@destroy
$LN13@destroy:
  00113	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR tv89[rsp], 0
$LN14@destroy:

; 506  : 		m_pThreadList = NULL;

  0011c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00124	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0
$LN4@destroy:

; 507  : 	}
; 508  : 	if (m_pEventThreadList) {

  0012c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00134	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00139	74 5e		 je	 SHORT $LN5@destroy

; 509  : 		delete m_pEventThreadList;

  0013b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00143	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00147	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR $T10[rsp], rax
  0014f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR $T10[rsp]
  00157	48 89 44 24 38	 mov	 QWORD PTR $T4[rsp], rax
  0015c	48 83 7c 24 38
	00		 cmp	 QWORD PTR $T4[rsp], 0
  00162	74 19		 je	 SHORT $LN15@destroy
  00164	ba 01 00 00 00	 mov	 edx, 1
  00169	48 8b 4c 24 38	 mov	 rcx, QWORD PTR $T4[rsp]
  0016e	e8 00 00 00 00	 call	 ??_G?$CTList@VCComQueueThread@@@@QEAAPEAXI@Z
  00173	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv130[rsp], rax
  0017b	eb 0c		 jmp	 SHORT $LN16@destroy
$LN15@destroy:
  0017d	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv130[rsp], 0
$LN16@destroy:

; 510  : 		m_pEventThreadList = NULL;

  00189	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00191	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0
$LN5@destroy:

; 511  : 	}
; 512  : 	if (m_pIntervalPool) {

  00199	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001a1	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  001a6	74 5e		 je	 SHORT $LN6@destroy

; 513  : 		delete m_pIntervalPool;

  001a8	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001b0	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  001b4	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR $T11[rsp], rax
  001bc	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR $T11[rsp]
  001c4	48 89 44 24 40	 mov	 QWORD PTR $T5[rsp], rax
  001c9	48 83 7c 24 40
	00		 cmp	 QWORD PTR $T5[rsp], 0
  001cf	74 19		 je	 SHORT $LN17@destroy
  001d1	ba 01 00 00 00	 mov	 edx, 1
  001d6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR $T5[rsp]
  001db	e8 00 00 00 00	 call	 ??_G?$CMemPool@USTIntervalInfo@@@@QEAAPEAXI@Z
  001e0	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv139[rsp], rax
  001e8	eb 0c		 jmp	 SHORT $LN18@destroy
$LN17@destroy:
  001ea	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv139[rsp], 0
$LN18@destroy:

; 514  : 		m_pIntervalPool = NULL;

  001f6	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001fe	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0
$LN6@destroy:

; 515  : 	}
; 516  : 	if (m_pEventPool) {

  00206	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0020e	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00213	74 5e		 je	 SHORT $LN7@destroy

; 517  : 		delete m_pEventPool;

  00215	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0021d	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00221	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR $T12[rsp], rax
  00229	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR $T12[rsp]
  00231	48 89 44 24 48	 mov	 QWORD PTR $T6[rsp], rax
  00236	48 83 7c 24 48
	00		 cmp	 QWORD PTR $T6[rsp], 0
  0023c	74 19		 je	 SHORT $LN19@destroy
  0023e	ba 01 00 00 00	 mov	 edx, 1
  00243	48 8b 4c 24 48	 mov	 rcx, QWORD PTR $T6[rsp]
  00248	e8 00 00 00 00	 call	 ??_G?$CMemPool@USTEvent@@@@QEAAPEAXI@Z
  0024d	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv148[rsp], rax
  00255	eb 0c		 jmp	 SHORT $LN20@destroy
$LN19@destroy:
  00257	48 c7 84 24 a8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv148[rsp], 0
$LN20@destroy:

; 518  : 		m_pEventPool = NULL;

  00263	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0026b	48 c7 40 28 00
	00 00 00	 mov	 QWORD PTR [rax+40], 0
$LN7@destroy:

; 519  : 	}
; 520  : }

  00273	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  0027a	c3		 ret	 0
?destroy@CCoreList@@QEAAXXZ ENDP			; CCoreList::destroy
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?start@CCoreList@@QEAA_NXZ
_TEXT	SEGMENT
i$ = 32
$T1 = 36
$T2 = 37
nCount$ = 40
pWriter$ = 48
pScheduler$ = 56
pEventThread$ = 64
pComThread$ = 72
$T3 = 80
curTm$ = 96
__$ArrayPad$ = 208
this$ = 240
?start@CCoreList@@QEAA_NXZ PROC				; CCoreList::start, COMDAT

; 917  : {

$LN32:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000c	48 c7 44 24 50
	fe ff ff ff	 mov	 QWORD PTR $T3[rsp], -2
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 918  : 	int i, nCount;
; 919  : 	CSTLogger *pWriter;
; 920  : 	CScheduler *pScheduler;
; 921  : 	CComQueueThread *pEventThread;
; 922  : 	CComThread *pComThread;	
; 923  : 
; 924  : 
; 925  : 	CDateTime curTm;

  00027	45 33 c0	 xor	 r8d, r8d
  0002a	ba 01 00 00 00	 mov	 edx, 1
  0002f	48 8d 4c 24 60	 lea	 rcx, QWORD PTR curTm$[rsp]
  00034	e8 00 00 00 00	 call	 ??0CDateTime@@QEAA@W4DT_TYPE@@W4TZ_TYPE@@@Z ; CDateTime::CDateTime
  00039	90		 npad	 1

; 926  : 	gs_today_time.date		= _ttoi(curTm.DateString(0));

  0003a	33 d2		 xor	 edx, edx
  0003c	48 8d 4c 24 60	 lea	 rcx, QWORD PTR curTm$[rsp]
  00041	e8 00 00 00 00	 call	 ?DateString@CDateTime@@QEAAPEBDD@Z ; CDateTime::DateString
  00046	48 8b c8	 mov	 rcx, rax
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  0004f	89 05 18 00 00
	00		 mov	 DWORD PTR ?gs_today_time@@3USTTodayTime@@A+24, eax

; 927  : 	gs_today_time.year		= curTm.Year();

  00055	48 8d 4c 24 60	 lea	 rcx, QWORD PTR curTm$[rsp]
  0005a	e8 00 00 00 00	 call	 ?Year@CDateTime@@QEAAHXZ ; CDateTime::Year
  0005f	89 05 00 00 00
	00		 mov	 DWORD PTR ?gs_today_time@@3USTTodayTime@@A, eax

; 928  : 	gs_today_time.month		= curTm.Month();

  00065	48 8d 4c 24 60	 lea	 rcx, QWORD PTR curTm$[rsp]
  0006a	e8 00 00 00 00	 call	 ?Month@CDateTime@@QEAAHXZ ; CDateTime::Month
  0006f	89 05 04 00 00
	00		 mov	 DWORD PTR ?gs_today_time@@3USTTodayTime@@A+4, eax

; 929  : 	gs_today_time.mday		= curTm.Mday();

  00075	48 8d 4c 24 60	 lea	 rcx, QWORD PTR curTm$[rsp]
  0007a	e8 00 00 00 00	 call	 ?Mday@CDateTime@@QEAAHXZ ; CDateTime::Mday
  0007f	89 05 08 00 00
	00		 mov	 DWORD PTR ?gs_today_time@@3USTTodayTime@@A+8, eax

; 930  : 	gs_today_time.hour		= curTm.Hour();

  00085	48 8d 4c 24 60	 lea	 rcx, QWORD PTR curTm$[rsp]
  0008a	e8 00 00 00 00	 call	 ?Hour@CDateTime@@QEAAHXZ ; CDateTime::Hour
  0008f	89 05 0c 00 00
	00		 mov	 DWORD PTR ?gs_today_time@@3USTTodayTime@@A+12, eax

; 931  : 	gs_today_time.minute	= curTm.Minute();

  00095	48 8d 4c 24 60	 lea	 rcx, QWORD PTR curTm$[rsp]
  0009a	e8 00 00 00 00	 call	 ?Minute@CDateTime@@QEAAHXZ ; CDateTime::Minute
  0009f	89 05 10 00 00
	00		 mov	 DWORD PTR ?gs_today_time@@3USTTodayTime@@A+16, eax

; 932  : 
; 933  : 	// STLogger
; 934  : 	if (m_pWriterList)

  000a5	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000ad	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  000b1	74 6b		 je	 SHORT $LN14@start

; 935  : 	{
; 936  : 		nCount = m_pWriterList->size();

  000b3	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000bb	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000be	e8 00 00 00 00	 call	 ?size@?$CTList@VCSTLogger@@@@QEAAHXZ ; CTList<CSTLogger>::size
  000c3	89 44 24 28	 mov	 DWORD PTR nCount$[rsp], eax

; 937  : 		for (i = 0; i < nCount; i++) {

  000c7	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000cf	eb 0a		 jmp	 SHORT $LN4@start
$LN2@start:
  000d1	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000d5	ff c0		 inc	 eax
  000d7	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@start:
  000db	8b 44 24 28	 mov	 eax, DWORD PTR nCount$[rsp]
  000df	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  000e3	7d 39		 jge	 SHORT $LN14@start

; 938  : 			pWriter = m_pWriterList->getObj(i);

  000e5	8b 54 24 20	 mov	 edx, DWORD PTR i$[rsp]
  000e9	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000f1	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000f4	e8 00 00 00 00	 call	 ?getObj@?$CTList@VCSTLogger@@@@QEAAPEAVCSTLogger@@H@Z ; CTList<CSTLogger>::getObj
  000f9	48 89 44 24 30	 mov	 QWORD PTR pWriter$[rsp], rax

; 939  : 			if (pWriter) {

  000fe	48 83 7c 24 30
	00		 cmp	 QWORD PTR pWriter$[rsp], 0
  00104	74 16		 je	 SHORT $LN15@start

; 940  : 				if (!pWriter->start()) {

  00106	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pWriter$[rsp]
  0010b	e8 00 00 00 00	 call	 ?start@CSTLogger@@QEAA_NXZ ; CSTLogger::start
  00110	0f b6 c0	 movzx	 eax, al
  00113	85 c0		 test	 eax, eax
  00115	75 05		 jne	 SHORT $LN15@start

; 941  : 					goto ERROR_STARTPROC;

  00117	e9 89 01 00 00	 jmp	 $ERROR_STARTPROC$33
$LN15@start:

; 942  : 				}
; 943  : 			}
; 944  : 		}

  0011c	eb b3		 jmp	 SHORT $LN2@start
$LN14@start:

; 945  : 	}
; 946  : 
; 947  : 	// CScheduler
; 948  : 	if (m_pSchedulerList)

  0011e	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00126	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0012b	74 6d		 je	 SHORT $LN18@start

; 949  : 	{
; 950  : 		nCount = m_pSchedulerList->size();

  0012d	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00135	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00139	e8 00 00 00 00	 call	 ?size@?$CTList@VCScheduler@@@@QEAAHXZ ; CTList<CScheduler>::size
  0013e	89 44 24 28	 mov	 DWORD PTR nCount$[rsp], eax

; 951  : 		for (i = 0; i < nCount; i++) {

  00142	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0014a	eb 0a		 jmp	 SHORT $LN7@start
$LN5@start:
  0014c	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00150	ff c0		 inc	 eax
  00152	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@start:
  00156	8b 44 24 28	 mov	 eax, DWORD PTR nCount$[rsp]
  0015a	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0015e	7d 3a		 jge	 SHORT $LN18@start

; 952  : 			pScheduler = m_pSchedulerList->getObj(i);

  00160	8b 54 24 20	 mov	 edx, DWORD PTR i$[rsp]
  00164	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0016c	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00170	e8 00 00 00 00	 call	 ?getObj@?$CTList@VCScheduler@@@@QEAAPEAVCScheduler@@H@Z ; CTList<CScheduler>::getObj
  00175	48 89 44 24 38	 mov	 QWORD PTR pScheduler$[rsp], rax

; 953  : 			if (pScheduler) {

  0017a	48 83 7c 24 38
	00		 cmp	 QWORD PTR pScheduler$[rsp], 0
  00180	74 16		 je	 SHORT $LN19@start

; 954  : 				if (!pScheduler->start()) {

  00182	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pScheduler$[rsp]
  00187	e8 00 00 00 00	 call	 ?start@CScheduler@@QEAA_NXZ ; CScheduler::start
  0018c	0f b6 c0	 movzx	 eax, al
  0018f	85 c0		 test	 eax, eax
  00191	75 05		 jne	 SHORT $LN19@start

; 955  : 					goto ERROR_STARTPROC;

  00193	e9 0d 01 00 00	 jmp	 $ERROR_STARTPROC$33
$LN19@start:

; 956  : 				}
; 957  : 			}
; 958  : 		}

  00198	eb b2		 jmp	 SHORT $LN5@start
$LN18@start:

; 959  : 	}
; 960  : 
; 961  : 	// Event
; 962  : 	if (m_pEventThreadList)

  0019a	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001a2	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  001a7	74 6d		 je	 SHORT $LN22@start

; 963  : 	{
; 964  : 		nCount = m_pEventThreadList->size();

  001a9	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001b1	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  001b5	e8 00 00 00 00	 call	 ?size@?$CTList@VCComQueueThread@@@@QEAAHXZ ; CTList<CComQueueThread>::size
  001ba	89 44 24 28	 mov	 DWORD PTR nCount$[rsp], eax

; 965  : 		for (i = 0; i < nCount; i++) {

  001be	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001c6	eb 0a		 jmp	 SHORT $LN10@start
$LN8@start:
  001c8	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  001cc	ff c0		 inc	 eax
  001ce	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN10@start:
  001d2	8b 44 24 28	 mov	 eax, DWORD PTR nCount$[rsp]
  001d6	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  001da	7d 3a		 jge	 SHORT $LN22@start

; 966  : 			pEventThread = m_pEventThreadList->getObj(i);

  001dc	8b 54 24 20	 mov	 edx, DWORD PTR i$[rsp]
  001e0	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001e8	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  001ec	e8 00 00 00 00	 call	 ?getObj@?$CTList@VCComQueueThread@@@@QEAAPEAVCComQueueThread@@H@Z ; CTList<CComQueueThread>::getObj
  001f1	48 89 44 24 40	 mov	 QWORD PTR pEventThread$[rsp], rax

; 967  : 			if (pEventThread) {

  001f6	48 83 7c 24 40
	00		 cmp	 QWORD PTR pEventThread$[rsp], 0
  001fc	74 16		 je	 SHORT $LN23@start

; 968  : 				if (!pEventThread->start()) {

  001fe	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pEventThread$[rsp]
  00203	e8 00 00 00 00	 call	 ?start@CComQueueThread@@QEAA_NXZ ; CComQueueThread::start
  00208	0f b6 c0	 movzx	 eax, al
  0020b	85 c0		 test	 eax, eax
  0020d	75 05		 jne	 SHORT $LN23@start

; 969  : 					goto ERROR_STARTPROC;

  0020f	e9 91 00 00 00	 jmp	 $ERROR_STARTPROC$33
$LN23@start:

; 970  : 				}
; 971  : 			}
; 972  : 		}

  00214	eb b2		 jmp	 SHORT $LN8@start
$LN22@start:

; 973  : 	}
; 974  : 
; 975  : 	// comThread
; 976  : 	if (m_pThreadList)

  00216	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0021e	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00223	74 6a		 je	 SHORT $LN26@start

; 977  : 	{
; 978  : 		nCount = m_pThreadList->size();

  00225	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0022d	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00231	e8 00 00 00 00	 call	 ?size@?$CTList@VCComThread@@@@QEAAHXZ ; CTList<CComThread>::size
  00236	89 44 24 28	 mov	 DWORD PTR nCount$[rsp], eax

; 979  : 		for (i = 0; i < nCount; i++) {

  0023a	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00242	eb 0a		 jmp	 SHORT $LN13@start
$LN11@start:
  00244	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00248	ff c0		 inc	 eax
  0024a	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN13@start:
  0024e	8b 44 24 28	 mov	 eax, DWORD PTR nCount$[rsp]
  00252	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00256	7d 37		 jge	 SHORT $LN26@start

; 980  : 			pComThread = m_pThreadList->getObj(i);

  00258	8b 54 24 20	 mov	 edx, DWORD PTR i$[rsp]
  0025c	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00264	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00268	e8 00 00 00 00	 call	 ?getObj@?$CTList@VCComThread@@@@QEAAPEAVCComThread@@H@Z ; CTList<CComThread>::getObj
  0026d	48 89 44 24 48	 mov	 QWORD PTR pComThread$[rsp], rax

; 981  : 			if (pComThread) {

  00272	48 83 7c 24 48
	00		 cmp	 QWORD PTR pComThread$[rsp], 0
  00278	74 13		 je	 SHORT $LN27@start

; 982  : 				if (!pComThread->start()) {

  0027a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pComThread$[rsp]
  0027f	e8 00 00 00 00	 call	 ?start@CComThread@@QEAA_NXZ ; CComThread::start
  00284	0f b6 c0	 movzx	 eax, al
  00287	85 c0		 test	 eax, eax
  00289	75 02		 jne	 SHORT $LN27@start

; 983  : 					goto ERROR_STARTPROC;

  0028b	eb 18		 jmp	 SHORT $ERROR_STARTPROC$33
$LN27@start:

; 984  : 				}
; 985  : 			}
; 986  : 		}

  0028d	eb b5		 jmp	 SHORT $LN11@start
$LN26@start:

; 987  : 	}
; 988  : 	return true;

  0028f	c6 44 24 24 01	 mov	 BYTE PTR $T1[rsp], 1
  00294	48 8d 4c 24 60	 lea	 rcx, QWORD PTR curTm$[rsp]
  00299	e8 00 00 00 00	 call	 ??1CDateTime@@QEAA@XZ	; CDateTime::~CDateTime
  0029e	0f b6 44 24 24	 movzx	 eax, BYTE PTR $T1[rsp]
  002a3	eb 21		 jmp	 SHORT $LN1@start
$ERROR_STARTPROC$33:

; 989  : 
; 990  : ERROR_STARTPROC:
; 991  : 	destroy();

  002a5	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  002ad	e8 00 00 00 00	 call	 ?destroy@CCoreList@@QEAAXXZ ; CCoreList::destroy

; 992  : 	return false;

  002b2	c6 44 24 25 00	 mov	 BYTE PTR $T2[rsp], 0
  002b7	48 8d 4c 24 60	 lea	 rcx, QWORD PTR curTm$[rsp]
  002bc	e8 00 00 00 00	 call	 ??1CDateTime@@QEAA@XZ	; CDateTime::~CDateTime
  002c1	0f b6 44 24 25	 movzx	 eax, BYTE PTR $T2[rsp]
$LN1@start:

; 993  : }

  002c6	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002ce	48 33 cc	 xor	 rcx, rsp
  002d1	e8 00 00 00 00	 call	 __security_check_cookie
  002d6	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  002dd	c3		 ret	 0
?start@CCoreList@@QEAA_NXZ ENDP				; CCoreList::start
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
i$ = 32
$T1 = 36
$T2 = 37
nCount$ = 40
pWriter$ = 48
pScheduler$ = 56
pEventThread$ = 64
pComThread$ = 72
$T3 = 80
curTm$ = 96
__$ArrayPad$ = 208
this$ = 240
?dtor$0@?0??start@CCoreList@@QEAA_NXZ@4HA PROC		; `CCoreList::start'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 4d 60	 lea	 rcx, QWORD PTR curTm$[rbp]
  0000d	e8 00 00 00 00	 call	 ??1CDateTime@@QEAA@XZ	; CDateTime::~CDateTime
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$0@?0??start@CCoreList@@QEAA_NXZ@4HA ENDP		; `CCoreList::start'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
i$ = 32
$T1 = 36
$T2 = 37
nCount$ = 40
pWriter$ = 48
pScheduler$ = 56
pEventThread$ = 64
pComThread$ = 72
$T3 = 80
curTm$ = 96
__$ArrayPad$ = 208
this$ = 240
?dtor$0@?0??start@CCoreList@@QEAA_NXZ@4HA PROC		; `CCoreList::start'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 4d 60	 lea	 rcx, QWORD PTR curTm$[rbp]
  0000d	e8 00 00 00 00	 call	 ??1CDateTime@@QEAA@XZ	; CDateTime::~CDateTime
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$0@?0??start@CCoreList@@QEAA_NXZ@4HA ENDP		; `CCoreList::start'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?setLoggerDisable@CCoreList@@QEAA_NPEAVCLogger@@@Z
_TEXT	SEGMENT
pBuf$ = 32
pWriter$ = 40
this$ = 64
pLogger$ = 72
?setLoggerDisable@CCoreList@@QEAA_NPEAVCLogger@@@Z PROC	; CCoreList::setLoggerDisable, COMDAT

; 899  : {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 900  : 	CSTLogger *pWriter = m_pWriterList->getObj(pLogger->getSTLNo());

  0000e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pLogger$[rsp]
  00013	e8 00 00 00 00	 call	 ?getSTLNo@CLogger@@QEAAHXZ ; CLogger::getSTLNo
  00018	8b d0		 mov	 edx, eax
  0001a	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0001f	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00022	e8 00 00 00 00	 call	 ?getObj@?$CTList@VCSTLogger@@@@QEAAPEAVCSTLogger@@H@Z ; CTList<CSTLogger>::getObj
  00027	48 89 44 24 28	 mov	 QWORD PTR pWriter$[rsp], rax

; 901  : 	if (!pWriter) {

  0002c	48 83 7c 24 28
	00		 cmp	 QWORD PTR pWriter$[rsp], 0
  00032	75 3d		 jne	 SHORT $LN2@setLoggerD

; 902  : 		_stprintf(g_szMessage, _T("pWriter is NULL! pLogger[nSTLNo:%d]"), pLogger->getSTLNo());

  00034	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pLogger$[rsp]
  00039	e8 00 00 00 00	 call	 ?getSTLNo@CLogger@@QEAAHXZ ; CLogger::getSTLNo
  0003e	44 8b c0	 mov	 r8d, eax
  00041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46226
  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  0004f	e8 00 00 00 00	 call	 sprintf

; 903  : 		comErrorPrint(g_szMessage);

  00054	41 b8 87 03 00
	00		 mov	 r8d, 903		; 00000387H
  0005a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46227
  00061	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  00068	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 904  : 		return false;

  0006d	32 c0		 xor	 al, al
  0006f	eb 4f		 jmp	 SHORT $LN1@setLoggerD
$LN2@setLoggerD:

; 905  : 	}
; 906  : 	pLogger->clearLogFlag(IS_LOG_ENABLE);

  00071	ba 00 00 08 00	 mov	 edx, 524288		; 00080000H
  00076	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pLogger$[rsp]
  0007b	e8 00 00 00 00	 call	 ?clearLogFlag@CLogger@@QEAAXW4E_LOG_FLAG@@@Z ; CLogger::clearLogFlag

; 907  : 	STLCommand *pBuf = (STLCommand *)gs_pMMgr->newBuf(sizeof(STLCommand));

  00080	ba 10 00 00 00	 mov	 edx, 16
  00085	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  0008c	e8 00 00 00 00	 call	 ?newBuf@CMemManager@@QEAAPEADH@Z ; CMemManager::newBuf
  00091	48 89 44 24 20	 mov	 QWORD PTR pBuf$[rsp], rax

; 908  : 	pBuf->nCommandCode = eLCode_DISABLE;

  00096	48 8b 44 24 20	 mov	 rax, QWORD PTR pBuf$[rsp]
  0009b	c7 00 02 00 00
	00		 mov	 DWORD PTR [rax], 2

; 909  : 	pBuf->p = pLogger;

  000a1	48 8b 44 24 20	 mov	 rax, QWORD PTR pBuf$[rsp]
  000a6	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pLogger$[rsp]
  000ab	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 910  : 	pWriter->pushCommand(pBuf);

  000af	48 8b 54 24 20	 mov	 rdx, QWORD PTR pBuf$[rsp]
  000b4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pWriter$[rsp]
  000b9	e8 00 00 00 00	 call	 ?pushCommand@CSTLogger@@QEAA_NPEAUSTLCommand@@@Z ; CSTLogger::pushCommand

; 911  : 	return true;

  000be	b0 01		 mov	 al, 1
$LN1@setLoggerD:

; 912  : }

  000c0	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c4	c3		 ret	 0
?setLoggerDisable@CCoreList@@QEAA_NPEAVCLogger@@@Z ENDP	; CCoreList::setLoggerDisable
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?setLoggerEnable@CCoreList@@QEAA_NPEAVCLogger@@@Z
_TEXT	SEGMENT
pBuf$ = 32
pWriter$ = 40
this$ = 64
pLogger$ = 72
?setLoggerEnable@CCoreList@@QEAA_NPEAVCLogger@@@Z PROC	; CCoreList::setLoggerEnable, COMDAT

; 883  : {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 884  : 	CSTLogger *pWriter = m_pWriterList->getObj(pLogger->getSTLNo());

  0000e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pLogger$[rsp]
  00013	e8 00 00 00 00	 call	 ?getSTLNo@CLogger@@QEAAHXZ ; CLogger::getSTLNo
  00018	8b d0		 mov	 edx, eax
  0001a	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0001f	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00022	e8 00 00 00 00	 call	 ?getObj@?$CTList@VCSTLogger@@@@QEAAPEAVCSTLogger@@H@Z ; CTList<CSTLogger>::getObj
  00027	48 89 44 24 28	 mov	 QWORD PTR pWriter$[rsp], rax

; 885  : 	if (!pWriter) {

  0002c	48 83 7c 24 28
	00		 cmp	 QWORD PTR pWriter$[rsp], 0
  00032	75 3d		 jne	 SHORT $LN2@setLoggerE

; 886  : 		_stprintf(g_szMessage, _T("pWriter is NULL! pLogger[nSTLNo:%d]"), pLogger->getSTLNo());

  00034	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pLogger$[rsp]
  00039	e8 00 00 00 00	 call	 ?getSTLNo@CLogger@@QEAAHXZ ; CLogger::getSTLNo
  0003e	44 8b c0	 mov	 r8d, eax
  00041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46215
  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  0004f	e8 00 00 00 00	 call	 sprintf

; 887  : 		comErrorPrint(g_szMessage);

  00054	41 b8 77 03 00
	00		 mov	 r8d, 887		; 00000377H
  0005a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46216
  00061	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  00068	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 888  : 		return false;

  0006d	32 c0		 xor	 al, al
  0006f	eb 4f		 jmp	 SHORT $LN1@setLoggerE
$LN2@setLoggerE:

; 889  : 	}
; 890  : 	pLogger->setLogFlag(IS_LOG_ENABLE);

  00071	ba 00 00 08 00	 mov	 edx, 524288		; 00080000H
  00076	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pLogger$[rsp]
  0007b	e8 00 00 00 00	 call	 ?setLogFlag@CLogger@@QEAAXW4E_LOG_FLAG@@@Z ; CLogger::setLogFlag

; 891  : 	STLCommand *pBuf = (STLCommand *)gs_pMMgr->newBuf(sizeof(STLCommand));

  00080	ba 10 00 00 00	 mov	 edx, 16
  00085	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  0008c	e8 00 00 00 00	 call	 ?newBuf@CMemManager@@QEAAPEADH@Z ; CMemManager::newBuf
  00091	48 89 44 24 20	 mov	 QWORD PTR pBuf$[rsp], rax

; 892  : 	pBuf->nCommandCode = eLCode_ENABLE;

  00096	48 8b 44 24 20	 mov	 rax, QWORD PTR pBuf$[rsp]
  0009b	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 893  : 	pBuf->p = pLogger;

  000a1	48 8b 44 24 20	 mov	 rax, QWORD PTR pBuf$[rsp]
  000a6	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pLogger$[rsp]
  000ab	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 894  : 	pWriter->pushCommand(pBuf);

  000af	48 8b 54 24 20	 mov	 rdx, QWORD PTR pBuf$[rsp]
  000b4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pWriter$[rsp]
  000b9	e8 00 00 00 00	 call	 ?pushCommand@CSTLogger@@QEAA_NPEAUSTLCommand@@@Z ; CSTLogger::pushCommand

; 895  : 	return true;

  000be	b0 01		 mov	 al, 1
$LN1@setLoggerE:

; 896  : }

  000c0	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c4	c3		 ret	 0
?setLoggerEnable@CCoreList@@QEAA_NPEAVCLogger@@@Z ENDP	; CCoreList::setLoggerEnable
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?initLogger@CCoreList@@QEAA_NPEAVCLogger@@@Z
_TEXT	SEGMENT
pWriter$ = 32
this$ = 64
pLogger$ = 72
?initLogger@CCoreList@@QEAA_NPEAVCLogger@@@Z PROC	; CCoreList::initLogger, COMDAT

; 863  : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 864  : 	if (!pLogger) {

  0000e	48 83 7c 24 48
	00		 cmp	 QWORD PTR pLogger$[rsp], 0
  00014	75 1d		 jne	 SHORT $LN2@initLogger

; 865  : 		comErrorPrint(g_szMessage);

  00016	41 b8 61 03 00
	00		 mov	 r8d, 865		; 00000361H
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46202
  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  0002a	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 866  : 		return false;

  0002f	32 c0		 xor	 al, al
  00031	eb 74		 jmp	 SHORT $LN1@initLogger
$LN2@initLogger:

; 867  : 	}
; 868  : 
; 869  : 	CSTLogger *pWriter = m_pWriterList->getObj(pLogger->getSTLNo());

  00033	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pLogger$[rsp]
  00038	e8 00 00 00 00	 call	 ?getSTLNo@CLogger@@QEAAHXZ ; CLogger::getSTLNo
  0003d	8b d0		 mov	 edx, eax
  0003f	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00044	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00047	e8 00 00 00 00	 call	 ?getObj@?$CTList@VCSTLogger@@@@QEAAPEAVCSTLogger@@H@Z ; CTList<CSTLogger>::getObj
  0004c	48 89 44 24 20	 mov	 QWORD PTR pWriter$[rsp], rax

; 870  : 	if (!pWriter) {

  00051	48 83 7c 24 20
	00		 cmp	 QWORD PTR pWriter$[rsp], 0
  00057	75 3d		 jne	 SHORT $LN3@initLogger

; 871  : 		_stprintf(g_szMessage, _T("pWriter is NULL!!![nSTLNo:%d]\n"), pLogger->getSTLNo());

  00059	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pLogger$[rsp]
  0005e	e8 00 00 00 00	 call	 ?getSTLNo@CLogger@@QEAAHXZ ; CLogger::getSTLNo
  00063	44 8b c0	 mov	 r8d, eax
  00066	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46204
  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  00074	e8 00 00 00 00	 call	 sprintf

; 872  : 		comErrorPrint(g_szMessage);

  00079	41 b8 68 03 00
	00		 mov	 r8d, 872		; 00000368H
  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46205
  00086	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  0008d	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 873  : 		return false;

  00092	32 c0		 xor	 al, al
  00094	eb 11		 jmp	 SHORT $LN1@initLogger
$LN3@initLogger:

; 874  : 	}
; 875  : 
; 876  : 	pWriter->procLoggerEnable(pLogger);

  00096	48 8b 54 24 48	 mov	 rdx, QWORD PTR pLogger$[rsp]
  0009b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pWriter$[rsp]
  000a0	e8 00 00 00 00	 call	 ?procLoggerEnable@CSTLogger@@QEAAXPEAVCLogger@@@Z ; CSTLogger::procLoggerEnable

; 877  : 
; 878  : 	return true;

  000a5	b0 01		 mov	 al, 1
$LN1@initLogger:

; 879  : }

  000a7	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ab	c3		 ret	 0
?initLogger@CCoreList@@QEAA_NPEAVCLogger@@@Z ENDP	; CCoreList::initLogger
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?initLogger@CCoreList@@QEAA_NPEAVCLogger@@PEAD1@Z
_TEXT	SEGMENT
tv76 = 48
eRes$ = 52
pWriter$1 = 56
this$ = 80
pLogger$ = 88
pConfig$ = 96
pSection$ = 104
?initLogger@CCoreList@@QEAA_NPEAVCLogger@@PEAD1@Z PROC	; CCoreList::initLogger, COMDAT

; 829  : {

$LN10:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 830  : 	E_LOG_INIT_RES eRes;
; 831  : 	if (!pLogger) {

  00018	48 83 7c 24 58
	00		 cmp	 QWORD PTR pLogger$[rsp], 0
  0001e	75 3d		 jne	 SHORT $LN4@initLogger

; 832  : 		_stprintf(g_szMessage, _T("pLogger is NULL! [%s:%s]"), pConfig, pSection);

  00020	4c 8b 4c 24 68	 mov	 r9, QWORD PTR pSection$[rsp]
  00025	4c 8b 44 24 60	 mov	 r8, QWORD PTR pConfig$[rsp]
  0002a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46186
  00031	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  00038	e8 00 00 00 00	 call	 sprintf

; 833  : 		comErrorPrint(g_szMessage);

  0003d	41 b8 41 03 00
	00		 mov	 r8d, 833		; 00000341H
  00043	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46187
  0004a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  00051	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 834  : 		return false;

  00056	32 c0		 xor	 al, al
  00058	e9 01 01 00 00	 jmp	 $LN1@initLogger
$LN4@initLogger:

; 835  : 	}
; 836  : 	eRes = pLogger->initConfig(pConfig, pSection);

  0005d	4c 8b 44 24 68	 mov	 r8, QWORD PTR pSection$[rsp]
  00062	48 8b 54 24 60	 mov	 rdx, QWORD PTR pConfig$[rsp]
  00067	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pLogger$[rsp]
  0006c	e8 00 00 00 00	 call	 ?initConfig@CLogger@@QEAA?AW4E_LOG_INIT_RES@@PEAD0@Z ; CLogger::initConfig
  00071	89 44 24 34	 mov	 DWORD PTR eRes$[rsp], eax

; 837  : 
; 838  : 	switch (eRes) {

  00075	8b 44 24 34	 mov	 eax, DWORD PTR eRes$[rsp]
  00079	89 44 24 30	 mov	 DWORD PTR tv76[rsp], eax
  0007d	83 7c 24 30 ff	 cmp	 DWORD PTR tv76[rsp], -1
  00082	74 21		 je	 SHORT $LN6@initLogger
  00084	83 7c 24 30 00	 cmp	 DWORD PTR tv76[rsp], 0
  00089	74 13		 je	 SHORT $LN5@initLogger
  0008b	83 7c 24 30 01	 cmp	 DWORD PTR tv76[rsp], 1
  00090	74 4d		 je	 SHORT $LN7@initLogger
  00092	83 7c 24 30 02	 cmp	 DWORD PTR tv76[rsp], 2
  00097	74 05		 je	 SHORT $LN5@initLogger
  00099	e9 be 00 00 00	 jmp	 $LN2@initLogger
$LN5@initLogger:

; 839  : 		case LOG_INIT_CHANGED_SUCCESS: 
; 840  : 		case LOG_INIT_NO_FILE: return true;

  0009e	b0 01		 mov	 al, 1
  000a0	e9 b9 00 00 00	 jmp	 $LN1@initLogger
$LN6@initLogger:

; 841  : 		case LOG_INIT_ERROR:
; 842  : 		{
; 843  : 			_stprintf(g_szMessage, _T("pLogger->initConfig has Failed!!![%s:%s]"), pConfig, pSection);

  000a5	4c 8b 4c 24 68	 mov	 r9, QWORD PTR pSection$[rsp]
  000aa	4c 8b 44 24 60	 mov	 r8, QWORD PTR pConfig$[rsp]
  000af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46190
  000b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  000bd	e8 00 00 00 00	 call	 sprintf

; 844  : 			comErrorPrint(g_szMessage);

  000c2	41 b8 4c 03 00
	00		 mov	 r8d, 844		; 0000034cH
  000c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46191
  000cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  000d6	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 845  : 			return false;

  000db	32 c0		 xor	 al, al
  000dd	eb 7f		 jmp	 SHORT $LN1@initLogger
$LN7@initLogger:

; 846  : 		}
; 847  : 		case LOG_INIT_SUCCESS: 
; 848  : 		{
; 849  : 			CSTLogger *pWriter = m_pWriterList->getObj(pLogger->getSTLNo());

  000df	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pLogger$[rsp]
  000e4	e8 00 00 00 00	 call	 ?getSTLNo@CLogger@@QEAAHXZ ; CLogger::getSTLNo
  000e9	8b d0		 mov	 edx, eax
  000eb	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  000f0	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000f3	e8 00 00 00 00	 call	 ?getObj@?$CTList@VCSTLogger@@@@QEAAPEAVCSTLogger@@H@Z ; CTList<CSTLogger>::getObj
  000f8	48 89 44 24 38	 mov	 QWORD PTR pWriter$1[rsp], rax

; 850  : 			if (!pWriter) {

  000fd	48 83 7c 24 38
	00		 cmp	 QWORD PTR pWriter$1[rsp], 0
  00103	75 48		 jne	 SHORT $LN8@initLogger

; 851  : 				_stprintf(g_szMessage, _T("pWriter is NULL!!![%s:%s] [nSTLNo:%d]"), pConfig, pSection, pLogger->getSTLNo());

  00105	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pLogger$[rsp]
  0010a	e8 00 00 00 00	 call	 ?getSTLNo@CLogger@@QEAAHXZ ; CLogger::getSTLNo
  0010f	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00113	4c 8b 4c 24 68	 mov	 r9, QWORD PTR pSection$[rsp]
  00118	4c 8b 44 24 60	 mov	 r8, QWORD PTR pConfig$[rsp]
  0011d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46194
  00124	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  0012b	e8 00 00 00 00	 call	 sprintf

; 852  : 				comErrorPrint(g_szMessage);

  00130	41 b8 54 03 00
	00		 mov	 r8d, 852		; 00000354H
  00136	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46195
  0013d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  00144	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 853  : 				return false;

  00149	32 c0		 xor	 al, al
  0014b	eb 11		 jmp	 SHORT $LN1@initLogger
$LN8@initLogger:

; 854  : 			}
; 855  : 			pWriter->procLoggerEnable(pLogger);

  0014d	48 8b 54 24 58	 mov	 rdx, QWORD PTR pLogger$[rsp]
  00152	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pWriter$1[rsp]
  00157	e8 00 00 00 00	 call	 ?procLoggerEnable@CSTLogger@@QEAAXPEAVCLogger@@@Z ; CSTLogger::procLoggerEnable
$LN2@initLogger:

; 856  : 		}
; 857  : 		break;
; 858  : 	}
; 859  : 	return true;

  0015c	b0 01		 mov	 al, 1
$LN1@initLogger:

; 860  : }

  0015e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00162	c3		 ret	 0
?initLogger@CCoreList@@QEAA_NPEAVCLogger@@PEAD1@Z ENDP	; CCoreList::initLogger
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?initDefaultPool@CCoreList@@QEAA_NHHH@Z
_TEXT	SEGMENT
i$ = 32
nVal$ = 36
szConf$ = 48
__$ArrayPad$ = 144
this$ = 176
nCnt_IdxBuf2$ = 184
nCnt_IdxBuf32$ = 192
nCnt_IdxBuf_1m$ = 200
?initDefaultPool@CCoreList@@QEAA_NHHH@Z PROC		; CCoreList::initDefaultPool, COMDAT

; 595  : {

$LN16:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 596  : 	int i, nVal;
; 597  : 
; 598  : 	STBufConf szConf;
; 599  : 	memset(&szConf, 0, sizeof(STBufConf));

  0002d	48 8d 44 24 30	 lea	 rax, QWORD PTR szConf$[rsp]
  00032	48 8b f8	 mov	 rdi, rax
  00035	33 c0		 xor	 eax, eax
  00037	b9 58 00 00 00	 mov	 ecx, 88			; 00000058H
  0003c	f3 aa		 rep stosb

; 600  : 
; 601  : 	szConf.nMaxList[IDX_BUF_2] = nCnt_IdxBuf2;

  0003e	b8 04 00 00 00	 mov	 eax, 4
  00043	48 6b c0 01	 imul	 rax, rax, 1
  00047	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR nCnt_IdxBuf2$[rsp]
  0004e	89 4c 04 30	 mov	 DWORD PTR szConf$[rsp+rax], ecx

; 602  : 	
; 603  : 	nVal = nCnt_IdxBuf32 << 2;

  00052	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR nCnt_IdxBuf32$[rsp]
  00059	c1 e0 02	 shl	 eax, 2
  0005c	89 44 24 24	 mov	 DWORD PTR nVal$[rsp], eax

; 604  : 	for (i = IDX_BUF_4; i < IDX_BUF_256; i++)

  00060	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR i$[rsp], 2
  00068	eb 0a		 jmp	 SHORT $LN4@initDefaul
$LN2@initDefaul:
  0006a	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0006e	ff c0		 inc	 eax
  00070	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@initDefaul:
  00074	83 7c 24 20 08	 cmp	 DWORD PTR i$[rsp], 8
  00079	7d 14		 jge	 SHORT $LN3@initDefaul

; 605  : 	{
; 606  : 		szConf.nMaxList[i] = nVal + 1024;

  0007b	8b 44 24 24	 mov	 eax, DWORD PTR nVal$[rsp]
  0007f	05 00 04 00 00	 add	 eax, 1024		; 00000400H
  00084	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00089	89 44 8c 30	 mov	 DWORD PTR szConf$[rsp+rcx*4], eax

; 607  : 	}

  0008d	eb db		 jmp	 SHORT $LN2@initDefaul
$LN3@initDefaul:

; 608  : 
; 609  : 	for (i = IDX_BUF_256; i < IDX_BUF_1k; i++)

  0008f	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR i$[rsp], 8
  00097	eb 0a		 jmp	 SHORT $LN7@initDefaul
$LN5@initDefaul:
  00099	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0009d	ff c0		 inc	 eax
  0009f	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@initDefaul:
  000a3	83 7c 24 20 0a	 cmp	 DWORD PTR i$[rsp], 10
  000a8	7d 15		 jge	 SHORT $LN6@initDefaul

; 610  : 	{
; 611  : 		szConf.nMaxList[i] = nCnt_IdxBuf32 + 64;

  000aa	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR nCnt_IdxBuf32$[rsp]
  000b1	83 c0 40	 add	 eax, 64			; 00000040H
  000b4	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  000b9	89 44 8c 30	 mov	 DWORD PTR szConf$[rsp+rcx*4], eax

; 612  : 	}

  000bd	eb da		 jmp	 SHORT $LN5@initDefaul
$LN6@initDefaul:

; 613  : 
; 614  : 	nVal = nCnt_IdxBuf32 >> 2;

  000bf	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR nCnt_IdxBuf32$[rsp]
  000c6	c1 f8 02	 sar	 eax, 2
  000c9	89 44 24 24	 mov	 DWORD PTR nVal$[rsp], eax

; 615  : 	for (i = IDX_BUF_1k; i < IDX_BUF_64k; i++)

  000cd	c7 44 24 20 0a
	00 00 00	 mov	 DWORD PTR i$[rsp], 10
  000d5	eb 0a		 jmp	 SHORT $LN10@initDefaul
$LN8@initDefaul:
  000d7	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000db	ff c0		 inc	 eax
  000dd	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN10@initDefaul:
  000e1	83 7c 24 20 10	 cmp	 DWORD PTR i$[rsp], 16
  000e6	7d 12		 jge	 SHORT $LN9@initDefaul

; 616  : 	{
; 617  : 		szConf.nMaxList[i] = nVal + 4;

  000e8	8b 44 24 24	 mov	 eax, DWORD PTR nVal$[rsp]
  000ec	83 c0 04	 add	 eax, 4
  000ef	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  000f4	89 44 8c 30	 mov	 DWORD PTR szConf$[rsp+rcx*4], eax

; 618  : 	}

  000f8	eb dd		 jmp	 SHORT $LN8@initDefaul
$LN9@initDefaul:

; 619  : 	//6(64K)
; 620  : 	for (i = IDX_BUF_64k; i < IDX_BUF_512k; i++)

  000fa	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR i$[rsp], 16
  00102	eb 0a		 jmp	 SHORT $LN13@initDefaul
$LN11@initDefaul:
  00104	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00108	ff c0		 inc	 eax
  0010a	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN13@initDefaul:
  0010e	83 7c 24 20 13	 cmp	 DWORD PTR i$[rsp], 19
  00113	7d 12		 jge	 SHORT $LN12@initDefaul

; 621  : 	{
; 622  : 		szConf.nMaxList[i] = nVal + 2;

  00115	8b 44 24 24	 mov	 eax, DWORD PTR nVal$[rsp]
  00119	83 c0 02	 add	 eax, 2
  0011c	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00121	89 44 8c 30	 mov	 DWORD PTR szConf$[rsp+rcx*4], eax

; 623  : 	}

  00125	eb dd		 jmp	 SHORT $LN11@initDefaul
$LN12@initDefaul:

; 624  : 	//9(512K)
; 625  : 	nVal = nCnt_IdxBuf32 >> 8;

  00127	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR nCnt_IdxBuf32$[rsp]
  0012e	c1 f8 08	 sar	 eax, 8
  00131	89 44 24 24	 mov	 DWORD PTR nVal$[rsp], eax

; 626  : 	szConf.nMaxList[IDX_BUF_512k] = nVal;

  00135	b8 04 00 00 00	 mov	 eax, 4
  0013a	48 6b c0 13	 imul	 rax, rax, 19
  0013e	8b 4c 24 24	 mov	 ecx, DWORD PTR nVal$[rsp]
  00142	89 4c 04 30	 mov	 DWORD PTR szConf$[rsp+rax], ecx

; 627  : 	szConf.nMaxList[IDX_BUF_1m] = nCnt_IdxBuf_1m;

  00146	b8 04 00 00 00	 mov	 eax, 4
  0014b	48 6b c0 14	 imul	 rax, rax, 20
  0014f	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR nCnt_IdxBuf_1m$[rsp]
  00156	89 4c 04 30	 mov	 DWORD PTR szConf$[rsp+rax], ecx

; 628  : 	szConf.nMaxList[IDX_BUF_2m] = nCnt_IdxBuf_1m;

  0015a	b8 04 00 00 00	 mov	 eax, 4
  0015f	48 6b c0 15	 imul	 rax, rax, 21
  00163	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR nCnt_IdxBuf_1m$[rsp]
  0016a	89 4c 04 30	 mov	 DWORD PTR szConf$[rsp+rax], ecx

; 629  : 
; 630  : 	gs_pMMgr->init(&szConf);

  0016e	48 8d 54 24 30	 lea	 rdx, QWORD PTR szConf$[rsp]
  00173	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  0017a	e8 00 00 00 00	 call	 ?init@CMemManager@@QEAAXPEAUSTBufConf@@@Z ; CMemManager::init

; 631  : 	if (!gs_pMMgr->alloc()) {

  0017f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  00186	e8 00 00 00 00	 call	 ?alloc@CMemManager@@QEAA_NXZ ; CMemManager::alloc
  0018b	0f b6 c0	 movzx	 eax, al
  0018e	85 c0		 test	 eax, eax
  00190	75 1d		 jne	 SHORT $LN14@initDefaul

; 632  : 		comErrorPrint("gs_pMMgr->alloc() has Failed!!!");

  00192	41 b8 78 02 00
	00		 mov	 r8d, 632		; 00000278H
  00198	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45970
  0019f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG45971
  001a6	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 633  : 		return false;

  001ab	32 c0		 xor	 al, al
  001ad	eb 02		 jmp	 SHORT $LN1@initDefaul
$LN14@initDefaul:

; 634  : 	}
; 635  : 
; 636  : 	return true;

  001af	b0 01		 mov	 al, 1
$LN1@initDefaul:

; 637  : }

  001b1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001b9	48 33 cc	 xor	 rcx, rsp
  001bc	e8 00 00 00 00	 call	 __security_check_cookie
  001c1	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  001c8	5f		 pop	 rdi
  001c9	c3		 ret	 0
?initDefaultPool@CCoreList@@QEAA_NHHH@Z ENDP		; CCoreList::initDefaultPool
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?initSystemFile@CCoreList@@QEAA_NXZ
_TEXT	SEGMENT
i$ = 32
nShift$ = 36
nVal$ = 40
tv332 = 44
tv337 = 48
tv344 = 52
tv350 = 56
szConf$ = 64
szKey$ = 160
__$ArrayPad$ = 200
this$ = 224
?initSystemFile@CCoreList@@QEAA_NXZ PROC		; CCoreList::initSystemFile, COMDAT

; 523  : {

$LN25:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00014	48 33 c4	 xor	 rax, rsp
  00017	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 524  : 	int i, nVal, nShift;
; 525  : 	if (!CEnv::initSystem()) return false;

  0001f	33 c9		 xor	 ecx, ecx
  00021	e8 00 00 00 00	 call	 ?initSystem@CEnv@@SAHPEAD@Z ; CEnv::initSystem
  00026	85 c0		 test	 eax, eax
  00028	75 07		 jne	 SHORT $LN14@initSystem
  0002a	32 c0		 xor	 al, al
  0002c	e9 5f 04 00 00	 jmp	 $LN1@initSystem
$LN14@initSystem:

; 526  : 
; 527  : 	STBufConf szConf;
; 528  : 	TCHAR szKey[36];
; 529  : 	memset(&szConf, 0, sizeof(STBufConf));

  00031	48 8d 44 24 40	 lea	 rax, QWORD PTR szConf$[rsp]
  00036	48 8b f8	 mov	 rdi, rax
  00039	33 c0		 xor	 eax, eax
  0003b	b9 58 00 00 00	 mov	 ecx, 88			; 00000058H
  00040	f3 aa		 rep stosb

; 530  : 
; 531  : 	nVal = GetPrivateProfileInt(_T("MPOOL"), _T("IDX_BUF_32"), 0, g_pSystem);

  00042	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR ?g_pSystem@@3PEADEA ; g_pSystem
  00049	45 33 c0	 xor	 r8d, r8d
  0004c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45909
  00053	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG45910
  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetPrivateProfileIntA
  00060	89 44 24 28	 mov	 DWORD PTR nVal$[rsp], eax

; 532  : 	if (!nVal) goto INIT_THREAD;

  00064	83 7c 24 28 00	 cmp	 DWORD PTR nVal$[rsp], 0
  00069	75 0a		 jne	 SHORT $LN15@initSystem
  0006b	e9 fd 02 00 00	 jmp	 $LN16@initSystem
  00070	e9 f8 02 00 00	 jmp	 $INIT_THREAD$26
$LN15@initSystem:

; 533  : 	
; 534  : 	szConf.nMaxList[IDX_BUF_2] = GetPrivateProfileInt(_T("MPOOL"), _T("IDX_BUF_2"), 0, g_pSystem);

  00075	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR ?g_pSystem@@3PEADEA ; g_pSystem
  0007c	45 33 c0	 xor	 r8d, r8d
  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45913
  00086	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG45914
  0008d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetPrivateProfileIntA
  00093	b9 04 00 00 00	 mov	 ecx, 4
  00098	48 6b c9 01	 imul	 rcx, rcx, 1
  0009c	89 44 0c 40	 mov	 DWORD PTR szConf$[rsp+rcx], eax

; 535  : 	
; 536  : 	for (i = IDX_BUF_4; i < IDX_BUF_256; i++)

  000a0	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR i$[rsp], 2
  000a8	eb 0a		 jmp	 SHORT $LN4@initSystem
$LN2@initSystem:
  000aa	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000ae	ff c0		 inc	 eax
  000b0	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@initSystem:
  000b4	83 7c 24 20 08	 cmp	 DWORD PTR i$[rsp], 8
  000b9	7d 5c		 jge	 SHORT $LN3@initSystem

; 537  : 	{
; 538  : 		_stprintf(szKey, _T("IDX_BUF_%d"), 1 << i);

  000bb	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000bf	b9 01 00 00 00	 mov	 ecx, 1
  000c4	89 4c 24 2c	 mov	 DWORD PTR tv332[rsp], ecx
  000c8	0f b6 c8	 movzx	 ecx, al
  000cb	8b 44 24 2c	 mov	 eax, DWORD PTR tv332[rsp]
  000cf	d3 e0		 shl	 eax, cl
  000d1	44 8b c0	 mov	 r8d, eax
  000d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45915
  000db	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR szKey$[rsp]
  000e3	e8 00 00 00 00	 call	 sprintf

; 539  : 		szConf.nMaxList[i] = GetPrivateProfileInt(_T("MPOOL"), szKey, 0, g_pSystem) + 256;

  000e8	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR ?g_pSystem@@3PEADEA ; g_pSystem
  000ef	45 33 c0	 xor	 r8d, r8d
  000f2	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR szKey$[rsp]
  000fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG45916
  00101	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetPrivateProfileIntA
  00107	05 00 01 00 00	 add	 eax, 256		; 00000100H
  0010c	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00111	89 44 8c 40	 mov	 DWORD PTR szConf$[rsp+rcx*4], eax

; 540  : 	}

  00115	eb 93		 jmp	 SHORT $LN2@initSystem
$LN3@initSystem:

; 541  : 	for (i = IDX_BUF_256; i < IDX_BUF_1k; i++)

  00117	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR i$[rsp], 8
  0011f	eb 0a		 jmp	 SHORT $LN7@initSystem
$LN5@initSystem:
  00121	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00125	ff c0		 inc	 eax
  00127	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@initSystem:
  0012b	83 7c 24 20 0a	 cmp	 DWORD PTR i$[rsp], 10
  00130	7d 5a		 jge	 SHORT $LN6@initSystem

; 542  : 	{
; 543  : 		_stprintf(szKey, _T("IDX_BUF_%d"), 1 << i);

  00132	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00136	b9 01 00 00 00	 mov	 ecx, 1
  0013b	89 4c 24 30	 mov	 DWORD PTR tv337[rsp], ecx
  0013f	0f b6 c8	 movzx	 ecx, al
  00142	8b 44 24 30	 mov	 eax, DWORD PTR tv337[rsp]
  00146	d3 e0		 shl	 eax, cl
  00148	44 8b c0	 mov	 r8d, eax
  0014b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45917
  00152	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR szKey$[rsp]
  0015a	e8 00 00 00 00	 call	 sprintf

; 544  : 		szConf.nMaxList[i] = GetPrivateProfileInt(_T("MPOOL"), szKey, 0, g_pSystem) + 64;

  0015f	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR ?g_pSystem@@3PEADEA ; g_pSystem
  00166	45 33 c0	 xor	 r8d, r8d
  00169	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR szKey$[rsp]
  00171	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG45918
  00178	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetPrivateProfileIntA
  0017e	83 c0 40	 add	 eax, 64			; 00000040H
  00181	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00186	89 44 8c 40	 mov	 DWORD PTR szConf$[rsp+rcx*4], eax

; 545  : 	}

  0018a	eb 95		 jmp	 SHORT $LN5@initSystem
$LN6@initSystem:

; 546  : 
; 547  : 	nVal = 1; nShift = 0;

  0018c	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR nVal$[rsp], 1
  00194	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR nShift$[rsp], 0

; 548  : 	for (i = IDX_BUF_1k; i < IDX_BUF_64k; i++)

  0019c	c7 44 24 20 0a
	00 00 00	 mov	 DWORD PTR i$[rsp], 10
  001a4	eb 0a		 jmp	 SHORT $LN10@initSystem
$LN8@initSystem:
  001a6	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  001aa	ff c0		 inc	 eax
  001ac	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN10@initSystem:
  001b0	83 7c 24 20 10	 cmp	 DWORD PTR i$[rsp], 16
  001b5	7d 6a		 jge	 SHORT $LN9@initSystem

; 549  : 	{
; 550  : 		_stprintf(szKey, _T("IDX_BUF_%dk"), nVal); nShift++; //0(1K), 1(2K), 2(4K), 3(8K), 4(16K), 5(32K)

  001b7	44 8b 44 24 28	 mov	 r8d, DWORD PTR nVal$[rsp]
  001bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45919
  001c3	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR szKey$[rsp]
  001cb	e8 00 00 00 00	 call	 sprintf
  001d0	8b 44 24 24	 mov	 eax, DWORD PTR nShift$[rsp]
  001d4	ff c0		 inc	 eax
  001d6	89 44 24 24	 mov	 DWORD PTR nShift$[rsp], eax

; 551  : 		szConf.nMaxList[i] = GetPrivateProfileInt(_T("MPOOL"), szKey, 0, g_pSystem) + 4;

  001da	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR ?g_pSystem@@3PEADEA ; g_pSystem
  001e1	45 33 c0	 xor	 r8d, r8d
  001e4	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR szKey$[rsp]
  001ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG45920
  001f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetPrivateProfileIntA
  001f9	83 c0 04	 add	 eax, 4
  001fc	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00201	89 44 8c 40	 mov	 DWORD PTR szConf$[rsp+rcx*4], eax

; 552  : 		nVal = 1 << nShift;

  00205	8b 44 24 24	 mov	 eax, DWORD PTR nShift$[rsp]
  00209	b9 01 00 00 00	 mov	 ecx, 1
  0020e	89 4c 24 34	 mov	 DWORD PTR tv344[rsp], ecx
  00212	0f b6 c8	 movzx	 ecx, al
  00215	8b 44 24 34	 mov	 eax, DWORD PTR tv344[rsp]
  00219	d3 e0		 shl	 eax, cl
  0021b	89 44 24 28	 mov	 DWORD PTR nVal$[rsp], eax

; 553  : 	}

  0021f	eb 85		 jmp	 SHORT $LN8@initSystem
$LN9@initSystem:

; 554  : 	//6(64K)
; 555  : 	for (i = IDX_BUF_64k; i < IDX_BUF_512k; i++)

  00221	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR i$[rsp], 16
  00229	eb 0a		 jmp	 SHORT $LN13@initSystem
$LN11@initSystem:
  0022b	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0022f	ff c0		 inc	 eax
  00231	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN13@initSystem:
  00235	83 7c 24 20 13	 cmp	 DWORD PTR i$[rsp], 19
  0023a	7d 6a		 jge	 SHORT $LN12@initSystem

; 556  : 	{
; 557  : 		_stprintf(szKey, _T("IDX_BUF_%dk"), nVal); nShift++; //6(64K), 7(128K), 8(256K)

  0023c	44 8b 44 24 28	 mov	 r8d, DWORD PTR nVal$[rsp]
  00241	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45921
  00248	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR szKey$[rsp]
  00250	e8 00 00 00 00	 call	 sprintf
  00255	8b 44 24 24	 mov	 eax, DWORD PTR nShift$[rsp]
  00259	ff c0		 inc	 eax
  0025b	89 44 24 24	 mov	 DWORD PTR nShift$[rsp], eax

; 558  : 		szConf.nMaxList[i] = GetPrivateProfileInt(_T("MPOOL"), szKey, 0, g_pSystem) + 2;

  0025f	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR ?g_pSystem@@3PEADEA ; g_pSystem
  00266	45 33 c0	 xor	 r8d, r8d
  00269	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR szKey$[rsp]
  00271	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG45922
  00278	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetPrivateProfileIntA
  0027e	83 c0 02	 add	 eax, 2
  00281	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00286	89 44 8c 40	 mov	 DWORD PTR szConf$[rsp+rcx*4], eax

; 559  : 		nVal = 1 << nShift;

  0028a	8b 44 24 24	 mov	 eax, DWORD PTR nShift$[rsp]
  0028e	b9 01 00 00 00	 mov	 ecx, 1
  00293	89 4c 24 38	 mov	 DWORD PTR tv350[rsp], ecx
  00297	0f b6 c8	 movzx	 ecx, al
  0029a	8b 44 24 38	 mov	 eax, DWORD PTR tv350[rsp]
  0029e	d3 e0		 shl	 eax, cl
  002a0	89 44 24 28	 mov	 DWORD PTR nVal$[rsp], eax

; 560  : 	}

  002a4	eb 85		 jmp	 SHORT $LN11@initSystem
$LN12@initSystem:

; 561  : 	//9(512K)
; 562  : 	szConf.nMaxList[IDX_BUF_512k] = GetPrivateProfileInt(_T("MPOOL"), _T("IDX_BUF_512k"), 0, g_pSystem) + 1;

  002a6	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR ?g_pSystem@@3PEADEA ; g_pSystem
  002ad	45 33 c0	 xor	 r8d, r8d
  002b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45923
  002b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG45924
  002be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetPrivateProfileIntA
  002c4	ff c0		 inc	 eax
  002c6	b9 04 00 00 00	 mov	 ecx, 4
  002cb	48 6b c9 13	 imul	 rcx, rcx, 19
  002cf	89 44 0c 40	 mov	 DWORD PTR szConf$[rsp+rcx], eax

; 563  : 	szConf.nMaxList[IDX_BUF_1m] = GetPrivateProfileInt(_T("MPOOL"), _T("IDX_BUF_1m"), 0, g_pSystem);

  002d3	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR ?g_pSystem@@3PEADEA ; g_pSystem
  002da	45 33 c0	 xor	 r8d, r8d
  002dd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45925
  002e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG45926
  002eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetPrivateProfileIntA
  002f1	b9 04 00 00 00	 mov	 ecx, 4
  002f6	48 6b c9 14	 imul	 rcx, rcx, 20
  002fa	89 44 0c 40	 mov	 DWORD PTR szConf$[rsp+rcx], eax

; 564  : 	szConf.nMaxList[IDX_BUF_2m] = GetPrivateProfileInt(_T("MPOOL"), _T("IDX_BUF_2m"), 0, g_pSystem);

  002fe	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR ?g_pSystem@@3PEADEA ; g_pSystem
  00305	45 33 c0	 xor	 r8d, r8d
  00308	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45927
  0030f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG45928
  00316	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetPrivateProfileIntA
  0031c	b9 04 00 00 00	 mov	 ecx, 4
  00321	48 6b c9 15	 imul	 rcx, rcx, 21
  00325	89 44 0c 40	 mov	 DWORD PTR szConf$[rsp+rcx], eax

; 565  : 
; 566  : 	gs_pMMgr->init(&szConf);

  00329	48 8d 54 24 40	 lea	 rdx, QWORD PTR szConf$[rsp]
  0032e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  00335	e8 00 00 00 00	 call	 ?init@CMemManager@@QEAAXPEAUSTBufConf@@@Z ; CMemManager::init

; 567  : 	if (!gs_pMMgr->alloc()) {

  0033a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  00341	e8 00 00 00 00	 call	 ?alloc@CMemManager@@QEAA_NXZ ; CMemManager::alloc
  00346	0f b6 c0	 movzx	 eax, al
  00349	85 c0		 test	 eax, eax
  0034b	75 20		 jne	 SHORT $LN17@initSystem

; 568  : 		comErrorPrint("gs_pMMgr->alloc() has Failed!!!");

  0034d	41 b8 38 02 00
	00		 mov	 r8d, 568		; 00000238H
  00353	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45930
  0035a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG45931
  00361	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 569  : 		return false;

  00366	32 c0		 xor	 al, al
  00368	e9 23 01 00 00	 jmp	 $LN1@initSystem
$LN17@initSystem:
$LN16@initSystem:
$INIT_THREAD$26:

; 570  : 	}
; 571  : 
; 572  : INIT_THREAD :
; 573  : 	if (!initComThread(g_pSystem, _T("COMTHREAD")))			return false;

  0036d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG45933
  00374	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?g_pSystem@@3PEADEA ; g_pSystem
  0037b	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00383	e8 00 00 00 00	 call	 ?initComThread@CCoreList@@QEAA_NPEAD0@Z ; CCoreList::initComThread
  00388	0f b6 c0	 movzx	 eax, al
  0038b	85 c0		 test	 eax, eax
  0038d	75 07		 jne	 SHORT $LN18@initSystem
  0038f	32 c0		 xor	 al, al
  00391	e9 fa 00 00 00	 jmp	 $LN1@initSystem
$LN18@initSystem:

; 574  : 	if (!initLogWriter(g_pSystem, _T("LOG_WRITER"),true))	return false;

  00396	41 b1 01	 mov	 r9b, 1
  00399	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG45935
  003a0	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?g_pSystem@@3PEADEA ; g_pSystem
  003a7	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  003af	e8 00 00 00 00	 call	 ?initLogWriter@CCoreList@@QEAA_NPEAD0_N@Z ; CCoreList::initLogWriter
  003b4	0f b6 c0	 movzx	 eax, al
  003b7	85 c0		 test	 eax, eax
  003b9	75 07		 jne	 SHORT $LN19@initSystem
  003bb	32 c0		 xor	 al, al
  003bd	e9 ce 00 00 00	 jmp	 $LN1@initSystem
$LN19@initSystem:

; 575  : 	if (!initScheduler(g_pSystem, _T("SCHEDULER")))			return false;

  003c2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG45937
  003c9	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?g_pSystem@@3PEADEA ; g_pSystem
  003d0	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  003d8	e8 00 00 00 00	 call	 ?initScheduler@CCoreList@@QEAA_NPEAD0@Z ; CCoreList::initScheduler
  003dd	0f b6 c0	 movzx	 eax, al
  003e0	85 c0		 test	 eax, eax
  003e2	75 07		 jne	 SHORT $LN20@initSystem
  003e4	32 c0		 xor	 al, al
  003e6	e9 a5 00 00 00	 jmp	 $LN1@initSystem
$LN20@initSystem:

; 576  : 	if (!initQueueThread(g_pSystem, _T("EVENTPROC")))		return false;

  003eb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG45939
  003f2	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?g_pSystem@@3PEADEA ; g_pSystem
  003f9	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00401	e8 00 00 00 00	 call	 ?initQueueThread@CCoreList@@QEAA_NPEAD0@Z ; CCoreList::initQueueThread
  00406	0f b6 c0	 movzx	 eax, al
  00409	85 c0		 test	 eax, eax
  0040b	75 04		 jne	 SHORT $LN21@initSystem
  0040d	32 c0		 xor	 al, al
  0040f	eb 7f		 jmp	 SHORT $LN1@initSystem
$LN21@initSystem:

; 577  : 
; 578  : 	// LogTimeExpresion
; 579  : 	if (!gs_DTEManager.initConfig(g_pSystem)) {

  00411	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?g_pSystem@@3PEADEA ; g_pSystem
  00418	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?gs_DTEManager@@3VCTimeExpManager@@A ; gs_DTEManager
  0041f	e8 00 00 00 00	 call	 ?initConfig@CTimeExpManager@@QEAA_NPEAD@Z ; CTimeExpManager::initConfig
  00424	0f b6 c0	 movzx	 eax, al
  00427	85 c0		 test	 eax, eax
  00429	75 1d		 jne	 SHORT $LN22@initSystem

; 580  : 		comErrorPrint("gs_DTEManager.initConfig has Failed!!!");

  0042b	41 b8 44 02 00
	00		 mov	 r8d, 580		; 00000244H
  00431	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45941
  00438	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG45942
  0043f	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 581  : 		return false;

  00444	32 c0		 xor	 al, al
  00446	eb 48		 jmp	 SHORT $LN1@initSystem
$LN22@initSystem:

; 582  : 	}
; 583  : 
; 584  : 	// basic logger init
; 585  : 	if (!initLogger(&gs_cLogger, g_pSystem, _T("LOG"))) {

  00448	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG45944
  0044f	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR ?g_pSystem@@3PEADEA ; g_pSystem
  00456	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  0045d	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00465	e8 00 00 00 00	 call	 ?initLogger@CCoreList@@QEAA_NPEAVCLogger@@PEAD1@Z ; CCoreList::initLogger
  0046a	0f b6 c0	 movzx	 eax, al
  0046d	85 c0		 test	 eax, eax
  0046f	75 1d		 jne	 SHORT $LN23@initSystem

; 586  : 		comErrorPrint("initLogger has Failed!!!");

  00471	41 b8 4a 02 00
	00		 mov	 r8d, 586		; 0000024aH
  00477	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45945
  0047e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG45946
  00485	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 587  : 		return false;

  0048a	32 c0		 xor	 al, al
  0048c	eb 02		 jmp	 SHORT $LN1@initSystem
$LN23@initSystem:

; 588  : 	}
; 589  : 
; 590  : 	return true;

  0048e	b0 01		 mov	 al, 1
$LN1@initSystem:

; 591  : 
; 592  : }

  00490	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00498	48 33 cc	 xor	 rcx, rsp
  0049b	e8 00 00 00 00	 call	 __security_check_cookie
  004a0	48 81 c4 d0 00
	00 00		 add	 rsp, 208		; 000000d0H
  004a7	5f		 pop	 rdi
  004a8	c3		 ret	 0
?initSystemFile@CCoreList@@QEAA_NXZ ENDP		; CCoreList::initSystemFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ??1CCoreList@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??1CCoreList@@QEAA@XZ PROC				; CCoreList::~CCoreList, COMDAT

; 490  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00009	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2

; 491  : 	destroy();

  00012	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00017	e8 00 00 00 00	 call	 ?destroy@CCoreList@@QEAAXXZ ; CCoreList::destroy
  0001c	90		 npad	 1

; 492  : }

  0001d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00021	c3		 ret	 0
??1CCoreList@@QEAA@XZ ENDP				; CCoreList::~CCoreList
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ??0CCoreList@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
tv82 = 40
$T2 = 48
$T3 = 56
this$ = 80
??0CCoreList@@QEAA@XZ PROC				; CCoreList::CCoreList, COMDAT

; 463  : {

$LN10:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00009	48 c7 44 24 38
	fe ff ff ff	 mov	 QWORD PTR $T3[rsp], -2

; 464  : 	m_pWriterList = NULL;

  00012	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00017	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 465  : 	m_pSchedulerList = NULL;

  0001e	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00023	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 466  : 	m_pThreadList = NULL;

  0002b	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00030	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 467  : 	m_pEventThreadList = NULL;

  00038	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0003d	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 468  : 	m_pIntervalPool = NULL;

  00045	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0004a	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 469  : 	m_pEventPool = NULL;

  00052	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00057	48 c7 40 28 00
	00 00 00	 mov	 QWORD PTR [rax+40], 0

; 470  : 
; 471  : 	gs_pMMgr = new (std::nothrow) CMemManager();

  0005f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00066	b9 10 01 00 00	 mov	 ecx, 272		; 00000110H
  0006b	e8 00 00 00 00	 call	 ??2@YAPEAX_KAEBUnothrow_t@std@@@Z ; operator new
  00070	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax
  00075	48 83 7c 24 20
	00		 cmp	 QWORD PTR $T1[rsp], 0
  0007b	74 11		 je	 SHORT $LN6@CCoreList
  0007d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR $T1[rsp]
  00082	e8 00 00 00 00	 call	 ??0CMemManager@@QEAA@XZ	; CMemManager::CMemManager
  00087	48 89 44 24 28	 mov	 QWORD PTR tv82[rsp], rax
  0008c	eb 09		 jmp	 SHORT $LN7@CCoreList
$LN6@CCoreList:
  0008e	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR tv82[rsp], 0
$LN7@CCoreList:
  00097	48 8b 44 24 28	 mov	 rax, QWORD PTR tv82[rsp]
  0009c	48 89 44 24 30	 mov	 QWORD PTR $T2[rsp], rax
  000a1	48 8b 44 24 30	 mov	 rax, QWORD PTR $T2[rsp]
  000a6	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA, rax ; gs_pMMgr

; 472  : 	if (!gs_pMMgr) {

  000ad	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA, 0 ; gs_pMMgr
  000b5	75 21		 jne	 SHORT $LN2@CCoreList

; 473  : 		comErrorPrint("gs_pMMgr alloc has Failed!!!");

  000b7	41 b8 d9 01 00
	00		 mov	 r8d, 473		; 000001d9H
  000bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45606
  000c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG45607
  000cb	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 474  : 		exit(0);

  000d0	33 c9		 xor	 ecx, ecx
  000d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN2@CCoreList:

; 475  : 	}
; 476  : 
; 477  : 	if (!initSystemFile()) {

  000d8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  000dd	e8 00 00 00 00	 call	 ?initSystemFile@CCoreList@@QEAA_NXZ ; CCoreList::initSystemFile
  000e2	0f b6 c0	 movzx	 eax, al
  000e5	85 c0		 test	 eax, eax
  000e7	75 21		 jne	 SHORT $LN3@CCoreList

; 478  : 		comErrorPrint("initSystemFile() has Failed!!!");

  000e9	41 b8 de 01 00
	00		 mov	 r8d, 478		; 000001deH
  000ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45609
  000f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG45610
  000fd	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 479  : 		exit(0);

  00102	33 c9		 xor	 ecx, ecx
  00104	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN3@CCoreList:

; 480  : 	}
; 481  : 	if (!start())

  0010a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  0010f	e8 00 00 00 00	 call	 ?start@CCoreList@@QEAA_NXZ ; CCoreList::start
  00114	0f b6 c0	 movzx	 eax, al
  00117	85 c0		 test	 eax, eax
  00119	75 21		 jne	 SHORT $LN4@CCoreList

; 482  : 	{
; 483  : 		comErrorPrint("start() has Failed!!!");

  0011b	41 b8 e3 01 00
	00		 mov	 r8d, 483		; 000001e3H
  00121	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45612
  00128	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG45613
  0012f	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 484  : 		exit(0);

  00134	33 c9		 xor	 ecx, ecx
  00136	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN4@CCoreList:

; 485  : 	}	
; 486  : }

  0013c	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00141	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00145	c3		 ret	 0
$LN9@CCoreList:
??0CCoreList@@QEAA@XZ ENDP				; CCoreList::CCoreList
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv82 = 40
$T2 = 48
$T3 = 56
this$ = 80
?dtor$0@?0???0CCoreList@@QEAA@XZ@4HA PROC		; `CCoreList::CCoreList'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00010	48 8b 4d 20	 mov	 rcx, QWORD PTR $T1[rbp]
  00014	e8 00 00 00 00	 call	 ??3@YAXPEAXAEBUnothrow_t@std@@@Z ; operator delete
  00019	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001d	5d		 pop	 rbp
  0001e	c3		 ret	 0
?dtor$0@?0???0CCoreList@@QEAA@XZ@4HA ENDP		; `CCoreList::CCoreList'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv82 = 40
$T2 = 48
$T3 = 56
this$ = 80
?dtor$0@?0???0CCoreList@@QEAA@XZ@4HA PROC		; `CCoreList::CCoreList'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00010	48 8b 4d 20	 mov	 rcx, QWORD PTR $T1[rbp]
  00014	e8 00 00 00 00	 call	 ??3@YAXPEAXAEBUnothrow_t@std@@@Z ; operator delete
  00019	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001d	5d		 pop	 rbp
  0001e	c3		 ret	 0
?dtor$0@?0???0CCoreList@@QEAA@XZ@4HA ENDP		; `CCoreList::CCoreList'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_ECComQueueThread@@QEAAPEAXI@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__flags$ = 72
??_ECComQueueThread@@QEAAPEAXI@Z PROC			; CComQueueThread::`vector deleting destructor', COMDAT
$LN6:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  0000d	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00016	8b 44 24 48	 mov	 eax, DWORD PTR __flags$[rsp]
  0001a	83 e0 02	 and	 eax, 2
  0001d	85 c0		 test	 eax, eax
  0001f	74 59		 je	 SHORT $LN2@vector
  00021	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??1CComQueueThread@@QEAA@XZ ; CComQueueThread::~CComQueueThread
  00028	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0002d	4c 8b 40 f8	 mov	 r8, QWORD PTR [rax-8]
  00031	ba a8 00 00 00	 mov	 edx, 168		; 000000a8H
  00036	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0003b	e8 00 00 00 00	 call	 ??_M@YAXPEAX_K1P6AX0@Z@Z
  00040	90		 npad	 1
  00041	8b 44 24 48	 mov	 eax, DWORD PTR __flags$[rsp]
  00045	83 e0 01	 and	 eax, 1
  00048	85 c0		 test	 eax, eax
  0004a	74 23		 je	 SHORT $LN3@vector
  0004c	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00051	48 69 40 f8 a8
	00 00 00	 imul	 rax, QWORD PTR [rax-8], 168 ; 000000a8H
  00059	48 83 c0 08	 add	 rax, 8
  0005d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00062	48 83 e9 08	 sub	 rcx, 8
  00066	48 8b d0	 mov	 rdx, rax
  00069	e8 00 00 00 00	 call	 ??_V@YAXPEAX_K@Z	; operator delete[]
  0006e	90		 npad	 1
$LN3@vector:
  0006f	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00074	48 83 e8 08	 sub	 rax, 8
  00078	eb 2b		 jmp	 SHORT $LN1@vector
$LN2@vector:
  0007a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0007f	e8 00 00 00 00	 call	 ??1CComQueueThread@@QEAA@XZ ; CComQueueThread::~CComQueueThread
  00084	90		 npad	 1
  00085	8b 44 24 48	 mov	 eax, DWORD PTR __flags$[rsp]
  00089	83 e0 01	 and	 eax, 1
  0008c	85 c0		 test	 eax, eax
  0008e	74 10		 je	 SHORT $LN4@vector
  00090	ba a8 00 00 00	 mov	 edx, 168		; 000000a8H
  00095	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0009a	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  0009f	90		 npad	 1
$LN4@vector:
  000a0	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
$LN1@vector:
  000a5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a9	c3		 ret	 0
??_ECComQueueThread@@QEAAPEAXI@Z ENDP			; CComQueueThread::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GCComQueueThread@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GCComQueueThread@@QEAAPEAXI@Z PROC			; CComQueueThread::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00012	e8 00 00 00 00	 call	 ??1CComQueueThread@@QEAA@XZ ; CComQueueThread::~CComQueueThread
  00017	8b 44 24 38	 mov	 eax, DWORD PTR __flags$[rsp]
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 0f		 je	 SHORT $LN2@scalar
  00022	ba a8 00 00 00	 mov	 edx, 168		; 000000a8H
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
??_GCComQueueThread@@QEAAPEAXI@Z ENDP			; CComQueueThread::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comcore.h
;	COMDAT ?getEvent@CComQueueThread@@QEAAPEAUSTEvent@@XZ
_TEXT	SEGMENT
this$ = 48
?getEvent@CComQueueThread@@QEAAPEAUSTEvent@@XZ PROC	; CComQueueThread::getEvent, COMDAT

; 168  : 	STEvent *getEvent() { return (STEvent *)m_sLogQueue.pop(); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 83 c0 48	 add	 rax, 72			; 00000048H
  00012	48 8b c8	 mov	 rcx, rax
  00015	e8 00 00 00 00	 call	 ?pop@CQueueS@@QEAAPEAXXZ ; CQueueS::pop
  0001a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001e	c3		 ret	 0
?getEvent@CComQueueThread@@QEAAPEAUSTEvent@@XZ ENDP	; CComQueueThread::getEvent
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comcore.h
;	COMDAT ?putQueue@CComQueueThread@@QEAA_NPEAUSTEvent@@@Z
_TEXT	SEGMENT
this$ = 48
p$ = 56
?putQueue@CComQueueThread@@QEAA_NPEAUSTEvent@@@Z PROC	; CComQueueThread::putQueue, COMDAT

; 167  : 	bool putQueue(STEvent *p) { if (m_cThread.bActive()) { m_sLogQueue.push(p); m_cThread.sendSignal(); return true; } return false; }

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00013	48 8b c8	 mov	 rcx, rax
  00016	e8 00 00 00 00	 call	 ?bActive@CComThread@@QEAA_NXZ ; CComThread::bActive
  0001b	0f b6 c0	 movzx	 eax, al
  0001e	85 c0		 test	 eax, eax
  00020	74 27		 je	 SHORT $LN2@putQueue
  00022	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00027	48 83 c0 48	 add	 rax, 72			; 00000048H
  0002b	48 8b 54 24 38	 mov	 rdx, QWORD PTR p$[rsp]
  00030	48 8b c8	 mov	 rcx, rax
  00033	e8 00 00 00 00	 call	 ?push@CQueueS@@QEAA_NPEAX@Z ; CQueueS::push
  00038	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0003d	48 8b c8	 mov	 rcx, rax
  00040	e8 00 00 00 00	 call	 ?sendSignal@CComThread@@QEAAXXZ ; CComThread::sendSignal
  00045	b0 01		 mov	 al, 1
  00047	eb 02		 jmp	 SHORT $LN1@putQueue
$LN2@putQueue:
  00049	32 c0		 xor	 al, al
$LN1@putQueue:
  0004b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004f	c3		 ret	 0
?putQueue@CComQueueThread@@QEAA_NPEAUSTEvent@@@Z ENDP	; CComQueueThread::putQueue
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?quit@CComQueueThread@@QEAA_NXZ
_TEXT	SEGMENT
this$ = 48
?quit@CComQueueThread@@QEAA_NXZ PROC			; CComQueueThread::quit, COMDAT

; 444  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 445  : 	m_cThread.quit();

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b c8	 mov	 rcx, rax
  00011	e8 00 00 00 00	 call	 ?quit@CComThread@@QEAA_NXZ ; CComThread::quit

; 446  : 	return true;

  00016	b0 01		 mov	 al, 1

; 447  : }

  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001c	c3		 ret	 0
?quit@CComQueueThread@@QEAA_NXZ ENDP			; CComQueueThread::quit
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?start@CComQueueThread@@QEAA_NXZ
_TEXT	SEGMENT
this$ = 64
?start@CComQueueThread@@QEAA_NXZ PROC			; CComQueueThread::start, COMDAT

; 430  : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 431  : 	if (m_cThread.bActive()) return true;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b c8	 mov	 rcx, rax
  00011	e8 00 00 00 00	 call	 ?bActive@CComThread@@QEAA_NXZ ; CComThread::bActive
  00016	0f b6 c0	 movzx	 eax, al
  00019	85 c0		 test	 eax, eax
  0001b	74 04		 je	 SHORT $LN2@start
  0001d	b0 01		 mov	 al, 1
  0001f	eb 7f		 jmp	 SHORT $LN1@start
$LN2@start:

; 432  : 	if (!m_cThread.init(eventThreadLoop, this, INFINITE)) {

  00021	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00026	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0002f	41 b9 ff ff ff
	ff		 mov	 r9d, -1
  00035	4c 8b 44 24 40	 mov	 r8, QWORD PTR this$[rsp]
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?eventThreadLoop@@YAXPEAUSTThreadInfo@@@Z ; eventThreadLoop
  00041	48 8b c8	 mov	 rcx, rax
  00044	e8 00 00 00 00	 call	 ?init@CComThread@@QEAA_NP6AXPEAUSTThreadInfo@@@ZPEAXH2@Z ; CComThread::init
  00049	0f b6 c0	 movzx	 eax, al
  0004c	85 c0		 test	 eax, eax
  0004e	75 1d		 jne	 SHORT $LN3@start

; 433  : 		comErrorPrint("m_cThread.init");

  00050	41 b8 b1 01 00
	00		 mov	 r8d, 433		; 000001b1H
  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45579
  0005d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG45580
  00064	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 434  : 		return false;

  00069	32 c0		 xor	 al, al
  0006b	eb 33		 jmp	 SHORT $LN1@start
$LN3@start:

; 435  : 	}
; 436  : 	if (!m_cThread.start()) {

  0006d	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00072	48 8b c8	 mov	 rcx, rax
  00075	e8 00 00 00 00	 call	 ?start@CComThread@@QEAA_NXZ ; CComThread::start
  0007a	0f b6 c0	 movzx	 eax, al
  0007d	85 c0		 test	 eax, eax
  0007f	75 1d		 jne	 SHORT $LN4@start

; 437  : 		comErrorPrint("m_cThread.start");

  00081	41 b8 b5 01 00
	00		 mov	 r8d, 437		; 000001b5H
  00087	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45582
  0008e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG45583
  00095	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 438  : 		return false;

  0009a	32 c0		 xor	 al, al
  0009c	eb 02		 jmp	 SHORT $LN1@start
$LN4@start:

; 439  : 	}
; 440  : 	return true;

  0009e	b0 01		 mov	 al, 1
$LN1@start:

; 441  : }

  000a0	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a4	c3		 ret	 0
?start@CComQueueThread@@QEAA_NXZ ENDP			; CComQueueThread::start
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?init@CComQueueThread@@QEAA_NHH@Z
_TEXT	SEGMENT
this$ = 48
nCount$ = 56
nIdx$ = 64
?init@CComQueueThread@@QEAA_NHH@Z PROC			; CComQueueThread::init, COMDAT

; 422  : {

$LN4:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 423  : 	if (!m_sLogQueue.alloc(nCount, eAlloc_Type_none)) { printf("has Failed!! m_sLogQueue.alloc(%d)\n", nCount); return false; }

  00012	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00017	48 83 c0 48	 add	 rax, 72			; 00000048H
  0001b	45 33 c0	 xor	 r8d, r8d
  0001e	8b 54 24 38	 mov	 edx, DWORD PTR nCount$[rsp]
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 ?alloc@CQueueS@@QEAA_NHW4E_ALLOC_TYPE@@@Z ; CQueueS::alloc
  0002a	0f b6 c0	 movzx	 eax, al
  0002d	85 c0		 test	 eax, eax
  0002f	75 14		 jne	 SHORT $LN2@init
  00031	8b 54 24 38	 mov	 edx, DWORD PTR nCount$[rsp]
  00035	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG45573
  0003c	e8 00 00 00 00	 call	 printf
  00041	32 c0		 xor	 al, al
  00043	eb 13		 jmp	 SHORT $LN1@init
$LN2@init:

; 424  : 	m_cThread.setIdx(nIdx);

  00045	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0004a	8b 54 24 40	 mov	 edx, DWORD PTR nIdx$[rsp]
  0004e	48 8b c8	 mov	 rcx, rax
  00051	e8 00 00 00 00	 call	 ?setIdx@CComThread@@QEAAXH@Z ; CComThread::setIdx

; 425  : 	return true;

  00056	b0 01		 mov	 al, 1
$LN1@init:

; 426  : }

  00058	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005c	c3		 ret	 0
?init@CComQueueThread@@QEAA_NHH@Z ENDP			; CComQueueThread::init
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?initConfig@CComQueueThread@@QEAA_NPEADH0@Z
_TEXT	SEGMENT
nCount$ = 32
szSect$ = 40
__$ArrayPad$ = 64
this$ = 96
pConfigFile$ = 104
seq$ = 112
pSection$ = 120
?initConfig@CComQueueThread@@QEAA_NPEADH0@Z PROC	; CComQueueThread::initConfig, COMDAT

; 410  : {

$LN4:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 411  : 	TCHAR szSect[24];
; 412  : 	int nCount;
; 413  : 
; 414  : 	_stprintf(szSect, _T("%s_%d"), pSection, seq);

  00027	44 8b 4c 24 70	 mov	 r9d, DWORD PTR seq$[rsp]
  0002c	4c 8b 44 24 78	 mov	 r8, QWORD PTR pSection$[rsp]
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45563
  00038	48 8d 4c 24 28	 lea	 rcx, QWORD PTR szSect$[rsp]
  0003d	e8 00 00 00 00	 call	 sprintf

; 415  : 	nCount = GetPrivateProfileInt(szSect, _T("LIST_COUNT"), 20, pConfigFile) + LIST_ADD_COUNT;

  00042	4c 8b 4c 24 68	 mov	 r9, QWORD PTR pConfigFile$[rsp]
  00047	41 b8 14 00 00
	00		 mov	 r8d, 20
  0004d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45564
  00054	48 8d 4c 24 28	 lea	 rcx, QWORD PTR szSect$[rsp]
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetPrivateProfileIntA
  0005f	83 c0 0a	 add	 eax, 10
  00062	89 44 24 20	 mov	 DWORD PTR nCount$[rsp], eax

; 416  : 
; 417  : 	if (!m_sLogQueue.alloc(nCount, eAlloc_Type_none)) { printf("has Failed!! m_sLogQueue.alloc(%d)\n", nCount); return false; }

  00066	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  0006b	48 83 c0 48	 add	 rax, 72			; 00000048H
  0006f	45 33 c0	 xor	 r8d, r8d
  00072	8b 54 24 20	 mov	 edx, DWORD PTR nCount$[rsp]
  00076	48 8b c8	 mov	 rcx, rax
  00079	e8 00 00 00 00	 call	 ?alloc@CQueueS@@QEAA_NHW4E_ALLOC_TYPE@@@Z ; CQueueS::alloc
  0007e	0f b6 c0	 movzx	 eax, al
  00081	85 c0		 test	 eax, eax
  00083	75 14		 jne	 SHORT $LN2@initConfig
  00085	8b 54 24 20	 mov	 edx, DWORD PTR nCount$[rsp]
  00089	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG45566
  00090	e8 00 00 00 00	 call	 printf
  00095	32 c0		 xor	 al, al
  00097	eb 02		 jmp	 SHORT $LN1@initConfig
$LN2@initConfig:

; 418  : 	return true;

  00099	b0 01		 mov	 al, 1
$LN1@initConfig:

; 419  : }

  0009b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000a0	48 33 cc	 xor	 rcx, rsp
  000a3	e8 00 00 00 00	 call	 __security_check_cookie
  000a8	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000ac	c3		 ret	 0
?initConfig@CComQueueThread@@QEAA_NPEADH0@Z ENDP	; CComQueueThread::initConfig
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ??1CComQueueThread@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??1CComQueueThread@@QEAA@XZ PROC			; CComQueueThread::~CComQueueThread, COMDAT

; 405  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00009	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2

; 406  : 	quit();

  00012	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00017	e8 00 00 00 00	 call	 ?quit@CComQueueThread@@QEAA_NXZ ; CComQueueThread::quit
  0001c	90		 npad	 1

; 407  : }

  0001d	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00022	48 83 c0 48	 add	 rax, 72			; 00000048H
  00026	48 8b c8	 mov	 rcx, rax
  00029	e8 00 00 00 00	 call	 ??1CQueueS@@QEAA@XZ	; CQueueS::~CQueueS
  0002e	90		 npad	 1
  0002f	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00034	48 8b c8	 mov	 rcx, rax
  00037	e8 00 00 00 00	 call	 ??1CComThread@@QEAA@XZ	; CComThread::~CComThread
  0003c	90		 npad	 1
  0003d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00041	c3		 ret	 0
??1CComQueueThread@@QEAA@XZ ENDP			; CComQueueThread::~CComQueueThread
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ??0CComQueueThread@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??0CComQueueThread@@QEAA@XZ PROC			; CComQueueThread::CComQueueThread, COMDAT

; 401  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00009	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00012	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00017	48 8b c8	 mov	 rcx, rax
  0001a	e8 00 00 00 00	 call	 ??0CComThread@@QEAA@XZ	; CComThread::CComThread
  0001f	90		 npad	 1
  00020	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00025	48 83 c0 48	 add	 rax, 72			; 00000048H
  00029	48 8b c8	 mov	 rcx, rax
  0002c	e8 00 00 00 00	 call	 ??0CQueueS@@QEAA@XZ	; CQueueS::CQueueS
  00031	90		 npad	 1

; 402  : 
; 403  : }

  00032	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00037	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003b	c3		 ret	 0
??0CComQueueThread@@QEAA@XZ ENDP			; CComQueueThread::CComQueueThread
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$0@?0???0CComQueueThread@@QEAA@XZ@4HA PROC		; `CComQueueThread::CComQueueThread'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8b 4d 40	 mov	 rcx, QWORD PTR this$[rbp]
  0000d	e8 00 00 00 00	 call	 ??1CComThread@@QEAA@XZ	; CComThread::~CComThread
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$0@?0???0CComQueueThread@@QEAA@XZ@4HA ENDP		; `CComQueueThread::CComQueueThread'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$0@?0???0CComQueueThread@@QEAA@XZ@4HA PROC		; `CComQueueThread::CComQueueThread'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8b 4d 40	 mov	 rcx, QWORD PTR this$[rbp]
  0000d	e8 00 00 00 00	 call	 ??1CComThread@@QEAA@XZ	; CComThread::~CComThread
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$0@?0???0CComQueueThread@@QEAA@XZ@4HA ENDP		; `CComQueueThread::CComQueueThread'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?eventThreadLoop@@YAXPEAUSTThreadInfo@@@Z
_TEXT	SEGMENT
pEvent$ = 32
pBasic$ = 40
p$ = 64
?eventThreadLoop@@YAXPEAUSTThreadInfo@@@Z PROC		; eventThreadLoop, COMDAT

; 451  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 452  : 	CComQueueThread *pBasic = (CComQueueThread *)p->pClass;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR p$[rsp]
  0000e	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00012	48 89 44 24 28	 mov	 QWORD PTR pBasic$[rsp], rax

; 453  : 	STEvent *pEvent = pBasic->getEvent();

  00017	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pBasic$[rsp]
  0001c	e8 00 00 00 00	 call	 ?getEvent@CComQueueThread@@QEAAPEAUSTEvent@@XZ ; CComQueueThread::getEvent
  00021	48 89 44 24 20	 mov	 QWORD PTR pEvent$[rsp], rax
$LN2@eventThrea:

; 454  : 	while (pEvent)

  00026	48 83 7c 24 20
	00		 cmp	 QWORD PTR pEvent$[rsp], 0
  0002c	74 45		 je	 SHORT $LN3@eventThrea

; 455  : 	{
; 456  : 		pEvent->fpProc(pEvent->pObj, pEvent->pObj2, pEvent->nValue);

  0002e	48 8b 44 24 20	 mov	 rax, QWORD PTR pEvent$[rsp]
  00033	44 8b 40 04	 mov	 r8d, DWORD PTR [rax+4]
  00037	48 8b 44 24 20	 mov	 rax, QWORD PTR pEvent$[rsp]
  0003c	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00040	48 8b 44 24 20	 mov	 rax, QWORD PTR pEvent$[rsp]
  00045	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00049	48 8b 44 24 20	 mov	 rax, QWORD PTR pEvent$[rsp]
  0004e	ff 50 18	 call	 QWORD PTR [rax+24]

; 457  : 		gs_pCore->delEvent(pEvent);

  00051	48 8b 54 24 20	 mov	 rdx, QWORD PTR pEvent$[rsp]
  00056	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pCore@@3PEAVCCoreList@@EA ; gs_pCore
  0005d	e8 00 00 00 00	 call	 ?delEvent@CCoreList@@QEAA_NPEAUSTEvent@@@Z ; CCoreList::delEvent

; 458  : 		pEvent = pBasic->getEvent();

  00062	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pBasic$[rsp]
  00067	e8 00 00 00 00	 call	 ?getEvent@CComQueueThread@@QEAAPEAUSTEvent@@XZ ; CComQueueThread::getEvent
  0006c	48 89 44 24 20	 mov	 QWORD PTR pEvent$[rsp], rax

; 459  : 	}

  00071	eb b3		 jmp	 SHORT $LN2@eventThrea
$LN3@eventThrea:

; 460  : }

  00073	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00077	c3		 ret	 0
?eventThreadLoop@@YAXPEAUSTThreadInfo@@@Z ENDP		; eventThreadLoop
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$CMemList@USTIntervalInfo@@@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$CMemList@USTIntervalInfo@@@@QEAAPEAXI@Z PROC	; CMemList<STIntervalInfo>::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00012	e8 00 00 00 00	 call	 ??1?$CMemList@USTIntervalInfo@@@@QEAA@XZ ; CMemList<STIntervalInfo>::~CMemList<STIntervalInfo>
  00017	8b 44 24 38	 mov	 eax, DWORD PTR __flags$[rsp]
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 0f		 je	 SHORT $LN2@scalar
  00022	ba 30 00 00 00	 mov	 edx, 48			; 00000030H
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
??_G?$CMemList@USTIntervalInfo@@@@QEAAPEAXI@Z ENDP	; CMemList<STIntervalInfo>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit2@?$CMemList@USTIntervalInfo@@@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 16
classSize$ = 24
?__autoclassinit2@?$CMemList@USTIntervalInfo@@@@QEAAX_K@Z PROC ; CMemList<STIntervalInfo>::__autoclassinit2, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 8b 7c 24 10	 mov	 rdi, QWORD PTR this$[rsp]
  00010	33 c0		 xor	 eax, eax
  00012	48 8b 4c 24 18	 mov	 rcx, QWORD PTR classSize$[rsp]
  00017	f3 aa		 rep stosb
  00019	5f		 pop	 rdi
  0001a	c3		 ret	 0
?__autoclassinit2@?$CMemList@USTIntervalInfo@@@@QEAAX_K@Z ENDP ; CMemList<STIntervalInfo>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?_del@?$CMemList@USTIntervalInfo@@@@AEAAXH@Z
_TEXT	SEGMENT
this$ = 48
i$ = 56
?_del@?$CMemList@USTIntervalInfo@@@@AEAAXH@Z PROC	; CMemList<STIntervalInfo>::_del, COMDAT

; 283  : {

$LN6:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 284  : 	m_nCurCount.atomic_decrement();

  0000d	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00012	48 83 c0 10	 add	 rax, 16
  00016	48 8b c8	 mov	 rcx, rax
  00019	e8 00 00 00 00	 call	 ?atomic_decrement@win64_atomic@win32@common@@QEAA_JXZ ; common::win32::win64_atomic::atomic_decrement

; 285  : 	m_nFlagArray[i].setCount(0);

  0001e	48 63 44 24 38	 movsxd	 rax, DWORD PTR i$[rsp]
  00023	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00028	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0002c	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  00030	33 d2		 xor	 edx, edx
  00032	48 8b c8	 mov	 rcx, rax
  00035	e8 00 00 00 00	 call	 ?setCount@win64_atomic@win32@common@@QEAAXH@Z ; common::win32::win64_atomic::setCount

; 286  : 	if(m_nEmptyFirstIdx < 0) m_nEmptyFirstIdx = i;

  0003a	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0003f	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00043	7d 0e		 jge	 SHORT $LN2@del
  00045	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0004a	8b 4c 24 38	 mov	 ecx, DWORD PTR i$[rsp]
  0004e	89 48 18	 mov	 DWORD PTR [rax+24], ecx
  00051	eb 1a		 jmp	 SHORT $LN3@del
$LN2@del:

; 287  : 	else if (i < m_nEmptyFirstIdx) m_nEmptyFirstIdx = i;

  00053	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00058	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0005b	39 44 24 38	 cmp	 DWORD PTR i$[rsp], eax
  0005f	7d 0c		 jge	 SHORT $LN4@del
  00061	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00066	8b 4c 24 38	 mov	 ecx, DWORD PTR i$[rsp]
  0006a	89 48 18	 mov	 DWORD PTR [rax+24], ecx
$LN4@del:
$LN3@del:

; 288  : }

  0006d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00071	c3		 ret	 0
?_del@?$CMemList@USTIntervalInfo@@@@AEAAXH@Z ENDP	; CMemList<STIntervalInfo>::_del
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?del@?$CMemList@USTIntervalInfo@@@@QEAA_NPEAUSTIntervalInfo@@@Z
_TEXT	SEGMENT
i$ = 32
this$ = 64
Obj$ = 72
?del@?$CMemList@USTIntervalInfo@@@@QEAA_NPEAUSTIntervalInfo@@@Z PROC ; CMemList<STIntervalInfo>::del, COMDAT

; 268  : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 269  : 	int i;
; 270  : 	for (i = 0; i < m_nMaxCount; i++)

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00016	eb 0a		 jmp	 SHORT $LN4@del
$LN2@del:
  00018	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0001c	ff c0		 inc	 eax
  0001e	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@del:
  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00027	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  0002a	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0002e	7d 2c		 jge	 SHORT $LN3@del

; 271  : 	{
; 272  : 		if (m_pArray[i] == Obj) {

  00030	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00035	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0003a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0003d	48 8b 54 24 48	 mov	 rdx, QWORD PTR Obj$[rsp]
  00042	48 39 14 c1	 cmp	 QWORD PTR [rcx+rax*8], rdx
  00046	75 12		 jne	 SHORT $LN5@del

; 273  : 			_del(i);

  00048	8b 54 24 20	 mov	 edx, DWORD PTR i$[rsp]
  0004c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00051	e8 00 00 00 00	 call	 ?_del@?$CMemList@USTIntervalInfo@@@@AEAAXH@Z ; CMemList<STIntervalInfo>::_del

; 274  : 			return true;

  00056	b0 01		 mov	 al, 1
  00058	eb 1d		 jmp	 SHORT $LN1@del
$LN5@del:

; 275  : 		}
; 276  : 	}

  0005a	eb bc		 jmp	 SHORT $LN2@del
$LN3@del:

; 277  : 	comErrorPrint("can't find obj");

  0005c	41 b8 15 01 00
	00		 mov	 r8d, 277		; 00000115H
  00062	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46856
  00069	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG46857
  00070	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 278  : 	return false;

  00075	32 c0		 xor	 al, al
$LN1@del:

; 279  : }

  00077	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007b	c3		 ret	 0
?del@?$CMemList@USTIntervalInfo@@@@QEAA_NPEAUSTIntervalInfo@@@Z ENDP ; CMemList<STIntervalInfo>::del
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?add@?$CMemList@USTIntervalInfo@@@@QEAAHPEAUSTIntervalInfo@@@Z
_TEXT	SEGMENT
bFind$ = 32
nAddIdx$ = 36
i$ = 40
this$ = 64
Obj$ = 72
?add@?$CMemList@USTIntervalInfo@@@@QEAAHPEAUSTIntervalInfo@@@Z PROC ; CMemList<STIntervalInfo>::add, COMDAT

; 212  : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 213  : 	int nAddIdx = m_nEmptyFirstIdx, i;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00013	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00016	89 44 24 24	 mov	 DWORD PTR nAddIdx$[rsp], eax

; 214  : 	bool bFind = false;

  0001a	c6 44 24 20 00	 mov	 BYTE PTR bFind$[rsp], 0

; 215  : 
; 216  : 	if (0 <= nAddIdx) {

  0001f	83 7c 24 24 00	 cmp	 DWORD PTR nAddIdx$[rsp], 0
  00024	7c 5b		 jl	 SHORT $LN5@add

; 217  : 		if (!m_nFlagArray[nAddIdx].getCount()) {

  00026	48 63 44 24 24	 movsxd	 rax, DWORD PTR nAddIdx$[rsp]
  0002b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00030	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00034	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  00038	48 8b c8	 mov	 rcx, rax
  0003b	e8 00 00 00 00	 call	 ?getCount@win64_atomic@win32@common@@QEAAHXZ ; common::win32::win64_atomic::getCount
  00040	85 c0		 test	 eax, eax
  00042	75 3d		 jne	 SHORT $LN6@add

; 218  : 			if (!m_nFlagArray[nAddIdx].atomic_compare_exchange(1, 0)) {

  00044	48 63 44 24 24	 movsxd	 rax, DWORD PTR nAddIdx$[rsp]
  00049	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0004e	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00052	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  00056	45 33 c0	 xor	 r8d, r8d
  00059	ba 01 00 00 00	 mov	 edx, 1
  0005e	48 8b c8	 mov	 rcx, rax
  00061	e8 00 00 00 00	 call	 ?atomic_compare_exchange@win64_atomic@win32@common@@QEAA_J_J0@Z ; common::win32::win64_atomic::atomic_compare_exchange
  00066	48 85 c0	 test	 rax, rax
  00069	75 16		 jne	 SHORT $LN7@add

; 219  : 				m_nEmptyFirstIdx = -1;

  0006b	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00070	c7 40 18 ff ff
	ff ff		 mov	 DWORD PTR [rax+24], -1

; 220  : 				goto ADD_SUCCESS;

  00077	e9 d3 00 00 00	 jmp	 $LN8@add
  0007c	e9 ce 00 00 00	 jmp	 $ADD_SUCCESS$17
$LN7@add:
$LN6@add:
$LN5@add:

; 221  : 			}
; 222  : 		}
; 223  : 	}
; 224  : 
; 225  : 	nAddIdx = m_nCurCount.getCount();

  00081	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00086	48 83 c0 10	 add	 rax, 16
  0008a	48 8b c8	 mov	 rcx, rax
  0008d	e8 00 00 00 00	 call	 ?getCount@win64_atomic@win32@common@@QEAAHXZ ; common::win32::win64_atomic::getCount
  00092	89 44 24 24	 mov	 DWORD PTR nAddIdx$[rsp], eax

; 226  : 	for (i = 0; i < m_nMaxCount; i++) {

  00096	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0009e	eb 0a		 jmp	 SHORT $LN4@add
$LN2@add:
  000a0	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  000a4	ff c0		 inc	 eax
  000a6	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN4@add:
  000aa	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000af	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  000b2	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  000b6	0f 8d 93 00 00
	00		 jge	 $LN3@add

; 227  : 		if (m_nMaxCount <= m_nCurCount.getCount()) goto ADD_ERROR;

  000bc	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000c1	48 83 c0 10	 add	 rax, 16
  000c5	48 8b c8	 mov	 rcx, rax
  000c8	e8 00 00 00 00	 call	 ?getCount@win64_atomic@win32@common@@QEAAHXZ ; common::win32::win64_atomic::getCount
  000cd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000d2	39 41 1c	 cmp	 DWORD PTR [rcx+28], eax
  000d5	7f 0a		 jg	 SHORT $LN9@add
  000d7	e9 bf 00 00 00	 jmp	 $LN10@add
  000dc	e9 ba 00 00 00	 jmp	 $ADD_ERROR$18
$LN9@add:

; 228  : 		if (nAddIdx == m_nMaxCount) nAddIdx = 0;

  000e1	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000e6	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  000e9	39 44 24 24	 cmp	 DWORD PTR nAddIdx$[rsp], eax
  000ed	75 08		 jne	 SHORT $LN11@add
  000ef	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR nAddIdx$[rsp], 0
$LN11@add:

; 229  : 		if (!m_nFlagArray[nAddIdx].getCount()) {

  000f7	48 63 44 24 24	 movsxd	 rax, DWORD PTR nAddIdx$[rsp]
  000fc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00101	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00105	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  00109	48 8b c8	 mov	 rcx, rax
  0010c	e8 00 00 00 00	 call	 ?getCount@win64_atomic@win32@common@@QEAAHXZ ; common::win32::win64_atomic::getCount
  00111	85 c0		 test	 eax, eax
  00113	75 2b		 jne	 SHORT $LN12@add

; 230  : 			if (!m_nFlagArray[nAddIdx].atomic_compare_exchange(1, 0)) goto ADD_SUCCESS;

  00115	48 63 44 24 24	 movsxd	 rax, DWORD PTR nAddIdx$[rsp]
  0011a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0011f	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00123	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  00127	45 33 c0	 xor	 r8d, r8d
  0012a	ba 01 00 00 00	 mov	 edx, 1
  0012f	48 8b c8	 mov	 rcx, rax
  00132	e8 00 00 00 00	 call	 ?atomic_compare_exchange@win64_atomic@win32@common@@QEAA_J_J0@Z ; common::win32::win64_atomic::atomic_compare_exchange
  00137	48 85 c0	 test	 rax, rax
  0013a	75 04		 jne	 SHORT $LN13@add
  0013c	eb 11		 jmp	 SHORT $LN14@add
  0013e	eb 0f		 jmp	 SHORT $ADD_SUCCESS$17
$LN13@add:
$LN12@add:

; 231  : 		}
; 232  : 		nAddIdx++;

  00140	8b 44 24 24	 mov	 eax, DWORD PTR nAddIdx$[rsp]
  00144	ff c0		 inc	 eax
  00146	89 44 24 24	 mov	 DWORD PTR nAddIdx$[rsp], eax

; 233  : 	}

  0014a	e9 51 ff ff ff	 jmp	 $LN2@add
$LN3@add:
$LN8@add:
$LN14@add:
$ADD_SUCCESS$17:

; 234  : 
; 235  : ADD_SUCCESS:
; 236  : 	m_pArray[nAddIdx] = Obj;

  0014f	48 63 44 24 24	 movsxd	 rax, DWORD PTR nAddIdx$[rsp]
  00154	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00159	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0015c	48 8b 54 24 48	 mov	 rdx, QWORD PTR Obj$[rsp]
  00161	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx

; 237  : 	m_nFlagArray[nAddIdx].setCount(2);

  00165	48 63 44 24 24	 movsxd	 rax, DWORD PTR nAddIdx$[rsp]
  0016a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0016f	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00173	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  00177	ba 02 00 00 00	 mov	 edx, 2
  0017c	48 8b c8	 mov	 rcx, rax
  0017f	e8 00 00 00 00	 call	 ?setCount@win64_atomic@win32@common@@QEAAXH@Z ; common::win32::win64_atomic::setCount

; 238  : 	m_nCurCount.atomic_increment();

  00184	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00189	48 83 c0 10	 add	 rax, 16
  0018d	48 8b c8	 mov	 rcx, rax
  00190	e8 00 00 00 00	 call	 ?atomic_increment@win64_atomic@win32@common@@QEAA_JXZ ; common::win32::win64_atomic::atomic_increment

; 239  : 	return nAddIdx;

  00195	8b 44 24 24	 mov	 eax, DWORD PTR nAddIdx$[rsp]
  00199	eb 3a		 jmp	 SHORT $LN1@add
$LN10@add:
$ADD_ERROR$18:

; 240  : 
; 241  : ADD_ERROR :
; 242  : 	_stprintf(g_szMessage, _T("FULL! m_nMaxCount[%d]"), m_nMaxCount);

  0019b	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  001a0	44 8b 40 1c	 mov	 r8d, DWORD PTR [rax+28]
  001a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46844
  001ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  001b2	e8 00 00 00 00	 call	 sprintf

; 243  : 	comErrorPrint(g_szMessage);

  001b7	41 b8 f3 00 00
	00		 mov	 r8d, 243		; 000000f3H
  001bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46845
  001c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  001cb	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 244  : 	return -1;

  001d0	b8 ff ff ff ff	 mov	 eax, -1
$LN1@add:

; 245  : }

  001d5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001d9	c3		 ret	 0
?add@?$CMemList@USTIntervalInfo@@@@QEAAHPEAUSTIntervalInfo@@@Z ENDP ; CMemList<STIntervalInfo>::add
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?getNext@?$CMemList@USTIntervalInfo@@@@QEAAPEAUSTIntervalInfo@@PEAH@Z
_TEXT	SEGMENT
idx$1 = 32
i$ = 36
this$ = 64
pCurIdx$ = 72
?getNext@?$CMemList@USTIntervalInfo@@@@QEAAPEAUSTIntervalInfo@@PEAH@Z PROC ; CMemList<STIntervalInfo>::getNext, COMDAT

; 136  : {

$LN10:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 137  : 	int i = *pCurIdx;

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR pCurIdx$[rsp]
  00013	8b 00		 mov	 eax, DWORD PTR [rax]
  00015	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax

; 138  : 	if (i < m_nMaxCount)

  00019	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0001e	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00021	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  00025	0f 8d a2 00 00
	00		 jge	 $LN5@getNext

; 139  : 	{
; 140  : 		if (m_nFlagArray[i].getCount() == 2) {

  0002b	48 63 44 24 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00030	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00035	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00039	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  0003d	48 8b c8	 mov	 rcx, rax
  00040	e8 00 00 00 00	 call	 ?getCount@win64_atomic@win32@common@@QEAAHXZ ; common::win32::win64_atomic::getCount
  00045	83 f8 02	 cmp	 eax, 2
  00048	75 20		 jne	 SHORT $LN6@getNext

; 141  : 			*pCurIdx = i;

  0004a	48 8b 44 24 48	 mov	 rax, QWORD PTR pCurIdx$[rsp]
  0004f	8b 4c 24 24	 mov	 ecx, DWORD PTR i$[rsp]
  00053	89 08		 mov	 DWORD PTR [rax], ecx

; 142  : 			return m_pArray[i];

  00055	48 63 44 24 24	 movsxd	 rax, DWORD PTR i$[rsp]
  0005a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0005f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00062	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00066	eb 67		 jmp	 SHORT $LN1@getNext

; 143  : 		}
; 144  : 		else

  00068	eb 63		 jmp	 SHORT $LN7@getNext
$LN6@getNext:

; 145  : 		{
; 146  : 			int idx = i + 1;

  0006a	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  0006e	ff c0		 inc	 eax
  00070	89 44 24 20	 mov	 DWORD PTR idx$1[rsp], eax

; 147  : 			for (idx; idx < m_nMaxCount; idx++)

  00074	eb 0a		 jmp	 SHORT $LN4@getNext
$LN2@getNext:
  00076	8b 44 24 20	 mov	 eax, DWORD PTR idx$1[rsp]
  0007a	ff c0		 inc	 eax
  0007c	89 44 24 20	 mov	 DWORD PTR idx$1[rsp], eax
$LN4@getNext:
  00080	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00085	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00088	39 44 24 20	 cmp	 DWORD PTR idx$1[rsp], eax
  0008c	7d 3f		 jge	 SHORT $LN3@getNext

; 148  : 			{
; 149  : 				if (m_nFlagArray[idx].getCount() == 2) {

  0008e	48 63 44 24 20	 movsxd	 rax, DWORD PTR idx$1[rsp]
  00093	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00098	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0009c	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  000a0	48 8b c8	 mov	 rcx, rax
  000a3	e8 00 00 00 00	 call	 ?getCount@win64_atomic@win32@common@@QEAAHXZ ; common::win32::win64_atomic::getCount
  000a8	83 f8 02	 cmp	 eax, 2
  000ab	75 1e		 jne	 SHORT $LN8@getNext

; 150  : 					*pCurIdx = idx;

  000ad	48 8b 44 24 48	 mov	 rax, QWORD PTR pCurIdx$[rsp]
  000b2	8b 4c 24 20	 mov	 ecx, DWORD PTR idx$1[rsp]
  000b6	89 08		 mov	 DWORD PTR [rax], ecx

; 151  : 					return m_pArray[idx];

  000b8	48 63 44 24 20	 movsxd	 rax, DWORD PTR idx$1[rsp]
  000bd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000c2	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000c5	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  000c9	eb 04		 jmp	 SHORT $LN1@getNext
$LN8@getNext:

; 152  : 				}
; 153  : 			}

  000cb	eb a9		 jmp	 SHORT $LN2@getNext
$LN3@getNext:
$LN7@getNext:
$LN5@getNext:

; 154  : 		}
; 155  : 	}
; 156  : 	return NULL;

  000cd	33 c0		 xor	 eax, eax
$LN1@getNext:

; 157  : }

  000cf	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d3	c3		 ret	 0
?getNext@?$CMemList@USTIntervalInfo@@@@QEAAPEAUSTIntervalInfo@@PEAH@Z ENDP ; CMemList<STIntervalInfo>::getNext
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?alloc@?$CMemList@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z
_TEXT	SEGMENT
i$ = 48
$T1 = 56
$T2 = 64
tv135 = 72
$T3 = 80
$T4 = 88
this$ = 112
nMaxCount$ = 120
type$ = 128
?alloc@?$CMemList@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z PROC ; CMemList<STIntervalInfo>::alloc, COMDAT

; 104  : int CMemList<T>::alloc(int nMaxCount, E_ALLOC_TYPE type) {

$LN11:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00012	48 c7 44 24 58
	fe ff ff ff	 mov	 QWORD PTR $T4[rsp], -2

; 105  : 
; 106  : 	//T  ObjMem = 0;	
; 107  : 
; 108  : 	m_pArray = (T **)calloc(nMaxCount, sizeof(T*));

  0001b	48 63 44 24 78	 movsxd	 rax, DWORD PTR nMaxCount$[rsp]
  00020	ba 08 00 00 00	 mov	 edx, 8
  00025	48 8b c8	 mov	 rcx, rax
  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  0002e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR this$[rsp]
  00033	48 89 01	 mov	 QWORD PTR [rcx], rax

; 109  : 	if (m_pArray == 0) {

  00036	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  0003b	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0003f	75 07		 jne	 SHORT $LN5@alloc

; 110  : 		//_stprintf(m_szMessage, _T("CMemList::m_pArray allock ERROR"));
; 111  : 		return 0;

  00041	33 c0		 xor	 eax, eax
  00043	e9 4b 01 00 00	 jmp	 $LN1@alloc
$LN5@alloc:

; 112  : 	}
; 113  : 
; 114  : 	m_nFlagArray = new(std::nothrow)atomic_nr[nMaxCount];

  00048	48 63 44 24 78	 movsxd	 rax, DWORD PTR nMaxCount$[rsp]
  0004d	48 89 44 24 40	 mov	 QWORD PTR $T2[rsp], rax
  00052	b8 08 00 00 00	 mov	 eax, 8
  00057	48 f7 64 24 40	 mul	 QWORD PTR $T2[rsp]
  0005c	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  00063	48 0f 40 c1	 cmovo	 rax, rcx
  00067	48 83 c0 08	 add	 rax, 8
  0006b	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  00072	48 0f 42 c1	 cmovb	 rax, rcx
  00076	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  0007d	48 8b c8	 mov	 rcx, rax
  00080	e8 00 00 00 00	 call	 ??_U@YAPEAX_KAEBUnothrow_t@std@@@Z ; operator new[]
  00085	48 89 44 24 38	 mov	 QWORD PTR $T1[rsp], rax
  0008a	48 83 7c 24 38
	00		 cmp	 QWORD PTR $T1[rsp], 0
  00090	74 4b		 je	 SHORT $LN8@alloc
  00092	48 8b 44 24 38	 mov	 rax, QWORD PTR $T1[rsp]
  00097	48 8b 4c 24 40	 mov	 rcx, QWORD PTR $T2[rsp]
  0009c	48 89 08	 mov	 QWORD PTR [rax], rcx
  0009f	48 8b 44 24 38	 mov	 rax, QWORD PTR $T1[rsp]
  000a4	48 83 c0 08	 add	 rax, 8
  000a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??1win64_atomic@win32@common@@QEAA@XZ ; common::win32::win64_atomic::~win64_atomic
  000af	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000b4	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??0win64_atomic@win32@common@@QEAA@XZ ; common::win32::win64_atomic::win64_atomic
  000bb	4c 8b 44 24 40	 mov	 r8, QWORD PTR $T2[rsp]
  000c0	ba 08 00 00 00	 mov	 edx, 8
  000c5	48 8b c8	 mov	 rcx, rax
  000c8	e8 00 00 00 00	 call	 ??_L@YAXPEAX_K1P6AX0@Z2@Z
  000cd	48 8b 44 24 38	 mov	 rax, QWORD PTR $T1[rsp]
  000d2	48 83 c0 08	 add	 rax, 8
  000d6	48 89 44 24 48	 mov	 QWORD PTR tv135[rsp], rax
  000db	eb 09		 jmp	 SHORT $LN9@alloc
$LN8@alloc:
  000dd	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR tv135[rsp], 0
$LN9@alloc:
  000e6	48 8b 44 24 48	 mov	 rax, QWORD PTR tv135[rsp]
  000eb	48 89 44 24 50	 mov	 QWORD PTR $T3[rsp], rax
  000f0	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  000f5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR $T3[rsp]
  000fa	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 115  : 	if (m_nFlagArray == 0) {

  000fe	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  00103	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00108	75 12		 jne	 SHORT $LN6@alloc

; 116  : 		//_stprintf(m_szMessage, _T("CMemList::m_nFlagArray allock ERROR"));
; 117  : 		free(m_pArray);

  0010a	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  0010f	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00112	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 118  : 		return 0;

  00118	33 c0		 xor	 eax, eax
  0011a	eb 77		 jmp	 SHORT $LN1@alloc
$LN6@alloc:

; 119  : 	}
; 120  : 	int i;
; 121  : 	for (i = 0; i < nMaxCount; i++)

  0011c	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00124	eb 0a		 jmp	 SHORT $LN4@alloc
$LN2@alloc:
  00126	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0012a	ff c0		 inc	 eax
  0012c	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN4@alloc:
  00130	8b 44 24 78	 mov	 eax, DWORD PTR nMaxCount$[rsp]
  00134	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00138	7d 1c		 jge	 SHORT $LN3@alloc

; 122  : 	{
; 123  : 		m_nFlagArray[i].init();

  0013a	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  0013f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR this$[rsp]
  00144	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00148	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  0014c	48 8b c8	 mov	 rcx, rax
  0014f	e8 00 00 00 00	 call	 ?init@win64_atomic@win32@common@@QEAAXXZ ; common::win32::win64_atomic::init

; 124  : 	}

  00154	eb d0		 jmp	 SHORT $LN2@alloc
$LN3@alloc:

; 125  : 
; 126  : 	m_nMaxCount = nMaxCount;

  00156	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  0015b	8b 4c 24 78	 mov	 ecx, DWORD PTR nMaxCount$[rsp]
  0015f	89 48 1c	 mov	 DWORD PTR [rax+28], ecx

; 127  : 	m_nObjAllocType = type;

  00162	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  00167	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR type$[rsp]
  0016e	89 48 20	 mov	 DWORD PTR [rax+32], ecx

; 128  : 	m_pEnd = m_pArray[nMaxCount-1];

  00171	8b 44 24 78	 mov	 eax, DWORD PTR nMaxCount$[rsp]
  00175	ff c8		 dec	 eax
  00177	48 98		 cdqe
  00179	48 8b 4c 24 70	 mov	 rcx, QWORD PTR this$[rsp]
  0017e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00181	48 8b 54 24 70	 mov	 rdx, QWORD PTR this$[rsp]
  00186	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0018a	48 89 42 28	 mov	 QWORD PTR [rdx+40], rax

; 129  : 	//_stprintf(m_szMessage, _T("CMemList::alloc list m_nMaxCount[%d]"), m_nMaxCount);
; 130  : 	return 1;

  0018e	b8 01 00 00 00	 mov	 eax, 1
$LN1@alloc:

; 131  : }

  00193	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00197	c3		 ret	 0
?alloc@?$CMemList@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z ENDP ; CMemList<STIntervalInfo>::alloc
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
i$ = 48
$T1 = 56
$T2 = 64
tv135 = 72
$T3 = 80
$T4 = 88
this$ = 112
nMaxCount$ = 120
type$ = 128
?dtor$0@?0??alloc@?$CMemList@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z@4HA PROC ; `CMemList<STIntervalInfo>::alloc'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00010	48 8b 4d 38	 mov	 rcx, QWORD PTR $T1[rbp]
  00014	e8 00 00 00 00	 call	 ??_V@YAXPEAXAEBUnothrow_t@std@@@Z ; operator delete[]
  00019	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001d	5d		 pop	 rbp
  0001e	c3		 ret	 0
?dtor$0@?0??alloc@?$CMemList@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z@4HA ENDP ; `CMemList<STIntervalInfo>::alloc'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
i$ = 48
$T1 = 56
$T2 = 64
tv135 = 72
$T3 = 80
$T4 = 88
this$ = 112
nMaxCount$ = 120
type$ = 128
?dtor$0@?0??alloc@?$CMemList@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z@4HA PROC ; `CMemList<STIntervalInfo>::alloc'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00010	48 8b 4d 38	 mov	 rcx, QWORD PTR $T1[rbp]
  00014	e8 00 00 00 00	 call	 ??_V@YAXPEAXAEBUnothrow_t@std@@@Z ; operator delete[]
  00019	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001d	5d		 pop	 rbp
  0001e	c3		 ret	 0
?dtor$0@?0??alloc@?$CMemList@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z@4HA ENDP ; `CMemList<STIntervalInfo>::alloc'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ??1?$CMemList@USTIntervalInfo@@@@QEAA@XZ
_TEXT	SEGMENT
p$1 = 32
tv79 = 40
tv152 = 48
$T2 = 56
$T3 = 64
$T4 = 72
tv83 = 80
tv151 = 88
tv94 = 96
$T5 = 104
tv146 = 112
$T6 = 120
idx$7 = 128
__$ArrayPad$ = 136
this$ = 160
??1?$CMemList@USTIntervalInfo@@@@QEAA@XZ PROC		; CMemList<STIntervalInfo>::~CMemList<STIntervalInfo>, COMDAT

; 75   : {

$LN24:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  0000c	48 c7 44 24 78
	fe ff ff ff	 mov	 QWORD PTR $T6[rsp], -2
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 76   : 	if (!m_pArray) return;

  00027	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0002f	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00033	75 05		 jne	 SHORT $LN6@CMemList
  00035	e9 1b 02 00 00	 jmp	 $LN1@CMemList
$LN6@CMemList:

; 77   : 
; 78   : 	if (ISABLETODELETE(m_nObjAllocType)) {

  0003a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00042	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  00045	e8 00 00 00 00	 call	 ?ISABLETODELETE@@YA_NW4E_ALLOC_TYPE@@@Z ; ISABLETODELETE
  0004a	90		 npad	 1
  0004b	0f b6 c0	 movzx	 eax, al
  0004e	85 c0		 test	 eax, eax
  00050	0f 84 6e 01 00
	00		 je	 $LN7@CMemList

; 79   : 		int idx = 0;

  00056	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR idx$7[rsp], 0

; 80   : 		T *p = getNext(&idx);

  00061	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR idx$7[rsp]
  00069	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00071	e8 00 00 00 00	 call	 ?getNext@?$CMemList@USTIntervalInfo@@@@QEAAPEAUSTIntervalInfo@@PEAH@Z ; CMemList<STIntervalInfo>::getNext
  00076	90		 npad	 1
  00077	48 89 44 24 20	 mov	 QWORD PTR p$1[rsp], rax
$LN2@CMemList:

; 81   : 		while (p) {

  0007c	48 83 7c 24 20
	00		 cmp	 QWORD PTR p$1[rsp], 0
  00082	0f 84 3c 01 00
	00		 je	 $LN7@CMemList

; 82   : 			idx++;

  00088	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR idx$7[rsp]
  0008f	ff c0		 inc	 eax
  00091	89 84 24 80 00
	00 00		 mov	 DWORD PTR idx$7[rsp], eax

; 83   : 			switch (m_nObjAllocType) {

  00098	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000a0	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  000a3	89 44 24 28	 mov	 DWORD PTR tv79[rsp], eax
  000a7	83 7c 24 28 02	 cmp	 DWORD PTR tv79[rsp], 2
  000ac	74 1e		 je	 SHORT $LN8@CMemList
  000ae	83 7c 24 28 03	 cmp	 DWORD PTR tv79[rsp], 3
  000b3	74 5c		 je	 SHORT $LN9@CMemList
  000b5	83 7c 24 28 04	 cmp	 DWORD PTR tv79[rsp], 4
  000ba	74 66		 je	 SHORT $LN10@CMemList
  000bc	83 7c 24 28 05	 cmp	 DWORD PTR tv79[rsp], 5
  000c1	0f 84 a2 00 00
	00		 je	 $LN11@CMemList
  000c7	e9 d8 00 00 00	 jmp	 $LN4@CMemList
$LN8@CMemList:

; 84   : 			case eAlloc_Type_new		: delete p; break;

  000cc	48 8b 44 24 20	 mov	 rax, QWORD PTR p$1[rsp]
  000d1	48 89 44 24 38	 mov	 QWORD PTR $T2[rsp], rax
  000d6	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  000db	48 8b 4c 24 38	 mov	 rcx, QWORD PTR $T2[rsp]
  000e0	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  000e5	90		 npad	 1
  000e6	48 83 7c 24 38
	00		 cmp	 QWORD PTR $T2[rsp], 0
  000ec	75 0b		 jne	 SHORT $LN17@CMemList
  000ee	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR tv83[rsp], 0
  000f7	eb 13		 jmp	 SHORT $LN18@CMemList
$LN17@CMemList:
  000f9	48 c7 44 24 20
	23 81 00 00	 mov	 QWORD PTR p$1[rsp], 33059 ; 00008123H
  00102	48 8b 44 24 20	 mov	 rax, QWORD PTR p$1[rsp]
  00107	48 89 44 24 50	 mov	 QWORD PTR tv83[rsp], rax
$LN18@CMemList:
  0010c	e9 93 00 00 00	 jmp	 $LN4@CMemList
$LN9@CMemList:

; 85   : 			case eAlloc_Type_alloc		: free(p); break;

  00111	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$1[rsp]
  00116	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  0011c	90		 npad	 1
  0011d	e9 82 00 00 00	 jmp	 $LN4@CMemList
$LN10@CMemList:

; 86   : 			case eAlloc_Type_BufPool	: gs_pMMgr->delBuf((char *)p, STRING_SIZE((TCHAR *)p)); break;

  00122	48 8b 44 24 20	 mov	 rax, QWORD PTR p$1[rsp]
  00127	48 89 44 24 58	 mov	 QWORD PTR tv151[rsp], rax
  0012c	48 c7 44 24 30
	ff ff ff ff	 mov	 QWORD PTR tv152[rsp], -1
$LL23@CMemList:
  00135	48 ff 44 24 30	 inc	 QWORD PTR tv152[rsp]
  0013a	48 8b 44 24 58	 mov	 rax, QWORD PTR tv151[rsp]
  0013f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv152[rsp]
  00144	80 3c 08 00	 cmp	 BYTE PTR [rax+rcx], 0
  00148	75 eb		 jne	 SHORT $LL23@CMemList
  0014a	48 8b 44 24 30	 mov	 rax, QWORD PTR tv152[rsp]
  0014f	48 ff c0	 inc	 rax
  00152	44 8b c0	 mov	 r8d, eax
  00155	48 8b 54 24 20	 mov	 rdx, QWORD PTR p$1[rsp]
  0015a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  00161	e8 00 00 00 00	 call	 ?delBuf@CMemManager@@QEAAXPEADH@Z ; CMemManager::delBuf
  00166	90		 npad	 1
  00167	eb 3b		 jmp	 SHORT $LN4@CMemList
$LN11@CMemList:

; 87   : 			case eAlloc_Type_newArray	: delete[] p; break;

  00169	48 8b 44 24 20	 mov	 rax, QWORD PTR p$1[rsp]
  0016e	48 89 44 24 40	 mov	 QWORD PTR $T3[rsp], rax
  00173	48 8b 4c 24 40	 mov	 rcx, QWORD PTR $T3[rsp]
  00178	e8 00 00 00 00	 call	 ??_V@YAXPEAX@Z		; operator delete[]
  0017d	90		 npad	 1
  0017e	48 83 7c 24 40
	00		 cmp	 QWORD PTR $T3[rsp], 0
  00184	75 0b		 jne	 SHORT $LN19@CMemList
  00186	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR tv94[rsp], 0
  0018f	eb 13		 jmp	 SHORT $LN4@CMemList
$LN19@CMemList:
  00191	48 c7 44 24 20
	23 81 00 00	 mov	 QWORD PTR p$1[rsp], 33059 ; 00008123H
  0019a	48 8b 44 24 20	 mov	 rax, QWORD PTR p$1[rsp]
  0019f	48 89 44 24 60	 mov	 QWORD PTR tv94[rsp], rax
$LN4@CMemList:

; 88   : 			case eAlloc_Type_none		: break;
; 89   : 			case eAlloc_Type_MemPool	: break;
; 90   : 			}
; 91   : 			p = getNext(&idx);

  001a4	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR idx$7[rsp]
  001ac	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  001b4	e8 00 00 00 00	 call	 ?getNext@?$CMemList@USTIntervalInfo@@@@QEAAPEAUSTIntervalInfo@@PEAH@Z ; CMemList<STIntervalInfo>::getNext
  001b9	90		 npad	 1
  001ba	48 89 44 24 20	 mov	 QWORD PTR p$1[rsp], rax

; 92   : 		}

  001bf	e9 b8 fe ff ff	 jmp	 $LN2@CMemList
$LN7@CMemList:

; 93   : 	}
; 94   : 
; 95   : 	if (m_pArray)        free(m_pArray);

  001c4	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001cc	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  001d0	74 12		 je	 SHORT $LN14@CMemList
  001d2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001da	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  001dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  001e3	90		 npad	 1
$LN14@CMemList:

; 96   : 	m_pArray = 0;

  001e4	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001ec	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 97   : 
; 98   : 	if (m_nFlagArray)    delete[] m_nFlagArray;

  001f3	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001fb	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00200	74 43		 je	 SHORT $LN15@CMemList
  00202	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0020a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0020e	48 89 44 24 68	 mov	 QWORD PTR $T5[rsp], rax
  00213	48 8b 44 24 68	 mov	 rax, QWORD PTR $T5[rsp]
  00218	48 89 44 24 48	 mov	 QWORD PTR $T4[rsp], rax
  0021d	48 83 7c 24 48
	00		 cmp	 QWORD PTR $T4[rsp], 0
  00223	74 17		 je	 SHORT $LN21@CMemList
  00225	ba 03 00 00 00	 mov	 edx, 3
  0022a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR $T4[rsp]
  0022f	e8 00 00 00 00	 call	 ??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z
  00234	90		 npad	 1
  00235	48 89 44 24 70	 mov	 QWORD PTR tv146[rsp], rax
  0023a	eb 09		 jmp	 SHORT $LN15@CMemList
$LN21@CMemList:
  0023c	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR tv146[rsp], 0
$LN15@CMemList:

; 99   : 	m_nFlagArray = 0;

  00245	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0024d	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
$LN1@CMemList:

; 100  : }

  00255	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0025d	48 83 c0 10	 add	 rax, 16
  00261	48 8b c8	 mov	 rcx, rax
  00264	e8 00 00 00 00	 call	 ??1win64_atomic@win32@common@@QEAA@XZ ; common::win32::win64_atomic::~win64_atomic
  00269	90		 npad	 1
  0026a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00272	48 33 cc	 xor	 rcx, rsp
  00275	e8 00 00 00 00	 call	 __security_check_cookie
  0027a	90		 npad	 1
  0027b	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00282	c3		 ret	 0
??1?$CMemList@USTIntervalInfo@@@@QEAA@XZ ENDP		; CMemList<STIntervalInfo>::~CMemList<STIntervalInfo>
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ??0?$CMemList@USTIntervalInfo@@@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??0?$CMemList@USTIntervalInfo@@@@QEAA@XZ PROC		; CMemList<STIntervalInfo>::CMemList<STIntervalInfo>, COMDAT

; 65   : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00009	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00012	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00017	48 83 c0 10	 add	 rax, 16
  0001b	48 8b c8	 mov	 rcx, rax
  0001e	e8 00 00 00 00	 call	 ??0win64_atomic@win32@common@@QEAA@XZ ; common::win32::win64_atomic::win64_atomic
  00023	90		 npad	 1

; 66   : 	//memset(m_szMessage, 0, LEN_MEM_MESSAGE);
; 67   : 	m_pArray = NULL;

  00024	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00029	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 68   : 	m_nFlagArray = NULL;

  00030	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00035	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 69   : 	m_nObjAllocType = eAlloc_Type_none;

  0003d	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00042	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [rax+32], 0

; 70   : 	m_nCurCount.init();

  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0004e	48 83 c0 10	 add	 rax, 16
  00052	48 8b c8	 mov	 rcx, rax
  00055	e8 00 00 00 00	 call	 ?init@win64_atomic@win32@common@@QEAAXXZ ; common::win32::win64_atomic::init
  0005a	90		 npad	 1

; 71   : }

  0005b	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00060	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00064	c3		 ret	 0
??0?$CMemList@USTIntervalInfo@@@@QEAA@XZ ENDP		; CMemList<STIntervalInfo>::CMemList<STIntervalInfo>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$0@?0???0?$CMemList@USTIntervalInfo@@@@QEAA@XZ@4HA PROC ; `CMemList<STIntervalInfo>::CMemList<STIntervalInfo>'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8b 4d 40	 mov	 rcx, QWORD PTR this$[rbp]
  0000d	48 83 c1 10	 add	 rcx, 16
  00011	e8 00 00 00 00	 call	 ??1win64_atomic@win32@common@@QEAA@XZ ; common::win32::win64_atomic::~win64_atomic
  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5d		 pop	 rbp
  0001b	c3		 ret	 0
?dtor$0@?0???0?$CMemList@USTIntervalInfo@@@@QEAA@XZ@4HA ENDP ; `CMemList<STIntervalInfo>::CMemList<STIntervalInfo>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$0@?0???0?$CMemList@USTIntervalInfo@@@@QEAA@XZ@4HA PROC ; `CMemList<STIntervalInfo>::CMemList<STIntervalInfo>'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8b 4d 40	 mov	 rcx, QWORD PTR this$[rbp]
  0000d	48 83 c1 10	 add	 rcx, 16
  00011	e8 00 00 00 00	 call	 ??1win64_atomic@win32@common@@QEAA@XZ ; common::win32::win64_atomic::~win64_atomic
  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5d		 pop	 rbp
  0001b	c3		 ret	 0
?dtor$0@?0???0?$CMemList@USTIntervalInfo@@@@QEAA@XZ@4HA ENDP ; `CMemList<STIntervalInfo>::CMemList<STIntervalInfo>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_ECScheduler@@QEAAPEAXI@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__flags$ = 72
??_ECScheduler@@QEAAPEAXI@Z PROC			; CScheduler::`vector deleting destructor', COMDAT
$LN6:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  0000d	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00016	8b 44 24 48	 mov	 eax, DWORD PTR __flags$[rsp]
  0001a	83 e0 02	 and	 eax, 2
  0001d	85 c0		 test	 eax, eax
  0001f	74 56		 je	 SHORT $LN2@vector
  00021	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??1CScheduler@@QEAA@XZ ; CScheduler::~CScheduler
  00028	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0002d	4c 8b 40 f8	 mov	 r8, QWORD PTR [rax-8]
  00031	ba 60 00 00 00	 mov	 edx, 96			; 00000060H
  00036	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0003b	e8 00 00 00 00	 call	 ??_M@YAXPEAX_K1P6AX0@Z@Z
  00040	90		 npad	 1
  00041	8b 44 24 48	 mov	 eax, DWORD PTR __flags$[rsp]
  00045	83 e0 01	 and	 eax, 1
  00048	85 c0		 test	 eax, eax
  0004a	74 20		 je	 SHORT $LN3@vector
  0004c	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00051	48 6b 40 f8 60	 imul	 rax, QWORD PTR [rax-8], 96 ; 00000060H
  00056	48 83 c0 08	 add	 rax, 8
  0005a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0005f	48 83 e9 08	 sub	 rcx, 8
  00063	48 8b d0	 mov	 rdx, rax
  00066	e8 00 00 00 00	 call	 ??_V@YAXPEAX_K@Z	; operator delete[]
  0006b	90		 npad	 1
$LN3@vector:
  0006c	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00071	48 83 e8 08	 sub	 rax, 8
  00075	eb 2b		 jmp	 SHORT $LN1@vector
$LN2@vector:
  00077	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0007c	e8 00 00 00 00	 call	 ??1CScheduler@@QEAA@XZ	; CScheduler::~CScheduler
  00081	90		 npad	 1
  00082	8b 44 24 48	 mov	 eax, DWORD PTR __flags$[rsp]
  00086	83 e0 01	 and	 eax, 1
  00089	85 c0		 test	 eax, eax
  0008b	74 10		 je	 SHORT $LN4@vector
  0008d	ba 60 00 00 00	 mov	 edx, 96			; 00000060H
  00092	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00097	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  0009c	90		 npad	 1
$LN4@vector:
  0009d	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
$LN1@vector:
  000a2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a6	c3		 ret	 0
??_ECScheduler@@QEAAPEAXI@Z ENDP			; CScheduler::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GCScheduler@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GCScheduler@@QEAAPEAXI@Z PROC			; CScheduler::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00012	e8 00 00 00 00	 call	 ??1CScheduler@@QEAA@XZ	; CScheduler::~CScheduler
  00017	8b 44 24 38	 mov	 eax, DWORD PTR __flags$[rsp]
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 0f		 je	 SHORT $LN2@scalar
  00022	ba 60 00 00 00	 mov	 edx, 96			; 00000060H
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
??_GCScheduler@@QEAAPEAXI@Z ENDP			; CScheduler::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comcore.h
;	COMDAT ?getGoal@CScheduler@@QEAAIXZ
_TEXT	SEGMENT
this$ = 8
?getGoal@CScheduler@@QEAAIXZ PROC			; CScheduler::getGoal, COMDAT

; 146  : 	inline TICKTIME_MILLISEC getGoal() { 	return m_nMillSecGoal;	}

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  0000d	c3		 ret	 0
?getGoal@CScheduler@@QEAAIXZ ENDP			; CScheduler::getGoal
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comcore.h
;	COMDAT ?setGoal@CScheduler@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?setGoal@CScheduler@@QEAAXXZ PROC			; CScheduler::setGoal, COMDAT

; 145  : 	inline void setGoal() {	m_nMillSecGoal += m_nMilliSecWait;	}

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  0000d	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  00012	03 41 50	 add	 eax, DWORD PTR [rcx+80]
  00015	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  0001a	89 41 58	 mov	 DWORD PTR [rcx+88], eax
  0001d	c3		 ret	 0
?setGoal@CScheduler@@QEAAXXZ ENDP			; CScheduler::setGoal
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comcore.h
;	COMDAT ?getMilliSecHalf@CScheduler@@QEAAHXZ
_TEXT	SEGMENT
this$ = 8
?getMilliSecHalf@CScheduler@@QEAAHXZ PROC		; CScheduler::getMilliSecHalf, COMDAT

; 144  : 	inline int getMilliSecHalf() { return m_nMillSecHalf; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	8b 40 54	 mov	 eax, DWORD PTR [rax+84]
  0000d	c3		 ret	 0
?getMilliSecHalf@CScheduler@@QEAAHXZ ENDP		; CScheduler::getMilliSecHalf
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comcore.h
;	COMDAT ?addTime@CScheduler@@QEAAHPEAUSTIntervalInfo@@@Z
_TEXT	SEGMENT
this$ = 48
pData$ = 56
?addTime@CScheduler@@QEAAHPEAUSTIntervalInfo@@@Z PROC	; CScheduler::addTime, COMDAT

; 142  : 	inline int addTime(STIntervalInfo *pData) { return m_pTimeList->add(pData); }

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR pData$[rsp]
  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00018	48 8b 48 48	 mov	 rcx, QWORD PTR [rax+72]
  0001c	e8 00 00 00 00	 call	 ?add@?$CMemList@USTIntervalInfo@@@@QEAAHPEAUSTIntervalInfo@@@Z ; CMemList<STIntervalInfo>::add
  00021	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00025	c3		 ret	 0
?addTime@CScheduler@@QEAAHPEAUSTIntervalInfo@@@Z ENDP	; CScheduler::addTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comcore.h
;	COMDAT ?deleteTime@CScheduler@@QEAA_NPEAUSTIntervalInfo@@@Z
_TEXT	SEGMENT
this$ = 48
pData$ = 56
?deleteTime@CScheduler@@QEAA_NPEAUSTIntervalInfo@@@Z PROC ; CScheduler::deleteTime, COMDAT

; 141  : 	inline bool deleteTime(STIntervalInfo *pData) { return m_pTimeList->del(pData); }

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR pData$[rsp]
  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00018	48 8b 48 48	 mov	 rcx, QWORD PTR [rax+72]
  0001c	e8 00 00 00 00	 call	 ?del@?$CMemList@USTIntervalInfo@@@@QEAA_NPEAUSTIntervalInfo@@@Z ; CMemList<STIntervalInfo>::del
  00021	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00025	c3		 ret	 0
?deleteTime@CScheduler@@QEAA_NPEAUSTIntervalInfo@@@Z ENDP ; CScheduler::deleteTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comcore.h
;	COMDAT ?timeNext@CScheduler@@QEAAPEAUSTIntervalInfo@@PEAH@Z
_TEXT	SEGMENT
this$ = 48
idx$ = 56
?timeNext@CScheduler@@QEAAPEAUSTIntervalInfo@@PEAH@Z PROC ; CScheduler::timeNext, COMDAT

; 140  : 	inline STIntervalInfo *timeNext(int *idx) { return m_pTimeList->getNext(idx); }

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR idx$[rsp]
  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00018	48 8b 48 48	 mov	 rcx, QWORD PTR [rax+72]
  0001c	e8 00 00 00 00	 call	 ?getNext@?$CMemList@USTIntervalInfo@@@@QEAAPEAUSTIntervalInfo@@PEAH@Z ; CMemList<STIntervalInfo>::getNext
  00021	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00025	c3		 ret	 0
?timeNext@CScheduler@@QEAAPEAUSTIntervalInfo@@PEAH@Z ENDP ; CScheduler::timeNext
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?quit@CScheduler@@QEAA_NXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
tv73 = 48
this$ = 80
?quit@CScheduler@@QEAA_NXZ PROC				; CScheduler::quit, COMDAT

; 358  : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 359  : 	m_cThread.quit();

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b c8	 mov	 rcx, rax
  00011	e8 00 00 00 00	 call	 ?quit@CComThread@@QEAA_NXZ ; CComThread::quit

; 360  : 	if (m_pTimeList) {

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0001b	48 83 78 48 00	 cmp	 QWORD PTR [rax+72], 0
  00020	74 4c		 je	 SHORT $LN2@quit

; 361  : 		delete m_pTimeList;

  00022	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00027	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  0002b	48 89 44 24 28	 mov	 QWORD PTR $T2[rsp], rax
  00030	48 8b 44 24 28	 mov	 rax, QWORD PTR $T2[rsp]
  00035	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax
  0003a	48 83 7c 24 20
	00		 cmp	 QWORD PTR $T1[rsp], 0
  00040	74 16		 je	 SHORT $LN4@quit
  00042	ba 01 00 00 00	 mov	 edx, 1
  00047	48 8b 4c 24 20	 mov	 rcx, QWORD PTR $T1[rsp]
  0004c	e8 00 00 00 00	 call	 ??_G?$CMemList@USTIntervalInfo@@@@QEAAPEAXI@Z
  00051	48 89 44 24 30	 mov	 QWORD PTR tv73[rsp], rax
  00056	eb 09		 jmp	 SHORT $LN5@quit
$LN4@quit:
  00058	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tv73[rsp], 0
$LN5@quit:

; 362  : 		m_pTimeList = NULL;

  00061	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00066	48 c7 40 48 00
	00 00 00	 mov	 QWORD PTR [rax+72], 0
$LN2@quit:

; 363  : 	}
; 364  : 	return true;

  0006e	b0 01		 mov	 al, 1

; 365  : }

  00070	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00074	c3		 ret	 0
?quit@CScheduler@@QEAA_NXZ ENDP				; CScheduler::quit
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?start@CScheduler@@QEAA_NXZ
_TEXT	SEGMENT
this$ = 64
?start@CScheduler@@QEAA_NXZ PROC			; CScheduler::start, COMDAT

; 344  : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 345  : 	if (m_cThread.bActive()) return true;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b c8	 mov	 rcx, rax
  00011	e8 00 00 00 00	 call	 ?bActive@CComThread@@QEAA_NXZ ; CComThread::bActive
  00016	0f b6 c0	 movzx	 eax, al
  00019	85 c0		 test	 eax, eax
  0001b	74 07		 je	 SHORT $LN2@start
  0001d	b0 01		 mov	 al, 1
  0001f	e9 82 00 00 00	 jmp	 $LN1@start
$LN2@start:

; 346  : 	if (!m_cThread.init(schedulerLoop, this, m_nMillSecHalf)) {

  00024	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00029	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00032	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00037	44 8b 49 54	 mov	 r9d, DWORD PTR [rcx+84]
  0003b	4c 8b 44 24 40	 mov	 r8, QWORD PTR this$[rsp]
  00040	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?schedulerLoop@@YAXPEAUSTThreadInfo@@@Z ; schedulerLoop
  00047	48 8b c8	 mov	 rcx, rax
  0004a	e8 00 00 00 00	 call	 ?init@CComThread@@QEAA_NP6AXPEAUSTThreadInfo@@@ZPEAXH2@Z ; CComThread::init
  0004f	0f b6 c0	 movzx	 eax, al
  00052	85 c0		 test	 eax, eax
  00054	75 1d		 jne	 SHORT $LN3@start

; 347  : 		comErrorPrint("m_cThread.init");

  00056	41 b8 5b 01 00
	00		 mov	 r8d, 347		; 0000015bH
  0005c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45522
  00063	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG45523
  0006a	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 348  : 		return false;

  0006f	32 c0		 xor	 al, al
  00071	eb 33		 jmp	 SHORT $LN1@start
$LN3@start:

; 349  : 	}
; 350  : 	if (!m_cThread.start()) {

  00073	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00078	48 8b c8	 mov	 rcx, rax
  0007b	e8 00 00 00 00	 call	 ?start@CComThread@@QEAA_NXZ ; CComThread::start
  00080	0f b6 c0	 movzx	 eax, al
  00083	85 c0		 test	 eax, eax
  00085	75 1d		 jne	 SHORT $LN4@start

; 351  : 		comErrorPrint("m_cThread.start");

  00087	41 b8 5f 01 00
	00		 mov	 r8d, 351		; 0000015fH
  0008d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45525
  00094	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG45526
  0009b	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 352  : 		return false;

  000a0	32 c0		 xor	 al, al
  000a2	eb 02		 jmp	 SHORT $LN1@start
$LN4@start:

; 353  : 	}
; 354  : 	return true;

  000a4	b0 01		 mov	 al, 1
$LN1@start:

; 355  : }

  000a6	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000aa	c3		 ret	 0
?start@CScheduler@@QEAA_NXZ ENDP			; CScheduler::start
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?init@CScheduler@@QEAA_NHHH@Z
_TEXT	SEGMENT
$T1 = 32
tv86 = 40
$T2 = 48
$T3 = 56
$T4 = 64
tv129 = 72
$T5 = 80
this$ = 112
nCount$ = 120
nMilliSecWait$ = 128
nIdx$ = 136
?init@CScheduler@@QEAA_NHHH@Z PROC			; CScheduler::init, COMDAT

; 332  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00017	48 c7 44 24 50
	fe ff ff ff	 mov	 QWORD PTR $T5[rsp], -2

; 333  : 	m_nMilliSecWait = nMilliSecWait;

  00020	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  00025	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR nMilliSecWait$[rsp]
  0002c	89 48 50	 mov	 DWORD PTR [rax+80], ecx

; 334  : 	m_nMillSecHalf = m_nMilliSecWait / 2;

  0002f	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  00034	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  00037	99		 cdq
  00038	2b c2		 sub	 eax, edx
  0003a	d1 f8		 sar	 eax, 1
  0003c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR this$[rsp]
  00041	89 41 54	 mov	 DWORD PTR [rcx+84], eax

; 335  : 	m_nMillSecGoal = CURRENT_TIME + m_nMilliSecWait;

  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetTickCount
  0004a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR this$[rsp]
  0004f	03 41 50	 add	 eax, DWORD PTR [rcx+80]
  00052	48 8b 4c 24 70	 mov	 rcx, QWORD PTR this$[rsp]
  00057	89 41 58	 mov	 DWORD PTR [rcx+88], eax

; 336  : 	m_pTimeList = new CMemList<STIntervalInfo>();

  0005a	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  0005f	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00064	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax
  00069	48 83 7c 24 20
	00		 cmp	 QWORD PTR $T1[rsp], 0
  0006f	74 20		 je	 SHORT $LN4@init
  00071	ba 30 00 00 00	 mov	 edx, 48			; 00000030H
  00076	48 8b 4c 24 20	 mov	 rcx, QWORD PTR $T1[rsp]
  0007b	e8 00 00 00 00	 call	 ?__autoclassinit2@?$CMemList@USTIntervalInfo@@@@QEAAX_K@Z
  00080	48 8b 4c 24 20	 mov	 rcx, QWORD PTR $T1[rsp]
  00085	e8 00 00 00 00	 call	 ??0?$CMemList@USTIntervalInfo@@@@QEAA@XZ ; CMemList<STIntervalInfo>::CMemList<STIntervalInfo>
  0008a	48 89 44 24 28	 mov	 QWORD PTR tv86[rsp], rax
  0008f	eb 09		 jmp	 SHORT $LN5@init
$LN4@init:
  00091	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR tv86[rsp], 0
$LN5@init:
  0009a	48 8b 44 24 28	 mov	 rax, QWORD PTR tv86[rsp]
  0009f	48 89 44 24 38	 mov	 QWORD PTR $T3[rsp], rax
  000a4	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  000a9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR $T3[rsp]
  000ae	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 337  : 	if (!m_pTimeList->alloc(nCount, eAlloc_Type_none)) { delete m_pTimeList; printf("has Failed!! m_pTimeList->alloc(%d)\n", nCount); return false; }

  000b2	45 33 c0	 xor	 r8d, r8d
  000b5	8b 54 24 78	 mov	 edx, DWORD PTR nCount$[rsp]
  000b9	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  000be	48 8b 48 48	 mov	 rcx, QWORD PTR [rax+72]
  000c2	e8 00 00 00 00	 call	 ?alloc@?$CMemList@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z ; CMemList<STIntervalInfo>::alloc
  000c7	85 c0		 test	 eax, eax
  000c9	75 53		 jne	 SHORT $LN2@init
  000cb	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  000d0	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  000d4	48 89 44 24 40	 mov	 QWORD PTR $T4[rsp], rax
  000d9	48 8b 44 24 40	 mov	 rax, QWORD PTR $T4[rsp]
  000de	48 89 44 24 30	 mov	 QWORD PTR $T2[rsp], rax
  000e3	48 83 7c 24 30
	00		 cmp	 QWORD PTR $T2[rsp], 0
  000e9	74 16		 je	 SHORT $LN6@init
  000eb	ba 01 00 00 00	 mov	 edx, 1
  000f0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR $T2[rsp]
  000f5	e8 00 00 00 00	 call	 ??_G?$CMemList@USTIntervalInfo@@@@QEAAPEAXI@Z
  000fa	48 89 44 24 48	 mov	 QWORD PTR tv129[rsp], rax
  000ff	eb 09		 jmp	 SHORT $LN7@init
$LN6@init:
  00101	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR tv129[rsp], 0
$LN7@init:
  0010a	8b 54 24 78	 mov	 edx, DWORD PTR nCount$[rsp]
  0010e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG45516
  00115	e8 00 00 00 00	 call	 printf
  0011a	32 c0		 xor	 al, al
  0011c	eb 16		 jmp	 SHORT $LN1@init
$LN2@init:

; 338  : 	m_cThread.setIdx(nIdx);

  0011e	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  00123	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR nIdx$[rsp]
  0012a	48 8b c8	 mov	 rcx, rax
  0012d	e8 00 00 00 00	 call	 ?setIdx@CComThread@@QEAAXH@Z ; CComThread::setIdx

; 339  : 	return true;

  00132	b0 01		 mov	 al, 1
$LN1@init:

; 340  : }

  00134	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00138	c3		 ret	 0
?init@CScheduler@@QEAA_NHHH@Z ENDP			; CScheduler::init
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv86 = 40
$T2 = 48
$T3 = 56
$T4 = 64
tv129 = 72
$T5 = 80
this$ = 112
nCount$ = 120
nMilliSecWait$ = 128
nIdx$ = 136
?dtor$0@?0??init@CScheduler@@QEAA_NHHH@Z@4HA PROC	; `CScheduler::init'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	ba 30 00 00 00	 mov	 edx, 48			; 00000030H
  0000e	48 8b 4d 20	 mov	 rcx, QWORD PTR $T1[rbp]
  00012	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5d		 pop	 rbp
  0001c	c3		 ret	 0
?dtor$0@?0??init@CScheduler@@QEAA_NHHH@Z@4HA ENDP	; `CScheduler::init'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv86 = 40
$T2 = 48
$T3 = 56
$T4 = 64
tv129 = 72
$T5 = 80
this$ = 112
nCount$ = 120
nMilliSecWait$ = 128
nIdx$ = 136
?dtor$0@?0??init@CScheduler@@QEAA_NHHH@Z@4HA PROC	; `CScheduler::init'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	ba 30 00 00 00	 mov	 edx, 48			; 00000030H
  0000e	48 8b 4d 20	 mov	 rcx, QWORD PTR $T1[rbp]
  00012	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5d		 pop	 rbp
  0001c	c3		 ret	 0
?dtor$0@?0??init@CScheduler@@QEAA_NHHH@Z@4HA ENDP	; `CScheduler::init'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?initConfig@CScheduler@@QEAA_NPEADH0@Z
_TEXT	SEGMENT
nCount$ = 32
$T1 = 40
tv133 = 48
$T2 = 56
$T3 = 64
$T4 = 72
tv144 = 80
$T5 = 88
szSect$ = 96
__$ArrayPad$ = 120
this$ = 144
pConfigFile$ = 152
i$ = 160
pSection$ = 168
?initConfig@CScheduler@@QEAA_NPEADH0@Z PROC		; CScheduler::initConfig, COMDAT

; 313  : {

$LN10:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  0001b	48 c7 44 24 58
	fe ff ff ff	 mov	 QWORD PTR $T5[rsp], -2
  00024	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002b	48 33 c4	 xor	 rax, rsp
  0002e	48 89 44 24 78	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 314  : 	TCHAR szSect[24];
; 315  : 	int nCount;
; 316  : 
; 317  : 	_stprintf(szSect, _T("%s_%d"), pSection, i);

  00033	44 8b 8c 24 a0
	00 00 00	 mov	 r9d, DWORD PTR i$[rsp]
  0003b	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR pSection$[rsp]
  00043	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45488
  0004a	48 8d 4c 24 60	 lea	 rcx, QWORD PTR szSect$[rsp]
  0004f	e8 00 00 00 00	 call	 sprintf

; 318  : 	nCount = GetPrivateProfileInt(szSect, _T("LIST_COUNT"), 0, pConfigFile);

  00054	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR pConfigFile$[rsp]
  0005c	45 33 c0	 xor	 r8d, r8d
  0005f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45489
  00066	48 8d 4c 24 60	 lea	 rcx, QWORD PTR szSect$[rsp]
  0006b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetPrivateProfileIntA
  00071	89 44 24 20	 mov	 DWORD PTR nCount$[rsp], eax

; 319  : 	if (!nCount) return false;

  00075	83 7c 24 20 00	 cmp	 DWORD PTR nCount$[rsp], 0
  0007a	75 07		 jne	 SHORT $LN2@initConfig
  0007c	32 c0		 xor	 al, al
  0007e	e9 31 01 00 00	 jmp	 $LN1@initConfig
$LN2@initConfig:

; 320  : 	m_nMilliSecWait = GetPrivateProfileInt(szSect, _T("TIME_WAIT"), -1, pConfigFile);

  00083	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR pConfigFile$[rsp]
  0008b	41 b8 ff ff ff
	ff		 mov	 r8d, -1
  00091	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45491
  00098	48 8d 4c 24 60	 lea	 rcx, QWORD PTR szSect$[rsp]
  0009d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetPrivateProfileIntA
  000a3	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  000ab	89 41 50	 mov	 DWORD PTR [rcx+80], eax

; 321  : 	m_nMillSecHalf = m_nMilliSecWait / 2;

  000ae	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000b6	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  000b9	99		 cdq
  000ba	2b c2		 sub	 eax, edx
  000bc	d1 f8		 sar	 eax, 1
  000be	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  000c6	89 41 54	 mov	 DWORD PTR [rcx+84], eax

; 322  : 	m_nMillSecGoal = CURRENT_TIME + m_nMilliSecWait;

  000c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetTickCount
  000cf	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  000d7	03 41 50	 add	 eax, DWORD PTR [rcx+80]
  000da	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  000e2	89 41 58	 mov	 DWORD PTR [rcx+88], eax

; 323  : 
; 324  : 	m_pTimeList = new CMemList<STIntervalInfo>();

  000e5	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  000ea	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  000ef	48 89 44 24 28	 mov	 QWORD PTR $T1[rsp], rax
  000f4	48 83 7c 24 28
	00		 cmp	 QWORD PTR $T1[rsp], 0
  000fa	74 20		 je	 SHORT $LN5@initConfig
  000fc	ba 30 00 00 00	 mov	 edx, 48			; 00000030H
  00101	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T1[rsp]
  00106	e8 00 00 00 00	 call	 ?__autoclassinit2@?$CMemList@USTIntervalInfo@@@@QEAAX_K@Z
  0010b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T1[rsp]
  00110	e8 00 00 00 00	 call	 ??0?$CMemList@USTIntervalInfo@@@@QEAA@XZ ; CMemList<STIntervalInfo>::CMemList<STIntervalInfo>
  00115	48 89 44 24 30	 mov	 QWORD PTR tv133[rsp], rax
  0011a	eb 09		 jmp	 SHORT $LN6@initConfig
$LN5@initConfig:
  0011c	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tv133[rsp], 0
$LN6@initConfig:
  00125	48 8b 44 24 30	 mov	 rax, QWORD PTR tv133[rsp]
  0012a	48 89 44 24 40	 mov	 QWORD PTR $T3[rsp], rax
  0012f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00137	48 8b 4c 24 40	 mov	 rcx, QWORD PTR $T3[rsp]
  0013c	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 325  : 	if (!m_pTimeList->alloc(nCount, eAlloc_Type_none)) { delete m_pTimeList; printf("has Failed!! m_pTimeList->alloc(%d)\n", nCount); return false; }

  00140	45 33 c0	 xor	 r8d, r8d
  00143	8b 54 24 20	 mov	 edx, DWORD PTR nCount$[rsp]
  00147	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0014f	48 8b 48 48	 mov	 rcx, QWORD PTR [rax+72]
  00153	e8 00 00 00 00	 call	 ?alloc@?$CMemList@USTIntervalInfo@@@@QEAAHHW4E_ALLOC_TYPE@@@Z ; CMemList<STIntervalInfo>::alloc
  00158	85 c0		 test	 eax, eax
  0015a	75 56		 jne	 SHORT $LN3@initConfig
  0015c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00164	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  00168	48 89 44 24 48	 mov	 QWORD PTR $T4[rsp], rax
  0016d	48 8b 44 24 48	 mov	 rax, QWORD PTR $T4[rsp]
  00172	48 89 44 24 38	 mov	 QWORD PTR $T2[rsp], rax
  00177	48 83 7c 24 38
	00		 cmp	 QWORD PTR $T2[rsp], 0
  0017d	74 16		 je	 SHORT $LN7@initConfig
  0017f	ba 01 00 00 00	 mov	 edx, 1
  00184	48 8b 4c 24 38	 mov	 rcx, QWORD PTR $T2[rsp]
  00189	e8 00 00 00 00	 call	 ??_G?$CMemList@USTIntervalInfo@@@@QEAAPEAXI@Z
  0018e	48 89 44 24 50	 mov	 QWORD PTR tv144[rsp], rax
  00193	eb 09		 jmp	 SHORT $LN8@initConfig
$LN7@initConfig:
  00195	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR tv144[rsp], 0
$LN8@initConfig:
  0019e	8b 54 24 20	 mov	 edx, DWORD PTR nCount$[rsp]
  001a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG45494
  001a9	e8 00 00 00 00	 call	 printf
  001ae	32 c0		 xor	 al, al
  001b0	eb 02		 jmp	 SHORT $LN1@initConfig
$LN3@initConfig:

; 326  : 
; 327  : 	return true;

  001b2	b0 01		 mov	 al, 1
$LN1@initConfig:

; 328  : 
; 329  : }

  001b4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001b9	48 33 cc	 xor	 rcx, rsp
  001bc	e8 00 00 00 00	 call	 __security_check_cookie
  001c1	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  001c8	c3		 ret	 0
?initConfig@CScheduler@@QEAA_NPEADH0@Z ENDP		; CScheduler::initConfig
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
nCount$ = 32
$T1 = 40
tv133 = 48
$T2 = 56
$T3 = 64
$T4 = 72
tv144 = 80
$T5 = 88
szSect$ = 96
__$ArrayPad$ = 120
this$ = 144
pConfigFile$ = 152
i$ = 160
pSection$ = 168
?dtor$0@?0??initConfig@CScheduler@@QEAA_NPEADH0@Z@4HA PROC ; `CScheduler::initConfig'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	ba 30 00 00 00	 mov	 edx, 48			; 00000030H
  0000e	48 8b 4d 28	 mov	 rcx, QWORD PTR $T1[rbp]
  00012	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5d		 pop	 rbp
  0001c	c3		 ret	 0
?dtor$0@?0??initConfig@CScheduler@@QEAA_NPEADH0@Z@4HA ENDP ; `CScheduler::initConfig'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
nCount$ = 32
$T1 = 40
tv133 = 48
$T2 = 56
$T3 = 64
$T4 = 72
tv144 = 80
$T5 = 88
szSect$ = 96
__$ArrayPad$ = 120
this$ = 144
pConfigFile$ = 152
i$ = 160
pSection$ = 168
?dtor$0@?0??initConfig@CScheduler@@QEAA_NPEADH0@Z@4HA PROC ; `CScheduler::initConfig'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	ba 30 00 00 00	 mov	 edx, 48			; 00000030H
  0000e	48 8b 4d 28	 mov	 rcx, QWORD PTR $T1[rbp]
  00012	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5d		 pop	 rbp
  0001c	c3		 ret	 0
?dtor$0@?0??initConfig@CScheduler@@QEAA_NPEADH0@Z@4HA ENDP ; `CScheduler::initConfig'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ??1CScheduler@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??1CScheduler@@QEAA@XZ PROC				; CScheduler::~CScheduler, COMDAT

; 308  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00009	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2

; 309  : 	quit();

  00012	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00017	e8 00 00 00 00	 call	 ?quit@CScheduler@@QEAA_NXZ ; CScheduler::quit
  0001c	90		 npad	 1

; 310  : }

  0001d	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 ??1CComThread@@QEAA@XZ	; CComThread::~CComThread
  0002a	90		 npad	 1
  0002b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0002f	c3		 ret	 0
??1CScheduler@@QEAA@XZ ENDP				; CScheduler::~CScheduler
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ??0CScheduler@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0CScheduler@@QEAA@XZ PROC				; CScheduler::CScheduler, COMDAT

; 302  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b c8	 mov	 rcx, rax
  00011	e8 00 00 00 00	 call	 ??0CComThread@@QEAA@XZ	; CComThread::CComThread

; 303  : 	m_pTimeList = NULL;

  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0001b	48 c7 40 48 00
	00 00 00	 mov	 QWORD PTR [rax+72], 0

; 304  : 	m_nMilliSecWait = -1;

  00023	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00028	c7 40 50 ff ff
	ff ff		 mov	 DWORD PTR [rax+80], -1

; 305  : 	m_nMillSecGoal = 0;

  0002f	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00034	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [rax+88], 0

; 306  : }

  0003b	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00040	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00044	c3		 ret	 0
??0CScheduler@@QEAA@XZ ENDP				; CScheduler::CScheduler
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?schedulerLoop@@YAXPEAUSTThreadInfo@@@Z
_TEXT	SEGMENT
pData$ = 32
pBasic$ = 40
diff$ = 48
cur$ = 52
idx$ = 56
__$ArrayPad$ = 64
p$ = 96
?schedulerLoop@@YAXPEAUSTThreadInfo@@@Z PROC		; schedulerLoop, COMDAT

; 368  : {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 369  : 	CScheduler *pBasic = (CScheduler *)p->pClass;

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  0001d	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00021	48 89 44 24 28	 mov	 QWORD PTR pBasic$[rsp], rax

; 370  : 	STIntervalInfo *pData;
; 371  : 	TICKTIME_MILLISEC cur = CURRENT_TIME;

  00026	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetTickCount
  0002c	89 44 24 34	 mov	 DWORD PTR cur$[rsp], eax

; 372  : 	int diff = pBasic->getGoal() - cur;

  00030	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pBasic$[rsp]
  00035	e8 00 00 00 00	 call	 ?getGoal@CScheduler@@QEAAIXZ ; CScheduler::getGoal
  0003a	2b 44 24 34	 sub	 eax, DWORD PTR cur$[rsp]
  0003e	89 44 24 30	 mov	 DWORD PTR diff$[rsp], eax

; 373  : 	
; 374  : 
; 375  : 	if (1 < diff) {

  00042	83 7c 24 30 01	 cmp	 DWORD PTR diff$[rsp], 1
  00047	7e 11		 jle	 SHORT $LN4@schedulerL

; 376  : 		p->millisecSleep = diff;

  00049	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  0004e	8b 4c 24 30	 mov	 ecx, DWORD PTR diff$[rsp]
  00052	89 48 30	 mov	 DWORD PTR [rax+48], ecx

; 377  : 		return;

  00055	e9 89 00 00 00	 jmp	 $LN1@schedulerL
$LN4@schedulerL:

; 378  : 	}
; 379  : 
; 380  : 
; 381  : 	int idx = 0;

  0005a	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR idx$[rsp], 0

; 382  : 	pData = (STIntervalInfo *)pBasic->timeNext(&idx);

  00062	48 8d 54 24 38	 lea	 rdx, QWORD PTR idx$[rsp]
  00067	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pBasic$[rsp]
  0006c	e8 00 00 00 00	 call	 ?timeNext@CScheduler@@QEAAPEAUSTIntervalInfo@@PEAH@Z ; CScheduler::timeNext
  00071	48 89 44 24 20	 mov	 QWORD PTR pData$[rsp], rax
$LN2@schedulerL:

; 383  : 	while (pData)

  00076	48 83 7c 24 20
	00		 cmp	 QWORD PTR pData$[rsp], 0
  0007c	74 49		 je	 SHORT $LN3@schedulerL

; 384  : 	{
; 385  : 		if (!pData->nFlag) {

  0007e	48 8b 44 24 20	 mov	 rax, QWORD PTR pData$[rsp]
  00083	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  00087	75 11		 jne	 SHORT $LN5@schedulerL

; 386  : 			pBasic->deleteTime(pData);

  00089	48 8b 54 24 20	 mov	 rdx, QWORD PTR pData$[rsp]
  0008e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pBasic$[rsp]
  00093	e8 00 00 00 00	 call	 ?deleteTime@CScheduler@@QEAA_NPEAUSTIntervalInfo@@@Z ; CScheduler::deleteTime

; 387  : 		}
; 388  : 		else 

  00098	eb 0d		 jmp	 SHORT $LN6@schedulerL
$LN5@schedulerL:

; 389  : 		{
; 390  : 			pData->pFunction(pData);

  0009a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pData$[rsp]
  0009f	48 8b 44 24 20	 mov	 rax, QWORD PTR pData$[rsp]
  000a4	ff 50 20	 call	 QWORD PTR [rax+32]
$LN6@schedulerL:

; 391  : 		}
; 392  : 
; 393  : 		idx++;

  000a7	8b 44 24 38	 mov	 eax, DWORD PTR idx$[rsp]
  000ab	ff c0		 inc	 eax
  000ad	89 44 24 38	 mov	 DWORD PTR idx$[rsp], eax

; 394  : 		pData = (STIntervalInfo *)pBasic->timeNext(&idx);

  000b1	48 8d 54 24 38	 lea	 rdx, QWORD PTR idx$[rsp]
  000b6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pBasic$[rsp]
  000bb	e8 00 00 00 00	 call	 ?timeNext@CScheduler@@QEAAPEAUSTIntervalInfo@@PEAH@Z ; CScheduler::timeNext
  000c0	48 89 44 24 20	 mov	 QWORD PTR pData$[rsp], rax

; 395  : 	}

  000c5	eb af		 jmp	 SHORT $LN2@schedulerL
$LN3@schedulerL:

; 396  : 	pBasic->setGoal();

  000c7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pBasic$[rsp]
  000cc	e8 00 00 00 00	 call	 ?setGoal@CScheduler@@QEAAXXZ ; CScheduler::setGoal

; 397  : 	p->millisecSleep = pBasic->getMilliSecHalf();

  000d1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pBasic$[rsp]
  000d6	e8 00 00 00 00	 call	 ?getMilliSecHalf@CScheduler@@QEAAHXZ ; CScheduler::getMilliSecHalf
  000db	48 8b 4c 24 60	 mov	 rcx, QWORD PTR p$[rsp]
  000e0	89 41 30	 mov	 DWORD PTR [rcx+48], eax
$LN1@schedulerL:

; 398  : }

  000e3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000e8	48 33 cc	 xor	 rcx, rsp
  000eb	e8 00 00 00 00	 call	 __security_check_cookie
  000f0	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f4	c3		 ret	 0
?schedulerLoop@@YAXPEAUSTThreadInfo@@@Z ENDP		; schedulerLoop
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_ECSTLogger@@QEAAPEAXI@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__flags$ = 72
??_ECSTLogger@@QEAAPEAXI@Z PROC				; CSTLogger::`vector deleting destructor', COMDAT
$LN6:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  0000d	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00016	8b 44 24 48	 mov	 eax, DWORD PTR __flags$[rsp]
  0001a	83 e0 02	 and	 eax, 2
  0001d	85 c0		 test	 eax, eax
  0001f	74 56		 je	 SHORT $LN2@vector
  00021	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??1CSTLogger@@QEAA@XZ ; CSTLogger::~CSTLogger
  00028	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0002d	4c 8b 40 f8	 mov	 r8, QWORD PTR [rax-8]
  00031	ba 58 00 00 00	 mov	 edx, 88			; 00000058H
  00036	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0003b	e8 00 00 00 00	 call	 ??_M@YAXPEAX_K1P6AX0@Z@Z
  00040	90		 npad	 1
  00041	8b 44 24 48	 mov	 eax, DWORD PTR __flags$[rsp]
  00045	83 e0 01	 and	 eax, 1
  00048	85 c0		 test	 eax, eax
  0004a	74 20		 je	 SHORT $LN3@vector
  0004c	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00051	48 6b 40 f8 58	 imul	 rax, QWORD PTR [rax-8], 88 ; 00000058H
  00056	48 83 c0 08	 add	 rax, 8
  0005a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0005f	48 83 e9 08	 sub	 rcx, 8
  00063	48 8b d0	 mov	 rdx, rax
  00066	e8 00 00 00 00	 call	 ??_V@YAXPEAX_K@Z	; operator delete[]
  0006b	90		 npad	 1
$LN3@vector:
  0006c	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00071	48 83 e8 08	 sub	 rax, 8
  00075	eb 2b		 jmp	 SHORT $LN1@vector
$LN2@vector:
  00077	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0007c	e8 00 00 00 00	 call	 ??1CSTLogger@@QEAA@XZ	; CSTLogger::~CSTLogger
  00081	90		 npad	 1
  00082	8b 44 24 48	 mov	 eax, DWORD PTR __flags$[rsp]
  00086	83 e0 01	 and	 eax, 1
  00089	85 c0		 test	 eax, eax
  0008b	74 10		 je	 SHORT $LN4@vector
  0008d	ba 58 00 00 00	 mov	 edx, 88			; 00000058H
  00092	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00097	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  0009c	90		 npad	 1
$LN4@vector:
  0009d	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
$LN1@vector:
  000a2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a6	c3		 ret	 0
??_ECSTLogger@@QEAAPEAXI@Z ENDP				; CSTLogger::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GCSTLogger@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GCSTLogger@@QEAAPEAXI@Z PROC				; CSTLogger::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00012	e8 00 00 00 00	 call	 ??1CSTLogger@@QEAA@XZ	; CSTLogger::~CSTLogger
  00017	8b 44 24 38	 mov	 eax, DWORD PTR __flags$[rsp]
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 0f		 je	 SHORT $LN2@scalar
  00022	ba 58 00 00 00	 mov	 edx, 88			; 00000058H
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
??_GCSTLogger@@QEAAPEAXI@Z ENDP				; CSTLogger::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?_init@CSTLogger@@AEAA_NH@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
tv78 = 48
tv130 = 56
$T3 = 64
$T4 = 72
$T5 = 80
this$ = 112
nCount$ = 120
?_init@CSTLogger@@AEAA_NH@Z PROC			; CSTLogger::_init, COMDAT

; 132  : bool CSTLogger::_init(int nCount) {

$LN11:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  0000d	48 c7 44 24 50
	fe ff ff ff	 mov	 QWORD PTR $T5[rsp], -2

; 133  : 	m_pLoggerList = new CTList<CLogger>();

  00016	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0001b	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00020	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax
  00025	48 83 7c 24 20
	00		 cmp	 QWORD PTR $T1[rsp], 0
  0002b	74 20		 je	 SHORT $LN5@init
  0002d	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00032	48 8b 4c 24 20	 mov	 rcx, QWORD PTR $T1[rsp]
  00037	e8 00 00 00 00	 call	 ?__autoclassinit2@?$CTList@VCLogger@@@@QEAAX_K@Z
  0003c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR $T1[rsp]
  00041	e8 00 00 00 00	 call	 ??0?$CTList@VCLogger@@@@QEAA@XZ ; CTList<CLogger>::CTList<CLogger>
  00046	48 89 44 24 30	 mov	 QWORD PTR tv78[rsp], rax
  0004b	eb 09		 jmp	 SHORT $LN6@init
$LN5@init:
  0004d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tv78[rsp], 0
$LN6@init:
  00056	48 8b 44 24 30	 mov	 rax, QWORD PTR tv78[rsp]
  0005b	48 89 44 24 40	 mov	 QWORD PTR $T3[rsp], rax
  00060	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  00065	48 8b 4c 24 40	 mov	 rcx, QWORD PTR $T3[rsp]
  0006a	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 134  : 	if (!m_pLoggerList->alloc(nCount, eAlloc_Type_none)) return false;

  0006e	45 33 c0	 xor	 r8d, r8d
  00071	8b 54 24 78	 mov	 edx, DWORD PTR nCount$[rsp]
  00075	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  0007a	48 8b 48 48	 mov	 rcx, QWORD PTR [rax+72]
  0007e	e8 00 00 00 00	 call	 ?alloc@?$CTList@VCLogger@@@@QEAAHHW4E_ALLOC_TYPE@@@Z ; CTList<CLogger>::alloc
  00083	85 c0		 test	 eax, eax
  00085	75 04		 jne	 SHORT $LN2@init
  00087	32 c0		 xor	 al, al
  00089	eb 7b		 jmp	 SHORT $LN1@init
$LN2@init:

; 135  : 	m_pComandList = new CQueueS();

  0008b	b9 60 00 00 00	 mov	 ecx, 96			; 00000060H
  00090	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00095	48 89 44 24 28	 mov	 QWORD PTR $T2[rsp], rax
  0009a	48 83 7c 24 28
	00		 cmp	 QWORD PTR $T2[rsp], 0
  000a0	74 20		 je	 SHORT $LN7@init
  000a2	ba 60 00 00 00	 mov	 edx, 96			; 00000060H
  000a7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T2[rsp]
  000ac	e8 00 00 00 00	 call	 ?__autoclassinit2@CQueueS@@QEAAX_K@Z
  000b1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T2[rsp]
  000b6	e8 00 00 00 00	 call	 ??0CQueueS@@QEAA@XZ	; CQueueS::CQueueS
  000bb	48 89 44 24 38	 mov	 QWORD PTR tv130[rsp], rax
  000c0	eb 09		 jmp	 SHORT $LN8@init
$LN7@init:
  000c2	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tv130[rsp], 0
$LN8@init:
  000cb	48 8b 44 24 38	 mov	 rax, QWORD PTR tv130[rsp]
  000d0	48 89 44 24 48	 mov	 QWORD PTR $T4[rsp], rax
  000d5	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  000da	48 8b 4c 24 48	 mov	 rcx, QWORD PTR $T4[rsp]
  000df	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx

; 136  : 	if (!m_pComandList->alloc(10, eAlloc_Type_none)) return false;

  000e3	45 33 c0	 xor	 r8d, r8d
  000e6	ba 0a 00 00 00	 mov	 edx, 10
  000eb	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  000f0	48 8b 48 50	 mov	 rcx, QWORD PTR [rax+80]
  000f4	e8 00 00 00 00	 call	 ?alloc@CQueueS@@QEAA_NHW4E_ALLOC_TYPE@@@Z ; CQueueS::alloc
  000f9	0f b6 c0	 movzx	 eax, al
  000fc	85 c0		 test	 eax, eax
  000fe	75 04		 jne	 SHORT $LN3@init
  00100	32 c0		 xor	 al, al
  00102	eb 02		 jmp	 SHORT $LN1@init
$LN3@init:

; 137  : 	return true;

  00104	b0 01		 mov	 al, 1
$LN1@init:

; 138  : }

  00106	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0010a	c3		 ret	 0
?_init@CSTLogger@@AEAA_NH@Z ENDP			; CSTLogger::_init
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
tv78 = 48
tv130 = 56
$T3 = 64
$T4 = 72
$T5 = 80
this$ = 112
nCount$ = 120
?dtor$0@?0??_init@CSTLogger@@AEAA_NH@Z@4HA PROC		; `CSTLogger::_init'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0000e	48 8b 4d 20	 mov	 rcx, QWORD PTR $T1[rbp]
  00012	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5d		 pop	 rbp
  0001c	c3		 ret	 0
?dtor$0@?0??_init@CSTLogger@@AEAA_NH@Z@4HA ENDP		; `CSTLogger::_init'::`1'::dtor$0
$T1 = 32
$T2 = 40
tv78 = 48
tv130 = 56
$T3 = 64
$T4 = 72
$T5 = 80
this$ = 112
nCount$ = 120
?dtor$1@?0??_init@CSTLogger@@AEAA_NH@Z@4HA PROC		; `CSTLogger::_init'::`1'::dtor$1
  0001d	40 55		 push	 rbp
  0001f	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00023	48 8b ea	 mov	 rbp, rdx
  00026	ba 60 00 00 00	 mov	 edx, 96			; 00000060H
  0002b	48 8b 4d 28	 mov	 rcx, QWORD PTR $T2[rbp]
  0002f	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5d		 pop	 rbp
  00039	c3		 ret	 0
?dtor$1@?0??_init@CSTLogger@@AEAA_NH@Z@4HA ENDP		; `CSTLogger::_init'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
tv78 = 48
tv130 = 56
$T3 = 64
$T4 = 72
$T5 = 80
this$ = 112
nCount$ = 120
?dtor$0@?0??_init@CSTLogger@@AEAA_NH@Z@4HA PROC		; `CSTLogger::_init'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0000e	48 8b 4d 20	 mov	 rcx, QWORD PTR $T1[rbp]
  00012	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5d		 pop	 rbp
  0001c	c3		 ret	 0
?dtor$0@?0??_init@CSTLogger@@AEAA_NH@Z@4HA ENDP		; `CSTLogger::_init'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
tv78 = 48
tv130 = 56
$T3 = 64
$T4 = 72
$T5 = 80
this$ = 112
nCount$ = 120
?dtor$1@?0??_init@CSTLogger@@AEAA_NH@Z@4HA PROC		; `CSTLogger::_init'::`1'::dtor$1
  0001d	40 55		 push	 rbp
  0001f	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00023	48 8b ea	 mov	 rbp, rdx
  00026	ba 60 00 00 00	 mov	 edx, 96			; 00000060H
  0002b	48 8b 4d 28	 mov	 rcx, QWORD PTR $T2[rbp]
  0002f	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5d		 pop	 rbp
  00039	c3		 ret	 0
?dtor$1@?0??_init@CSTLogger@@AEAA_NH@Z@4HA ENDP		; `CSTLogger::_init'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comcore.h
;	COMDAT ?pushCommand@CSTLogger@@QEAA_NPEAUSTLCommand@@@Z
_TEXT	SEGMENT
this$ = 48
p$ = 56
?pushCommand@CSTLogger@@QEAA_NPEAUSTLCommand@@@Z PROC	; CSTLogger::pushCommand, COMDAT

; 119  : 	inline bool pushCommand(STLCommand *p) {if(m_pComandList->push(p)) { m_cThread.sendSignal(); return true; } return false;}

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR p$[rsp]
  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00018	48 8b 48 50	 mov	 rcx, QWORD PTR [rax+80]
  0001c	e8 00 00 00 00	 call	 ?push@CQueueS@@QEAA_NPEAX@Z ; CQueueS::push
  00021	0f b6 c0	 movzx	 eax, al
  00024	85 c0		 test	 eax, eax
  00026	74 11		 je	 SHORT $LN2@pushComman
  00028	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0002d	48 8b c8	 mov	 rcx, rax
  00030	e8 00 00 00 00	 call	 ?sendSignal@CComThread@@QEAAXXZ ; CComThread::sendSignal
  00035	b0 01		 mov	 al, 1
  00037	eb 02		 jmp	 SHORT $LN1@pushComman
$LN2@pushComman:
  00039	32 c0		 xor	 al, al
$LN1@pushComman:
  0003b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003f	c3		 ret	 0
?pushCommand@CSTLogger@@QEAA_NPEAUSTLCommand@@@Z ENDP	; CSTLogger::pushCommand
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?porcLoggerDisable@CSTLogger@@QEAAXPEAVCLogger@@@Z
_TEXT	SEGMENT
nCount$ = 32
nLen$1 = 36
pData$ = 40
tv128 = 48
tv95 = 56
this$ = 80
pLogger$ = 88
?porcLoggerDisable@CSTLogger@@QEAAXPEAVCLogger@@@Z PROC	; CSTLogger::porcLoggerDisable, COMDAT

; 208  : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 209  : 	int nCount = 0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR nCount$[rsp], 0

; 210  : 	TCHAR *pData = pLogger->pop();

  00016	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pLogger$[rsp]
  0001b	e8 00 00 00 00	 call	 ?pop@CLogger@@QEAAPEADXZ ; CLogger::pop
  00020	48 89 44 24 28	 mov	 QWORD PTR pData$[rsp], rax
$LN2@porcLogger:

; 211  : 	while (pData)

  00025	48 83 7c 24 28
	00		 cmp	 QWORD PTR pData$[rsp], 0
  0002b	0f 84 84 00 00
	00		 je	 $LN3@porcLogger

; 212  : 	{
; 213  : 		int nLen = (int)_tcslen(pData) + 1;

  00031	48 8b 44 24 28	 mov	 rax, QWORD PTR pData$[rsp]
  00036	48 89 44 24 38	 mov	 QWORD PTR tv95[rsp], rax
  0003b	48 c7 44 24 30
	ff ff ff ff	 mov	 QWORD PTR tv128[rsp], -1
$LL5@porcLogger:
  00044	48 ff 44 24 30	 inc	 QWORD PTR tv128[rsp]
  00049	48 8b 44 24 38	 mov	 rax, QWORD PTR tv95[rsp]
  0004e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv128[rsp]
  00053	80 3c 08 00	 cmp	 BYTE PTR [rax+rcx], 0
  00057	75 eb		 jne	 SHORT $LL5@porcLogger
  00059	48 8b 44 24 30	 mov	 rax, QWORD PTR tv128[rsp]
  0005e	ff c0		 inc	 eax
  00060	89 44 24 24	 mov	 DWORD PTR nLen$1[rsp], eax

; 214  : 		pLogger->LogPrint(pData);

  00064	48 8b 54 24 28	 mov	 rdx, QWORD PTR pData$[rsp]
  00069	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pLogger$[rsp]
  0006e	e8 00 00 00 00	 call	 ?LogPrint@CLogger@@QEAAXPEAD@Z ; CLogger::LogPrint

; 215  : 		pLogger->addLogSize(nLen);

  00073	8b 54 24 24	 mov	 edx, DWORD PTR nLen$1[rsp]
  00077	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pLogger$[rsp]
  0007c	e8 00 00 00 00	 call	 ?addLogSize@CLogger@@QEAAXH@Z ; CLogger::addLogSize

; 216  : 		gs_pMMgr->delBuf(pData, nLen);

  00081	44 8b 44 24 24	 mov	 r8d, DWORD PTR nLen$1[rsp]
  00086	48 8b 54 24 28	 mov	 rdx, QWORD PTR pData$[rsp]
  0008b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  00092	e8 00 00 00 00	 call	 ?delBuf@CMemManager@@QEAAXPEADH@Z ; CMemManager::delBuf

; 217  : 		nCount++;

  00097	8b 44 24 20	 mov	 eax, DWORD PTR nCount$[rsp]
  0009b	ff c0		 inc	 eax
  0009d	89 44 24 20	 mov	 DWORD PTR nCount$[rsp], eax

; 218  : 		pData = pLogger->pop();

  000a1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pLogger$[rsp]
  000a6	e8 00 00 00 00	 call	 ?pop@CLogger@@QEAAPEADXZ ; CLogger::pop
  000ab	48 89 44 24 28	 mov	 QWORD PTR pData$[rsp], rax

; 219  : 
; 220  : 	}

  000b0	e9 70 ff ff ff	 jmp	 $LN2@porcLogger
$LN3@porcLogger:

; 221  : 	pLogger->disable();

  000b5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pLogger$[rsp]
  000ba	e8 00 00 00 00	 call	 ?disable@CLogger@@QEAAXXZ ; CLogger::disable

; 222  : 	m_pLoggerList->del(pLogger);

  000bf	48 8b 54 24 58	 mov	 rdx, QWORD PTR pLogger$[rsp]
  000c4	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  000c9	48 8b 48 48	 mov	 rcx, QWORD PTR [rax+72]
  000cd	e8 00 00 00 00	 call	 ?del@?$CTList@VCLogger@@@@QEAA_NPEAVCLogger@@@Z ; CTList<CLogger>::del

; 223  : 	pLogger->clearLogFlag(IS_LOG_ENABLE);

  000d2	ba 00 00 08 00	 mov	 edx, 524288		; 00080000H
  000d7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pLogger$[rsp]
  000dc	e8 00 00 00 00	 call	 ?clearLogFlag@CLogger@@QEAAXW4E_LOG_FLAG@@@Z ; CLogger::clearLogFlag

; 224  : 	printf("writeCount[%d] [%s] porcLoggerDisable\n", nCount, pLogger->getLogName());

  000e1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pLogger$[rsp]
  000e6	e8 00 00 00 00	 call	 ?getLogName@CLogger@@QEAAPEADXZ ; CLogger::getLogName
  000eb	4c 8b c0	 mov	 r8, rax
  000ee	8b 54 24 20	 mov	 edx, DWORD PTR nCount$[rsp]
  000f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG45430
  000f9	e8 00 00 00 00	 call	 printf

; 225  : }

  000fe	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00102	c3		 ret	 0
?porcLoggerDisable@CSTLogger@@QEAAXPEAVCLogger@@@Z ENDP	; CSTLogger::porcLoggerDisable
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?procLoggerEnable@CSTLogger@@QEAAXPEAVCLogger@@@Z
_TEXT	SEGMENT
this$ = 48
pLogger$ = 56
?procLoggerEnable@CSTLogger@@QEAAXPEAVCLogger@@@Z PROC	; CSTLogger::procLoggerEnable, COMDAT

; 176  : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 177  : 	if (pLogger->isLogFlag(IS_LOG_ENABLE)) {

  0000e	ba 00 00 08 00	 mov	 edx, 524288		; 00080000H
  00013	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pLogger$[rsp]
  00018	e8 00 00 00 00	 call	 ?isLogFlag@CLogger@@QEAA_NW4E_LOG_FLAG@@@Z ; CLogger::isLogFlag
  0001d	0f b6 c0	 movzx	 eax, al
  00020	85 c0		 test	 eax, eax
  00022	74 13		 je	 SHORT $LN2@procLogger

; 178  : 		printf("Logger is already Enabled!");

  00024	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG45407
  0002b	e8 00 00 00 00	 call	 printf

; 179  : 		return ;

  00030	e9 ed 00 00 00	 jmp	 $LN1@procLogger
  00035	eb 58		 jmp	 SHORT $LN3@procLogger
$LN2@procLogger:

; 180  : 	}
; 181  : 	else if (pLogger->isLogFlag(IS_LOG_OPEN)) {}

  00037	ba 00 00 04 00	 mov	 edx, 262144		; 00040000H
  0003c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pLogger$[rsp]
  00041	e8 00 00 00 00	 call	 ?isLogFlag@CLogger@@QEAA_NW4E_LOG_FLAG@@@Z ; CLogger::isLogFlag
  00046	0f b6 c0	 movzx	 eax, al
  00049	85 c0		 test	 eax, eax
  0004b	74 02		 je	 SHORT $LN4@procLogger
  0004d	eb 40		 jmp	 SHORT $LN5@procLogger
$LN4@procLogger:

; 182  : 	else if (pLogger->isLogFlag(IS_LOG_SET_COMPLETE)) {

  0004f	ba 00 00 02 00	 mov	 edx, 131072		; 00020000H
  00054	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pLogger$[rsp]
  00059	e8 00 00 00 00	 call	 ?isLogFlag@CLogger@@QEAA_NW4E_LOG_FLAG@@@Z ; CLogger::isLogFlag
  0005e	0f b6 c0	 movzx	 eax, al
  00061	85 c0		 test	 eax, eax
  00063	74 0c		 je	 SHORT $LN6@procLogger

; 183  : 		pLogger->OpenLogger();

  00065	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pLogger$[rsp]
  0006a	e8 00 00 00 00	 call	 ?OpenLogger@CLogger@@QEAAXXZ ; CLogger::OpenLogger

; 184  : 	}
; 185  : 	else {

  0006f	eb 1e		 jmp	 SHORT $LN7@procLogger
$LN6@procLogger:

; 186  : 		comErrorPrint("Logger has not Initialized!");

  00071	41 b8 ba 00 00
	00		 mov	 r8d, 186		; 000000baH
  00077	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45412
  0007e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG45413
  00085	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 187  : 		return ;

  0008a	e9 93 00 00 00	 jmp	 $LN1@procLogger
$LN7@procLogger:
$LN5@procLogger:
$LN3@procLogger:

; 188  : 	}
; 189  : 
; 190  : 	// input
; 191  : 	if (m_pLoggerList->IsExist(pLogger)) {

  0008f	48 8b 54 24 38	 mov	 rdx, QWORD PTR pLogger$[rsp]
  00094	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00099	48 8b 48 48	 mov	 rcx, QWORD PTR [rax+72]
  0009d	e8 00 00 00 00	 call	 ?IsExist@?$CTList@VCLogger@@@@QEAA_NPEAVCLogger@@@Z ; CTList<CLogger>::IsExist
  000a2	0f b6 c0	 movzx	 eax, al
  000a5	85 c0		 test	 eax, eax
  000a7	74 10		 je	 SHORT $LN8@procLogger

; 192  : 		printf("Logger already exist!\n");

  000a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG45416
  000b0	e8 00 00 00 00	 call	 printf

; 193  : 		return;

  000b5	eb 6b		 jmp	 SHORT $LN1@procLogger

; 194  : 	}
; 195  : 	else {

  000b7	eb 41		 jmp	 SHORT $LN9@procLogger
$LN8@procLogger:

; 196  : 		pLogger->setCondition(&m_cThread.m_stInfo.cThreadCond);

  000b9	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  000be	48 83 c0 10	 add	 rax, 16
  000c2	48 8b d0	 mov	 rdx, rax
  000c5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pLogger$[rsp]
  000ca	e8 00 00 00 00	 call	 ?setCondition@CLogger@@QEAAXPEAVcondition@win32@common@@@Z ; CLogger::setCondition

; 197  : 		if (!m_pLoggerList->push_back(pLogger)) {

  000cf	45 33 c0	 xor	 r8d, r8d
  000d2	48 8b 54 24 38	 mov	 rdx, QWORD PTR pLogger$[rsp]
  000d7	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  000dc	48 8b 48 48	 mov	 rcx, QWORD PTR [rax+72]
  000e0	e8 00 00 00 00	 call	 ?push_back@?$CTList@VCLogger@@@@QEAA_NPEAVCLogger@@PEAH@Z ; CTList<CLogger>::push_back
  000e5	0f b6 c0	 movzx	 eax, al
  000e8	85 c0		 test	 eax, eax
  000ea	75 0e		 jne	 SHORT $LN10@procLogger

; 198  : 			printf("m_pLoggerList->push_back failed!\n");

  000ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG45418
  000f3	e8 00 00 00 00	 call	 printf

; 199  : 			return;

  000f8	eb 28		 jmp	 SHORT $LN1@procLogger
$LN10@procLogger:
$LN9@procLogger:

; 200  : 		}
; 201  : 	}
; 202  : 	pLogger->setLogFlag(IS_LOG_ENABLE);

  000fa	ba 00 00 08 00	 mov	 edx, 524288		; 00080000H
  000ff	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pLogger$[rsp]
  00104	e8 00 00 00 00	 call	 ?setLogFlag@CLogger@@QEAAXW4E_LOG_FLAG@@@Z ; CLogger::setLogFlag

; 203  : 	printf("[%s] procLoggerEnable\n", pLogger->getLogName());

  00109	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pLogger$[rsp]
  0010e	e8 00 00 00 00	 call	 ?getLogName@CLogger@@QEAAPEADXZ ; CLogger::getLogName
  00113	48 8b d0	 mov	 rdx, rax
  00116	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG45419
  0011d	e8 00 00 00 00	 call	 printf
$LN1@procLogger:

; 204  : 
; 205  : }

  00122	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00126	c3		 ret	 0
?procLoggerEnable@CSTLogger@@QEAAXPEAVCLogger@@@Z ENDP	; CSTLogger::procLoggerEnable
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?TimeProc@CSTLogger@@QEAAXXZ
_TEXT	SEGMENT
nFlag$ = 32
pLogger$1 = 40
$T2 = 48
idx$3 = 56
ltm$ = 64
__$ArrayPad$ = 176
this$ = 208
?TimeProc@CSTLogger@@QEAAXXZ PROC			; CSTLogger::TimeProc, COMDAT

; 270  : {

$LN10:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  0000c	48 c7 44 24 30
	fe ff ff ff	 mov	 QWORD PTR $T2[rsp], -2
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 271  : 	CDateTime	ltm;

  00027	45 33 c0	 xor	 r8d, r8d
  0002a	ba 01 00 00 00	 mov	 edx, 1
  0002f	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ltm$[rsp]
  00034	e8 00 00 00 00	 call	 ??0CDateTime@@QEAA@W4DT_TYPE@@W4TZ_TYPE@@@Z ; CDateTime::CDateTime
  00039	90		 npad	 1

; 272  : 	int nFlag = 0;

  0003a	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR nFlag$[rsp], 0

; 273  : 	gs_today_time.second = ltm.Sec();

  00042	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ltm$[rsp]
  00047	e8 00 00 00 00	 call	 ?Sec@CDateTime@@QEAAHXZ	; CDateTime::Sec
  0004c	89 05 14 00 00
	00		 mov	 DWORD PTR ?gs_today_time@@3USTTodayTime@@A+20, eax

; 274  : 	if (ltm.Minute() != gs_today_time.minute) {

  00052	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ltm$[rsp]
  00057	e8 00 00 00 00	 call	 ?Minute@CDateTime@@QEAAHXZ ; CDateTime::Minute
  0005c	3b 05 10 00 00
	00		 cmp	 eax, DWORD PTR ?gs_today_time@@3USTTodayTime@@A+16
  00062	74 1b		 je	 SHORT $LN4@TimeProc

; 275  : 		gs_today_time.minute = ltm.Minute();

  00064	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ltm$[rsp]
  00069	e8 00 00 00 00	 call	 ?Minute@CDateTime@@QEAAHXZ ; CDateTime::Minute
  0006e	89 05 10 00 00
	00		 mov	 DWORD PTR ?gs_today_time@@3USTTodayTime@@A+16, eax

; 276  : 		nFlag |= LOG_FLAG_MINCHANGE;

  00074	8b 44 24 20	 mov	 eax, DWORD PTR nFlag$[rsp]
  00078	83 c8 04	 or	 eax, 4
  0007b	89 44 24 20	 mov	 DWORD PTR nFlag$[rsp], eax
$LN4@TimeProc:

; 277  : 	}
; 278  : 	if (ltm.Hour() != gs_today_time.hour) {

  0007f	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ltm$[rsp]
  00084	e8 00 00 00 00	 call	 ?Hour@CDateTime@@QEAAHXZ ; CDateTime::Hour
  00089	3b 05 0c 00 00
	00		 cmp	 eax, DWORD PTR ?gs_today_time@@3USTTodayTime@@A+12
  0008f	74 1b		 je	 SHORT $LN5@TimeProc

; 279  : 		gs_today_time.hour = ltm.Hour();

  00091	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ltm$[rsp]
  00096	e8 00 00 00 00	 call	 ?Hour@CDateTime@@QEAAHXZ ; CDateTime::Hour
  0009b	89 05 0c 00 00
	00		 mov	 DWORD PTR ?gs_today_time@@3USTTodayTime@@A+12, eax

; 280  : 		nFlag |= LOG_FLAG_HOURCHANGE;

  000a1	8b 44 24 20	 mov	 eax, DWORD PTR nFlag$[rsp]
  000a5	83 c8 02	 or	 eax, 2
  000a8	89 44 24 20	 mov	 DWORD PTR nFlag$[rsp], eax
$LN5@TimeProc:

; 281  : 	}
; 282  : 	if (ltm.Mday() != gs_today_time.mday) { // 1. Day Change 

  000ac	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ltm$[rsp]
  000b1	e8 00 00 00 00	 call	 ?Mday@CDateTime@@QEAAHXZ ; CDateTime::Mday
  000b6	3b 05 08 00 00
	00		 cmp	 eax, DWORD PTR ?gs_today_time@@3USTTodayTime@@A+8
  000bc	74 56		 je	 SHORT $LN6@TimeProc

; 283  : 		nFlag |= LOG_FLAG_DAYCHANGE;

  000be	8b 44 24 20	 mov	 eax, DWORD PTR nFlag$[rsp]
  000c2	83 c8 01	 or	 eax, 1
  000c5	89 44 24 20	 mov	 DWORD PTR nFlag$[rsp], eax

; 284  : 		gs_today_time.date  = _ttoi(ltm.DateString(0));

  000c9	33 d2		 xor	 edx, edx
  000cb	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ltm$[rsp]
  000d0	e8 00 00 00 00	 call	 ?DateString@CDateTime@@QEAAPEBDD@Z ; CDateTime::DateString
  000d5	48 8b c8	 mov	 rcx, rax
  000d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  000de	89 05 18 00 00
	00		 mov	 DWORD PTR ?gs_today_time@@3USTTodayTime@@A+24, eax

; 285  : 		gs_today_time.year	= ltm.Year();

  000e4	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ltm$[rsp]
  000e9	e8 00 00 00 00	 call	 ?Year@CDateTime@@QEAAHXZ ; CDateTime::Year
  000ee	89 05 00 00 00
	00		 mov	 DWORD PTR ?gs_today_time@@3USTTodayTime@@A, eax

; 286  : 		gs_today_time.month	= ltm.Month();

  000f4	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ltm$[rsp]
  000f9	e8 00 00 00 00	 call	 ?Month@CDateTime@@QEAAHXZ ; CDateTime::Month
  000fe	89 05 04 00 00
	00		 mov	 DWORD PTR ?gs_today_time@@3USTTodayTime@@A+4, eax

; 287  : 		gs_today_time.mday	= ltm.Mday();

  00104	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ltm$[rsp]
  00109	e8 00 00 00 00	 call	 ?Mday@CDateTime@@QEAAHXZ ; CDateTime::Mday
  0010e	89 05 08 00 00
	00		 mov	 DWORD PTR ?gs_today_time@@3USTTodayTime@@A+8, eax
$LN6@TimeProc:

; 288  : 	}
; 289  : 
; 290  : 	if (nFlag) {

  00114	83 7c 24 20 00	 cmp	 DWORD PTR nFlag$[rsp], 0
  00119	74 60		 je	 SHORT $LN7@TimeProc

; 291  : 		int idx = 0;

  0011b	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR idx$3[rsp], 0

; 292  : 		CLogger *pLogger = m_pLoggerList->getNext(&idx);

  00123	48 8d 54 24 38	 lea	 rdx, QWORD PTR idx$3[rsp]
  00128	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00130	48 8b 48 48	 mov	 rcx, QWORD PTR [rax+72]
  00134	e8 00 00 00 00	 call	 ?getNext@?$CTList@VCLogger@@@@QEAAPEAVCLogger@@PEAH@Z ; CTList<CLogger>::getNext
  00139	48 89 44 24 28	 mov	 QWORD PTR pLogger$1[rsp], rax
$LN2@TimeProc:

; 293  : 		while (pLogger) {

  0013e	48 83 7c 24 28
	00		 cmp	 QWORD PTR pLogger$1[rsp], 0
  00144	74 35		 je	 SHORT $LN7@TimeProc

; 294  : 			pLogger->checkChangeProc(nFlag);

  00146	8b 54 24 20	 mov	 edx, DWORD PTR nFlag$[rsp]
  0014a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pLogger$1[rsp]
  0014f	e8 00 00 00 00	 call	 ?checkChangeProc@CLogger@@QEAAXH@Z ; CLogger::checkChangeProc

; 295  : 			idx++;

  00154	8b 44 24 38	 mov	 eax, DWORD PTR idx$3[rsp]
  00158	ff c0		 inc	 eax
  0015a	89 44 24 38	 mov	 DWORD PTR idx$3[rsp], eax

; 296  : 			pLogger = m_pLoggerList->getNext(&idx);

  0015e	48 8d 54 24 38	 lea	 rdx, QWORD PTR idx$3[rsp]
  00163	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0016b	48 8b 48 48	 mov	 rcx, QWORD PTR [rax+72]
  0016f	e8 00 00 00 00	 call	 ?getNext@?$CTList@VCLogger@@@@QEAAPEAVCLogger@@PEAH@Z ; CTList<CLogger>::getNext
  00174	48 89 44 24 28	 mov	 QWORD PTR pLogger$1[rsp], rax

; 297  : 		}

  00179	eb c3		 jmp	 SHORT $LN2@TimeProc
$LN7@TimeProc:

; 298  : 	}
; 299  : }

  0017b	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ltm$[rsp]
  00180	e8 00 00 00 00	 call	 ??1CDateTime@@QEAA@XZ	; CDateTime::~CDateTime
  00185	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0018d	48 33 cc	 xor	 rcx, rsp
  00190	e8 00 00 00 00	 call	 __security_check_cookie
  00195	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  0019c	c3		 ret	 0
?TimeProc@CSTLogger@@QEAAXXZ ENDP			; CSTLogger::TimeProc
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
nFlag$ = 32
pLogger$1 = 40
$T2 = 48
idx$3 = 56
ltm$ = 64
__$ArrayPad$ = 176
this$ = 208
?dtor$0@?0??TimeProc@CSTLogger@@QEAAXXZ@4HA PROC	; `CSTLogger::TimeProc'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 4d 40	 lea	 rcx, QWORD PTR ltm$[rbp]
  0000d	e8 00 00 00 00	 call	 ??1CDateTime@@QEAA@XZ	; CDateTime::~CDateTime
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$0@?0??TimeProc@CSTLogger@@QEAAXXZ@4HA ENDP	; `CSTLogger::TimeProc'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
nFlag$ = 32
pLogger$1 = 40
$T2 = 48
idx$3 = 56
ltm$ = 64
__$ArrayPad$ = 176
this$ = 208
?dtor$0@?0??TimeProc@CSTLogger@@QEAAXXZ@4HA PROC	; `CSTLogger::TimeProc'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 4d 40	 lea	 rcx, QWORD PTR ltm$[rbp]
  0000d	e8 00 00 00 00	 call	 ??1CDateTime@@QEAA@XZ	; CDateTime::~CDateTime
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5d		 pop	 rbp
  00017	c3		 ret	 0
?dtor$0@?0??TimeProc@CSTLogger@@QEAAXXZ@4HA ENDP	; `CSTLogger::TimeProc'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?GetQueue@CSTLogger@@QEAAXXZ
_TEXT	SEGMENT
pLogger$ = 32
nLen$1 = 40
pData$ = 48
tv94 = 56
tv93 = 64
idx$ = 72
__$ArrayPad$ = 80
this$ = 112
?GetQueue@CSTLogger@@QEAAXXZ PROC			; CSTLogger::GetQueue, COMDAT

; 239  : {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 240  : 	int idx=0;

  00018	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR idx$[rsp], 0

; 241  : 	TCHAR *pData;
; 242  : 	CLogger *pLogger = m_pLoggerList->getNext(&idx);

  00020	48 8d 54 24 48	 lea	 rdx, QWORD PTR idx$[rsp]
  00025	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  0002a	48 8b 48 48	 mov	 rcx, QWORD PTR [rax+72]
  0002e	e8 00 00 00 00	 call	 ?getNext@?$CTList@VCLogger@@@@QEAAPEAVCLogger@@PEAH@Z ; CTList<CLogger>::getNext
  00033	48 89 44 24 20	 mov	 QWORD PTR pLogger$[rsp], rax
$LN2@GetQueue:

; 243  : 	while (pLogger) {

  00038	48 83 7c 24 20
	00		 cmp	 QWORD PTR pLogger$[rsp], 0
  0003e	0f 84 b5 00 00
	00		 je	 $LN3@GetQueue

; 244  : 
; 245  : 		pData = pLogger->pop();

  00044	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pLogger$[rsp]
  00049	e8 00 00 00 00	 call	 ?pop@CLogger@@QEAAPEADXZ ; CLogger::pop
  0004e	48 89 44 24 30	 mov	 QWORD PTR pData$[rsp], rax
$LN4@GetQueue:

; 246  : 		while (pData)

  00053	48 83 7c 24 30
	00		 cmp	 QWORD PTR pData$[rsp], 0
  00059	74 77		 je	 SHORT $LN5@GetQueue

; 247  : 		{
; 248  : 			int nLen = (int)_tcslen(pData) + 1;

  0005b	48 8b 44 24 30	 mov	 rax, QWORD PTR pData$[rsp]
  00060	48 89 44 24 40	 mov	 QWORD PTR tv93[rsp], rax
  00065	48 c7 44 24 38
	ff ff ff ff	 mov	 QWORD PTR tv94[rsp], -1
$LL7@GetQueue:
  0006e	48 ff 44 24 38	 inc	 QWORD PTR tv94[rsp]
  00073	48 8b 44 24 40	 mov	 rax, QWORD PTR tv93[rsp]
  00078	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv94[rsp]
  0007d	80 3c 08 00	 cmp	 BYTE PTR [rax+rcx], 0
  00081	75 eb		 jne	 SHORT $LL7@GetQueue
  00083	48 8b 44 24 38	 mov	 rax, QWORD PTR tv94[rsp]
  00088	ff c0		 inc	 eax
  0008a	89 44 24 28	 mov	 DWORD PTR nLen$1[rsp], eax

; 249  : 			pLogger->LogPrint(pData);

  0008e	48 8b 54 24 30	 mov	 rdx, QWORD PTR pData$[rsp]
  00093	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pLogger$[rsp]
  00098	e8 00 00 00 00	 call	 ?LogPrint@CLogger@@QEAAXPEAD@Z ; CLogger::LogPrint

; 250  : 			pLogger->addLogSize(nLen);

  0009d	8b 54 24 28	 mov	 edx, DWORD PTR nLen$1[rsp]
  000a1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pLogger$[rsp]
  000a6	e8 00 00 00 00	 call	 ?addLogSize@CLogger@@QEAAXH@Z ; CLogger::addLogSize

; 251  : 			gs_pMMgr->delBuf(pData, nLen);

  000ab	44 8b 44 24 28	 mov	 r8d, DWORD PTR nLen$1[rsp]
  000b0	48 8b 54 24 30	 mov	 rdx, QWORD PTR pData$[rsp]
  000b5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  000bc	e8 00 00 00 00	 call	 ?delBuf@CMemManager@@QEAAXPEADH@Z ; CMemManager::delBuf

; 252  : 			pData = pLogger->pop();

  000c1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pLogger$[rsp]
  000c6	e8 00 00 00 00	 call	 ?pop@CLogger@@QEAAPEADXZ ; CLogger::pop
  000cb	48 89 44 24 30	 mov	 QWORD PTR pData$[rsp], rax

; 253  : 
; 254  : 		}

  000d0	eb 81		 jmp	 SHORT $LN4@GetQueue
$LN5@GetQueue:

; 255  : 		idx++;

  000d2	8b 44 24 48	 mov	 eax, DWORD PTR idx$[rsp]
  000d6	ff c0		 inc	 eax
  000d8	89 44 24 48	 mov	 DWORD PTR idx$[rsp], eax

; 256  : 		pLogger = m_pLoggerList->getNext(&idx);

  000dc	48 8d 54 24 48	 lea	 rdx, QWORD PTR idx$[rsp]
  000e1	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  000e6	48 8b 48 48	 mov	 rcx, QWORD PTR [rax+72]
  000ea	e8 00 00 00 00	 call	 ?getNext@?$CTList@VCLogger@@@@QEAAPEAVCLogger@@PEAH@Z ; CTList<CLogger>::getNext
  000ef	48 89 44 24 20	 mov	 QWORD PTR pLogger$[rsp], rax

; 257  : 	}

  000f4	e9 3f ff ff ff	 jmp	 $LN2@GetQueue
$LN3@GetQueue:

; 258  : }

  000f9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000fe	48 33 cc	 xor	 rcx, rsp
  00101	e8 00 00 00 00	 call	 __security_check_cookie
  00106	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0010a	c3		 ret	 0
?GetQueue@CSTLogger@@QEAAXXZ ENDP			; CSTLogger::GetQueue
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?IsCommand@CSTLogger@@QEAA_NXZ
_TEXT	SEGMENT
bRes$ = 32
nSTLSize$ = 36
pCommand$ = 40
this$ = 64
?IsCommand@CSTLogger@@QEAA_NXZ PROC			; CSTLogger::IsCommand, COMDAT

; 156  : {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 157  : 	bool bRes = false;

  00009	c6 44 24 20 00	 mov	 BYTE PTR bRes$[rsp], 0

; 158  : 	STLCommand *pCommand = (STLCommand *)m_pComandList->pop();

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00013	48 8b 48 50	 mov	 rcx, QWORD PTR [rax+80]
  00017	e8 00 00 00 00	 call	 ?pop@CQueueS@@QEAAPEAXXZ ; CQueueS::pop
  0001c	48 89 44 24 28	 mov	 QWORD PTR pCommand$[rsp], rax

; 159  : 	int nSTLSize = sizeof(STLCommand);

  00021	c7 44 24 24 10
	00 00 00	 mov	 DWORD PTR nSTLSize$[rsp], 16
$LN2@IsCommand:

; 160  : 	while (pCommand) {

  00029	48 83 7c 24 28
	00		 cmp	 QWORD PTR pCommand$[rsp], 0
  0002f	74 6c		 je	 SHORT $LN3@IsCommand

; 161  : 		bRes = true;

  00031	c6 44 24 20 01	 mov	 BYTE PTR bRes$[rsp], 1

; 162  : 		if (pCommand->nCommandCode == 1) { // enable

  00036	48 8b 44 24 28	 mov	 rax, QWORD PTR pCommand$[rsp]
  0003b	83 38 01	 cmp	 DWORD PTR [rax], 1
  0003e	75 15		 jne	 SHORT $LN4@IsCommand

; 163  : 			procLoggerEnable((CLogger *)pCommand->p);

  00040	48 8b 44 24 28	 mov	 rax, QWORD PTR pCommand$[rsp]
  00045	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00049	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0004e	e8 00 00 00 00	 call	 ?procLoggerEnable@CSTLogger@@QEAAXPEAVCLogger@@@Z ; CSTLogger::procLoggerEnable
  00053	eb 1d		 jmp	 SHORT $LN5@IsCommand
$LN4@IsCommand:

; 164  : 		}
; 165  : 		else if (pCommand->nCommandCode == 2) { // 

  00055	48 8b 44 24 28	 mov	 rax, QWORD PTR pCommand$[rsp]
  0005a	83 38 02	 cmp	 DWORD PTR [rax], 2
  0005d	75 13		 jne	 SHORT $LN6@IsCommand

; 166  : 			porcLoggerDisable((CLogger *)pCommand->p);

  0005f	48 8b 44 24 28	 mov	 rax, QWORD PTR pCommand$[rsp]
  00064	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00068	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0006d	e8 00 00 00 00	 call	 ?porcLoggerDisable@CSTLogger@@QEAAXPEAVCLogger@@@Z ; CSTLogger::porcLoggerDisable
$LN6@IsCommand:
$LN5@IsCommand:

; 167  : 		}
; 168  : 		gs_pMMgr->delBuf((char *)pCommand, nSTLSize);

  00072	44 8b 44 24 24	 mov	 r8d, DWORD PTR nSTLSize$[rsp]
  00077	48 8b 54 24 28	 mov	 rdx, QWORD PTR pCommand$[rsp]
  0007c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  00083	e8 00 00 00 00	 call	 ?delBuf@CMemManager@@QEAAXPEADH@Z ; CMemManager::delBuf

; 169  : 		pCommand = (STLCommand *)m_pComandList->pop();

  00088	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0008d	48 8b 48 50	 mov	 rcx, QWORD PTR [rax+80]
  00091	e8 00 00 00 00	 call	 ?pop@CQueueS@@QEAAPEAXXZ ; CQueueS::pop
  00096	48 89 44 24 28	 mov	 QWORD PTR pCommand$[rsp], rax

; 170  : 	}

  0009b	eb 8c		 jmp	 SHORT $LN2@IsCommand
$LN3@IsCommand:

; 171  : 
; 172  : 	return false;

  0009d	32 c0		 xor	 al, al

; 173  : }

  0009f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a3	c3		 ret	 0
?IsCommand@CSTLogger@@QEAA_NXZ ENDP			; CSTLogger::IsCommand
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?quit@CSTLogger@@QEAA_NXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
tv73 = 48
this$ = 80
?quit@CSTLogger@@QEAA_NXZ PROC				; CSTLogger::quit, COMDAT

; 228  : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 229  : 	m_cThread.quit();

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b c8	 mov	 rcx, rax
  00011	e8 00 00 00 00	 call	 ?quit@CComThread@@QEAA_NXZ ; CComThread::quit

; 230  : 	if (m_pLoggerList) {

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0001b	48 83 78 48 00	 cmp	 QWORD PTR [rax+72], 0
  00020	74 4c		 je	 SHORT $LN2@quit

; 231  : 		delete m_pLoggerList;

  00022	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00027	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  0002b	48 89 44 24 28	 mov	 QWORD PTR $T2[rsp], rax
  00030	48 8b 44 24 28	 mov	 rax, QWORD PTR $T2[rsp]
  00035	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax
  0003a	48 83 7c 24 20
	00		 cmp	 QWORD PTR $T1[rsp], 0
  00040	74 16		 je	 SHORT $LN4@quit
  00042	ba 01 00 00 00	 mov	 edx, 1
  00047	48 8b 4c 24 20	 mov	 rcx, QWORD PTR $T1[rsp]
  0004c	e8 00 00 00 00	 call	 ??_G?$CTList@VCLogger@@@@QEAAPEAXI@Z
  00051	48 89 44 24 30	 mov	 QWORD PTR tv73[rsp], rax
  00056	eb 09		 jmp	 SHORT $LN5@quit
$LN4@quit:
  00058	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tv73[rsp], 0
$LN5@quit:

; 232  : 		m_pLoggerList = NULL;

  00061	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00066	48 c7 40 48 00
	00 00 00	 mov	 QWORD PTR [rax+72], 0
$LN2@quit:

; 233  : 	}
; 234  : 	return true;

  0006e	b0 01		 mov	 al, 1

; 235  : }

  00070	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00074	c3		 ret	 0
?quit@CSTLogger@@QEAA_NXZ ENDP				; CSTLogger::quit
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?start@CSTLogger@@QEAA_NXZ
_TEXT	SEGMENT
this$ = 64
?start@CSTLogger@@QEAA_NXZ PROC				; CSTLogger::start, COMDAT

; 141  : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 142  : 	if (m_cThread.bActive()) return true;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b c8	 mov	 rcx, rax
  00011	e8 00 00 00 00	 call	 ?bActive@CComThread@@QEAA_NXZ ; CComThread::bActive
  00016	0f b6 c0	 movzx	 eax, al
  00019	85 c0		 test	 eax, eax
  0001b	74 07		 je	 SHORT $LN2@start
  0001d	b0 01		 mov	 al, 1
  0001f	e9 8b 00 00 00	 jmp	 $LN1@start
$LN2@start:

; 143  : 	if (!m_cThread.init(loggerLoop, this, INFINITE)) {

  00024	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00029	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00032	41 b9 ff ff ff
	ff		 mov	 r9d, -1
  00038	4c 8b 44 24 40	 mov	 r8, QWORD PTR this$[rsp]
  0003d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?loggerLoop@@YAXPEAUSTThreadInfo@@@Z ; loggerLoop
  00044	48 8b c8	 mov	 rcx, rax
  00047	e8 00 00 00 00	 call	 ?init@CComThread@@QEAA_NP6AXPEAUSTThreadInfo@@@ZPEAXH2@Z ; CComThread::init
  0004c	0f b6 c0	 movzx	 eax, al
  0004f	85 c0		 test	 eax, eax
  00051	75 1d		 jne	 SHORT $LN3@start

; 144  : 		comErrorPrint("m_cThread.init");

  00053	41 b8 90 00 00
	00		 mov	 r8d, 144		; 00000090H
  00059	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45378
  00060	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG45379
  00067	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 145  : 		return false;

  0006c	32 c0		 xor	 al, al
  0006e	eb 3f		 jmp	 SHORT $LN1@start
$LN3@start:

; 146  : 	}
; 147  : 	if (!m_cThread.start()) {

  00070	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00075	48 8b c8	 mov	 rcx, rax
  00078	e8 00 00 00 00	 call	 ?start@CComThread@@QEAA_NXZ ; CComThread::start
  0007d	0f b6 c0	 movzx	 eax, al
  00080	85 c0		 test	 eax, eax
  00082	75 1d		 jne	 SHORT $LN4@start

; 148  : 		comErrorPrint("m_cThread.start");

  00084	41 b8 94 00 00
	00		 mov	 r8d, 148		; 00000094H
  0008a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45381
  00091	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG45382
  00098	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 149  : 		return false;

  0009d	32 c0		 xor	 al, al
  0009f	eb 0e		 jmp	 SHORT $LN1@start
$LN4@start:

; 150  : 	}
; 151  : 	printf("CSTLogger::start()\n");

  000a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG45383
  000a8	e8 00 00 00 00	 call	 printf

; 152  : 	return true;

  000ad	b0 01		 mov	 al, 1
$LN1@start:

; 153  : }

  000af	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b3	c3		 ret	 0
?start@CSTLogger@@QEAA_NXZ ENDP				; CSTLogger::start
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?init@CSTLogger@@QEAA_NHH@Z
_TEXT	SEGMENT
this$ = 48
nCount$ = 56
idx$ = 64
?init@CSTLogger@@QEAA_NHH@Z PROC			; CSTLogger::init, COMDAT

; 125  : {

$LN5:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 126  : 	if (!nCount) return false;

  00012	83 7c 24 38 00	 cmp	 DWORD PTR nCount$[rsp], 0
  00017	75 04		 jne	 SHORT $LN2@init
  00019	32 c0		 xor	 al, al
  0001b	eb 2c		 jmp	 SHORT $LN1@init
$LN2@init:

; 127  : 	if (!_init(nCount)) return false;

  0001d	8b 54 24 38	 mov	 edx, DWORD PTR nCount$[rsp]
  00021	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00026	e8 00 00 00 00	 call	 ?_init@CSTLogger@@AEAA_NH@Z ; CSTLogger::_init
  0002b	0f b6 c0	 movzx	 eax, al
  0002e	85 c0		 test	 eax, eax
  00030	75 04		 jne	 SHORT $LN3@init
  00032	32 c0		 xor	 al, al
  00034	eb 13		 jmp	 SHORT $LN1@init
$LN3@init:

; 128  : 	m_cThread.setIdx(idx);

  00036	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0003b	8b 54 24 40	 mov	 edx, DWORD PTR idx$[rsp]
  0003f	48 8b c8	 mov	 rcx, rax
  00042	e8 00 00 00 00	 call	 ?setIdx@CComThread@@QEAAXH@Z ; CComThread::setIdx

; 129  : 	return true;

  00047	b0 01		 mov	 al, 1
$LN1@init:

; 130  : }

  00049	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004d	c3		 ret	 0
?init@CSTLogger@@QEAA_NHH@Z ENDP			; CSTLogger::init
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?initConfig@CSTLogger@@QEAA_NPEADH0@Z
_TEXT	SEGMENT
nMax$ = 32
szSect$ = 40
__$ArrayPad$ = 64
this$ = 96
pConfigFile$ = 104
i$ = 112
pSection$ = 120
?initConfig@CSTLogger@@QEAA_NPEADH0@Z PROC		; CSTLogger::initConfig, COMDAT

; 113  : {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 114  : 	TCHAR szSect[24];
; 115  : 	int nMax;
; 116  : 
; 117  : 	_stprintf(szSect, _T("%s_%d"), pSection, i);

  00027	44 8b 4c 24 70	 mov	 r9d, DWORD PTR i$[rsp]
  0002c	4c 8b 44 24 78	 mov	 r8, QWORD PTR pSection$[rsp]
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45340
  00038	48 8d 4c 24 28	 lea	 rcx, QWORD PTR szSect$[rsp]
  0003d	e8 00 00 00 00	 call	 sprintf

; 118  : 	nMax = GetPrivateProfileInt(szSect, _T("LIST_COUNT"), 0, pConfigFile);

  00042	4c 8b 4c 24 68	 mov	 r9, QWORD PTR pConfigFile$[rsp]
  00047	45 33 c0	 xor	 r8d, r8d
  0004a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45341
  00051	48 8d 4c 24 28	 lea	 rcx, QWORD PTR szSect$[rsp]
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetPrivateProfileIntA
  0005c	89 44 24 20	 mov	 DWORD PTR nMax$[rsp], eax

; 119  : 	if (!nMax) return false;

  00060	83 7c 24 20 00	 cmp	 DWORD PTR nMax$[rsp], 0
  00065	75 04		 jne	 SHORT $LN2@initConfig
  00067	32 c0		 xor	 al, al
  00069	eb 1b		 jmp	 SHORT $LN1@initConfig
$LN2@initConfig:

; 120  : 	if (!_init(nMax)) return false;

  0006b	8b 54 24 20	 mov	 edx, DWORD PTR nMax$[rsp]
  0006f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  00074	e8 00 00 00 00	 call	 ?_init@CSTLogger@@AEAA_NH@Z ; CSTLogger::_init
  00079	0f b6 c0	 movzx	 eax, al
  0007c	85 c0		 test	 eax, eax
  0007e	75 04		 jne	 SHORT $LN3@initConfig
  00080	32 c0		 xor	 al, al
  00082	eb 02		 jmp	 SHORT $LN1@initConfig
$LN3@initConfig:

; 121  : 	return true;

  00084	b0 01		 mov	 al, 1
$LN1@initConfig:

; 122  : }

  00086	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0008b	48 33 cc	 xor	 rcx, rsp
  0008e	e8 00 00 00 00	 call	 __security_check_cookie
  00093	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00097	c3		 ret	 0
?initConfig@CSTLogger@@QEAA_NPEADH0@Z ENDP		; CSTLogger::initConfig
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ??1CSTLogger@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 48
tv74 = 56
$T4 = 64
tv83 = 72
$T5 = 80
this$ = 112
??1CSTLogger@@QEAA@XZ PROC				; CSTLogger::~CSTLogger, COMDAT

; 98   : {

$LN9:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00009	48 c7 44 24 50
	fe ff ff ff	 mov	 QWORD PTR $T5[rsp], -2

; 99   : 	quit();

  00012	48 8b 4c 24 70	 mov	 rcx, QWORD PTR this$[rsp]
  00017	e8 00 00 00 00	 call	 ?quit@CSTLogger@@QEAA_NXZ ; CSTLogger::quit
  0001c	90		 npad	 1

; 100  : 	if (m_pComandList) {

  0001d	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  00022	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  00027	74 4d		 je	 SHORT $LN2@CSTLogger

; 101  : 		delete m_pComandList;

  00029	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  0002e	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00032	48 89 44 24 30	 mov	 QWORD PTR $T3[rsp], rax
  00037	48 8b 44 24 30	 mov	 rax, QWORD PTR $T3[rsp]
  0003c	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax
  00041	48 83 7c 24 20
	00		 cmp	 QWORD PTR $T1[rsp], 0
  00047	74 17		 je	 SHORT $LN5@CSTLogger
  00049	ba 01 00 00 00	 mov	 edx, 1
  0004e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR $T1[rsp]
  00053	e8 00 00 00 00	 call	 ??_GCQueueS@@QEAAPEAXI@Z
  00058	90		 npad	 1
  00059	48 89 44 24 38	 mov	 QWORD PTR tv74[rsp], rax
  0005e	eb 09		 jmp	 SHORT $LN6@CSTLogger
$LN5@CSTLogger:
  00060	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tv74[rsp], 0
$LN6@CSTLogger:

; 102  : 		m_pComandList = NULL;

  00069	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  0006e	48 c7 40 50 00
	00 00 00	 mov	 QWORD PTR [rax+80], 0
$LN2@CSTLogger:

; 103  : 	}
; 104  : 	if (m_pLoggerList) {

  00076	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  0007b	48 83 78 48 00	 cmp	 QWORD PTR [rax+72], 0
  00080	74 4d		 je	 SHORT $LN3@CSTLogger

; 105  : 		delete m_pLoggerList;

  00082	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  00087	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  0008b	48 89 44 24 40	 mov	 QWORD PTR $T4[rsp], rax
  00090	48 8b 44 24 40	 mov	 rax, QWORD PTR $T4[rsp]
  00095	48 89 44 24 28	 mov	 QWORD PTR $T2[rsp], rax
  0009a	48 83 7c 24 28
	00		 cmp	 QWORD PTR $T2[rsp], 0
  000a0	74 17		 je	 SHORT $LN7@CSTLogger
  000a2	ba 01 00 00 00	 mov	 edx, 1
  000a7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T2[rsp]
  000ac	e8 00 00 00 00	 call	 ??_G?$CTList@VCLogger@@@@QEAAPEAXI@Z
  000b1	90		 npad	 1
  000b2	48 89 44 24 48	 mov	 QWORD PTR tv83[rsp], rax
  000b7	eb 09		 jmp	 SHORT $LN8@CSTLogger
$LN7@CSTLogger:
  000b9	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR tv83[rsp], 0
$LN8@CSTLogger:

; 106  : 		m_pLoggerList = NULL;

  000c2	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  000c7	48 c7 40 48 00
	00 00 00	 mov	 QWORD PTR [rax+72], 0
$LN3@CSTLogger:

; 107  : 	}
; 108  : }

  000cf	48 8b 44 24 70	 mov	 rax, QWORD PTR this$[rsp]
  000d4	48 8b c8	 mov	 rcx, rax
  000d7	e8 00 00 00 00	 call	 ??1CComThread@@QEAA@XZ	; CComThread::~CComThread
  000dc	90		 npad	 1
  000dd	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000e1	c3		 ret	 0
??1CSTLogger@@QEAA@XZ ENDP				; CSTLogger::~CSTLogger
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ??0CSTLogger@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0CSTLogger@@QEAA@XZ PROC				; CSTLogger::CSTLogger, COMDAT

; 92   : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b c8	 mov	 rcx, rax
  00011	e8 00 00 00 00	 call	 ??0CComThread@@QEAA@XZ	; CComThread::CComThread

; 93   : 	m_pComandList = NULL;

  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0001b	48 c7 40 50 00
	00 00 00	 mov	 QWORD PTR [rax+80], 0

; 94   : 	m_pLoggerList = NULL;

  00023	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00028	48 c7 40 48 00
	00 00 00	 mov	 QWORD PTR [rax+72], 0

; 95   : }

  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00035	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00039	c3		 ret	 0
??0CSTLogger@@QEAA@XZ ENDP				; CSTLogger::CSTLogger
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?loggerLoop@@YAXPEAUSTThreadInfo@@@Z
_TEXT	SEGMENT
pBasic$ = 32
p$ = 64
?loggerLoop@@YAXPEAUSTThreadInfo@@@Z PROC		; loggerLoop, COMDAT

; 262  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 263  : 	CSTLogger *pBasic = (CSTLogger *)p->pClass;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR p$[rsp]
  0000e	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00012	48 89 44 24 20	 mov	 QWORD PTR pBasic$[rsp], rax

; 264  : 	if (pBasic->IsCommand()) return;

  00017	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pBasic$[rsp]
  0001c	e8 00 00 00 00	 call	 ?IsCommand@CSTLogger@@QEAA_NXZ ; CSTLogger::IsCommand
  00021	0f b6 c0	 movzx	 eax, al
  00024	85 c0		 test	 eax, eax
  00026	74 02		 je	 SHORT $LN2@loggerLoop
  00028	eb 14		 jmp	 SHORT $LN1@loggerLoop
$LN2@loggerLoop:

; 265  : 	pBasic->GetQueue();

  0002a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pBasic$[rsp]
  0002f	e8 00 00 00 00	 call	 ?GetQueue@CSTLogger@@QEAAXXZ ; CSTLogger::GetQueue

; 266  : 	pBasic->TimeProc();

  00034	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pBasic$[rsp]
  00039	e8 00 00 00 00	 call	 ?TimeProc@CSTLogger@@QEAAXXZ ; CSTLogger::TimeProc
$LN1@loggerLoop:

; 267  : }

  0003e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00042	c3		 ret	 0
?loggerLoop@@YAXPEAUSTThreadInfo@@@Z ENDP		; loggerLoop
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_ECComThread@@QEAAPEAXI@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__flags$ = 72
??_ECComThread@@QEAAPEAXI@Z PROC			; CComThread::`vector deleting destructor', COMDAT
$LN6:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  0000d	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00016	8b 44 24 48	 mov	 eax, DWORD PTR __flags$[rsp]
  0001a	83 e0 02	 and	 eax, 2
  0001d	85 c0		 test	 eax, eax
  0001f	74 56		 je	 SHORT $LN2@vector
  00021	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??1CComThread@@QEAA@XZ ; CComThread::~CComThread
  00028	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0002d	4c 8b 40 f8	 mov	 r8, QWORD PTR [rax-8]
  00031	ba 48 00 00 00	 mov	 edx, 72			; 00000048H
  00036	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0003b	e8 00 00 00 00	 call	 ??_M@YAXPEAX_K1P6AX0@Z@Z
  00040	90		 npad	 1
  00041	8b 44 24 48	 mov	 eax, DWORD PTR __flags$[rsp]
  00045	83 e0 01	 and	 eax, 1
  00048	85 c0		 test	 eax, eax
  0004a	74 20		 je	 SHORT $LN3@vector
  0004c	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00051	48 6b 40 f8 48	 imul	 rax, QWORD PTR [rax-8], 72 ; 00000048H
  00056	48 83 c0 08	 add	 rax, 8
  0005a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0005f	48 83 e9 08	 sub	 rcx, 8
  00063	48 8b d0	 mov	 rdx, rax
  00066	e8 00 00 00 00	 call	 ??_V@YAXPEAX_K@Z	; operator delete[]
  0006b	90		 npad	 1
$LN3@vector:
  0006c	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00071	48 83 e8 08	 sub	 rax, 8
  00075	eb 2b		 jmp	 SHORT $LN1@vector
$LN2@vector:
  00077	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0007c	e8 00 00 00 00	 call	 ??1CComThread@@QEAA@XZ	; CComThread::~CComThread
  00081	90		 npad	 1
  00082	8b 44 24 48	 mov	 eax, DWORD PTR __flags$[rsp]
  00086	83 e0 01	 and	 eax, 1
  00089	85 c0		 test	 eax, eax
  0008b	74 10		 je	 SHORT $LN4@vector
  0008d	ba 48 00 00 00	 mov	 edx, 72			; 00000048H
  00092	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00097	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  0009c	90		 npad	 1
$LN4@vector:
  0009d	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
$LN1@vector:
  000a2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a6	c3		 ret	 0
??_ECComThread@@QEAAPEAXI@Z ENDP			; CComThread::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GCComThread@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GCComThread@@QEAAPEAXI@Z PROC			; CComThread::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00012	e8 00 00 00 00	 call	 ??1CComThread@@QEAA@XZ	; CComThread::~CComThread
  00017	8b 44 24 38	 mov	 eax, DWORD PTR __flags$[rsp]
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 0f		 je	 SHORT $LN2@scalar
  00022	ba 48 00 00 00	 mov	 edx, 72			; 00000048H
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
??_GCComThread@@QEAAPEAXI@Z ENDP			; CComThread::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comcore.h
;	COMDAT ?sendSignal@CComThread@@QEAAXXZ
_TEXT	SEGMENT
tv75 = 32
this$ = 64
?sendSignal@CComThread@@QEAAXXZ PROC			; CComThread::sendSignal, COMDAT

; 92   : 	inline void sendSignal() { m_stInfo.cThreadCond.signal(); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 83 c0 10	 add	 rax, 16
  00012	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00017	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0001b	48 89 4c 24 20	 mov	 QWORD PTR tv75[rsp], rcx
  00020	48 8b c8	 mov	 rcx, rax
  00023	48 8b 44 24 20	 mov	 rax, QWORD PTR tv75[rsp]
  00028	ff 50 08	 call	 QWORD PTR [rax+8]
  0002b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0002f	c3		 ret	 0
?sendSignal@CComThread@@QEAAXXZ ENDP			; CComThread::sendSignal
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comcore.h
;	COMDAT ?bActive@CComThread@@QEAA_NXZ
_TEXT	SEGMENT
this$ = 8
?bActive@CComThread@@QEAA_NXZ PROC			; CComThread::bActive, COMDAT

; 91   : 	inline bool bActive() {	return m_stInfo.bActive; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	0f b6 40 34	 movzx	 eax, BYTE PTR [rax+52]
  0000e	c3		 ret	 0
?bActive@CComThread@@QEAA_NXZ ENDP			; CComThread::bActive
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comcore.h
;	COMDAT ?setIdx@CComThread@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 8
nIdx$ = 16
?setIdx@CComThread@@QEAAXH@Z PROC			; CComThread::setIdx, COMDAT

; 90   : 	inline void setIdx(int nIdx) { m_stInfo.nIdx = nIdx; }

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR nIdx$[rsp]
  00012	89 48 30	 mov	 DWORD PTR [rax+48], ecx
  00015	c3		 ret	 0
?setIdx@CComThread@@QEAAXH@Z ENDP			; CComThread::setIdx
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?ProcThread@CComThread@@SAKPEAX@Z
_TEXT	SEGMENT
pBasic$ = 32
pClass$ = 40
ptr$ = 64
?ProcThread@CComThread@@SAKPEAX@Z PROC			; CComThread::ProcThread, COMDAT

; 75   : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 76   : 	//pthread_detach(pthread_self());	
; 77   : 	CComThread *pClass = (CComThread *)ptr;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	48 89 44 24 28	 mov	 QWORD PTR pClass$[rsp], rax

; 78   : 	STThreadInfo *pBasic = &(pClass->m_stInfo);

  00013	48 8b 44 24 28	 mov	 rax, QWORD PTR pClass$[rsp]
  00018	48 83 c0 08	 add	 rax, 8
  0001c	48 89 44 24 20	 mov	 QWORD PTR pBasic$[rsp], rax
$LN2@ProcThread:

; 79   : 
; 80   : 	while (pBasic->bActive)

  00021	48 8b 44 24 20	 mov	 rax, QWORD PTR pBasic$[rsp]
  00026	0f b6 40 2c	 movzx	 eax, BYTE PTR [rax+44]
  0002a	85 c0		 test	 eax, eax
  0002c	74 2a		 je	 SHORT $LN3@ProcThread

; 81   : 	{
; 82   : 		pBasic->cThreadCond.wait(pBasic->millisecSleep, NULL);	// -1 : INFINITE

  0002e	48 8b 44 24 20	 mov	 rax, QWORD PTR pBasic$[rsp]
  00033	48 83 c0 08	 add	 rax, 8
  00037	45 33 c0	 xor	 r8d, r8d
  0003a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pBasic$[rsp]
  0003f	8b 51 30	 mov	 edx, DWORD PTR [rcx+48]
  00042	48 8b c8	 mov	 rcx, rax
  00045	e8 00 00 00 00	 call	 ?wait@condition@win32@common@@QEAA_NHPEAVcritical_section@23@@Z ; common::win32::condition::wait

; 83   : 		pClass->m_fpLoopProc(pBasic);

  0004a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pBasic$[rsp]
  0004f	48 8b 44 24 28	 mov	 rax, QWORD PTR pClass$[rsp]
  00054	ff 10		 call	 QWORD PTR [rax]

; 84   : 	}

  00056	eb c9		 jmp	 SHORT $LN2@ProcThread
$LN3@ProcThread:

; 85   : 	pClass->quit();

  00058	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pClass$[rsp]
  0005d	e8 00 00 00 00	 call	 ?quit@CComThread@@QEAA_NXZ ; CComThread::quit

; 86   : 	return 0;

  00062	33 c0		 xor	 eax, eax

; 87   : }

  00064	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00068	c3		 ret	 0
?ProcThread@CComThread@@SAKPEAX@Z ENDP			; CComThread::ProcThread
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?quit@CComThread@@QEAA_NXZ
_TEXT	SEGMENT
nStatus$ = 32
this$ = 64
?quit@CComThread@@QEAA_NXZ PROC				; CComThread::quit, COMDAT

; 65   : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 66   : 	if (!m_stInfo.hTHID) return false;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00013	75 04		 jne	 SHORT $LN2@quit
  00015	32 c0		 xor	 al, al
  00017	eb 22		 jmp	 SHORT $LN1@quit
$LN2@quit:

; 67   : 	int nStatus = 0; // for linux

  00019	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR nStatus$[rsp], 0

; 68   : 	m_stInfo.bActive = false;

  00021	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00026	c6 40 34 00	 mov	 BYTE PTR [rax+52], 0

; 69   : 	THREAD_JOIN(m_stInfo.hTHID, (void **)&nStatus);

  0002a	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0002f	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 70   : 	return true;

  00039	b0 01		 mov	 al, 1
$LN1@quit:

; 71   : }

  0003b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003f	c3		 ret	 0
?quit@CComThread@@QEAA_NXZ ENDP				; CComThread::quit
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?start@CComThread@@QEAA_NXZ
_TEXT	SEGMENT
tv81 = 48
this$ = 80
?start@CComThread@@QEAA_NXZ PROC			; CComThread::start, COMDAT

; 44   : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 45   : 	if (!m_fpLoopProc) {

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00012	75 20		 jne	 SHORT $LN2@start

; 46   : 		comErrorPrint("m_fpLoopProc is NULL");

  00014	41 b8 2e 00 00
	00		 mov	 r8d, 46			; 0000002eH
  0001a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45234
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG45235
  00028	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 47   : 		return false;

  0002d	32 c0		 xor	 al, al
  0002f	e9 a3 00 00 00	 jmp	 $LN1@start
$LN2@start:

; 48   : 	}
; 49   : 	if (0 > m_stInfo.nIdx) {

  00034	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00039	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  0003d	7d 1d		 jge	 SHORT $LN3@start

; 50   : 		comErrorPrint("0 > m_stInfo.nIdx");

  0003f	41 b8 32 00 00
	00		 mov	 r8d, 50			; 00000032H
  00045	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45237
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG45238
  00053	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 51   : 		return false;

  00058	32 c0		 xor	 al, al
  0005a	eb 7b		 jmp	 SHORT $LN1@start
$LN3@start:

; 52   : 	}
; 53   : 
; 54   : 	if (m_stInfo.bActive) return true;

  0005c	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00061	0f b6 40 34	 movzx	 eax, BYTE PTR [rax+52]
  00065	85 c0		 test	 eax, eax
  00067	74 04		 je	 SHORT $LN4@start
  00069	b0 01		 mov	 al, 1
  0006b	eb 6a		 jmp	 SHORT $LN1@start
$LN4@start:

; 55   : 	// create Single Thread
; 56   : 	if (!THREAD_CREATE(&m_stInfo.hTHID, ProcThread, this)) {

  0006d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00076	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  0007e	4c 8b 4c 24 50	 mov	 r9, QWORD PTR this$[rsp]
  00083	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:?ProcThread@CComThread@@SAKPEAX@Z ; CComThread::ProcThread
  0008a	33 d2		 xor	 edx, edx
  0008c	33 c9		 xor	 ecx, ecx
  0008e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateThread
  00094	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  00099	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0009e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  000a3	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  000a7	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv81[rsp], 0
  000ad	75 1d		 jne	 SHORT $LN5@start

; 57   : 		comErrorPrint("THREAD_CREATE has Failed");

  000af	41 b8 39 00 00
	00		 mov	 r8d, 57			; 00000039H
  000b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45241
  000bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG45242
  000c3	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPEADPEBDH@Z ; comGlobalErrorProc

; 58   : 		return false;

  000c8	32 c0		 xor	 al, al
  000ca	eb 0b		 jmp	 SHORT $LN1@start
$LN5@start:

; 59   : 	}
; 60   : 	m_stInfo.bActive = true;

  000cc	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  000d1	c6 40 34 01	 mov	 BYTE PTR [rax+52], 1

; 61   : 	return true;

  000d5	b0 01		 mov	 al, 1
$LN1@start:

; 62   : }

  000d7	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000db	c3		 ret	 0
?start@CComThread@@QEAA_NXZ ENDP			; CComThread::start
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ?init@CComThread@@QEAA_NP6AXPEAUSTThreadInfo@@@ZPEAXH2@Z
_TEXT	SEGMENT
this$ = 8
fpProc$ = 16
pClass$ = 24
millisec$ = 32
pObj$ = 40
?init@CComThread@@QEAA_NP6AXPEAUSTThreadInfo@@@ZPEAXH2@Z PROC ; CComThread::init, COMDAT

; 34   : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 35   : 	m_stInfo.pClass = pClass;

  00014	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00019	48 8b 4c 24 18	 mov	 rcx, QWORD PTR pClass$[rsp]
  0001e	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 36   : 	m_stInfo.pObj = pObj;

  00022	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00027	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pObj$[rsp]
  0002c	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 37   : 	m_stInfo.millisecSleep = millisec;

  00030	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00035	8b 4c 24 20	 mov	 ecx, DWORD PTR millisec$[rsp]
  00039	89 48 38	 mov	 DWORD PTR [rax+56], ecx

; 38   : 	m_fpLoopProc = fpProc;

  0003c	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00041	48 8b 4c 24 10	 mov	 rcx, QWORD PTR fpProc$[rsp]
  00046	48 89 08	 mov	 QWORD PTR [rax], rcx

; 39   : 	m_nMillisecSleep = millisec;

  00049	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0004e	8b 4c 24 20	 mov	 ecx, DWORD PTR millisec$[rsp]
  00052	89 48 40	 mov	 DWORD PTR [rax+64], ecx

; 40   : 	return true;

  00055	b0 01		 mov	 al, 1

; 41   : }

  00057	c3		 ret	 0
?init@CComThread@@QEAA_NP6AXPEAUSTThreadInfo@@@ZPEAXH2@Z ENDP ; CComThread::init
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ??1CComThread@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??1CComThread@@QEAA@XZ PROC				; CComThread::~CComThread, COMDAT

; 28   : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00009	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2

; 29   : 	quit();

  00012	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00017	e8 00 00 00 00	 call	 ?quit@CComThread@@QEAA_NXZ ; CComThread::quit
  0001c	90		 npad	 1

; 30   : }

  0001d	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00022	48 83 c0 08	 add	 rax, 8
  00026	48 8b c8	 mov	 rcx, rax
  00029	e8 00 00 00 00	 call	 ??1STThreadInfo@@QEAA@XZ
  0002e	90		 npad	 1
  0002f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00033	c3		 ret	 0
??1CComThread@@QEAA@XZ ENDP				; CComThread::~CComThread
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comcore.cpp
;	COMDAT ??0CComThread@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0CComThread@@QEAA@XZ PROC				; CComThread::CComThread, COMDAT

; 15   : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 83 c0 08	 add	 rax, 8
  00012	48 8b c8	 mov	 rcx, rax
  00015	e8 00 00 00 00	 call	 ??0STThreadInfo@@QEAA@XZ

; 16   : 	m_stInfo.bActive = false;

  0001a	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0001f	c6 40 34 00	 mov	 BYTE PTR [rax+52], 0

; 17   : 	m_stInfo.hTHID = NULL;

  00023	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00028	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 18   : 	m_stInfo.nIdx = -1;

  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00035	c7 40 30 ff ff
	ff ff		 mov	 DWORD PTR [rax+48], -1

; 19   : 	m_stInfo.pClass = NULL;

  0003c	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00041	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 20   : 	m_stInfo.millisecSleep = INFINITE;

  00049	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0004e	c7 40 38 ff ff
	ff ff		 mov	 DWORD PTR [rax+56], -1

; 21   : 	m_nMillisecSleep = INFINITE;

  00055	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0005a	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1

; 22   : 	m_stInfo.pObj = NULL;

  00061	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00066	48 c7 40 28 00
	00 00 00	 mov	 QWORD PTR [rax+40], 0

; 23   : 	m_fpLoopProc = NULL;

  0006e	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00073	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 24   : 
; 25   : }

  0007a	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0007f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00083	c3		 ret	 0
??0CComThread@@QEAA@XZ ENDP				; CComThread::CComThread
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1STThreadInfo@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1STThreadInfo@@QEAA@XZ PROC				; STThreadInfo::~STThreadInfo, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 83 c0 08	 add	 rax, 8
  00012	48 8b c8	 mov	 rcx, rax
  00015	e8 00 00 00 00	 call	 ??1condition@win32@common@@UEAA@XZ ; common::win32::condition::~condition
  0001a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001e	c3		 ret	 0
??1STThreadInfo@@QEAA@XZ ENDP				; STThreadInfo::~STThreadInfo
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0STThreadInfo@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0STThreadInfo@@QEAA@XZ PROC				; STThreadInfo::STThreadInfo, COMDAT
$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 83 c0 08	 add	 rax, 8
  00012	48 8b c8	 mov	 rcx, rax
  00015	e8 00 00 00 00	 call	 ??0condition@win32@common@@QEAA@XZ ; common::win32::condition::condition
  0001a	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0001f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00023	c3		 ret	 0
??0STThreadInfo@@QEAA@XZ ENDP				; STThreadInfo::STThreadInfo
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_ECLogger@@QEAAPEAXI@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__flags$ = 72
??_ECLogger@@QEAAPEAXI@Z PROC				; CLogger::`vector deleting destructor', COMDAT
$LN6:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  0000d	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00016	8b 44 24 48	 mov	 eax, DWORD PTR __flags$[rsp]
  0001a	83 e0 02	 and	 eax, 2
  0001d	85 c0		 test	 eax, eax
  0001f	74 59		 je	 SHORT $LN2@vector
  00021	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??1CLogger@@QEAA@XZ ; CLogger::~CLogger
  00028	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0002d	4c 8b 40 f8	 mov	 r8, QWORD PTR [rax-8]
  00031	ba 18 01 00 00	 mov	 edx, 280		; 00000118H
  00036	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0003b	e8 00 00 00 00	 call	 ??_M@YAXPEAX_K1P6AX0@Z@Z
  00040	90		 npad	 1
  00041	8b 44 24 48	 mov	 eax, DWORD PTR __flags$[rsp]
  00045	83 e0 01	 and	 eax, 1
  00048	85 c0		 test	 eax, eax
  0004a	74 23		 je	 SHORT $LN3@vector
  0004c	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00051	48 69 40 f8 18
	01 00 00	 imul	 rax, QWORD PTR [rax-8], 280 ; 00000118H
  00059	48 83 c0 08	 add	 rax, 8
  0005d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00062	48 83 e9 08	 sub	 rcx, 8
  00066	48 8b d0	 mov	 rdx, rax
  00069	e8 00 00 00 00	 call	 ??_V@YAXPEAX_K@Z	; operator delete[]
  0006e	90		 npad	 1
$LN3@vector:
  0006f	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00074	48 83 e8 08	 sub	 rax, 8
  00078	eb 2b		 jmp	 SHORT $LN1@vector
$LN2@vector:
  0007a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0007f	e8 00 00 00 00	 call	 ??1CLogger@@QEAA@XZ	; CLogger::~CLogger
  00084	90		 npad	 1
  00085	8b 44 24 48	 mov	 eax, DWORD PTR __flags$[rsp]
  00089	83 e0 01	 and	 eax, 1
  0008c	85 c0		 test	 eax, eax
  0008e	74 10		 je	 SHORT $LN4@vector
  00090	ba 18 01 00 00	 mov	 edx, 280		; 00000118H
  00095	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0009a	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  0009f	90		 npad	 1
$LN4@vector:
  000a0	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
$LN1@vector:
  000a5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a9	c3		 ret	 0
??_ECLogger@@QEAAPEAXI@Z ENDP				; CLogger::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GCLogger@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GCLogger@@QEAAPEAXI@Z PROC				; CLogger::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00012	e8 00 00 00 00	 call	 ??1CLogger@@QEAA@XZ	; CLogger::~CLogger
  00017	8b 44 24 38	 mov	 eax, DWORD PTR __flags$[rsp]
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 0f		 je	 SHORT $LN2@scalar
  00022	ba 18 01 00 00	 mov	 edx, 280		; 00000118H
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
??_GCLogger@@QEAAPEAXI@Z ENDP				; CLogger::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comlogger.h
;	COMDAT ?setCondition@CLogger@@QEAAXPEAVcondition@win32@common@@@Z
_TEXT	SEGMENT
this$ = 8
p$ = 16
?setCondition@CLogger@@QEAAXPEAVcondition@win32@common@@@Z PROC ; CLogger::setCondition, COMDAT

; 206  : 	inline void setCondition(THREAD_COND *p) { m_pCondition = p; }

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR p$[rsp]
  00014	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
  00018	c3		 ret	 0
?setCondition@CLogger@@QEAAXPEAVcondition@win32@common@@@Z ENDP ; CLogger::setCondition
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comlogger.h
;	COMDAT ?getLogName@CLogger@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
?getLogName@CLogger@@QEAAPEADXZ PROC			; CLogger::getLogName, COMDAT

; 203  : 	inline TCHAR *getLogName() { return m_pLogName;}

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  00011	c3		 ret	 0
?getLogName@CLogger@@QEAAPEADXZ ENDP			; CLogger::getLogName
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comlogger.h
;	COMDAT ?pop@CLogger@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 48
?pop@CLogger@@QEAAPEADXZ PROC				; CLogger::pop, COMDAT

; 198  : 	inline TCHAR * pop() { return (TCHAR *)m_sLogQueue.pop(); } // write   STLogger : 

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b c8	 mov	 rcx, rax
  00011	e8 00 00 00 00	 call	 ?pop@CQueueS@@QEAAPEAXXZ ; CQueueS::pop
  00016	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001a	c3		 ret	 0
?pop@CLogger@@QEAAPEADXZ ENDP				; CLogger::pop
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comlogger.h
;	COMDAT ?isLogFlag@CLogger@@QEAA_NW4E_LOG_FLAG@@@Z
_TEXT	SEGMENT
tv67 = 0
this$ = 32
nFlag$ = 40
?isLogFlag@CLogger@@QEAA_NW4E_LOG_FLAG@@@Z PROC		; CLogger::isLogFlag, COMDAT

; 185  : 	inline bool isLogFlag(E_LOG_FLAG nFlag) { return (m_nLogFlag & nFlag)?true:false; }

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 18	 sub	 rsp, 24
  0000d	48 8b 44 24 20	 mov	 rax, QWORD PTR this$[rsp]
  00012	8b 4c 24 28	 mov	 ecx, DWORD PTR nFlag$[rsp]
  00016	8b 80 b4 00 00
	00		 mov	 eax, DWORD PTR [rax+180]
  0001c	23 c1		 and	 eax, ecx
  0001e	85 c0		 test	 eax, eax
  00020	74 06		 je	 SHORT $LN3@isLogFlag
  00022	c6 04 24 01	 mov	 BYTE PTR tv67[rsp], 1
  00026	eb 04		 jmp	 SHORT $LN4@isLogFlag
$LN3@isLogFlag:
  00028	c6 04 24 00	 mov	 BYTE PTR tv67[rsp], 0
$LN4@isLogFlag:
  0002c	0f b6 04 24	 movzx	 eax, BYTE PTR tv67[rsp]
  00030	48 83 c4 18	 add	 rsp, 24
  00034	c3		 ret	 0
?isLogFlag@CLogger@@QEAA_NW4E_LOG_FLAG@@@Z ENDP		; CLogger::isLogFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comlogger.h
;	COMDAT ?clearLogFlag@CLogger@@QEAAXW4E_LOG_FLAG@@@Z
_TEXT	SEGMENT
this$ = 8
nFlag$ = 16
?clearLogFlag@CLogger@@QEAAXW4E_LOG_FLAG@@@Z PROC	; CLogger::clearLogFlag, COMDAT

; 184  : 	inline void clearLogFlag(E_LOG_FLAG nFlag) { m_nLogFlag &= ~nFlag; }

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	8b 44 24 10	 mov	 eax, DWORD PTR nFlag$[rsp]
  0000d	f7 d0		 not	 eax
  0000f	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  00014	8b 89 b4 00 00
	00		 mov	 ecx, DWORD PTR [rcx+180]
  0001a	23 c8		 and	 ecx, eax
  0001c	8b c1		 mov	 eax, ecx
  0001e	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  00023	89 81 b4 00 00
	00		 mov	 DWORD PTR [rcx+180], eax
  00029	c3		 ret	 0
?clearLogFlag@CLogger@@QEAAXW4E_LOG_FLAG@@@Z ENDP	; CLogger::clearLogFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comlogger.h
;	COMDAT ?setLogFlag@CLogger@@QEAAXW4E_LOG_FLAG@@@Z
_TEXT	SEGMENT
this$ = 8
nFlag$ = 16
?setLogFlag@CLogger@@QEAAXW4E_LOG_FLAG@@@Z PROC		; CLogger::setLogFlag, COMDAT

; 183  : 	inline void setLogFlag(E_LOG_FLAG nFlag) { m_nLogFlag |= nFlag; }

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR nFlag$[rsp]
  00012	8b 80 b4 00 00
	00		 mov	 eax, DWORD PTR [rax+180]
  00018	0b c1		 or	 eax, ecx
  0001a	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  0001f	89 81 b4 00 00
	00		 mov	 DWORD PTR [rcx+180], eax
  00025	c3		 ret	 0
?setLogFlag@CLogger@@QEAAXW4E_LOG_FLAG@@@Z ENDP		; CLogger::setLogFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comlogger.h
;	COMDAT ?getSTLNo@CLogger@@QEAAHXZ
_TEXT	SEGMENT
this$ = 8
?getSTLNo@CLogger@@QEAAHXZ PROC				; CLogger::getSTLNo, COMDAT

; 182  : 	inline int getSTLNo() {	return m_nStlNo; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	8b 80 bc 00 00
	00		 mov	 eax, DWORD PTR [rax+188]
  00010	c3		 ret	 0
?getSTLNo@CLogger@@QEAAHXZ ENDP				; CLogger::getSTLNo
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comlogger.h
;	COMDAT ?addLogSize@CLogger@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 8
nLen$ = 16
?addLogSize@CLogger@@QEAAXH@Z PROC			; CLogger::addLogSize, COMDAT

; 180  : 	inline void addLogSize(int nLen) {m_nLogSize += nLen;}

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000e	8b 80 c4 00 00
	00		 mov	 eax, DWORD PTR [rax+196]
  00014	03 44 24 10	 add	 eax, DWORD PTR nLen$[rsp]
  00018	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  0001d	89 81 c4 00 00
	00		 mov	 DWORD PTR [rcx+196], eax
  00023	c3		 ret	 0
?addLogSize@CLogger@@QEAAXH@Z ENDP			; CLogger::addLogSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\commemmanager.h
;	COMDAT ?delBuf@CMemManager@@QEAAXPEADH@Z
_TEXT	SEGMENT
nIdx$ = 32
this$ = 64
pBuf$ = 72
nSize$ = 80
?delBuf@CMemManager@@QEAAXPEADH@Z PROC			; CMemManager::delBuf, COMDAT

; 38   : 	inline void delBuf(char *pBuf, int nSize) { int nIdx = getIndex(nSize); delBufByIndex(pBuf, nIdx); }

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00013	8b 4c 24 50	 mov	 ecx, DWORD PTR nSize$[rsp]
  00017	e8 00 00 00 00	 call	 ?getIndex@@YAHH@Z	; getIndex
  0001c	89 44 24 20	 mov	 DWORD PTR nIdx$[rsp], eax
  00020	44 8b 44 24 20	 mov	 r8d, DWORD PTR nIdx$[rsp]
  00025	48 8b 54 24 48	 mov	 rdx, QWORD PTR pBuf$[rsp]
  0002a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0002f	e8 00 00 00 00	 call	 ?delBufByIndex@CMemManager@@QEAAXPEADH@Z ; CMemManager::delBufByIndex
  00034	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00038	c3		 ret	 0
?delBuf@CMemManager@@QEAAXPEADH@Z ENDP			; CMemManager::delBuf
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\commemmanager.h
;	COMDAT ?newBuf@CMemManager@@QEAAPEADH@Z
_TEXT	SEGMENT
nIdx$ = 32
this$ = 64
nSize$ = 72
?newBuf@CMemManager@@QEAAPEADH@Z PROC			; CMemManager::newBuf, COMDAT

; 34   : 	inline char *newBuf(int nSize) { int nIdx = getIndex(nSize);  return __newBuf(nIdx, nSize); }

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  0000d	8b 4c 24 48	 mov	 ecx, DWORD PTR nSize$[rsp]
  00011	e8 00 00 00 00	 call	 ?getIndex@@YAHH@Z	; getIndex
  00016	89 44 24 20	 mov	 DWORD PTR nIdx$[rsp], eax
  0001a	48 63 44 24 48	 movsxd	 rax, DWORD PTR nSize$[rsp]
  0001f	4c 8b c0	 mov	 r8, rax
  00022	8b 54 24 20	 mov	 edx, DWORD PTR nIdx$[rsp]
  00026	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0002b	e8 00 00 00 00	 call	 ?__newBuf@CMemManager@@AEAAPEADH_K@Z ; CMemManager::__newBuf
  00030	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00034	c3		 ret	 0
?newBuf@CMemManager@@QEAAPEADH@Z ENDP			; CMemManager::newBuf
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\combufpool.h
;	COMDAT ?getIndex@@YAHH@Z
_TEXT	SEGMENT
tv73 = 0
m$ = 4
tv80 = 8
$S1$ = 16
s$ = 48
?getIndex@@YAHH@Z PROC					; getIndex, COMDAT

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

$LN5:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00008	f2 0f 2a 44 24
	30		 cvtsi2sd xmm0, DWORD PTR s$[rsp]
  0000e	f2 0f 11 44 24
	10		 movsd	 QWORD PTR $S1$[rsp], xmm0
  00014	b8 04 00 00 00	 mov	 eax, 4
  00019	48 6b c0 01	 imul	 rax, rax, 1
  0001d	8b 44 04 10	 mov	 eax, DWORD PTR $S1$[rsp+rax]
  00021	c1 f8 14	 sar	 eax, 20
  00024	2d ff 03 00 00	 sub	 eax, 1023		; 000003ffH
  00029	89 44 24 04	 mov	 DWORD PTR m$[rsp], eax
  0002d	8b 44 24 04	 mov	 eax, DWORD PTR m$[rsp]
  00031	b9 01 00 00 00	 mov	 ecx, 1
  00036	89 4c 24 08	 mov	 DWORD PTR tv80[rsp], ecx
  0003a	0f b6 c8	 movzx	 ecx, al
  0003d	8b 44 24 08	 mov	 eax, DWORD PTR tv80[rsp]
  00041	d3 e0		 shl	 eax, cl
  00043	8b 4c 24 30	 mov	 ecx, DWORD PTR s$[rsp]
  00047	2b c8		 sub	 ecx, eax
  00049	8b c1		 mov	 eax, ecx
  0004b	8b 4c 24 30	 mov	 ecx, DWORD PTR s$[rsp]
  0004f	23 c8		 and	 ecx, eax
  00051	8b c1		 mov	 eax, ecx
  00053	85 c0		 test	 eax, eax
  00055	74 09		 je	 SHORT $LN3@getIndex
  00057	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv73[rsp], 1
  0005e	eb 07		 jmp	 SHORT $LN4@getIndex
$LN3@getIndex:
  00060	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv73[rsp], 0
$LN4@getIndex:
  00067	8b 04 24	 mov	 eax, DWORD PTR tv73[rsp]
  0006a	8b 4c 24 04	 mov	 ecx, DWORD PTR m$[rsp]
  0006e	03 c8		 add	 ecx, eax
  00070	8b c1		 mov	 eax, ecx
  00072	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00076	c3		 ret	 0
?getIndex@@YAHH@Z ENDP					; getIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comdatetime.h
;	COMDAT ?Sec@CDateTime@@QEAAHXZ
_TEXT	SEGMENT
this$ = 8
?Sec@CDateTime@@QEAAHXZ PROC				; CDateTime::Sec, COMDAT

; 222  : 	inline int	Sec()		{ return m_tm.tm_sec; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	8b 00		 mov	 eax, DWORD PTR [rax]
  0000c	c3		 ret	 0
?Sec@CDateTime@@QEAAHXZ ENDP				; CDateTime::Sec
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comdatetime.h
;	COMDAT ?Minute@CDateTime@@QEAAHXZ
_TEXT	SEGMENT
this$ = 8
?Minute@CDateTime@@QEAAHXZ PROC				; CDateTime::Minute, COMDAT

; 221  : 	inline int	Minute()	{ return m_tm.tm_min; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0000d	c3		 ret	 0
?Minute@CDateTime@@QEAAHXZ ENDP				; CDateTime::Minute
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comdatetime.h
;	COMDAT ?Hour@CDateTime@@QEAAHXZ
_TEXT	SEGMENT
this$ = 8
?Hour@CDateTime@@QEAAHXZ PROC				; CDateTime::Hour, COMDAT

; 220  : 	inline int	Hour()		{ return m_tm.tm_hour; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0000d	c3		 ret	 0
?Hour@CDateTime@@QEAAHXZ ENDP				; CDateTime::Hour
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comdatetime.h
;	COMDAT ?Mday@CDateTime@@QEAAHXZ
_TEXT	SEGMENT
this$ = 8
?Mday@CDateTime@@QEAAHXZ PROC				; CDateTime::Mday, COMDAT

; 218  : 	inline int	Mday()		{ return m_tm.tm_mday; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  0000d	c3		 ret	 0
?Mday@CDateTime@@QEAAHXZ ENDP				; CDateTime::Mday
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comdatetime.h
;	COMDAT ?Month@CDateTime@@QEAAHXZ
_TEXT	SEGMENT
this$ = 8
?Month@CDateTime@@QEAAHXZ PROC				; CDateTime::Month, COMDAT

; 217  : 	inline int	Month()		{ return m_tm.tm_mon; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0000d	c3		 ret	 0
?Month@CDateTime@@QEAAHXZ ENDP				; CDateTime::Month
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comdatetime.h
;	COMDAT ?Year@CDateTime@@QEAAHXZ
_TEXT	SEGMENT
this$ = 8
?Year@CDateTime@@QEAAHXZ PROC				; CDateTime::Year, COMDAT

; 216  : 	inline int	Year()		{ return m_tm.tm_year; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0000d	c3		 ret	 0
?Year@CDateTime@@QEAAHXZ ENDP				; CDateTime::Year
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GCQueueS@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GCQueueS@@QEAAPEAXI@Z PROC				; CQueueS::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00012	e8 00 00 00 00	 call	 ??1CQueueS@@QEAA@XZ	; CQueueS::~CQueueS
  00017	8b 44 24 38	 mov	 eax, DWORD PTR __flags$[rsp]
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 0f		 je	 SHORT $LN2@scalar
  00022	ba 60 00 00 00	 mov	 edx, 96			; 00000060H
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
??_GCQueueS@@QEAAPEAXI@Z ENDP				; CQueueS::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit2@CQueueS@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 16
classSize$ = 24
?__autoclassinit2@CQueueS@@QEAAX_K@Z PROC		; CQueueS::__autoclassinit2, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 8b 7c 24 10	 mov	 rdi, QWORD PTR this$[rsp]
  00010	33 c0		 xor	 eax, eax
  00012	48 8b 4c 24 18	 mov	 rcx, QWORD PTR classSize$[rsp]
  00017	f3 aa		 rep stosb
  00019	5f		 pop	 rdi
  0001a	c3		 ret	 0
?__autoclassinit2@CQueueS@@QEAAX_K@Z ENDP		; CQueueS::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtypes.h
;	COMDAT ?comGlobalErrorProc@@YAXPEADPEBDH@Z
_TEXT	SEGMENT
pMsg$ = 64
_szFunc$ = 72
_nLine$ = 80
?comGlobalErrorProc@@YAXPEADPEBDH@Z PROC		; comGlobalErrorProc, COMDAT

; 324  : inline void comGlobalErrorProc(char *pMsg, const char *_szFunc, const int _nLine) {

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 325  : 	sprintf(g_szSystemError, "ERROR! [%s:%d] %s\n", _szFunc, _nLine, pMsg);

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR pMsg$[rsp]
  00018	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0001d	44 8b 4c 24 50	 mov	 r9d, DWORD PTR _nLine$[rsp]
  00022	4c 8b 44 24 48	 mov	 r8, QWORD PTR _szFunc$[rsp]
  00027	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@KEHDJCKJ@ERROR?$CB?5?$FL?$CFs?3?$CFd?$FN?5?$CFs?6?$AA@
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szSystemError@@3PADA ; g_szSystemError
  00035	e8 00 00 00 00	 call	 sprintf

; 326  : 	printf(g_szSystemError);

  0003a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szSystemError@@3PADA ; g_szSystemError
  00041	e8 00 00 00 00	 call	 printf

; 327  : }

  00046	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004a	c3		 ret	 0
?comGlobalErrorProc@@YAXPEADPEBDH@Z ENDP		; comGlobalErrorProc
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtypes.h
;	COMDAT ?ISINCLUDE@@YA_NHH@Z
_TEXT	SEGMENT
i$ = 8
max$ = 16
?ISINCLUDE@@YA_NHH@Z PROC				; ISINCLUDE, COMDAT

; 322  : inline bool ISINCLUDE(int i, int max) { if (0 <= i && i < max) return true; return false; }

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	83 7c 24 08 00	 cmp	 DWORD PTR i$[rsp], 0
  0000d	7c 0e		 jl	 SHORT $LN2@ISINCLUDE
  0000f	8b 44 24 10	 mov	 eax, DWORD PTR max$[rsp]
  00013	39 44 24 08	 cmp	 DWORD PTR i$[rsp], eax
  00017	7d 04		 jge	 SHORT $LN2@ISINCLUDE
  00019	b0 01		 mov	 al, 1
  0001b	eb 02		 jmp	 SHORT $LN1@ISINCLUDE
$LN2@ISINCLUDE:
  0001d	32 c0		 xor	 al, al
$LN1@ISINCLUDE:
  0001f	c3		 ret	 0
?ISINCLUDE@@YA_NHH@Z ENDP				; ISINCLUDE
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtypes.h
;	COMDAT ?ISABLETODELETE@@YA_NW4E_ALLOC_TYPE@@@Z
_TEXT	SEGMENT
e$ = 8
?ISABLETODELETE@@YA_NW4E_ALLOC_TYPE@@@Z PROC		; ISABLETODELETE, COMDAT

; 247  : inline bool ISABLETODELETE(E_ALLOC_TYPE e) { if (eAlloc_Type_MemPool < e) return true; return false; }

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	83 7c 24 08 01	 cmp	 DWORD PTR e$[rsp], 1
  00009	7e 04		 jle	 SHORT $LN2@ISABLETODE
  0000b	b0 01		 mov	 al, 1
  0000d	eb 02		 jmp	 SHORT $LN1@ISABLETODE
$LN2@ISABLETODE:
  0000f	32 c0		 xor	 al, al
$LN1@ISABLETODE:
  00011	c3		 ret	 0
?ISABLETODELETE@@YA_NW4E_ALLOC_TYPE@@@Z ENDP		; ISABLETODELETE
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__flags$ = 72
??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z PROC		; common::win32::win64_atomic::`vector deleting destructor', COMDAT
$LN6:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  0000d	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00016	8b 44 24 48	 mov	 eax, DWORD PTR __flags$[rsp]
  0001a	83 e0 02	 and	 eax, 2
  0001d	85 c0		 test	 eax, eax
  0001f	74 59		 je	 SHORT $LN2@vector
  00021	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??1win64_atomic@win32@common@@QEAA@XZ ; common::win32::win64_atomic::~win64_atomic
  00028	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0002d	4c 8b 40 f8	 mov	 r8, QWORD PTR [rax-8]
  00031	ba 08 00 00 00	 mov	 edx, 8
  00036	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0003b	e8 00 00 00 00	 call	 ??_M@YAXPEAX_K1P6AX0@Z@Z
  00040	90		 npad	 1
  00041	8b 44 24 48	 mov	 eax, DWORD PTR __flags$[rsp]
  00045	83 e0 01	 and	 eax, 1
  00048	85 c0		 test	 eax, eax
  0004a	74 23		 je	 SHORT $LN3@vector
  0004c	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00051	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  00055	48 8d 04 c5 08
	00 00 00	 lea	 rax, QWORD PTR [rax*8+8]
  0005d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00062	48 83 e9 08	 sub	 rcx, 8
  00066	48 8b d0	 mov	 rdx, rax
  00069	e8 00 00 00 00	 call	 ??_V@YAXPEAX_K@Z	; operator delete[]
  0006e	90		 npad	 1
$LN3@vector:
  0006f	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00074	48 83 e8 08	 sub	 rax, 8
  00078	eb 2b		 jmp	 SHORT $LN1@vector
$LN2@vector:
  0007a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0007f	e8 00 00 00 00	 call	 ??1win64_atomic@win32@common@@QEAA@XZ ; common::win32::win64_atomic::~win64_atomic
  00084	90		 npad	 1
  00085	8b 44 24 48	 mov	 eax, DWORD PTR __flags$[rsp]
  00089	83 e0 01	 and	 eax, 1
  0008c	85 c0		 test	 eax, eax
  0008e	74 10		 je	 SHORT $LN4@vector
  00090	ba 08 00 00 00	 mov	 edx, 8
  00095	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0009a	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  0009f	90		 npad	 1
$LN4@vector:
  000a0	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
$LN1@vector:
  000a5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a9	c3		 ret	 0
??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z ENDP		; common::win32::win64_atomic::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ?atomic_compare_exchange@win64_atomic@win32@common@@QEAA_J_J0@Z
_TEXT	SEGMENT
tv70 = 0
this$ = 32
nExchange$ = 40
nComperand$ = 48
?atomic_compare_exchange@win64_atomic@win32@common@@QEAA_J_J0@Z PROC ; common::win32::win64_atomic::atomic_compare_exchange, COMDAT

; 120  : 	inline long long atomic_compare_exchange(long long nExchange, long long nComperand) {return InterlockedCompareExchange64(&m_count, nExchange, nComperand);} // return long

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 18	 sub	 rsp, 24
  00013	48 8b 44 24 20	 mov	 rax, QWORD PTR this$[rsp]
  00018	48 8b 4c 24 28	 mov	 rcx, QWORD PTR nExchange$[rsp]
  0001d	48 89 04 24	 mov	 QWORD PTR tv70[rsp], rax
  00021	48 8b 44 24 30	 mov	 rax, QWORD PTR nComperand$[rsp]
  00026	48 8b 14 24	 mov	 rdx, QWORD PTR tv70[rsp]
  0002a	48 8b 14 24	 mov	 rdx, QWORD PTR tv70[rsp]
  0002e	f0 48 0f b1 0a	 lock cmpxchg QWORD PTR [rdx], rcx
  00033	48 83 c4 18	 add	 rsp, 24
  00037	c3		 ret	 0
?atomic_compare_exchange@win64_atomic@win32@common@@QEAA_J_J0@Z ENDP ; common::win32::win64_atomic::atomic_compare_exchange
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ?atomic_decrement@win64_atomic@win32@common@@QEAA_JXZ
_TEXT	SEGMENT
this$ = 8
?atomic_decrement@win64_atomic@win32@common@@QEAA_JXZ PROC ; common::win32::win64_atomic::atomic_decrement, COMDAT

; 118  : 	inline long long atomic_decrement() { return InterlockedDecrement64(&m_count);}

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  00011	f0 48 0f c1 08	 lock xadd QWORD PTR [rax], rcx
  00016	48 ff c9	 dec	 rcx
  00019	48 8b c1	 mov	 rax, rcx
  0001c	c3		 ret	 0
?atomic_decrement@win64_atomic@win32@common@@QEAA_JXZ ENDP ; common::win32::win64_atomic::atomic_decrement
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ?atomic_increment@win64_atomic@win32@common@@QEAA_JXZ
_TEXT	SEGMENT
this$ = 8
?atomic_increment@win64_atomic@win32@common@@QEAA_JXZ PROC ; common::win32::win64_atomic::atomic_increment, COMDAT

; 117  : 	inline long long atomic_increment() { return InterlockedIncrement64(&m_count);}

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	b9 01 00 00 00	 mov	 ecx, 1
  0000f	f0 48 0f c1 08	 lock xadd QWORD PTR [rax], rcx
  00014	48 ff c1	 inc	 rcx
  00017	48 8b c1	 mov	 rax, rcx
  0001a	c3		 ret	 0
?atomic_increment@win64_atomic@win32@common@@QEAA_JXZ ENDP ; common::win32::win64_atomic::atomic_increment
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ?init@win64_atomic@win32@common@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?init@win64_atomic@win32@common@@QEAAXXZ PROC		; common::win32::win64_atomic::init, COMDAT

; 114  : 	inline void init() { m_count = 0; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  00011	c3		 ret	 0
?init@win64_atomic@win32@common@@QEAAXXZ ENDP		; common::win32::win64_atomic::init
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ?setCount@win64_atomic@win32@common@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 8
nVal$ = 16
?setCount@win64_atomic@win32@common@@QEAAXH@Z PROC	; common::win32::win64_atomic::setCount, COMDAT

; 113  : 	inline void setCount(int nVal) { m_count = (long long)nVal; }

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 63 44 24 10	 movsxd	 rax, DWORD PTR nVal$[rsp]
  0000e	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  00013	48 89 01	 mov	 QWORD PTR [rcx], rax
  00016	c3		 ret	 0
?setCount@win64_atomic@win32@common@@QEAAXH@Z ENDP	; common::win32::win64_atomic::setCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ?getCount@win64_atomic@win32@common@@QEAAHXZ
_TEXT	SEGMENT
this$ = 8
?getCount@win64_atomic@win32@common@@QEAAHXZ PROC	; common::win32::win64_atomic::getCount, COMDAT

; 111  : 	inline int getCount() { return (int)m_count; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0000d	c3		 ret	 0
?getCount@win64_atomic@win32@common@@QEAAHXZ ENDP	; common::win32::win64_atomic::getCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ??1win64_atomic@win32@common@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1win64_atomic@win32@common@@QEAA@XZ PROC		; common::win32::win64_atomic::~win64_atomic, COMDAT

; 108  : 	~win64_atomic() {}

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	c3		 ret	 0
??1win64_atomic@win32@common@@QEAA@XZ ENDP		; common::win32::win64_atomic::~win64_atomic
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ??0win64_atomic@win32@common@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0win64_atomic@win32@common@@QEAA@XZ PROC		; common::win32::win64_atomic::win64_atomic, COMDAT

; 107  : 	win64_atomic() {m_count = 0;}

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  00011	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00016	c3		 ret	 0
??0win64_atomic@win32@common@@QEAA@XZ ENDP		; common::win32::win64_atomic::win64_atomic
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gcondition@win32@common@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gcondition@win32@common@@UEAAPEAXI@Z PROC		; common::win32::condition::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00012	e8 00 00 00 00	 call	 ??1condition@win32@common@@UEAA@XZ ; common::win32::condition::~condition
  00017	8b 44 24 38	 mov	 eax, DWORD PTR __flags$[rsp]
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 0f		 je	 SHORT $LN2@scalar
  00022	ba 10 00 00 00	 mov	 edx, 16
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
??_Gcondition@win32@common@@UEAAPEAXI@Z ENDP		; common::win32::condition::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ?wait@condition@win32@common@@QEAA_NHPEAVcritical_section@23@@Z
_TEXT	SEGMENT
rv$ = 32
tv65 = 36
tv80 = 40
timeout$ = 44
this$ = 64
milliseconds$ = 72
p$ = 80
?wait@condition@win32@common@@QEAA_NHPEAVcritical_section@23@@Z PROC ; common::win32::condition::wait, COMDAT

; 71   : 	  {

$LN9:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 72   : 			DWORD timeout = milliseconds < 0 ? INFINITE : milliseconds;

  00012	83 7c 24 48 00	 cmp	 DWORD PTR milliseconds$[rsp], 0
  00017	7d 0a		 jge	 SHORT $LN5@wait
  00019	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR tv65[rsp], -1	; ffffffffH
  00021	eb 08		 jmp	 SHORT $LN6@wait
$LN5@wait:
  00023	8b 44 24 48	 mov	 eax, DWORD PTR milliseconds$[rsp]
  00027	89 44 24 24	 mov	 DWORD PTR tv65[rsp], eax
$LN6@wait:
  0002b	8b 44 24 24	 mov	 eax, DWORD PTR tv65[rsp]
  0002f	89 44 24 2c	 mov	 DWORD PTR timeout$[rsp], eax

; 73   : 			if(p) p->enter();

  00033	48 83 7c 24 50
	00		 cmp	 QWORD PTR p$[rsp], 0
  00039	74 12		 je	 SHORT $LN2@wait
  0003b	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  00040	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00043	b2 01		 mov	 dl, 1
  00045	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p$[rsp]
  0004a	ff 50 08	 call	 QWORD PTR [rax+8]
$LN2@wait:

; 74   : 			bool rv = WaitForSingleObject(m_event, timeout) == WAIT_OBJECT_0;

  0004d	8b 54 24 2c	 mov	 edx, DWORD PTR timeout$[rsp]
  00051	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00056	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject
  00060	85 c0		 test	 eax, eax
  00062	75 0a		 jne	 SHORT $LN7@wait
  00064	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv80[rsp], 1
  0006c	eb 08		 jmp	 SHORT $LN8@wait
$LN7@wait:
  0006e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
$LN8@wait:
  00076	0f b6 44 24 28	 movzx	 eax, BYTE PTR tv80[rsp]
  0007b	88 44 24 20	 mov	 BYTE PTR rv$[rsp], al

; 75   : 			ResetEvent(m_event);

  0007f	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00084	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00088	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ResetEvent

; 76   : 			if(p) p->leave();

  0008e	48 83 7c 24 50
	00		 cmp	 QWORD PTR p$[rsp], 0
  00094	74 10		 je	 SHORT $LN3@wait
  00096	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  0009b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0009e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p$[rsp]
  000a3	ff 50 10	 call	 QWORD PTR [rax+16]
$LN3@wait:

; 77   : 			return rv;

  000a6	0f b6 44 24 20	 movzx	 eax, BYTE PTR rv$[rsp]

; 78   : 	  }

  000ab	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000af	c3		 ret	 0
?wait@condition@win32@common@@QEAA_NHPEAVcritical_section@23@@Z ENDP ; common::win32::condition::wait
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ?signal_all@condition@win32@common@@UEAAXXZ
_TEXT	SEGMENT
this$ = 48
?signal_all@condition@win32@common@@UEAAXXZ PROC	; common::win32::condition::signal_all, COMDAT

; 67   : 	  void signal_all() { abort(); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_abort
$LN2@signal_all:
  0000f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00013	c3		 ret	 0
?signal_all@condition@win32@common@@UEAAXXZ ENDP	; common::win32::condition::signal_all
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ?signal@condition@win32@common@@UEAAXXZ
_TEXT	SEGMENT
this$ = 48
?signal@condition@win32@common@@UEAAXXZ PROC		; common::win32::condition::signal, COMDAT

; 66   : 	  void signal() { SetEvent(m_event); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00012	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetEvent
  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001c	c3		 ret	 0
?signal@condition@win32@common@@UEAAXXZ ENDP		; common::win32::condition::signal
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ??1condition@win32@common@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1condition@win32@common@@UEAA@XZ PROC			; common::win32::condition::~condition, COMDAT

; 64   : 	  ~condition() { CloseHandle(m_event); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7condition@win32@common@@6B@
  00015	48 89 08	 mov	 QWORD PTR [rax], rcx
  00018	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0001d	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002c	e8 00 00 00 00	 call	 ??1abstract_condition@common@@UEAA@XZ ; common::abstract_condition::~abstract_condition
  00031	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00035	c3		 ret	 0
??1condition@win32@common@@UEAA@XZ ENDP			; common::win32::condition::~condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ??0condition@win32@common@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0condition@win32@common@@QEAA@XZ PROC			; common::win32::condition::condition, COMDAT

; 63   : 	  condition() { m_event = CreateEvent(NULL, TRUE, FALSE, NULL);}

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0000e	e8 00 00 00 00	 call	 ??0abstract_condition@common@@QEAA@XZ
  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7condition@win32@common@@6B@
  0001f	48 89 08	 mov	 QWORD PTR [rax], rcx
  00022	45 33 c9	 xor	 r9d, r9d
  00025	45 33 c0	 xor	 r8d, r8d
  00028	ba 01 00 00 00	 mov	 edx, 1
  0002d	33 c9		 xor	 ecx, ecx
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateEventA
  00035	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0003a	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  0003e	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00043	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00047	c3		 ret	 0
??0condition@win32@common@@QEAA@XZ ENDP			; common::win32::condition::condition
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gabstract_condition@common@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gabstract_condition@common@@UEAAPEAXI@Z PROC		; common::abstract_condition::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00012	e8 00 00 00 00	 call	 ??1abstract_condition@common@@UEAA@XZ ; common::abstract_condition::~abstract_condition
  00017	8b 44 24 38	 mov	 eax, DWORD PTR __flags$[rsp]
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 0f		 je	 SHORT $LN2@scalar
  00022	ba 08 00 00 00	 mov	 edx, 8
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
??_Gabstract_condition@common@@UEAAPEAXI@Z ENDP		; common::abstract_condition::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0abstract_condition@common@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0abstract_condition@common@@QEAA@XZ PROC		; common::abstract_condition::abstract_condition, COMDAT
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7abstract_condition@common@@6B@
  00011	48 89 08	 mov	 QWORD PTR [rax], rcx
  00014	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00019	c3		 ret	 0
??0abstract_condition@common@@QEAA@XZ ENDP		; common::abstract_condition::abstract_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\com\abstract_mtsync.h
;	COMDAT ??1abstract_condition@common@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1abstract_condition@common@@UEAA@XZ PROC		; common::abstract_condition::~abstract_condition, COMDAT

; 72   : 	virtual ~abstract_condition() {}

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7abstract_condition@common@@6B@
  00011	48 89 08	 mov	 QWORD PTR [rax], rcx
  00014	c3		 ret	 0
??1abstract_condition@common@@UEAA@XZ ENDP		; common::abstract_condition::~abstract_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
__$ArrayPad$ = 48
_Buffer$ = 80
_Format$ = 88
sprintf	PROC						; COMDAT

; 1776 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 44 24 30	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

  00027	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
  0002c	48 8d 44 24 60	 lea	 rax, QWORD PTR _Format$[rsp+8]
  00031	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  00036	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  0003b	45 33 c0	 xor	 r8d, r8d
  0003e	48 8b 54 24 58	 mov	 rdx, QWORD PTR _Format$[rsp]
  00043	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00048	e8 00 00 00 00	 call	 _vsprintf_l
  0004d	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

  00051	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 1787 :     return _Result;

  0005a	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 1788 : }

  0005e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00063	48 33 cc	 xor	 rcx, rsp
  00066	e8 00 00 00 00	 call	 __security_check_cookie
  0006b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0006f	c3		 ret	 0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1455 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00018	48 8b 44 24 58	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00022	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  00027	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  0002c	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  00033	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00038	e8 00 00 00 00	 call	 _vsnprintf_l

; 1459 :     #pragma warning(pop)
; 1460 : }

  0003d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00041	c3		 ret	 0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1385 : {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00020	48 83 c8 01	 or	 rax, 1
  00024	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00029	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0002e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00033	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00038	4c 8b 4c 24 60	 mov	 r9, QWORD PTR _Format$[rsp]
  0003d	4c 8b 44 24 58	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  00042	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00047	48 8b c8	 mov	 rcx, rax
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsprintf
  00050	89 44 24 30	 mov	 DWORD PTR _Result$[rsp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00054	83 7c 24 30 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00059	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  0005b	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  00063	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00065	8b 44 24 30	 mov	 eax, DWORD PTR _Result$[rsp]
  00069	89 44 24 34	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  0006d	8b 44 24 34	 mov	 eax, DWORD PTR tv74[rsp]

; 1391 : }

  00071	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00075	c3		 ret	 0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
__$ArrayPad$ = 48
_Format$ = 80
printf	PROC						; COMDAT

; 950  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 44 24 30	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 951  :     int _Result;
; 952  :     va_list _ArgList;
; 953  :     __crt_va_start(_ArgList, _Format);

  00027	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
  0002c	48 8d 44 24 58	 lea	 rax, QWORD PTR _Format$[rsp+8]
  00031	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 954  :     _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00036	b9 01 00 00 00	 mov	 ecx, 1
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00041	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00046	45 33 c0	 xor	 r8d, r8d
  00049	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Format$[rsp]
  0004e	48 8b c8	 mov	 rcx, rax
  00051	e8 00 00 00 00	 call	 _vfprintf_l
  00056	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 955  :     __crt_va_end(_ArgList);

  0005a	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 956  :     return _Result;

  00063	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 957  : }

  00067	48 8b 4c 24 30	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0006c	48 33 cc	 xor	 rcx, rsp
  0006f	e8 00 00 00 00	 call	 __security_check_cookie
  00074	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00078	c3		 ret	 0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ PROC ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ENDP ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 638  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00027	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  0002c	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00031	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Stream$[rsp]
  00036	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vfprintf

; 640  : }

  0003f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00043	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
