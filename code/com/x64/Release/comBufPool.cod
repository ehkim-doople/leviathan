; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?g_nSizeList@@3QBHB				; g_nSizeList
CONST	SEGMENT
$SG44498 DB	'new m_nFlagArray', 00H
	ORG $+7
$SG44499 DB	'CBufPool::alloc', 00H
$SG44501 DB	'm_pChunk alloc', 00H
	ORG $+1
$SG44502 DB	'CBufPool::alloc', 00H
$SG44594 DB	'm_nFlagArray alloc', 00H
	ORG $+5
$SG44595 DB	'CSBufPool::alloc', 00H
	ORG $+7
$SG44597 DB	'm_pChunk alloc', 00H
	ORG $+1
$SG44598 DB	'CSBufPool::alloc', 00H
	ORG $+7
$SG44599 DB	'mem allock list m_nAllocCount[%d]', 00H
	ORG $+14
?g_nSizeList@@3QBHB DD 01H				; g_nSizeList
	DD	02H
	DD	04H
	DD	08H
	DD	010H
	DD	020H
	DD	040H
	DD	080H
	DD	0100H
	DD	0200H
	DD	0400H
	DD	0800H
	DD	01000H
	DD	02000H
	DD	03fdcH
	DD	08000H
	DD	010000H
	DD	020000H
	DD	040000H
	DD	080000H
	DD	0100000H
	DD	0200000H
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	sprintf
PUBLIC	??0win64_atomic@win32@common@@QEAA@XZ		; common::win32::win64_atomic::win64_atomic
PUBLIC	??1win64_atomic@win32@common@@QEAA@XZ		; common::win32::win64_atomic::~win64_atomic
PUBLIC	?getCount@win64_atomic@win32@common@@QEAAHXZ	; common::win32::win64_atomic::getCount
PUBLIC	?init@win64_atomic@win32@common@@QEAAXXZ	; common::win32::win64_atomic::init
PUBLIC	?atomic_increment@win64_atomic@win32@common@@QEAA_JXZ ; common::win32::win64_atomic::atomic_increment
PUBLIC	?atomic_decrement@win64_atomic@win32@common@@QEAA_JXZ ; common::win32::win64_atomic::atomic_decrement
PUBLIC	?atomic_compare_exchange@win64_atomic@win32@common@@QEAA_J_J0@Z ; common::win32::win64_atomic::atomic_compare_exchange
PUBLIC	??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z	; common::win32::win64_atomic::`vector deleting destructor'
PUBLIC	?isBitSet_flag@@YA_NHPEAD@Z			; isBitSet_flag
PUBLIC	?bitClear_flag@@YAXHPEAD@Z			; bitClear_flag
PUBLIC	?bitSet_flag@@YAXHPEAD@Z			; bitSet_flag
PUBLIC	?ISINCLUDE@@YA_NHH@Z				; ISINCLUDE
PUBLIC	?getSizeByIndex@@YAHH@Z				; getSizeByIndex
PUBLIC	??0CBufPool@@QEAA@XZ				; CBufPool::CBufPool
PUBLIC	??1CBufPool@@QEAA@XZ				; CBufPool::~CBufPool
PUBLIC	?clear@CBufPool@@QEAAXXZ			; CBufPool::clear
PUBLIC	?alloc@CBufPool@@QEAA_NHH@Z			; CBufPool::alloc
PUBLIC	?newMem@CBufPool@@QEAAPEADXZ			; CBufPool::newMem
PUBLIC	?delMem@CBufPool@@QEAAXPEAD@Z			; CBufPool::delMem
PUBLIC	?newMemList@CBufPool@@QEAA_NH@Z			; CBufPool::newMemList
PUBLIC	?delMem@CBufPool@@QEAAXPEADH@Z			; CBufPool::delMem
PUBLIC	?ISINCLUDE_ADDRESS@CBufPool@@QEAA_NPEAD@Z	; CBufPool::ISINCLUDE_ADDRESS
PUBLIC	??0CSBufPool@@QEAA@XZ				; CSBufPool::CSBufPool
PUBLIC	??1CSBufPool@@QEAA@XZ				; CSBufPool::~CSBufPool
PUBLIC	?clear@CSBufPool@@QEAAXXZ			; CSBufPool::clear
PUBLIC	?alloc@CSBufPool@@QEAA_NHH@Z			; CSBufPool::alloc
PUBLIC	?destroy@CSBufPool@@QEAAXXZ			; CSBufPool::destroy
PUBLIC	?newMem@CSBufPool@@QEAAPEADPEAH@Z		; CSBufPool::newMem
PUBLIC	?delMem@CSBufPool@@QEAA_NPEAD@Z			; CSBufPool::delMem
PUBLIC	?delMemByIdx@CSBufPool@@QEAA_NPEADH@Z		; CSBufPool::delMemByIdx
PUBLIC	?newMemList@CSBufPool@@QEAA_NH@Z		; CSBufPool::newMemList
PUBLIC	?delMem@CSBufPool@@QEAA_NPEADH@Z		; CSBufPool::delMem
PUBLIC	?ISINCLUDE_ADDRESS@CSBufPool@@QEAA_NPEAD@Z	; CSBufPool::ISINCLUDE_ADDRESS
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
EXTRN	??_L@YAXPEAX_K1P6AX0@Z2@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YAXPEAX_K1P6AX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	??_V@YAXPEAX_K@Z:PROC				; operator delete[]
EXTRN	__imp___stdio_common_vsprintf:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	??_U@YAPEAX_KAEBUnothrow_t@std@@@Z:PROC		; operator new[]
EXTRN	??_V@YAXPEAXAEBUnothrow_t@std@@@Z:PROC		; operator delete[]
EXTRN	?__debugLog@CLogger@@QEAAXHPEBDH0ZZ:PROC	; CLogger::__debugLog
EXTRN	__CxxFrameHandler3:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	?nothrow@std@@3Unothrow_t@1@B:BYTE		; std::nothrow
EXTRN	?g_szMessage@@3PADA:BYTE			; g_szMessage
EXTRN	?gs_cLogger@@3VCLogger@@A:BYTE			; gs_cLogger
EXTRN	__security_cookie:QWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+118
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+112
	DD	imagerel $unwind$sprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?atomic_compare_exchange@win64_atomic@win32@common@@QEAA_J_J0@Z DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$?atomic_compare_exchange@win64_atomic@win32@common@@QEAA_J_J0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z DD imagerel $LN6
	DD	imagerel $LN6+170
	DD	imagerel $unwind$??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isBitSet_flag@@YA_NHPEAD@Z DD imagerel $LN5
	DD	imagerel $LN5+63
	DD	imagerel $unwind$?isBitSet_flag@@YA_NHPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0CBufPool@@QEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+158
	DD	imagerel $unwind$??0CBufPool@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0CBufPool@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0CBufPool@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0CBufPool@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???0CBufPool@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1CBufPool@@QEAA@XZ DD imagerel $LN7
	DD	imagerel $LN7+173
	DD	imagerel $unwind$??1CBufPool@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@CBufPool@@QEAAXXZ DD imagerel $LN6
	DD	imagerel $LN6+153
	DD	imagerel $unwind$?clear@CBufPool@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?alloc@CBufPool@@QEAA_NHH@Z DD imagerel $LN13
	DD	imagerel $LN13+702
	DD	imagerel $unwind$?alloc@CBufPool@@QEAA_NHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??alloc@CBufPool@@QEAA_NHH@Z@4HA DD imagerel ?dtor$0@?0??alloc@CBufPool@@QEAA_NHH@Z@4HA
	DD	imagerel ?dtor$0@?0??alloc@CBufPool@@QEAA_NHH@Z@4HA+31
	DD	imagerel $unwind$?dtor$0@?0??alloc@CBufPool@@QEAA_NHH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?newMem@CBufPool@@QEAAPEADXZ DD imagerel $LN11
	DD	imagerel $LN11+395
	DD	imagerel $unwind$?newMem@CBufPool@@QEAAPEADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?delMem@CBufPool@@QEAAXPEAD@Z DD imagerel $LN5
	DD	imagerel $LN5+180
	DD	imagerel $unwind$?delMem@CBufPool@@QEAAXPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?newMemList@CBufPool@@QEAA_NH@Z DD imagerel $LN17
	DD	imagerel $LN17+378
	DD	imagerel $unwind$?newMemList@CBufPool@@QEAA_NH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?delMem@CBufPool@@QEAAXPEADH@Z DD imagerel $LN9
	DD	imagerel $LN9+250
	DD	imagerel $unwind$?delMem@CBufPool@@QEAAXPEADH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0CSBufPool@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+106
	DD	imagerel $unwind$??0CSBufPool@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1CSBufPool@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$??1CSBufPool@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@CSBufPool@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+111
	DD	imagerel $unwind$?clear@CSBufPool@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?alloc@CSBufPool@@QEAA_NHH@Z DD imagerel $LN5
	DD	imagerel $LN5+349
	DD	imagerel $unwind$?alloc@CSBufPool@@QEAA_NHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?destroy@CSBufPool@@QEAAXXZ DD imagerel $LN5
	DD	imagerel $LN5+94
	DD	imagerel $unwind$?destroy@CSBufPool@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?newMem@CSBufPool@@QEAAPEADPEAH@Z DD imagerel $LN12
	DD	imagerel $LN12+366
	DD	imagerel $unwind$?newMem@CSBufPool@@QEAAPEADPEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?delMem@CSBufPool@@QEAA_NPEAD@Z DD imagerel $LN5
	DD	imagerel $LN5+162
	DD	imagerel $unwind$?delMem@CSBufPool@@QEAA_NPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?delMemByIdx@CSBufPool@@QEAA_NPEADH@Z DD imagerel $LN5
	DD	imagerel $LN5+144
	DD	imagerel $unwind$?delMemByIdx@CSBufPool@@QEAA_NPEADH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?newMemList@CSBufPool@@QEAA_NH@Z DD imagerel $LN15
	DD	imagerel $LN15+270
	DD	imagerel $unwind$?newMemList@CSBufPool@@QEAA_NH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?delMem@CSBufPool@@QEAA_NPEADH@Z DD imagerel $LN9
	DD	imagerel $LN9+221
	DD	imagerel $unwind$?delMem@CSBufPool@@QEAA_NPEADH@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?delMem@CSBufPool@@QEAA_NPEADH@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?newMemList@CSBufPool@@QEAA_NH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?delMemByIdx@CSBufPool@@QEAA_NPEADH@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?delMem@CSBufPool@@QEAA_NPEAD@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?newMem@CSBufPool@@QEAAPEADPEAH@Z DD 020f01H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?destroy@CSBufPool@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?alloc@CSBufPool@@QEAA_NHH@Z DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@CSBufPool@@QEAAXXZ DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1CSBufPool@@QEAA@XZ DD imagerel ??1CSBufPool@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1CSBufPool@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1CSBufPool@@QEAA@XZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1CSBufPool@@QEAA@XZ DD 011219H
	DD	06209H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1CSBufPool@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0CSBufPool@@QEAA@XZ DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?delMem@CBufPool@@QEAAXPEADH@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?newMemList@CBufPool@@QEAA_NH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?delMem@CBufPool@@QEAAXPEAD@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?newMem@CBufPool@@QEAAPEADXZ DD 020a01H
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??alloc@CBufPool@@QEAA_NHH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?alloc@CBufPool@@QEAA_NHH@Z DD imagerel ?alloc@CBufPool@@QEAA_NHH@Z
	DD	0ffffffffH
	DD	imagerel ?alloc@CBufPool@@QEAA_NHH@Z+96
	DD	00H
	DD	imagerel ?alloc@CBufPool@@QEAA_NHH@Z+198
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?alloc@CBufPool@@QEAA_NHH@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??alloc@CBufPool@@QEAA_NHH@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?alloc@CBufPool@@QEAA_NHH@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?alloc@CBufPool@@QEAA_NHH@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?alloc@CBufPool@@QEAA_NHH@Z
	DD	068H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?alloc@CBufPool@@QEAA_NHH@Z DD 011b11H
	DD	0e212H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?alloc@CBufPool@@QEAA_NHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@CBufPool@@QEAAXXZ DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1CBufPool@@QEAA@XZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0CBufPool@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0CBufPool@@QEAA@XZ DD imagerel ??0CBufPool@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??0CBufPool@@QEAA@XZ+37
	DD	00H
	DD	imagerel ??0CBufPool@@QEAA@XZ+147
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0CBufPool@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0CBufPool@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0CBufPool@@QEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0CBufPool@@QEAA@XZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??0CBufPool@@QEAA@XZ
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0CBufPool@@QEAA@XZ DD 021311H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0CBufPool@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isBitSet_flag@@YA_NHPEAD@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z DD imagerel ??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z DD 011619H
	DD	0620dH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?atomic_compare_exchange@win64_atomic@win32@common@@QEAA_J_J0@Z DD 011301H
	DD	02213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 012719H
	DD	08218H
	DD	imagerel __GSHandlerCheck
	DD	030H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 011801H
	DD	08218H
xdata	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\combufpool.h
;	COMDAT ?ISINCLUDE_ADDRESS@CSBufPool@@QEAA_NPEAD@Z
_TEXT	SEGMENT
this$ = 8
p$ = 16
?ISINCLUDE_ADDRESS@CSBufPool@@QEAA_NPEAD@Z PROC		; CSBufPool::ISINCLUDE_ADDRESS, COMDAT

; 131  : 	inline bool ISINCLUDE_ADDRESS(char *p) { if (m_pChunk <= p && p <= m_pEnd) return true; return false; }

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR p$[rsp]
  00014	48 39 48 18	 cmp	 QWORD PTR [rax+24], rcx
  00018	77 14		 ja	 SHORT $LN2@ISINCLUDE_
  0001a	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0001f	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00023	48 39 44 24 10	 cmp	 QWORD PTR p$[rsp], rax
  00028	77 04		 ja	 SHORT $LN2@ISINCLUDE_
  0002a	b0 01		 mov	 al, 1
  0002c	eb 02		 jmp	 SHORT $LN1@ISINCLUDE_
$LN2@ISINCLUDE_:
  0002e	32 c0		 xor	 al, al
$LN1@ISINCLUDE_:
  00030	c3		 ret	 0
?ISINCLUDE_ADDRESS@CSBufPool@@QEAA_NPEAD@Z ENDP		; CSBufPool::ISINCLUDE_ADDRESS
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\combufpool.cpp
;	COMDAT ?delMem@CSBufPool@@QEAA_NPEADH@Z
_TEXT	SEGMENT
nIdx$ = 32
i$ = 36
nPos$ = 40
this$ = 64
pUsedMem$ = 72
nCount$ = 80
?delMem@CSBufPool@@QEAA_NPEADH@Z PROC			; CSBufPool::delMem, COMDAT

; 365  : {

$LN9:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 366  : 	int nPos = (int)(pUsedMem - m_pChunk);

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00018	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0001c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pUsedMem$[rsp]
  00021	48 2b c8	 sub	 rcx, rax
  00024	48 8b c1	 mov	 rax, rcx
  00027	89 44 24 28	 mov	 DWORD PTR nPos$[rsp], eax

; 367  : 	int nIdx = nPos >> m_nShift;

  0002b	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00030	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00033	0f b6 c8	 movzx	 ecx, al
  00036	8b 44 24 28	 mov	 eax, DWORD PTR nPos$[rsp]
  0003a	d3 f8		 sar	 eax, cl
  0003c	89 44 24 20	 mov	 DWORD PTR nIdx$[rsp], eax

; 368  : 	int i;
; 369  : 
; 370  : 	if (pUsedMem != &m_pChunk[nPos]) return false;

  00040	48 63 44 24 28	 movsxd	 rax, DWORD PTR nPos$[rsp]
  00045	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0004a	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0004e	48 03 c8	 add	 rcx, rax
  00051	48 8b c1	 mov	 rax, rcx
  00054	48 39 44 24 48	 cmp	 QWORD PTR pUsedMem$[rsp], rax
  00059	74 04		 je	 SHORT $LN5@delMem
  0005b	32 c0		 xor	 al, al
  0005d	eb 79		 jmp	 SHORT $LN1@delMem
$LN5@delMem:

; 371  : 	for (i = 0; i < nCount; i++)

  0005f	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00067	eb 0a		 jmp	 SHORT $LN4@delMem
$LN2@delMem:
  00069	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  0006d	ff c0		 inc	 eax
  0006f	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@delMem:
  00073	8b 44 24 50	 mov	 eax, DWORD PTR nCount$[rsp]
  00077	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  0007b	7d 59		 jge	 SHORT $LN3@delMem

; 372  : 	{
; 373  : 		if (nIdx >= m_nAllocCount) return false;

  0007d	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00082	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00085	39 44 24 20	 cmp	 DWORD PTR nIdx$[rsp], eax
  00089	7c 04		 jl	 SHORT $LN6@delMem
  0008b	32 c0		 xor	 al, al
  0008d	eb 49		 jmp	 SHORT $LN1@delMem
$LN6@delMem:

; 374  : 		//printf("CBufPool::delMem nPos[%d] nIdx[%d] nShift[%d] pMem[%p]\n", nPos, nIdx, nShift, pUsedMem);
; 375  : 		if (isBitSet_flag(nIdx, m_nFlagArray))

  0008f	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00094	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00098	8b 4c 24 20	 mov	 ecx, DWORD PTR nIdx$[rsp]
  0009c	e8 00 00 00 00	 call	 ?isBitSet_flag@@YA_NHPEAD@Z ; isBitSet_flag
  000a1	0f b6 c0	 movzx	 eax, al
  000a4	85 c0		 test	 eax, eax
  000a6	74 22		 je	 SHORT $LN7@delMem

; 376  : 		{
; 377  : 			bitClear_flag(nIdx, m_nFlagArray);

  000a8	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000ad	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  000b1	8b 4c 24 20	 mov	 ecx, DWORD PTR nIdx$[rsp]
  000b5	e8 00 00 00 00	 call	 ?bitClear_flag@@YAXHPEAD@Z ; bitClear_flag

; 378  : 			m_nUseCnt--;

  000ba	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000bf	8b 00		 mov	 eax, DWORD PTR [rax]
  000c1	ff c8		 dec	 eax
  000c3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000c8	89 01		 mov	 DWORD PTR [rcx], eax
$LN7@delMem:

; 379  : 		}
; 380  : 		nIdx++;

  000ca	8b 44 24 20	 mov	 eax, DWORD PTR nIdx$[rsp]
  000ce	ff c0		 inc	 eax
  000d0	89 44 24 20	 mov	 DWORD PTR nIdx$[rsp], eax

; 381  : 	}

  000d4	eb 93		 jmp	 SHORT $LN2@delMem
$LN3@delMem:

; 382  : 	return true;

  000d6	b0 01		 mov	 al, 1
$LN1@delMem:

; 383  : }

  000d8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000dc	c3		 ret	 0
?delMem@CSBufPool@@QEAA_NPEADH@Z ENDP			; CSBufPool::delMem
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\combufpool.cpp
;	COMDAT ?newMemList@CSBufPool@@QEAA_NH@Z
_TEXT	SEGMENT
idx$ = 32
nLastLoopCnt$ = 36
i$ = 40
this$ = 64
nCount$ = 72
?newMemList@CSBufPool@@QEAA_NH@Z PROC			; CSBufPool::newMemList, COMDAT

; 333  : {

$LN15:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 334  : 	int i;
; 335  : 	int idx = m_nUseCnt, nLastLoopCnt=0;

  0000d	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00012	8b 00		 mov	 eax, DWORD PTR [rax]
  00014	89 44 24 20	 mov	 DWORD PTR idx$[rsp], eax
  00018	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR nLastLoopCnt$[rsp], 0

; 336  : 
; 337  : 	if (m_nUseCnt == m_nAllocCount) return false;

  00020	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00025	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0002a	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  0002d	39 08		 cmp	 DWORD PTR [rax], ecx
  0002f	75 07		 jne	 SHORT $LN8@newMemList
  00031	32 c0		 xor	 al, al
  00033	e9 d1 00 00 00	 jmp	 $LN1@newMemList
$LN8@newMemList:

; 338  : 
; 339  : 	for (i = 0; i < nCount; i++) {

  00038	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00040	eb 0a		 jmp	 SHORT $LN4@newMemList
$LN2@newMemList:
  00042	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00046	ff c0		 inc	 eax
  00048	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN4@newMemList:
  0004c	8b 44 24 48	 mov	 eax, DWORD PTR nCount$[rsp]
  00050	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  00054	7d 43		 jge	 SHORT $LN3@newMemList

; 340  : 		if (idx >= m_nAllocCount) break;

  00056	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0005b	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0005e	39 44 24 20	 cmp	 DWORD PTR idx$[rsp], eax
  00062	7c 02		 jl	 SHORT $LN9@newMemList
  00064	eb 33		 jmp	 SHORT $LN3@newMemList
$LN9@newMemList:

; 341  : 		if (!isBitSet_flag(idx, m_nFlagArray))

  00066	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0006b	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0006f	8b 4c 24 20	 mov	 ecx, DWORD PTR idx$[rsp]
  00073	e8 00 00 00 00	 call	 ?isBitSet_flag@@YA_NHPEAD@Z ; isBitSet_flag
  00078	0f b6 c0	 movzx	 eax, al
  0007b	85 c0		 test	 eax, eax
  0007d	75 0c		 jne	 SHORT $LN10@newMemList

; 342  : 		{
; 343  : 			nLastLoopCnt++;

  0007f	8b 44 24 24	 mov	 eax, DWORD PTR nLastLoopCnt$[rsp]
  00083	ff c0		 inc	 eax
  00085	89 44 24 24	 mov	 DWORD PTR nLastLoopCnt$[rsp], eax

; 344  : 		}
; 345  : 		else break;

  00089	eb 02		 jmp	 SHORT $LN11@newMemList
$LN10@newMemList:
  0008b	eb 0c		 jmp	 SHORT $LN3@newMemList
$LN11@newMemList:

; 346  : 		idx++;

  0008d	8b 44 24 20	 mov	 eax, DWORD PTR idx$[rsp]
  00091	ff c0		 inc	 eax
  00093	89 44 24 20	 mov	 DWORD PTR idx$[rsp], eax

; 347  : 	}

  00097	eb a9		 jmp	 SHORT $LN2@newMemList
$LN3@newMemList:

; 348  : 
; 349  : 	if (nLastLoopCnt == nCount) {

  00099	8b 44 24 48	 mov	 eax, DWORD PTR nCount$[rsp]
  0009d	39 44 24 24	 cmp	 DWORD PTR nLastLoopCnt$[rsp], eax
  000a1	75 16		 jne	 SHORT $LN12@newMemList

; 350  : 		m_nUseCnt += nCount;

  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000a8	8b 00		 mov	 eax, DWORD PTR [rax]
  000aa	03 44 24 48	 add	 eax, DWORD PTR nCount$[rsp]
  000ae	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000b3	89 01		 mov	 DWORD PTR [rcx], eax

; 351  : 		return true;

  000b5	b0 01		 mov	 al, 1
  000b7	eb 50		 jmp	 SHORT $LN1@newMemList
$LN12@newMemList:

; 352  : 	}
; 353  : 
; 354  : 	for (idx = m_nUseCnt; idx < nLastLoopCnt; idx++) {

  000b9	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000be	8b 00		 mov	 eax, DWORD PTR [rax]
  000c0	89 44 24 20	 mov	 DWORD PTR idx$[rsp], eax
  000c4	eb 0a		 jmp	 SHORT $LN7@newMemList
$LN5@newMemList:
  000c6	8b 44 24 20	 mov	 eax, DWORD PTR idx$[rsp]
  000ca	ff c0		 inc	 eax
  000cc	89 44 24 20	 mov	 DWORD PTR idx$[rsp], eax
$LN7@newMemList:
  000d0	8b 44 24 24	 mov	 eax, DWORD PTR nLastLoopCnt$[rsp]
  000d4	39 44 24 20	 cmp	 DWORD PTR idx$[rsp], eax
  000d8	7d 2d		 jge	 SHORT $LN6@newMemList

; 355  : 		if (isBitSet_flag(idx, m_nFlagArray))

  000da	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000df	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  000e3	8b 4c 24 20	 mov	 ecx, DWORD PTR idx$[rsp]
  000e7	e8 00 00 00 00	 call	 ?isBitSet_flag@@YA_NHPEAD@Z ; isBitSet_flag
  000ec	0f b6 c0	 movzx	 eax, al
  000ef	85 c0		 test	 eax, eax
  000f1	74 12		 je	 SHORT $LN13@newMemList

; 356  : 		{
; 357  : 			bitClear_flag(idx, m_nFlagArray);

  000f3	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000f8	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  000fc	8b 4c 24 20	 mov	 ecx, DWORD PTR idx$[rsp]
  00100	e8 00 00 00 00	 call	 ?bitClear_flag@@YAXHPEAD@Z ; bitClear_flag
$LN13@newMemList:

; 358  : 		}
; 359  : 	}

  00105	eb bf		 jmp	 SHORT $LN5@newMemList
$LN6@newMemList:

; 360  : 	return false;

  00107	32 c0		 xor	 al, al
$LN1@newMemList:

; 361  : }

  00109	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0010d	c3		 ret	 0
?newMemList@CSBufPool@@QEAA_NH@Z ENDP			; CSBufPool::newMemList
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\combufpool.cpp
;	COMDAT ?delMemByIdx@CSBufPool@@QEAA_NPEADH@Z
_TEXT	SEGMENT
this$ = 48
pUsedMem$ = 56
nIdx$ = 64
?delMemByIdx@CSBufPool@@QEAA_NPEADH@Z PROC		; CSBufPool::delMemByIdx, COMDAT

; 316  : {

$LN5:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 317  : 	if (!ISINCLUDE(nIdx, m_nAllocCount)) {

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00018	8b 50 04	 mov	 edx, DWORD PTR [rax+4]
  0001b	8b 4c 24 40	 mov	 ecx, DWORD PTR nIdx$[rsp]
  0001f	e8 00 00 00 00	 call	 ?ISINCLUDE@@YA_NHH@Z	; ISINCLUDE
  00024	0f b6 c0	 movzx	 eax, al
  00027	85 c0		 test	 eax, eax
  00029	75 0f		 jne	 SHORT $LN2@delMemById

; 318  : 		free(pUsedMem);

  0002b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pUsedMem$[rsp]
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 319  : 		return false;

  00036	32 c0		 xor	 al, al
  00038	eb 51		 jmp	 SHORT $LN1@delMemById
$LN2@delMemById:

; 320  : 	}
; 321  : 
; 322  : 	if (pUsedMem == &m_pChunk[nIdx << m_nShift]) {

  0003a	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0003f	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00042	0f b6 c8	 movzx	 ecx, al
  00045	8b 44 24 40	 mov	 eax, DWORD PTR nIdx$[rsp]
  00049	d3 e0		 shl	 eax, cl
  0004b	48 98		 cdqe
  0004d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00052	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00056	48 03 c8	 add	 rcx, rax
  00059	48 8b c1	 mov	 rax, rcx
  0005c	48 39 44 24 38	 cmp	 QWORD PTR pUsedMem$[rsp], rax
  00061	75 26		 jne	 SHORT $LN3@delMemById

; 323  : 		bitClear_flag(nIdx, m_nFlagArray);

  00063	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00068	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0006c	8b 4c 24 40	 mov	 ecx, DWORD PTR nIdx$[rsp]
  00070	e8 00 00 00 00	 call	 ?bitClear_flag@@YAXHPEAD@Z ; bitClear_flag

; 324  : 		m_nUseCnt--;

  00075	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0007a	8b 00		 mov	 eax, DWORD PTR [rax]
  0007c	ff c8		 dec	 eax
  0007e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00083	89 01		 mov	 DWORD PTR [rcx], eax

; 325  : 		return true;

  00085	b0 01		 mov	 al, 1
  00087	eb 02		 jmp	 SHORT $LN1@delMemById
$LN3@delMemById:

; 326  : 	}
; 327  : 	return false;

  00089	32 c0		 xor	 al, al
$LN1@delMemById:

; 328  : }

  0008b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0008f	c3		 ret	 0
?delMemByIdx@CSBufPool@@QEAA_NPEADH@Z ENDP		; CSBufPool::delMemByIdx
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\combufpool.cpp
;	COMDAT ?delMem@CSBufPool@@QEAA_NPEAD@Z
_TEXT	SEGMENT
nPos$ = 32
this$ = 64
pUsedMem$ = 72
?delMem@CSBufPool@@QEAA_NPEAD@Z PROC			; CSBufPool::delMem, COMDAT

; 299  : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 300  : 	if (!ISINCLUDE_ADDRESS(pUsedMem)) {

  0000e	48 8b 54 24 48	 mov	 rdx, QWORD PTR pUsedMem$[rsp]
  00013	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00018	e8 00 00 00 00	 call	 ?ISINCLUDE_ADDRESS@CSBufPool@@QEAA_NPEAD@Z ; CSBufPool::ISINCLUDE_ADDRESS
  0001d	0f b6 c0	 movzx	 eax, al
  00020	85 c0		 test	 eax, eax
  00022	75 0f		 jne	 SHORT $LN2@delMem

; 301  : 		free(pUsedMem);

  00024	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pUsedMem$[rsp]
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 302  : 		return false;

  0002f	32 c0		 xor	 al, al
  00031	eb 6a		 jmp	 SHORT $LN1@delMem
$LN2@delMem:

; 303  : 	}
; 304  : 	int nPos = (int)(pUsedMem - m_pChunk);

  00033	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00038	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0003c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pUsedMem$[rsp]
  00041	48 2b c8	 sub	 rcx, rax
  00044	48 8b c1	 mov	 rax, rcx
  00047	89 44 24 20	 mov	 DWORD PTR nPos$[rsp], eax

; 305  : 
; 306  : 	if (pUsedMem == &m_pChunk[nPos]) {

  0004b	48 63 44 24 20	 movsxd	 rax, DWORD PTR nPos$[rsp]
  00050	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00055	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00059	48 03 c8	 add	 rcx, rax
  0005c	48 8b c1	 mov	 rax, rcx
  0005f	48 39 44 24 48	 cmp	 QWORD PTR pUsedMem$[rsp], rax
  00064	75 35		 jne	 SHORT $LN3@delMem

; 307  : 		bitClear_flag(nPos >> m_nShift, m_nFlagArray);

  00066	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0006b	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0006e	0f b6 c8	 movzx	 ecx, al
  00071	8b 44 24 20	 mov	 eax, DWORD PTR nPos$[rsp]
  00075	d3 f8		 sar	 eax, cl
  00077	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0007c	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  00080	8b c8		 mov	 ecx, eax
  00082	e8 00 00 00 00	 call	 ?bitClear_flag@@YAXHPEAD@Z ; bitClear_flag

; 308  : 		m_nUseCnt--;

  00087	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0008c	8b 00		 mov	 eax, DWORD PTR [rax]
  0008e	ff c8		 dec	 eax
  00090	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00095	89 01		 mov	 DWORD PTR [rcx], eax

; 309  : 		return true;

  00097	b0 01		 mov	 al, 1
  00099	eb 02		 jmp	 SHORT $LN1@delMem
$LN3@delMem:

; 310  : 	}
; 311  : 	return false;

  0009b	32 c0		 xor	 al, al
$LN1@delMem:

; 312  : }

  0009d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a1	c3		 ret	 0
?delMem@CSBufPool@@QEAA_NPEAD@Z ENDP			; CSBufPool::delMem
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\combufpool.cpp
;	COMDAT ?newMem@CSBufPool@@QEAAPEADPEAH@Z
_TEXT	SEGMENT
i$ = 32
j$ = 36
tv94 = 40
this$ = 64
pKey$ = 72
?newMem@CSBufPool@@QEAAPEADPEAH@Z PROC			; CSBufPool::newMem, COMDAT

; 271  : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 272  : 	int i = m_nUseCnt, j;

  0000f	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00014	8b 00		 mov	 eax, DWORD PTR [rax]
  00016	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax

; 273  : 
; 274  : 	if (m_nUseCnt == m_nAllocCount) goto NEW_ALLOC;

  0001a	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0001f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00024	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  00027	39 08		 cmp	 DWORD PTR [rax], ecx
  00029	75 0a		 jne	 SHORT $LN5@newMem
  0002b	e9 03 01 00 00	 jmp	 $LN6@newMem
  00030	e9 fe 00 00 00	 jmp	 $NEW_ALLOC$13
$LN5@newMem:

; 275  : 
; 276  : 	for (j = 0; j < m_nAllocCount; j++) {

  00035	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  0003d	eb 0a		 jmp	 SHORT $LN4@newMem
$LN2@newMem:
  0003f	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  00043	ff c0		 inc	 eax
  00045	89 44 24 24	 mov	 DWORD PTR j$[rsp], eax
$LN4@newMem:
  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0004e	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00051	39 44 24 24	 cmp	 DWORD PTR j$[rsp], eax
  00055	0f 8d d8 00 00
	00		 jge	 $LN3@newMem

; 277  : 		if (i >= m_nAllocCount) { i = 0; }

  0005b	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00060	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00063	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00067	7c 08		 jl	 SHORT $LN7@newMem
  00069	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
$LN7@newMem:

; 278  : 		if (!isBitSet_flag(i, m_nFlagArray)) {

  00071	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00076	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0007a	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  0007e	e8 00 00 00 00	 call	 ?isBitSet_flag@@YA_NHPEAD@Z ; isBitSet_flag
  00083	0f b6 c0	 movzx	 eax, al
  00086	85 c0		 test	 eax, eax
  00088	0f 85 a0 00 00
	00		 jne	 $LN8@newMem

; 279  : 			if (pKey) {

  0008e	48 83 7c 24 48
	00		 cmp	 QWORD PTR pKey$[rsp], 0
  00094	74 0b		 je	 SHORT $LN9@newMem

; 280  : 				*pKey = i;

  00096	48 8b 44 24 48	 mov	 rax, QWORD PTR pKey$[rsp]
  0009b	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  0009f	89 08		 mov	 DWORD PTR [rax], ecx
$LN9@newMem:

; 281  : 			}
; 282  : 			m_nUseCnt++;

  000a1	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000a6	8b 00		 mov	 eax, DWORD PTR [rax]
  000a8	ff c0		 inc	 eax
  000aa	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000af	89 01		 mov	 DWORD PTR [rcx], eax

; 283  : 			bitSet_flag(i, m_nFlagArray);

  000b1	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000b6	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  000ba	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  000be	e8 00 00 00 00	 call	 ?bitSet_flag@@YAXHPEAD@Z ; bitSet_flag

; 284  : 			memset(&m_pChunk[i<<m_nShift], 0, g_nSizeList[m_nShift]);

  000c3	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000c8	48 63 40 10	 movsxd	 rax, DWORD PTR [rax+16]
  000cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_nSizeList@@3QBHB ; g_nSizeList
  000d3	48 63 04 81	 movsxd	 rax, DWORD PTR [rcx+rax*4]
  000d7	48 89 44 24 28	 mov	 QWORD PTR tv94[rsp], rax
  000dc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000e1	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  000e4	8b 54 24 20	 mov	 edx, DWORD PTR i$[rsp]
  000e8	d3 e2		 shl	 edx, cl
  000ea	8b ca		 mov	 ecx, edx
  000ec	48 63 c9	 movsxd	 rcx, ecx
  000ef	48 8b 54 24 40	 mov	 rdx, QWORD PTR this$[rsp]
  000f4	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  000f8	48 03 d1	 add	 rdx, rcx
  000fb	48 8b ca	 mov	 rcx, rdx
  000fe	48 8b f9	 mov	 rdi, rcx
  00101	33 c0		 xor	 eax, eax
  00103	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv94[rsp]
  00108	f3 aa		 rep stosb

; 285  : 			return &m_pChunk[i << m_nShift];

  0010a	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0010f	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00112	0f b6 c8	 movzx	 ecx, al
  00115	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00119	d3 e0		 shl	 eax, cl
  0011b	48 98		 cdqe
  0011d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00122	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00126	48 03 c8	 add	 rcx, rax
  00129	48 8b c1	 mov	 rax, rcx
  0012c	eb 3a		 jmp	 SHORT $LN1@newMem
$LN8@newMem:

; 286  : 		}
; 287  : 	}

  0012e	e9 0c ff ff ff	 jmp	 $LN2@newMem
$LN3@newMem:
$LN6@newMem:
$NEW_ALLOC$13:

; 288  : 
; 289  : NEW_ALLOC:
; 290  : 	if (pKey) {

  00133	48 83 7c 24 48
	00		 cmp	 QWORD PTR pKey$[rsp], 0
  00139	74 0b		 je	 SHORT $LN10@newMem

; 291  : 		*pKey = -1;

  0013b	48 8b 44 24 48	 mov	 rax, QWORD PTR pKey$[rsp]
  00140	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [rax], -1
$LN10@newMem:

; 292  : 	}
; 293  : 	return (char *)calloc(1, g_nSizeList[m_nShift]);

  00146	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0014b	48 63 40 10	 movsxd	 rax, DWORD PTR [rax+16]
  0014f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_nSizeList@@3QBHB ; g_nSizeList
  00156	48 63 04 81	 movsxd	 rax, DWORD PTR [rcx+rax*4]
  0015a	48 8b d0	 mov	 rdx, rax
  0015d	b9 01 00 00 00	 mov	 ecx, 1
  00162	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
$LN1@newMem:

; 294  : }

  00168	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0016c	5f		 pop	 rdi
  0016d	c3		 ret	 0
?newMem@CSBufPool@@QEAAPEADPEAH@Z ENDP			; CSBufPool::newMem
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\combufpool.cpp
;	COMDAT ?destroy@CSBufPool@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?destroy@CSBufPool@@QEAAXXZ PROC			; CSBufPool::destroy, COMDAT

; 217  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 218  : 	if (m_pChunk) {

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00013	74 1c		 je	 SHORT $LN2@destroy

; 219  : 		free(m_pChunk);

  00015	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0001a	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 220  : 		m_pChunk = NULL;

  00024	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00029	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0
$LN2@destroy:

; 221  : 	}
; 222  : 
; 223  : 	if (m_nFlagArray) {

  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00036	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0003b	74 1c		 je	 SHORT $LN3@destroy

; 224  : 		free(m_nFlagArray);

  0003d	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00042	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 225  : 		m_nFlagArray = NULL;

  0004c	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00051	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
$LN3@destroy:

; 226  : 	}
; 227  : }

  00059	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005d	c3		 ret	 0
?destroy@CSBufPool@@QEAAXXZ ENDP			; CSBufPool::destroy
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\combufpool.cpp
;	COMDAT ?alloc@CSBufPool@@QEAA_NHH@Z
_TEXT	SEGMENT
nFCount$ = 48
this$ = 80
nShift$ = 88
nMaxCount$ = 96
?alloc@CSBufPool@@QEAA_NHH@Z PROC			; CSBufPool::alloc, COMDAT

; 232  : {

$LN5:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 233  : 	int nFCount = (nMaxCount >> 3) + 1;

  00012	8b 44 24 60	 mov	 eax, DWORD PTR nMaxCount$[rsp]
  00016	c1 f8 03	 sar	 eax, 3
  00019	ff c0		 inc	 eax
  0001b	89 44 24 30	 mov	 DWORD PTR nFCount$[rsp], eax

; 234  : 	m_nFlagArray = (char *)calloc(nFCount, sizeof(char));

  0001f	48 63 44 24 30	 movsxd	 rax, DWORD PTR nFCount$[rsp]
  00024	ba 01 00 00 00	 mov	 edx, 1
  00029	48 8b c8	 mov	 rcx, rax
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00032	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00037	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 235  : 
; 236  : 	if (m_nFlagArray == NULL) {

  0003b	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00040	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00045	75 31		 jne	 SHORT $LN2@alloc

; 237  : 		gs_cLogger.DebugLog(LEVEL_ERROR, "m_nFlagArray alloc");

  00047	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG44594
  0004e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00053	41 b9 ed 00 00
	00		 mov	 r9d, 237		; 000000edH
  00059	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG44595
  00060	ba 05 00 00 00	 mov	 edx, 5
  00065	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  0006c	e8 00 00 00 00	 call	 ?__debugLog@CLogger@@QEAAXHPEBDH0ZZ ; CLogger::__debugLog

; 238  : 		return false;

  00071	32 c0		 xor	 al, al
  00073	e9 e0 00 00 00	 jmp	 $LN1@alloc
$LN2@alloc:

; 239  : 	} 
; 240  : 	m_nShift = nShift;

  00078	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0007d	8b 4c 24 58	 mov	 ecx, DWORD PTR nShift$[rsp]
  00081	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 241  : 	m_pChunk = (char *)calloc(nMaxCount, getSizeByIndex(m_nShift));

  00084	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00089	8b 48 10	 mov	 ecx, DWORD PTR [rax+16]
  0008c	e8 00 00 00 00	 call	 ?getSizeByIndex@@YAHH@Z	; getSizeByIndex
  00091	48 98		 cdqe
  00093	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR nMaxCount$[rsp]
  00098	48 8b d0	 mov	 rdx, rax
  0009b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  000a1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  000a6	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 242  : 
; 243  : 	if (m_pChunk == NULL) {

  000aa	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  000af	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  000b4	75 4a		 jne	 SHORT $LN3@alloc

; 244  : 		free(m_pChunk);

  000b6	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  000bb	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  000bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 245  : 		m_pChunk = NULL;

  000c5	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  000ca	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 246  : 		gs_cLogger.DebugLog(LEVEL_ERROR, "m_pChunk alloc");

  000d2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG44597
  000d9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000de	41 b9 f6 00 00
	00		 mov	 r9d, 246		; 000000f6H
  000e4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG44598
  000eb	ba 05 00 00 00	 mov	 edx, 5
  000f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  000f7	e8 00 00 00 00	 call	 ?__debugLog@CLogger@@QEAAXHPEBDH0ZZ ; CLogger::__debugLog

; 247  : 		return false;

  000fc	32 c0		 xor	 al, al
  000fe	eb 58		 jmp	 SHORT $LN1@alloc
$LN3@alloc:

; 248  : 	}
; 249  : 
; 250  : 	m_nAllocCount = nMaxCount;

  00100	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00105	8b 4c 24 60	 mov	 ecx, DWORD PTR nMaxCount$[rsp]
  00109	89 48 04	 mov	 DWORD PTR [rax+4], ecx

; 251  : 	m_pEnd = &m_pChunk[(m_nAllocCount - 1)<< m_nShift];

  0010c	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00111	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00114	ff c8		 dec	 eax
  00116	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  0011b	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  0011e	d3 e0		 shl	 eax, cl
  00120	48 98		 cdqe
  00122	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00127	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0012b	48 03 c8	 add	 rcx, rax
  0012e	48 8b c1	 mov	 rax, rcx
  00131	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00136	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 252  : 	_stprintf(g_szMessage, _T("mem allock list m_nAllocCount[%d]"), m_nAllocCount);

  0013a	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0013f	44 8b 40 04	 mov	 r8d, DWORD PTR [rax+4]
  00143	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG44599
  0014a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  00151	e8 00 00 00 00	 call	 sprintf

; 253  : 
; 254  : 	return true;

  00156	b0 01		 mov	 al, 1
$LN1@alloc:

; 255  : }

  00158	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0015c	c3		 ret	 0
?alloc@CSBufPool@@QEAA_NHH@Z ENDP			; CSBufPool::alloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\combufpool.cpp
;	COMDAT ?clear@CSBufPool@@QEAAXXZ
_TEXT	SEGMENT
tv77 = 32
this$ = 64
?clear@CSBufPool@@QEAAXXZ PROC				; CSBufPool::clear, COMDAT

; 260  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 261  : 	memset(m_nFlagArray, 0, sizeof(m_nFlagArray));

  0000a	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0000f	48 8b 78 08	 mov	 rdi, QWORD PTR [rax+8]
  00013	33 c0		 xor	 eax, eax
  00015	b9 08 00 00 00	 mov	 ecx, 8
  0001a	f3 aa		 rep stosb

; 262  : 	m_nUseCnt = 0;

  0001c	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00021	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 263  : 	memset(m_pChunk, 0, getSizeByIndex(m_nShift)*m_nAllocCount);

  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0002c	8b 48 10	 mov	 ecx, DWORD PTR [rax+16]
  0002f	e8 00 00 00 00	 call	 ?getSizeByIndex@@YAHH@Z	; getSizeByIndex
  00034	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00039	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  0003d	48 98		 cdqe
  0003f	48 89 44 24 20	 mov	 QWORD PTR tv77[rsp], rax
  00044	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00049	48 8b 79 18	 mov	 rdi, QWORD PTR [rcx+24]
  0004d	33 c0		 xor	 eax, eax
  0004f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv77[rsp]
  00054	f3 aa		 rep stosb

; 264  : 	memset(g_szMessage, 0, sizeof(g_szMessage));

  00056	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  0005d	48 8b f8	 mov	 rdi, rax
  00060	33 c0		 xor	 eax, eax
  00062	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00067	f3 aa		 rep stosb

; 265  : }

  00069	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006d	5f		 pop	 rdi
  0006e	c3		 ret	 0
?clear@CSBufPool@@QEAAXXZ ENDP				; CSBufPool::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\combufpool.cpp
;	COMDAT ??1CSBufPool@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??1CSBufPool@@QEAA@XZ PROC				; CSBufPool::~CSBufPool, COMDAT

; 211  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00009	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2

; 212  : 	destroy();

  00012	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00017	e8 00 00 00 00	 call	 ?destroy@CSBufPool@@QEAAXXZ ; CSBufPool::destroy
  0001c	90		 npad	 1

; 213  : }

  0001d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00021	c3		 ret	 0
??1CSBufPool@@QEAA@XZ ENDP				; CSBufPool::~CSBufPool
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\combufpool.cpp
;	COMDAT ??0CSBufPool@@QEAA@XZ
_TEXT	SEGMENT
this$ = 16
??0CSBufPool@@QEAA@XZ PROC				; CSBufPool::CSBufPool, COMDAT

; 199  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 200  : 	m_nAllocCount = 0;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  0000b	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0

; 201  : 	memset(g_szMessage, 0, LEN_MEM_MESSAGE);

  00012	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  00019	48 8b f8	 mov	 rdi, rax
  0001c	33 c0		 xor	 eax, eax
  0001e	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00023	f3 aa		 rep stosb

; 202  : 	m_pChunk = NULL;

  00025	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  0002a	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 203  : 	m_nUseCnt = 0;

  00032	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  00037	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 204  : 	m_nFlagArray = NULL;

  0003d	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  00042	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 205  : 	m_pEnd = NULL;

  0004a	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  0004f	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 206  : 	m_nShift = 0;

  00057	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  0005c	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 207  : }

  00063	48 8b 44 24 10	 mov	 rax, QWORD PTR this$[rsp]
  00068	5f		 pop	 rdi
  00069	c3		 ret	 0
??0CSBufPool@@QEAA@XZ ENDP				; CSBufPool::CSBufPool
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\combufpool.h
;	COMDAT ?ISINCLUDE_ADDRESS@CBufPool@@QEAA_NPEAD@Z
_TEXT	SEGMENT
this$ = 8
p$ = 16
?ISINCLUDE_ADDRESS@CBufPool@@QEAA_NPEAD@Z PROC		; CBufPool::ISINCLUDE_ADDRESS, COMDAT

; 81   : 	inline bool ISINCLUDE_ADDRESS(char *p) { if(m_pChunk <= p && p <= m_pEnd) return true; return false; }

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR p$[rsp]
  00014	48 39 48 28	 cmp	 QWORD PTR [rax+40], rcx
  00018	77 14		 ja	 SHORT $LN2@ISINCLUDE_
  0001a	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0001f	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00023	48 39 44 24 10	 cmp	 QWORD PTR p$[rsp], rax
  00028	77 04		 ja	 SHORT $LN2@ISINCLUDE_
  0002a	b0 01		 mov	 al, 1
  0002c	eb 02		 jmp	 SHORT $LN1@ISINCLUDE_
$LN2@ISINCLUDE_:
  0002e	32 c0		 xor	 al, al
$LN1@ISINCLUDE_:
  00030	c3		 ret	 0
?ISINCLUDE_ADDRESS@CBufPool@@QEAA_NPEAD@Z ENDP		; CBufPool::ISINCLUDE_ADDRESS
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\combufpool.cpp
;	COMDAT ?delMem@CBufPool@@QEAAXPEADH@Z
_TEXT	SEGMENT
nIdx$ = 32
i$ = 36
nPos$ = 40
this$ = 64
pUsedMem$ = 72
nCount$ = 80
?delMem@CBufPool@@QEAAXPEADH@Z PROC			; CBufPool::delMem, COMDAT

; 94   : {

$LN9:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 95   : 	int i;
; 96   : 	int nPos = (int)(pUsedMem - m_pChunk);

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00018	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0001c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pUsedMem$[rsp]
  00021	48 2b c8	 sub	 rcx, rax
  00024	48 8b c1	 mov	 rax, rcx
  00027	89 44 24 28	 mov	 DWORD PTR nPos$[rsp], eax

; 97   : 	int nIdx = nPos >> m_nShift;

  0002b	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00030	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00033	0f b6 c8	 movzx	 ecx, al
  00036	8b 44 24 28	 mov	 eax, DWORD PTR nPos$[rsp]
  0003a	d3 f8		 sar	 eax, cl
  0003c	89 44 24 20	 mov	 DWORD PTR nIdx$[rsp], eax

; 98   : 
; 99   : 	if (pUsedMem != &m_pChunk[nPos]) return;

  00040	48 63 44 24 28	 movsxd	 rax, DWORD PTR nPos$[rsp]
  00045	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0004a	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0004e	48 03 c8	 add	 rcx, rax
  00051	48 8b c1	 mov	 rax, rcx
  00054	48 39 44 24 48	 cmp	 QWORD PTR pUsedMem$[rsp], rax
  00059	74 05		 je	 SHORT $LN5@delMem
  0005b	e9 95 00 00 00	 jmp	 $LN1@delMem
$LN5@delMem:

; 100  : 	for (i = 0; i < nCount; i++)

  00060	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00068	eb 0a		 jmp	 SHORT $LN4@delMem
$LN2@delMem:
  0006a	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  0006e	ff c0		 inc	 eax
  00070	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@delMem:
  00074	8b 44 24 50	 mov	 eax, DWORD PTR nCount$[rsp]
  00078	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  0007c	7d 63		 jge	 SHORT $LN3@delMem

; 101  : 	{
; 102  : 		if (nIdx >= m_nAllocCount) return;

  0007e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00083	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00086	39 44 24 20	 cmp	 DWORD PTR nIdx$[rsp], eax
  0008a	7c 02		 jl	 SHORT $LN6@delMem
  0008c	eb 67		 jmp	 SHORT $LN1@delMem
$LN6@delMem:

; 103  : 		//printf("CBufPool::delMem nPos[%d] nIdx[%d] nShift[%d] pMem[%p]\n", nPos, nIdx, nShift, pUsedMem);
; 104  : 		if (m_nFlagArray[nIdx].getCount())

  0008e	48 63 44 24 20	 movsxd	 rax, DWORD PTR nIdx$[rsp]
  00093	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00098	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0009b	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  0009f	48 8b c8	 mov	 rcx, rax
  000a2	e8 00 00 00 00	 call	 ?getCount@win64_atomic@win32@common@@QEAAHXZ ; common::win32::win64_atomic::getCount
  000a7	85 c0		 test	 eax, eax
  000a9	74 2a		 je	 SHORT $LN7@delMem

; 105  : 		{
; 106  : 			m_nFlagArray[nIdx].init();

  000ab	48 63 44 24 20	 movsxd	 rax, DWORD PTR nIdx$[rsp]
  000b0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000b5	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000b8	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  000bc	48 8b c8	 mov	 rcx, rax
  000bf	e8 00 00 00 00	 call	 ?init@win64_atomic@win32@common@@QEAAXXZ ; common::win32::win64_atomic::init

; 107  : 			m_nUseCnt.atomic_decrement();

  000c4	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000c9	48 83 c0 08	 add	 rax, 8
  000cd	48 8b c8	 mov	 rcx, rax
  000d0	e8 00 00 00 00	 call	 ?atomic_decrement@win64_atomic@win32@common@@QEAA_JXZ ; common::win32::win64_atomic::atomic_decrement
$LN7@delMem:

; 108  : 		}
; 109  : 		nIdx++;

  000d5	8b 44 24 20	 mov	 eax, DWORD PTR nIdx$[rsp]
  000d9	ff c0		 inc	 eax
  000db	89 44 24 20	 mov	 DWORD PTR nIdx$[rsp], eax

; 110  : 	}

  000df	eb 89		 jmp	 SHORT $LN2@delMem
$LN3@delMem:

; 111  : 	m_nLastCount = nIdx - nCount;

  000e1	8b 44 24 50	 mov	 eax, DWORD PTR nCount$[rsp]
  000e5	8b 4c 24 20	 mov	 ecx, DWORD PTR nIdx$[rsp]
  000e9	2b c8		 sub	 ecx, eax
  000eb	8b c1		 mov	 eax, ecx
  000ed	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000f2	89 41 18	 mov	 DWORD PTR [rcx+24], eax
$LN1@delMem:

; 112  : }

  000f5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000f9	c3		 ret	 0
?delMem@CBufPool@@QEAAXPEADH@Z ENDP			; CBufPool::delMem
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\combufpool.cpp
;	COMDAT ?newMemList@CBufPool@@QEAA_NH@Z
_TEXT	SEGMENT
idx$ = 32
nLastLoopCnt$ = 36
i$ = 40
this$ = 64
nCount$ = 72
?newMemList@CBufPool@@QEAA_NH@Z PROC			; CBufPool::newMemList, COMDAT

; 152  : {

$LN17:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 153  : 	int idx = m_nLastCount, nLastLoopCnt=0;

  0000d	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00012	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00015	89 44 24 20	 mov	 DWORD PTR idx$[rsp], eax
  00019	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR nLastLoopCnt$[rsp], 0

; 154  : 	int i;
; 155  : 	if (m_nUseCnt.getCount()+nCount > m_nAllocCount) return false;

  00021	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00026	48 83 c0 08	 add	 rax, 8
  0002a	48 8b c8	 mov	 rcx, rax
  0002d	e8 00 00 00 00	 call	 ?getCount@win64_atomic@win32@common@@QEAAHXZ ; common::win32::win64_atomic::getCount
  00032	03 44 24 48	 add	 eax, DWORD PTR nCount$[rsp]
  00036	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0003b	3b 41 1c	 cmp	 eax, DWORD PTR [rcx+28]
  0003e	7e 07		 jle	 SHORT $LN8@newMemList
  00040	32 c0		 xor	 al, al
  00042	e9 2e 01 00 00	 jmp	 $LN1@newMemList
$LN8@newMemList:

; 156  : 
; 157  : 	for (i=0; i < nCount; i++) {

  00047	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0004f	eb 0a		 jmp	 SHORT $LN4@newMemList
$LN2@newMemList:
  00051	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00055	ff c0		 inc	 eax
  00057	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN4@newMemList:
  0005b	8b 44 24 48	 mov	 eax, DWORD PTR nCount$[rsp]
  0005f	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  00063	0f 8d 85 00 00
	00		 jge	 $LN3@newMemList

; 158  : 		if (idx >= m_nAllocCount) break;

  00069	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0006e	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00071	39 44 24 20	 cmp	 DWORD PTR idx$[rsp], eax
  00075	7c 02		 jl	 SHORT $LN9@newMemList
  00077	eb 75		 jmp	 SHORT $LN3@newMemList
$LN9@newMemList:

; 159  : 		if (!m_nFlagArray[idx].getCount())

  00079	48 63 44 24 20	 movsxd	 rax, DWORD PTR idx$[rsp]
  0007e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00083	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00086	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  0008a	48 8b c8	 mov	 rcx, rax
  0008d	e8 00 00 00 00	 call	 ?getCount@win64_atomic@win32@common@@QEAAHXZ ; common::win32::win64_atomic::getCount
  00092	85 c0		 test	 eax, eax
  00094	75 47		 jne	 SHORT $LN10@newMemList

; 160  : 		{
; 161  : 			if (!m_nFlagArray[idx].atomic_compare_exchange(1, 0)) {

  00096	48 63 44 24 20	 movsxd	 rax, DWORD PTR idx$[rsp]
  0009b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000a0	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000a3	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  000a7	45 33 c0	 xor	 r8d, r8d
  000aa	ba 01 00 00 00	 mov	 edx, 1
  000af	48 8b c8	 mov	 rcx, rax
  000b2	e8 00 00 00 00	 call	 ?atomic_compare_exchange@win64_atomic@win32@common@@QEAA_J_J0@Z ; common::win32::win64_atomic::atomic_compare_exchange
  000b7	48 85 c0	 test	 rax, rax
  000ba	75 1d		 jne	 SHORT $LN12@newMemList

; 162  : 				m_nUseCnt.atomic_increment();

  000bc	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000c1	48 83 c0 08	 add	 rax, 8
  000c5	48 8b c8	 mov	 rcx, rax
  000c8	e8 00 00 00 00	 call	 ?atomic_increment@win64_atomic@win32@common@@QEAA_JXZ ; common::win32::win64_atomic::atomic_increment

; 163  : 				nLastLoopCnt++;

  000cd	8b 44 24 24	 mov	 eax, DWORD PTR nLastLoopCnt$[rsp]
  000d1	ff c0		 inc	 eax
  000d3	89 44 24 24	 mov	 DWORD PTR nLastLoopCnt$[rsp], eax

; 164  : 			}
; 165  : 			else break;

  000d7	eb 02		 jmp	 SHORT $LN13@newMemList
$LN12@newMemList:
  000d9	eb 13		 jmp	 SHORT $LN3@newMemList
$LN13@newMemList:

; 166  : 		}
; 167  : 		else break;

  000db	eb 02		 jmp	 SHORT $LN11@newMemList
$LN10@newMemList:
  000dd	eb 0f		 jmp	 SHORT $LN3@newMemList
$LN11@newMemList:

; 168  : 		idx++;

  000df	8b 44 24 20	 mov	 eax, DWORD PTR idx$[rsp]
  000e3	ff c0		 inc	 eax
  000e5	89 44 24 20	 mov	 DWORD PTR idx$[rsp], eax

; 169  : 	}

  000e9	e9 63 ff ff ff	 jmp	 $LN2@newMemList
$LN3@newMemList:

; 170  : 
; 171  : 	if (nLastLoopCnt== nCount) {

  000ee	8b 44 24 48	 mov	 eax, DWORD PTR nCount$[rsp]
  000f2	39 44 24 24	 cmp	 DWORD PTR nLastLoopCnt$[rsp], eax
  000f6	75 10		 jne	 SHORT $LN14@newMemList

; 172  : 		m_nLastCount = idx;

  000f8	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000fd	8b 4c 24 20	 mov	 ecx, DWORD PTR idx$[rsp]
  00101	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 173  : 		return true;

  00104	b0 01		 mov	 al, 1
  00106	eb 6d		 jmp	 SHORT $LN1@newMemList
$LN14@newMemList:

; 174  : 	}
; 175  : 
; 176  : 	for (idx = m_nLastCount; idx < nLastLoopCnt; idx++) {

  00108	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0010d	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00110	89 44 24 20	 mov	 DWORD PTR idx$[rsp], eax
  00114	eb 0a		 jmp	 SHORT $LN7@newMemList
$LN5@newMemList:
  00116	8b 44 24 20	 mov	 eax, DWORD PTR idx$[rsp]
  0011a	ff c0		 inc	 eax
  0011c	89 44 24 20	 mov	 DWORD PTR idx$[rsp], eax
$LN7@newMemList:
  00120	8b 44 24 24	 mov	 eax, DWORD PTR nLastLoopCnt$[rsp]
  00124	39 44 24 20	 cmp	 DWORD PTR idx$[rsp], eax
  00128	7d 49		 jge	 SHORT $LN6@newMemList

; 177  : 		if (m_nFlagArray[idx].getCount())

  0012a	48 63 44 24 20	 movsxd	 rax, DWORD PTR idx$[rsp]
  0012f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00134	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00137	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  0013b	48 8b c8	 mov	 rcx, rax
  0013e	e8 00 00 00 00	 call	 ?getCount@win64_atomic@win32@common@@QEAAHXZ ; common::win32::win64_atomic::getCount
  00143	85 c0		 test	 eax, eax
  00145	74 2a		 je	 SHORT $LN15@newMemList

; 178  : 		{
; 179  : 			m_nFlagArray[idx].init();

  00147	48 63 44 24 20	 movsxd	 rax, DWORD PTR idx$[rsp]
  0014c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00151	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00154	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  00158	48 8b c8	 mov	 rcx, rax
  0015b	e8 00 00 00 00	 call	 ?init@win64_atomic@win32@common@@QEAAXXZ ; common::win32::win64_atomic::init

; 180  : 			m_nUseCnt.atomic_decrement();

  00160	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00165	48 83 c0 08	 add	 rax, 8
  00169	48 8b c8	 mov	 rcx, rax
  0016c	e8 00 00 00 00	 call	 ?atomic_decrement@win64_atomic@win32@common@@QEAA_JXZ ; common::win32::win64_atomic::atomic_decrement
$LN15@newMemList:

; 181  : 		}
; 182  : 	}

  00171	eb a3		 jmp	 SHORT $LN5@newMemList
$LN6@newMemList:

; 183  : 	return false;

  00173	32 c0		 xor	 al, al
$LN1@newMemList:

; 184  : }

  00175	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00179	c3		 ret	 0
?newMemList@CBufPool@@QEAA_NH@Z ENDP			; CBufPool::newMemList
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\combufpool.cpp
;	COMDAT ?delMem@CBufPool@@QEAAXPEAD@Z
_TEXT	SEGMENT
nPos$ = 32
nIdx$ = 36
this$ = 64
pUsedMem$ = 72
?delMem@CBufPool@@QEAAXPEAD@Z PROC			; CBufPool::delMem, COMDAT

; 76   : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 77   : 	if(!ISINCLUDE_ADDRESS(pUsedMem)) {

  0000e	48 8b 54 24 48	 mov	 rdx, QWORD PTR pUsedMem$[rsp]
  00013	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00018	e8 00 00 00 00	 call	 ?ISINCLUDE_ADDRESS@CBufPool@@QEAA_NPEAD@Z ; CBufPool::ISINCLUDE_ADDRESS
  0001d	0f b6 c0	 movzx	 eax, al
  00020	85 c0		 test	 eax, eax
  00022	75 0d		 jne	 SHORT $LN2@delMem

; 78   : 		free(pUsedMem);

  00024	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pUsedMem$[rsp]
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 79   : 		//m_nOverCnt.atomic_decrement();
; 80   : 		return;

  0002f	eb 7e		 jmp	 SHORT $LN1@delMem
$LN2@delMem:

; 81   : 	}
; 82   : 
; 83   : 	int nPos = (int)(pUsedMem - m_pChunk);

  00031	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00036	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0003a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pUsedMem$[rsp]
  0003f	48 2b c8	 sub	 rcx, rax
  00042	48 8b c1	 mov	 rax, rcx
  00045	89 44 24 20	 mov	 DWORD PTR nPos$[rsp], eax

; 84   : 	int nIdx = nPos >> m_nShift;

  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0004e	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00051	0f b6 c8	 movzx	 ecx, al
  00054	8b 44 24 20	 mov	 eax, DWORD PTR nPos$[rsp]
  00058	d3 f8		 sar	 eax, cl
  0005a	89 44 24 24	 mov	 DWORD PTR nIdx$[rsp], eax

; 85   : 
; 86   :     if(pUsedMem == &m_pChunk[nPos]) {

  0005e	48 63 44 24 20	 movsxd	 rax, DWORD PTR nPos$[rsp]
  00063	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00068	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0006c	48 03 c8	 add	 rcx, rax
  0006f	48 8b c1	 mov	 rax, rcx
  00072	48 39 44 24 48	 cmp	 QWORD PTR pUsedMem$[rsp], rax
  00077	75 36		 jne	 SHORT $LN3@delMem

; 87   : 		m_nFlagArray[nIdx].init();

  00079	48 63 44 24 24	 movsxd	 rax, DWORD PTR nIdx$[rsp]
  0007e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00083	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00086	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  0008a	48 8b c8	 mov	 rcx, rax
  0008d	e8 00 00 00 00	 call	 ?init@win64_atomic@win32@common@@QEAAXXZ ; common::win32::win64_atomic::init

; 88   : 		m_nUseCnt.atomic_decrement();

  00092	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00097	48 83 c0 08	 add	 rax, 8
  0009b	48 8b c8	 mov	 rcx, rax
  0009e	e8 00 00 00 00	 call	 ?atomic_decrement@win64_atomic@win32@common@@QEAA_JXZ ; common::win32::win64_atomic::atomic_decrement

; 89   : 		m_nLastCount = nIdx;

  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000a8	8b 4c 24 24	 mov	 ecx, DWORD PTR nIdx$[rsp]
  000ac	89 48 18	 mov	 DWORD PTR [rax+24], ecx
$LN3@delMem:
$LN1@delMem:

; 90   : 	}
; 91   : }

  000af	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b3	c3		 ret	 0
?delMem@CBufPool@@QEAAXPEAD@Z ENDP			; CBufPool::delMem
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\combufpool.cpp
;	COMDAT ?newMem@CBufPool@@QEAAPEADXZ
_TEXT	SEGMENT
i$ = 32
j$ = 36
tv133 = 40
p$ = 48
this$ = 80
?newMem@CBufPool@@QEAAPEADXZ PROC			; CBufPool::newMem, COMDAT

; 115  : {

$LN11:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 116  : 	int i= m_nLastCount,j;

  0000a	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0000f	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00012	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax

; 117  : 	if(m_nUseCnt.getCount() == m_nAllocCount) goto NEW_ALLOC;

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0001b	48 83 c0 08	 add	 rax, 8
  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 ?getCount@win64_atomic@win32@common@@QEAAHXZ ; common::win32::win64_atomic::getCount
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  0002c	3b 41 1c	 cmp	 eax, DWORD PTR [rcx+28]
  0002f	75 0a		 jne	 SHORT $LN5@newMem
  00031	e9 23 01 00 00	 jmp	 $LN6@newMem
  00036	e9 1e 01 00 00	 jmp	 $NEW_ALLOC$12
$LN5@newMem:

; 118  : 	
; 119  : 	for(j = 0; j < m_nAllocCount; j++)

  0003b	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00043	eb 0a		 jmp	 SHORT $LN4@newMem
$LN2@newMem:
  00045	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  00049	ff c0		 inc	 eax
  0004b	89 44 24 24	 mov	 DWORD PTR j$[rsp], eax
$LN4@newMem:
  0004f	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00054	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00057	39 44 24 24	 cmp	 DWORD PTR j$[rsp], eax
  0005b	0f 8d f8 00 00
	00		 jge	 $LN3@newMem

; 120  :     {
; 121  : 		if(i >= m_nAllocCount) {i = 0;} //    .  next    .

  00061	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00066	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00069	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0006d	7c 08		 jl	 SHORT $LN7@newMem
  0006f	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
$LN7@newMem:

; 122  : 		if(!m_nFlagArray[i].getCount()) 

  00077	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0007c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00081	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00084	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  00088	48 8b c8	 mov	 rcx, rax
  0008b	e8 00 00 00 00	 call	 ?getCount@win64_atomic@win32@common@@QEAAHXZ ; common::win32::win64_atomic::getCount
  00090	85 c0		 test	 eax, eax
  00092	0f 85 b2 00 00
	00		 jne	 $LN8@newMem

; 123  : 		{
; 124  : 			if(!m_nFlagArray[i].atomic_compare_exchange(1,0)) 

  00098	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0009d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  000a2	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000a5	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  000a9	45 33 c0	 xor	 r8d, r8d
  000ac	ba 01 00 00 00	 mov	 edx, 1
  000b1	48 8b c8	 mov	 rcx, rax
  000b4	e8 00 00 00 00	 call	 ?atomic_compare_exchange@win64_atomic@win32@common@@QEAA_J_J0@Z ; common::win32::win64_atomic::atomic_compare_exchange
  000b9	48 85 c0	 test	 rax, rax
  000bc	0f 85 88 00 00
	00		 jne	 $LN9@newMem

; 125  : 			{
; 126  : 				m_nUseCnt.atomic_increment();

  000c2	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  000c7	48 83 c0 08	 add	 rax, 8
  000cb	48 8b c8	 mov	 rcx, rax
  000ce	e8 00 00 00 00	 call	 ?atomic_increment@win64_atomic@win32@common@@QEAA_JXZ ; common::win32::win64_atomic::atomic_increment

; 127  : 				m_nLastCount=i;

  000d3	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  000d8	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  000dc	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 128  : 				memset(&m_pChunk[i << m_nShift], 0, g_nSizeList[m_nShift]);

  000df	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  000e4	48 63 40 20	 movsxd	 rax, DWORD PTR [rax+32]
  000e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_nSizeList@@3QBHB ; g_nSizeList
  000ef	48 63 04 81	 movsxd	 rax, DWORD PTR [rcx+rax*4]
  000f3	48 89 44 24 28	 mov	 QWORD PTR tv133[rsp], rax
  000f8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  000fd	8b 49 20	 mov	 ecx, DWORD PTR [rcx+32]
  00100	8b 54 24 20	 mov	 edx, DWORD PTR i$[rsp]
  00104	d3 e2		 shl	 edx, cl
  00106	8b ca		 mov	 ecx, edx
  00108	48 63 c9	 movsxd	 rcx, ecx
  0010b	48 8b 54 24 50	 mov	 rdx, QWORD PTR this$[rsp]
  00110	48 8b 52 28	 mov	 rdx, QWORD PTR [rdx+40]
  00114	48 03 d1	 add	 rdx, rcx
  00117	48 8b ca	 mov	 rcx, rdx
  0011a	48 8b f9	 mov	 rdi, rcx
  0011d	33 c0		 xor	 eax, eax
  0011f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv133[rsp]
  00124	f3 aa		 rep stosb

; 129  : 				return &m_pChunk[i << m_nShift];

  00126	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0012b	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  0012e	0f b6 c8	 movzx	 ecx, al
  00131	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00135	d3 e0		 shl	 eax, cl
  00137	48 98		 cdqe
  00139	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  0013e	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00142	48 03 c8	 add	 rcx, rax
  00145	48 8b c1	 mov	 rax, rcx
  00148	eb 3b		 jmp	 SHORT $LN1@newMem
$LN9@newMem:
$LN8@newMem:

; 130  : 			}
; 131  : 		}
; 132  : 		i++;

  0014a	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0014e	ff c0		 inc	 eax
  00150	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax

; 133  :     }    

  00154	e9 ec fe ff ff	 jmp	 $LN2@newMem
$LN3@newMem:
$LN6@newMem:
$NEW_ALLOC$12:

; 134  : NEW_ALLOC:
; 135  : 	//if (m_nOverMaxCnt.getCount() < m_nOverCnt.getCount()) {
; 136  : 	//	m_nOverMaxCnt.atomic_exchange(m_nOverCnt.getCount());
; 137  : 	//	gs_cLogger.DebugLog(LEVEL_WARN, "update m_nOverMaxCnt[%d]", m_nOverMaxCnt.getCount());
; 138  : 	//}
; 139  : 	char * p = (char *)calloc(1, g_nSizeList[m_nShift]);

  00159	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0015e	48 63 40 20	 movsxd	 rax, DWORD PTR [rax+32]
  00162	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_nSizeList@@3QBHB ; g_nSizeList
  00169	48 63 04 81	 movsxd	 rax, DWORD PTR [rcx+rax*4]
  0016d	48 8b d0	 mov	 rdx, rax
  00170	b9 01 00 00 00	 mov	 ecx, 1
  00175	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  0017b	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax

; 140  : 	//if (p) {
; 141  : 	//	m_nOverCnt.atomic_increment();
; 142  : 	//	gs_cLogger.DebugLog(LEVEL_TRACE, "update m_nOverCnt[%d] m_nShift[%d] m_nAllocCount[%d]", m_nOverCnt.atomic_increment(), m_nShift, m_nAllocCount);
; 143  : 	//}
; 144  : 	//else {
; 145  : 	//	gs_cLogger.DebugLog(LEVEL_ERROR, "calloc has Failed");
; 146  : 	//}
; 147  : 	return p;

  00180	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
$LN1@newMem:

; 148  : }

  00185	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00189	5f		 pop	 rdi
  0018a	c3		 ret	 0
?newMem@CBufPool@@QEAAPEADXZ ENDP			; CBufPool::newMem
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\combufpool.cpp
;	COMDAT ?alloc@CBufPool@@QEAA_NHH@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 56
tv93 = 64
$T3 = 72
$T4 = 80
$T5 = 88
tv169 = 96
$T6 = 104
this$ = 128
nShift$ = 136
nMaxCount$ = 144
?alloc@CBufPool@@QEAA_NHH@Z PROC			; CBufPool::alloc, COMDAT

; 33   : {

$LN13:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00012	48 c7 44 24 68
	fe ff ff ff	 mov	 QWORD PTR $T6[rsp], -2

; 34   : 	m_nFlagArray = new (std::nothrow) atomic_nr[nMaxCount];

  0001b	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR nMaxCount$[rsp]
  00023	48 89 44 24 38	 mov	 QWORD PTR $T2[rsp], rax
  00028	b8 08 00 00 00	 mov	 eax, 8
  0002d	48 f7 64 24 38	 mul	 QWORD PTR $T2[rsp]
  00032	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  00039	48 0f 40 c1	 cmovo	 rax, rcx
  0003d	48 83 c0 08	 add	 rax, 8
  00041	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  00048	48 0f 42 c1	 cmovb	 rax, rcx
  0004c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00053	48 8b c8	 mov	 rcx, rax
  00056	e8 00 00 00 00	 call	 ??_U@YAPEAX_KAEBUnothrow_t@std@@@Z ; operator new[]
  0005b	48 89 44 24 30	 mov	 QWORD PTR $T1[rsp], rax
  00060	48 83 7c 24 30
	00		 cmp	 QWORD PTR $T1[rsp], 0
  00066	74 4b		 je	 SHORT $LN8@alloc
  00068	48 8b 44 24 30	 mov	 rax, QWORD PTR $T1[rsp]
  0006d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR $T2[rsp]
  00072	48 89 08	 mov	 QWORD PTR [rax], rcx
  00075	48 8b 44 24 30	 mov	 rax, QWORD PTR $T1[rsp]
  0007a	48 83 c0 08	 add	 rax, 8
  0007e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??1win64_atomic@win32@common@@QEAA@XZ ; common::win32::win64_atomic::~win64_atomic
  00085	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0008a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??0win64_atomic@win32@common@@QEAA@XZ ; common::win32::win64_atomic::win64_atomic
  00091	4c 8b 44 24 38	 mov	 r8, QWORD PTR $T2[rsp]
  00096	ba 08 00 00 00	 mov	 edx, 8
  0009b	48 8b c8	 mov	 rcx, rax
  0009e	e8 00 00 00 00	 call	 ??_L@YAXPEAX_K1P6AX0@Z2@Z
  000a3	48 8b 44 24 30	 mov	 rax, QWORD PTR $T1[rsp]
  000a8	48 83 c0 08	 add	 rax, 8
  000ac	48 89 44 24 40	 mov	 QWORD PTR tv93[rsp], rax
  000b1	eb 09		 jmp	 SHORT $LN9@alloc
$LN8@alloc:
  000b3	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv93[rsp], 0
$LN9@alloc:
  000bc	48 8b 44 24 40	 mov	 rax, QWORD PTR tv93[rsp]
  000c1	48 89 44 24 50	 mov	 QWORD PTR $T4[rsp], rax
  000c6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000ce	48 8b 4c 24 50	 mov	 rcx, QWORD PTR $T4[rsp]
  000d3	48 89 08	 mov	 QWORD PTR [rax], rcx

; 35   : 	if(m_nFlagArray == NULL) {

  000d6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000de	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  000e2	75 31		 jne	 SHORT $LN5@alloc

; 36   : 		gs_cLogger.DebugLog(LEVEL_ERROR, "new m_nFlagArray");

  000e4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG44498
  000eb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000f0	41 b9 24 00 00
	00		 mov	 r9d, 36			; 00000024H
  000f6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG44499
  000fd	ba 05 00 00 00	 mov	 edx, 5
  00102	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  00109	e8 00 00 00 00	 call	 ?__debugLog@CLogger@@QEAAXHPEBDH0ZZ ; CLogger::__debugLog

; 37   : 		return false;

  0010e	32 c0		 xor	 al, al
  00110	e9 a4 01 00 00	 jmp	 $LN1@alloc
$LN5@alloc:

; 38   : 	}
; 39   : 	for (m_nLastCount = 0; m_nLastCount < nMaxCount; m_nLastCount++)

  00115	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0011d	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0
  00124	eb 18		 jmp	 SHORT $LN4@alloc
$LN2@alloc:
  00126	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0012e	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00131	ff c0		 inc	 eax
  00133	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0013b	89 41 18	 mov	 DWORD PTR [rcx+24], eax
$LN4@alloc:
  0013e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00146	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR nMaxCount$[rsp]
  0014d	39 48 18	 cmp	 DWORD PTR [rax+24], ecx
  00150	7d 25		 jge	 SHORT $LN3@alloc

; 40   : 	{
; 41   : 		m_nFlagArray[m_nLastCount].init();

  00152	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0015a	48 63 40 18	 movsxd	 rax, DWORD PTR [rax+24]
  0015e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00166	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00169	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  0016d	48 8b c8	 mov	 rcx, rax
  00170	e8 00 00 00 00	 call	 ?init@win64_atomic@win32@common@@QEAAXXZ ; common::win32::win64_atomic::init

; 42   : 	}

  00175	eb af		 jmp	 SHORT $LN2@alloc
$LN3@alloc:

; 43   : 
; 44   : 	m_pChunk = (char *)calloc(nMaxCount, getSizeByIndex(nShift));

  00177	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR nShift$[rsp]
  0017e	e8 00 00 00 00	 call	 ?getSizeByIndex@@YAHH@Z	; getSizeByIndex
  00183	48 98		 cdqe
  00185	48 63 8c 24 90
	00 00 00	 movsxd	 rcx, DWORD PTR nMaxCount$[rsp]
  0018d	48 8b d0	 mov	 rdx, rax
  00190	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00196	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0019e	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 45   : 
; 46   :     if(m_pChunk == NULL) {

  001a2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001aa	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  001af	0f 85 81 00 00
	00		 jne	 $LN6@alloc

; 47   : 		gs_cLogger.DebugLog(LEVEL_ERROR, "m_pChunk alloc");

  001b5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG44501
  001bc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c1	41 b9 2f 00 00
	00		 mov	 r9d, 47			; 0000002fH
  001c7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG44502
  001ce	ba 05 00 00 00	 mov	 edx, 5
  001d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  001da	e8 00 00 00 00	 call	 ?__debugLog@CLogger@@QEAAXHPEBDH0ZZ ; CLogger::__debugLog

; 48   : 		delete[] m_nFlagArray;

  001df	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001e7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001ea	48 89 44 24 58	 mov	 QWORD PTR $T5[rsp], rax
  001ef	48 8b 44 24 58	 mov	 rax, QWORD PTR $T5[rsp]
  001f4	48 89 44 24 48	 mov	 QWORD PTR $T3[rsp], rax
  001f9	48 83 7c 24 48
	00		 cmp	 QWORD PTR $T3[rsp], 0
  001ff	74 16		 je	 SHORT $LN10@alloc
  00201	ba 03 00 00 00	 mov	 edx, 3
  00206	48 8b 4c 24 48	 mov	 rcx, QWORD PTR $T3[rsp]
  0020b	e8 00 00 00 00	 call	 ??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z
  00210	48 89 44 24 60	 mov	 QWORD PTR tv169[rsp], rax
  00215	eb 09		 jmp	 SHORT $LN11@alloc
$LN10@alloc:
  00217	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR tv169[rsp], 0
$LN11@alloc:

; 49   : 		m_nFlagArray = NULL;

  00220	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00228	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 50   : 		return false;

  0022f	32 c0		 xor	 al, al
  00231	e9 83 00 00 00	 jmp	 $LN1@alloc
$LN6@alloc:

; 51   :     }
; 52   : 
; 53   :     m_nAllocCount   = nMaxCount;

  00236	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0023e	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR nMaxCount$[rsp]
  00245	89 48 1c	 mov	 DWORD PTR [rax+28], ecx

; 54   : 	m_nLastCount = 0;

  00248	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00250	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0

; 55   : 	m_nUseCnt.init();

  00257	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0025f	48 83 c0 08	 add	 rax, 8
  00263	48 8b c8	 mov	 rcx, rax
  00266	e8 00 00 00 00	 call	 ?init@win64_atomic@win32@common@@QEAAXXZ ; common::win32::win64_atomic::init

; 56   : 	m_nShift = nShift;

  0026b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00273	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR nShift$[rsp]
  0027a	89 48 20	 mov	 DWORD PTR [rax+32], ecx

; 57   : 	m_pEnd = &m_pChunk[(m_nAllocCount-1)<< m_nShift];

  0027d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00285	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00288	ff c8		 dec	 eax
  0028a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  00292	8b 49 20	 mov	 ecx, DWORD PTR [rcx+32]
  00295	d3 e0		 shl	 eax, cl
  00297	48 98		 cdqe
  00299	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  002a1	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  002a5	48 03 c8	 add	 rcx, rax
  002a8	48 8b c1	 mov	 rax, rcx
  002ab	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  002b3	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 58   : 	return true;

  002b7	b0 01		 mov	 al, 1
$LN1@alloc:

; 59   : }

  002b9	48 83 c4 78	 add	 rsp, 120		; 00000078H
  002bd	c3		 ret	 0
?alloc@CBufPool@@QEAA_NHH@Z ENDP			; CBufPool::alloc
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 56
tv93 = 64
$T3 = 72
$T4 = 80
$T5 = 88
tv169 = 96
$T6 = 104
this$ = 128
nShift$ = 136
nMaxCount$ = 144
?dtor$0@?0??alloc@CBufPool@@QEAA_NHH@Z@4HA PROC		; `CBufPool::alloc'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00010	48 8b 4d 30	 mov	 rcx, QWORD PTR $T1[rbp]
  00014	e8 00 00 00 00	 call	 ??_V@YAXPEAXAEBUnothrow_t@std@@@Z ; operator delete[]
  00019	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001d	5d		 pop	 rbp
  0001e	c3		 ret	 0
?dtor$0@?0??alloc@CBufPool@@QEAA_NHH@Z@4HA ENDP		; `CBufPool::alloc'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 56
tv93 = 64
$T3 = 72
$T4 = 80
$T5 = 88
tv169 = 96
$T6 = 104
this$ = 128
nShift$ = 136
nMaxCount$ = 144
?dtor$0@?0??alloc@CBufPool@@QEAA_NHH@Z@4HA PROC		; `CBufPool::alloc'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00010	48 8b 4d 30	 mov	 rcx, QWORD PTR $T1[rbp]
  00014	e8 00 00 00 00	 call	 ??_V@YAXPEAXAEBUnothrow_t@std@@@Z ; operator delete[]
  00019	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001d	5d		 pop	 rbp
  0001e	c3		 ret	 0
?dtor$0@?0??alloc@CBufPool@@QEAA_NHH@Z@4HA ENDP		; `CBufPool::alloc'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\combufpool.cpp
;	COMDAT ?clear@CBufPool@@QEAAXXZ
_TEXT	SEGMENT
i$ = 32
tv82 = 40
this$ = 64
?clear@CBufPool@@QEAAXXZ PROC				; CBufPool::clear, COMDAT

; 63   : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 64   : 	int i;
; 65   : 	m_nUseCnt.init();

  0000a	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0000f	48 83 c0 08	 add	 rax, 8
  00013	48 8b c8	 mov	 rcx, rax
  00016	e8 00 00 00 00	 call	 ?init@win64_atomic@win32@common@@QEAAXXZ ; common::win32::win64_atomic::init

; 66   : 	m_nLastCount = 0;

  0001b	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00020	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0

; 67   : 	for(i = 0; i < m_nAllocCount; i++)

  00027	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0002f	eb 0a		 jmp	 SHORT $LN4@clear
$LN2@clear:
  00031	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00035	ff c0		 inc	 eax
  00037	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@clear:
  0003b	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00040	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00043	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00047	7d 1b		 jge	 SHORT $LN3@clear

; 68   : 	{
; 69   : 		m_nFlagArray[i].init();

  00049	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0004e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00053	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00056	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  0005a	48 8b c8	 mov	 rcx, rax
  0005d	e8 00 00 00 00	 call	 ?init@win64_atomic@win32@common@@QEAAXXZ ; common::win32::win64_atomic::init

; 70   : 	}

  00062	eb cd		 jmp	 SHORT $LN2@clear
$LN3@clear:

; 71   : 	memset(m_pChunk, 0, getSizeByIndex(m_nShift)*m_nAllocCount);

  00064	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00069	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  0006c	e8 00 00 00 00	 call	 ?getSizeByIndex@@YAHH@Z	; getSizeByIndex
  00071	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00076	0f af 41 1c	 imul	 eax, DWORD PTR [rcx+28]
  0007a	48 98		 cdqe
  0007c	48 89 44 24 28	 mov	 QWORD PTR tv82[rsp], rax
  00081	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00086	48 8b 79 28	 mov	 rdi, QWORD PTR [rcx+40]
  0008a	33 c0		 xor	 eax, eax
  0008c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv82[rsp]
  00091	f3 aa		 rep stosb

; 72   : }

  00093	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00097	5f		 pop	 rdi
  00098	c3		 ret	 0
?clear@CBufPool@@QEAAXXZ ENDP				; CBufPool::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\combufpool.cpp
;	COMDAT ??1CBufPool@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
tv80 = 48
this$ = 80
??1CBufPool@@QEAA@XZ PROC				; CBufPool::~CBufPool, COMDAT

; 20   : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 21   :     if(m_pChunk) {

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00013	74 1c		 je	 SHORT $LN2@CBufPool

; 22   :         free(m_pChunk);

  00015	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0001a	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 23   :         m_pChunk = NULL;

  00024	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00029	48 c7 40 28 00
	00 00 00	 mov	 QWORD PTR [rax+40], 0
$LN2@CBufPool:

; 24   :     }
; 25   : 
; 26   :     if(m_nFlagArray) {

  00031	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00036	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0003a	74 4a		 je	 SHORT $LN3@CBufPool

; 27   :         delete [] m_nFlagArray;

  0003c	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00041	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00044	48 89 44 24 28	 mov	 QWORD PTR $T2[rsp], rax
  00049	48 8b 44 24 28	 mov	 rax, QWORD PTR $T2[rsp]
  0004e	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax
  00053	48 83 7c 24 20
	00		 cmp	 QWORD PTR $T1[rsp], 0
  00059	74 16		 je	 SHORT $LN5@CBufPool
  0005b	ba 03 00 00 00	 mov	 edx, 3
  00060	48 8b 4c 24 20	 mov	 rcx, QWORD PTR $T1[rsp]
  00065	e8 00 00 00 00	 call	 ??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z
  0006a	48 89 44 24 30	 mov	 QWORD PTR tv80[rsp], rax
  0006f	eb 09		 jmp	 SHORT $LN6@CBufPool
$LN5@CBufPool:
  00071	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tv80[rsp], 0
$LN6@CBufPool:

; 28   :         m_nFlagArray = NULL;

  0007a	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0007f	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN3@CBufPool:

; 29   :     }	
; 30   : }

  00086	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0008b	48 83 c0 10	 add	 rax, 16
  0008f	48 8b c8	 mov	 rcx, rax
  00092	e8 00 00 00 00	 call	 ??1win64_atomic@win32@common@@QEAA@XZ ; common::win32::win64_atomic::~win64_atomic
  00097	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0009c	48 83 c0 08	 add	 rax, 8
  000a0	48 8b c8	 mov	 rcx, rax
  000a3	e8 00 00 00 00	 call	 ??1win64_atomic@win32@common@@QEAA@XZ ; common::win32::win64_atomic::~win64_atomic
  000a8	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ac	c3		 ret	 0
??1CBufPool@@QEAA@XZ ENDP				; CBufPool::~CBufPool
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\combufpool.cpp
;	COMDAT ??0CBufPool@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??0CBufPool@@QEAA@XZ PROC				; CBufPool::CBufPool, COMDAT

; 7    : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00018	48 83 c0 08	 add	 rax, 8
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	e8 00 00 00 00	 call	 ??0win64_atomic@win32@common@@QEAA@XZ ; common::win32::win64_atomic::win64_atomic
  00024	90		 npad	 1
  00025	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0002a	48 83 c0 10	 add	 rax, 16
  0002e	48 8b c8	 mov	 rcx, rax
  00031	e8 00 00 00 00	 call	 ??0win64_atomic@win32@common@@QEAA@XZ ; common::win32::win64_atomic::win64_atomic

; 8    : 	m_nAllocCount = 0;

  00036	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0003b	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [rax+28], 0

; 9    : 	m_nLastCount = 0;

  00042	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00047	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0

; 10   : 	memset(g_szMessage, 0 ,LEN_MEM_MESSAGE); 

  0004e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  00055	48 8b f8	 mov	 rdi, rax
  00058	33 c0		 xor	 eax, eax
  0005a	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  0005f	f3 aa		 rep stosb

; 11   : 	m_pChunk = NULL;

  00061	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00066	48 c7 40 28 00
	00 00 00	 mov	 QWORD PTR [rax+40], 0

; 12   : 	m_nFlagArray = NULL;

  0006e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00073	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 13   : 	m_nShift = 0;

  0007a	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0007f	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [rax+32], 0

; 14   : 	m_pEnd = NULL;

  00086	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0008b	48 c7 40 30 00
	00 00 00	 mov	 QWORD PTR [rax+48], 0

; 15   : 	//m_nOverCnt.init();
; 16   : 	//m_nOverMaxCnt.init();
; 17   : }

  00093	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00098	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0009c	5f		 pop	 rdi
  0009d	c3		 ret	 0
??0CBufPool@@QEAA@XZ ENDP				; CBufPool::CBufPool
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$0@?0???0CBufPool@@QEAA@XZ@4HA PROC		; `CBufPool::CBufPool'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8b 4d 40	 mov	 rcx, QWORD PTR this$[rbp]
  0000d	48 83 c1 08	 add	 rcx, 8
  00011	e8 00 00 00 00	 call	 ??1win64_atomic@win32@common@@QEAA@XZ ; common::win32::win64_atomic::~win64_atomic
  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5d		 pop	 rbp
  0001b	c3		 ret	 0
?dtor$0@?0???0CBufPool@@QEAA@XZ@4HA ENDP		; `CBufPool::CBufPool'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$0@?0???0CBufPool@@QEAA@XZ@4HA PROC		; `CBufPool::CBufPool'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8b 4d 40	 mov	 rcx, QWORD PTR this$[rbp]
  0000d	48 83 c1 08	 add	 rcx, 8
  00011	e8 00 00 00 00	 call	 ??1win64_atomic@win32@common@@QEAA@XZ ; common::win32::win64_atomic::~win64_atomic
  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5d		 pop	 rbp
  0001b	c3		 ret	 0
?dtor$0@?0???0CBufPool@@QEAA@XZ@4HA ENDP		; `CBufPool::CBufPool'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\combufpool.h
;	COMDAT ?getSizeByIndex@@YAHH@Z
_TEXT	SEGMENT
nIdx$ = 8
?getSizeByIndex@@YAHH@Z PROC				; getSizeByIndex, COMDAT

; 52   : inline int getSizeByIndex(int nIdx) { return g_nSizeList[nIdx]; }

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 63 44 24 08	 movsxd	 rax, DWORD PTR nIdx$[rsp]
  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_nSizeList@@3QBHB ; g_nSizeList
  00010	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00013	c3		 ret	 0
?getSizeByIndex@@YAHH@Z ENDP				; getSizeByIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtypes.h
;	COMDAT ?ISINCLUDE@@YA_NHH@Z
_TEXT	SEGMENT
i$ = 8
max$ = 16
?ISINCLUDE@@YA_NHH@Z PROC				; ISINCLUDE, COMDAT

; 322  : inline bool ISINCLUDE(int i, int max) { if (0 <= i && i < max) return true; return false; }

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	83 7c 24 08 00	 cmp	 DWORD PTR i$[rsp], 0
  0000d	7c 0e		 jl	 SHORT $LN2@ISINCLUDE
  0000f	8b 44 24 10	 mov	 eax, DWORD PTR max$[rsp]
  00013	39 44 24 08	 cmp	 DWORD PTR i$[rsp], eax
  00017	7d 04		 jge	 SHORT $LN2@ISINCLUDE
  00019	b0 01		 mov	 al, 1
  0001b	eb 02		 jmp	 SHORT $LN1@ISINCLUDE
$LN2@ISINCLUDE:
  0001d	32 c0		 xor	 al, al
$LN1@ISINCLUDE:
  0001f	c3		 ret	 0
?ISINCLUDE@@YA_NHH@Z ENDP				; ISINCLUDE
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtypes.h
;	COMDAT ?bitSet_flag@@YAXHPEAD@Z
_TEXT	SEGMENT
n$ = 8
p$ = 16
?bitSet_flag@@YAXHPEAD@Z PROC				; bitSet_flag, COMDAT

; 316  : inline void bitSet_flag(int n, char *p) {  p[n >> 3] |= (n & 7); }

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	8b 44 24 08	 mov	 eax, DWORD PTR n$[rsp]
  0000d	c1 f8 03	 sar	 eax, 3
  00010	48 98		 cdqe
  00012	8b 4c 24 08	 mov	 ecx, DWORD PTR n$[rsp]
  00016	83 e1 07	 and	 ecx, 7
  00019	48 8b 54 24 10	 mov	 rdx, QWORD PTR p$[rsp]
  0001e	0f be 04 02	 movsx	 eax, BYTE PTR [rdx+rax]
  00022	0b c1		 or	 eax, ecx
  00024	8b 4c 24 08	 mov	 ecx, DWORD PTR n$[rsp]
  00028	c1 f9 03	 sar	 ecx, 3
  0002b	48 63 c9	 movsxd	 rcx, ecx
  0002e	48 8b 54 24 10	 mov	 rdx, QWORD PTR p$[rsp]
  00033	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00036	c3		 ret	 0
?bitSet_flag@@YAXHPEAD@Z ENDP				; bitSet_flag
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtypes.h
;	COMDAT ?bitClear_flag@@YAXHPEAD@Z
_TEXT	SEGMENT
n$ = 8
p$ = 16
?bitClear_flag@@YAXHPEAD@Z PROC				; bitClear_flag, COMDAT

; 315  : inline void bitClear_flag(int n, char *p) {  p[n >> 3] &= ~(n & 7); }

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	8b 44 24 08	 mov	 eax, DWORD PTR n$[rsp]
  0000d	c1 f8 03	 sar	 eax, 3
  00010	48 98		 cdqe
  00012	8b 4c 24 08	 mov	 ecx, DWORD PTR n$[rsp]
  00016	83 e1 07	 and	 ecx, 7
  00019	f7 d1		 not	 ecx
  0001b	48 8b 54 24 10	 mov	 rdx, QWORD PTR p$[rsp]
  00020	0f be 04 02	 movsx	 eax, BYTE PTR [rdx+rax]
  00024	23 c1		 and	 eax, ecx
  00026	8b 4c 24 08	 mov	 ecx, DWORD PTR n$[rsp]
  0002a	c1 f9 03	 sar	 ecx, 3
  0002d	48 63 c9	 movsxd	 rcx, ecx
  00030	48 8b 54 24 10	 mov	 rdx, QWORD PTR p$[rsp]
  00035	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00038	c3		 ret	 0
?bitClear_flag@@YAXHPEAD@Z ENDP				; bitClear_flag
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtypes.h
;	COMDAT ?isBitSet_flag@@YA_NHPEAD@Z
_TEXT	SEGMENT
tv72 = 0
n$ = 32
p$ = 40
?isBitSet_flag@@YA_NHPEAD@Z PROC			; isBitSet_flag, COMDAT

; 314  : inline bool isBitSet_flag(int n, char *p) { return p[n >> 3] & (n & 7)?true:false; }  // 8bit char   .

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 18	 sub	 rsp, 24
  0000d	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  00011	c1 f8 03	 sar	 eax, 3
  00014	48 98		 cdqe
  00016	48 8b 4c 24 28	 mov	 rcx, QWORD PTR p$[rsp]
  0001b	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0001f	8b 4c 24 20	 mov	 ecx, DWORD PTR n$[rsp]
  00023	83 e1 07	 and	 ecx, 7
  00026	23 c1		 and	 eax, ecx
  00028	85 c0		 test	 eax, eax
  0002a	74 06		 je	 SHORT $LN3@isBitSet_f
  0002c	c6 04 24 01	 mov	 BYTE PTR tv72[rsp], 1
  00030	eb 04		 jmp	 SHORT $LN4@isBitSet_f
$LN3@isBitSet_f:
  00032	c6 04 24 00	 mov	 BYTE PTR tv72[rsp], 0
$LN4@isBitSet_f:
  00036	0f b6 04 24	 movzx	 eax, BYTE PTR tv72[rsp]
  0003a	48 83 c4 18	 add	 rsp, 24
  0003e	c3		 ret	 0
?isBitSet_flag@@YA_NHPEAD@Z ENDP			; isBitSet_flag
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__flags$ = 72
??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z PROC		; common::win32::win64_atomic::`vector deleting destructor', COMDAT
$LN6:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  0000d	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00016	8b 44 24 48	 mov	 eax, DWORD PTR __flags$[rsp]
  0001a	83 e0 02	 and	 eax, 2
  0001d	85 c0		 test	 eax, eax
  0001f	74 59		 je	 SHORT $LN2@vector
  00021	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??1win64_atomic@win32@common@@QEAA@XZ ; common::win32::win64_atomic::~win64_atomic
  00028	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0002d	4c 8b 40 f8	 mov	 r8, QWORD PTR [rax-8]
  00031	ba 08 00 00 00	 mov	 edx, 8
  00036	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0003b	e8 00 00 00 00	 call	 ??_M@YAXPEAX_K1P6AX0@Z@Z
  00040	90		 npad	 1
  00041	8b 44 24 48	 mov	 eax, DWORD PTR __flags$[rsp]
  00045	83 e0 01	 and	 eax, 1
  00048	85 c0		 test	 eax, eax
  0004a	74 23		 je	 SHORT $LN3@vector
  0004c	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00051	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  00055	48 8d 04 c5 08
	00 00 00	 lea	 rax, QWORD PTR [rax*8+8]
  0005d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00062	48 83 e9 08	 sub	 rcx, 8
  00066	48 8b d0	 mov	 rdx, rax
  00069	e8 00 00 00 00	 call	 ??_V@YAXPEAX_K@Z	; operator delete[]
  0006e	90		 npad	 1
$LN3@vector:
  0006f	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00074	48 83 e8 08	 sub	 rax, 8
  00078	eb 2b		 jmp	 SHORT $LN1@vector
$LN2@vector:
  0007a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0007f	e8 00 00 00 00	 call	 ??1win64_atomic@win32@common@@QEAA@XZ ; common::win32::win64_atomic::~win64_atomic
  00084	90		 npad	 1
  00085	8b 44 24 48	 mov	 eax, DWORD PTR __flags$[rsp]
  00089	83 e0 01	 and	 eax, 1
  0008c	85 c0		 test	 eax, eax
  0008e	74 10		 je	 SHORT $LN4@vector
  00090	ba 08 00 00 00	 mov	 edx, 8
  00095	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0009a	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  0009f	90		 npad	 1
$LN4@vector:
  000a0	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
$LN1@vector:
  000a5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a9	c3		 ret	 0
??_Ewin64_atomic@win32@common@@QEAAPEAXI@Z ENDP		; common::win32::win64_atomic::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ?atomic_compare_exchange@win64_atomic@win32@common@@QEAA_J_J0@Z
_TEXT	SEGMENT
tv70 = 0
this$ = 32
nExchange$ = 40
nComperand$ = 48
?atomic_compare_exchange@win64_atomic@win32@common@@QEAA_J_J0@Z PROC ; common::win32::win64_atomic::atomic_compare_exchange, COMDAT

; 120  : 	inline long long atomic_compare_exchange(long long nExchange, long long nComperand) {return InterlockedCompareExchange64(&m_count, nExchange, nComperand);} // return long

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 18	 sub	 rsp, 24
  00013	48 8b 44 24 20	 mov	 rax, QWORD PTR this$[rsp]
  00018	48 8b 4c 24 28	 mov	 rcx, QWORD PTR nExchange$[rsp]
  0001d	48 89 04 24	 mov	 QWORD PTR tv70[rsp], rax
  00021	48 8b 44 24 30	 mov	 rax, QWORD PTR nComperand$[rsp]
  00026	48 8b 14 24	 mov	 rdx, QWORD PTR tv70[rsp]
  0002a	48 8b 14 24	 mov	 rdx, QWORD PTR tv70[rsp]
  0002e	f0 48 0f b1 0a	 lock cmpxchg QWORD PTR [rdx], rcx
  00033	48 83 c4 18	 add	 rsp, 24
  00037	c3		 ret	 0
?atomic_compare_exchange@win64_atomic@win32@common@@QEAA_J_J0@Z ENDP ; common::win32::win64_atomic::atomic_compare_exchange
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ?atomic_decrement@win64_atomic@win32@common@@QEAA_JXZ
_TEXT	SEGMENT
this$ = 8
?atomic_decrement@win64_atomic@win32@common@@QEAA_JXZ PROC ; common::win32::win64_atomic::atomic_decrement, COMDAT

; 118  : 	inline long long atomic_decrement() { return InterlockedDecrement64(&m_count);}

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  00011	f0 48 0f c1 08	 lock xadd QWORD PTR [rax], rcx
  00016	48 ff c9	 dec	 rcx
  00019	48 8b c1	 mov	 rax, rcx
  0001c	c3		 ret	 0
?atomic_decrement@win64_atomic@win32@common@@QEAA_JXZ ENDP ; common::win32::win64_atomic::atomic_decrement
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ?atomic_increment@win64_atomic@win32@common@@QEAA_JXZ
_TEXT	SEGMENT
this$ = 8
?atomic_increment@win64_atomic@win32@common@@QEAA_JXZ PROC ; common::win32::win64_atomic::atomic_increment, COMDAT

; 117  : 	inline long long atomic_increment() { return InterlockedIncrement64(&m_count);}

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	b9 01 00 00 00	 mov	 ecx, 1
  0000f	f0 48 0f c1 08	 lock xadd QWORD PTR [rax], rcx
  00014	48 ff c1	 inc	 rcx
  00017	48 8b c1	 mov	 rax, rcx
  0001a	c3		 ret	 0
?atomic_increment@win64_atomic@win32@common@@QEAA_JXZ ENDP ; common::win32::win64_atomic::atomic_increment
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ?init@win64_atomic@win32@common@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?init@win64_atomic@win32@common@@QEAAXXZ PROC		; common::win32::win64_atomic::init, COMDAT

; 114  : 	inline void init() { m_count = 0; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  00011	c3		 ret	 0
?init@win64_atomic@win32@common@@QEAAXXZ ENDP		; common::win32::win64_atomic::init
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ?getCount@win64_atomic@win32@common@@QEAAHXZ
_TEXT	SEGMENT
this$ = 8
?getCount@win64_atomic@win32@common@@QEAAHXZ PROC	; common::win32::win64_atomic::getCount, COMDAT

; 111  : 	inline int getCount() { return (int)m_count; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0000d	c3		 ret	 0
?getCount@win64_atomic@win32@common@@QEAAHXZ ENDP	; common::win32::win64_atomic::getCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ??1win64_atomic@win32@common@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1win64_atomic@win32@common@@QEAA@XZ PROC		; common::win32::win64_atomic::~win64_atomic, COMDAT

; 108  : 	~win64_atomic() {}

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	c3		 ret	 0
??1win64_atomic@win32@common@@QEAA@XZ ENDP		; common::win32::win64_atomic::~win64_atomic
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\com\win32\win32_mtsync.h
;	COMDAT ??0win64_atomic@win32@common@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0win64_atomic@win32@common@@QEAA@XZ PROC		; common::win32::win64_atomic::win64_atomic, COMDAT

; 107  : 	win64_atomic() {m_count = 0;}

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000a	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  00011	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00016	c3		 ret	 0
??0win64_atomic@win32@common@@QEAA@XZ ENDP		; common::win32::win64_atomic::win64_atomic
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
__$ArrayPad$ = 48
_Buffer$ = 80
_Format$ = 88
sprintf	PROC						; COMDAT

; 1776 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 44 24 30	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

  00027	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
  0002c	48 8d 44 24 60	 lea	 rax, QWORD PTR _Format$[rsp+8]
  00031	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  00036	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  0003b	45 33 c0	 xor	 r8d, r8d
  0003e	48 8b 54 24 58	 mov	 rdx, QWORD PTR _Format$[rsp]
  00043	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00048	e8 00 00 00 00	 call	 _vsprintf_l
  0004d	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

  00051	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 1787 :     return _Result;

  0005a	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 1788 : }

  0005e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00063	48 33 cc	 xor	 rcx, rsp
  00066	e8 00 00 00 00	 call	 __security_check_cookie
  0006b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0006f	c3		 ret	 0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1455 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00018	48 8b 44 24 58	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00022	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  00027	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  0002c	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  00033	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00038	e8 00 00 00 00	 call	 _vsnprintf_l

; 1459 :     #pragma warning(pop)
; 1460 : }

  0003d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00041	c3		 ret	 0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1385 : {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00020	48 83 c8 01	 or	 rax, 1
  00024	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00029	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0002e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00033	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00038	4c 8b 4c 24 60	 mov	 r9, QWORD PTR _Format$[rsp]
  0003d	4c 8b 44 24 58	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  00042	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00047	48 8b c8	 mov	 rcx, rax
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsprintf
  00050	89 44 24 30	 mov	 DWORD PTR _Result$[rsp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00054	83 7c 24 30 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00059	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  0005b	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  00063	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00065	8b 44 24 30	 mov	 eax, DWORD PTR _Result$[rsp]
  00069	89 44 24 34	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  0006d	8b 44 24 34	 mov	 eax, DWORD PTR tv74[rsp]

; 1391 : }

  00071	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00075	c3		 ret	 0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ PROC ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ENDP ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
