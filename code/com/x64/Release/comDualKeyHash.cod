; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG45265 DB	'CBMemPool::pPool alloc ERROR', 00H
	ORG $+3
$SG45267 DB	'CBMemPool::pFlag alloc ERROR', 00H
	ORG $+3
$SG45268 DB	'CBMemPool __alloc m_nAllocCount[%d]', 00H
	ORG $+4
$SG45335 DB	'CBMemPool::pPool alloc ERROR', 00H
	ORG $+3
$SG45337 DB	'CBMemPool::pFlag alloc ERROR', 00H
	ORG $+3
$SG45338 DB	'CBMemPool __alloc m_nAllocCount[%d]', 00H
	ORG $+4
$SG44991 DB	'DUPLICATE_KEYS pKey1[%s] pHash->hashLookup(pKey2[%s])', 00H
	ORG $+2
$SG44992 DB	'CDKeyHashMap::addKey', 00H
	ORG $+3
$SG44998 DB	'errorNo[%d] new CHash(max:%d) key1:%s', 00H
	ORG $+2
$SG44999 DB	'CDKeyHashMap::addKey', 00H
	ORG $+3
$SG45000 DB	'new CHash(max:%d) key1:%s hashNo[%d]', 00H
	ORG $+3
$SG45006 DB	'errorNo[%d] pHash->addNode(pNext, %s)', 00H
CONST	ENDS
PUBLIC	?setHashValue@CHash@@QEAAXPEAX@Z		; CHash::setHashValue
PUBLIC	?__autoclassinit2@CHash@@QEAAX_K@Z		; CHash::__autoclassinit2
PUBLIC	??_GCHash@@QEAAPEAXI@Z				; CHash::`scalar deleting destructor'
PUBLIC	__local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	sprintf
PUBLIC	?c_memcpy@@YAPEAXPEAXPEBXH@Z			; c_memcpy
PUBLIC	?ISINCLUDE@@YA_NHH@Z				; ISINCLUDE
PUBLIC	?getIndex@@YAHH@Z				; getIndex
PUBLIC	?init@CMemManager@@QEAAXW4E_IDX_BUF@@H@Z	; CMemManager::init
PUBLIC	?newBuf@CMemManager@@QEAAPEADH@Z		; CMemManager::newBuf
PUBLIC	?newBuf@CMemManager@@QEAAPEADHPEAH@Z		; CMemManager::newBuf
PUBLIC	?delBuf@CMemManager@@QEAAXPEADH@Z		; CMemManager::delBuf
PUBLIC	??0CDKeyHashMap@@QEAA@HH_N@Z			; CDKeyHashMap::CDKeyHashMap
PUBLIC	??1CDKeyHashMap@@QEAA@XZ			; CDKeyHashMap::~CDKeyHashMap
PUBLIC	?addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z ; CDKeyHashMap::addKey
PUBLIC	?addKeyValue@CDKeyHashMap@@QEAAHPEAD0PEAX1@Z	; CDKeyHashMap::addKeyValue
PUBLIC	?setValue@CDKeyHashMap@@QEAAHPEAD0PEAX@Z	; CDKeyHashMap::setValue
PUBLIC	?deleteHash@CDKeyHashMap@@QEAA_NPEAD@Z		; CDKeyHashMap::deleteHash
PUBLIC	?deleteNode@CDKeyHashMap@@QEAA_NPEAD0@Z		; CDKeyHashMap::deleteNode
PUBLIC	?newValueBuf@CDKeyHashMap@@QEAAPEAUSTValue@@HPEAD@Z ; CDKeyHashMap::newValueBuf
PUBLIC	?delValueBuf@CDKeyHashMap@@QEAAXPEAUSTValue@@@Z	; CDKeyHashMap::delValueBuf
PUBLIC	?isNode@CDKeyHashMap@@QEAA_NPEAD0@Z		; CDKeyHashMap::isNode
PUBLIC	?getHashMap@CDKeyHashMap@@QEAAPEAVCHash@@PEAD@Z	; CDKeyHashMap::getHashMap
PUBLIC	?getNode@CDKeyHashMap@@QEAAPEAUSTHash_Node@@PEAD0@Z ; CDKeyHashMap::getNode
PUBLIC	??0?$CBMemPool@USTValue@@@@QEAA@W4E_ALLOC_TYPE@@@Z ; CBMemPool<STValue>::CBMemPool<STValue>
PUBLIC	??1?$CBMemPool@USTValue@@@@QEAA@XZ		; CBMemPool<STValue>::~CBMemPool<STValue>
PUBLIC	?alloc@?$CBMemPool@USTValue@@@@QEAAHH@Z		; CBMemPool<STValue>::alloc
PUBLIC	?newMem@?$CBMemPool@USTValue@@@@QEAAPEAUSTValue@@XZ ; CBMemPool<STValue>::newMem
PUBLIC	?delMem@?$CBMemPool@USTValue@@@@QEAA_NPEAUSTValue@@@Z ; CBMemPool<STValue>::delMem
PUBLIC	?__unit_alloc@?$CBMemPool@USTValue@@@@AEAAPEAUSTValue@@XZ ; CBMemPool<STValue>::__unit_alloc
PUBLIC	?__alloc@?$CBMemPool@USTValue@@@@AEAAHH@Z	; CBMemPool<STValue>::__alloc
PUBLIC	?__autoclassinit2@?$CBMemPool@USTValue@@@@QEAAX_K@Z ; CBMemPool<STValue>::__autoclassinit2
PUBLIC	??_G?$CBMemPool@USTValue@@@@QEAAPEAXI@Z		; CBMemPool<STValue>::`scalar deleting destructor'
PUBLIC	??0?$CBMemPool@USThash_next@@@@QEAA@W4E_ALLOC_TYPE@@@Z ; CBMemPool<SThash_next>::CBMemPool<SThash_next>
PUBLIC	??1?$CBMemPool@USThash_next@@@@QEAA@XZ		; CBMemPool<SThash_next>::~CBMemPool<SThash_next>
PUBLIC	?alloc@?$CBMemPool@USThash_next@@@@QEAAHH@Z	; CBMemPool<SThash_next>::alloc
PUBLIC	?newMem@?$CBMemPool@USThash_next@@@@QEAAPEAUSThash_next@@XZ ; CBMemPool<SThash_next>::newMem
PUBLIC	?delMem@?$CBMemPool@USThash_next@@@@QEAA_NPEAUSThash_next@@@Z ; CBMemPool<SThash_next>::delMem
PUBLIC	?__unit_alloc@?$CBMemPool@USThash_next@@@@AEAAPEAUSThash_next@@XZ ; CBMemPool<SThash_next>::__unit_alloc
PUBLIC	?__alloc@?$CBMemPool@USThash_next@@@@AEAAHH@Z	; CBMemPool<SThash_next>::__alloc
PUBLIC	?__autoclassinit2@?$CBMemPool@USThash_next@@@@QEAAX_K@Z ; CBMemPool<SThash_next>::__autoclassinit2
PUBLIC	??_G?$CBMemPool@USThash_next@@@@QEAAPEAXI@Z	; CBMemPool<SThash_next>::`scalar deleting destructor'
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
EXTRN	??2@YAPEAX_K@Z:PROC				; operator new
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	??_V@YAXPEAX@Z:PROC				; operator delete[]
EXTRN	??0CHash@@QEAA@I@Z:PROC				; CHash::CHash
EXTRN	??1CHash@@QEAA@XZ:PROC				; CHash::~CHash
EXTRN	?hashLookup@CHash@@QEAAPEAUSTHash_Node@@PEAD@Z:PROC ; CHash::hashLookup
EXTRN	?getNext@CHash@@QEAAPEAUSThash_next@@I@Z:PROC	; CHash::getNext
EXTRN	?getNext@CHash@@QEAAPEAUSThash_next@@PEAD@Z:PROC ; CHash::getNext
EXTRN	?getNode@CHash@@QEAAPEAUSThash_next@@PEADPEAPEAU2@@Z:PROC ; CHash::getNode
EXTRN	?setValue@CHash@@QEAA?AW4HASH_RETURN_CODE@@IPEADPEAX@Z:PROC ; CHash::setValue
EXTRN	?addNode@CHash@@QEAAHPEAUSThash_next@@PEADPEAX@Z:PROC ; CHash::addNode
EXTRN	__imp___stdio_common_vsprintf:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	??2@YAPEAX_KAEBUnothrow_t@std@@@Z:PROC		; operator new
EXTRN	??_U@YAPEAX_KAEBUnothrow_t@std@@@Z:PROC		; operator new[]
EXTRN	??3@YAXPEAXAEBUnothrow_t@std@@@Z:PROC		; operator delete
EXTRN	?delBufByIndex@CMemManager@@QEAAXPEADH@Z:PROC	; CMemManager::delBufByIndex
EXTRN	?__newBuf@CMemManager@@AEAAPEADH_K@Z:PROC	; CMemManager::__newBuf
EXTRN	?PutLogQueue@CLogger@@QEAAXHPEBDZZ:PROC		; CLogger::PutLogQueue
EXTRN	?__debugLog@CLogger@@QEAAXHPEBDH0ZZ:PROC	; CLogger::__debugLog
EXTRN	__CxxFrameHandler3:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	?nothrow@std@@3Unothrow_t@1@B:BYTE		; std::nothrow
EXTRN	?g_szMessage@@3PADA:BYTE			; g_szMessage
EXTRN	?gs_pMMgr@@3PEAVCMemManager@@EA:QWORD		; gs_pMMgr
EXTRN	?gs_cLogger@@3VCLogger@@A:BYTE			; gs_cLogger
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__autoclassinit2@CHash@@QEAAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?__autoclassinit2@CHash@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GCHash@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_GCHash@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+118
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+112
	DD	imagerel $unwind$sprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?c_memcpy@@YAPEAXPEAXPEBXH@Z DD imagerel $LN5
	DD	imagerel $LN5+115
	DD	imagerel $unwind$?c_memcpy@@YAPEAXPEAXPEBXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getIndex@@YAHH@Z DD imagerel $LN5
	DD	imagerel $LN5+119
	DD	imagerel $unwind$?getIndex@@YAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?newBuf@CMemManager@@QEAAPEADH@Z DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$?newBuf@CMemManager@@QEAAPEADH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?newBuf@CMemManager@@QEAAPEADHPEAH@Z DD imagerel $LN3
	DD	imagerel $LN3+64
	DD	imagerel $unwind$?newBuf@CMemManager@@QEAAPEADHPEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?delBuf@CMemManager@@QEAAXPEADH@Z DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$?delBuf@CMemManager@@QEAAXPEADH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0CDKeyHashMap@@QEAA@HH_N@Z DD imagerel $LN14
	DD	imagerel $LN14+700
	DD	imagerel $unwind$??0CDKeyHashMap@@QEAA@HH_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA DD imagerel ?dtor$0@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA
	DD	imagerel ?dtor$0@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA+29
	DD	imagerel $unwind$?dtor$0@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA DD imagerel ?dtor$1@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA
	DD	imagerel ?dtor$1@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA+29
	DD	imagerel $unwind$?dtor$1@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA DD imagerel ?dtor$2@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA
	DD	imagerel ?dtor$2@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA+29
	DD	imagerel $unwind$?dtor$2@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1CDKeyHashMap@@QEAA@XZ DD imagerel $LN24
	DD	imagerel $LN24+814
	DD	imagerel $unwind$??1CDKeyHashMap@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z DD imagerel $LN22
	DD	imagerel $LN22+1170
	DD	imagerel $unwind$?addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z@4HA DD imagerel ?dtor$0@?0??addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z@4HA
	DD	imagerel ?dtor$0@?0??addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z@4HA+34
	DD	imagerel $unwind$?dtor$0@?0??addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?addKeyValue@CDKeyHashMap@@QEAAHPEAD0PEAX1@Z DD imagerel $LN6
	DD	imagerel $LN6+171
	DD	imagerel $unwind$?addKeyValue@CDKeyHashMap@@QEAAHPEAD0PEAX1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setValue@CDKeyHashMap@@QEAAHPEAD0PEAX@Z DD imagerel $LN6
	DD	imagerel $LN6+157
	DD	imagerel $unwind$?setValue@CDKeyHashMap@@QEAAHPEAD0PEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deleteHash@CDKeyHashMap@@QEAA_NPEAD@Z DD imagerel $LN14
	DD	imagerel $LN14+501
	DD	imagerel $unwind$?deleteHash@CDKeyHashMap@@QEAA_NPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deleteNode@CDKeyHashMap@@QEAA_NPEAD0@Z DD imagerel $LN7
	DD	imagerel $LN7+267
	DD	imagerel $unwind$?deleteNode@CDKeyHashMap@@QEAA_NPEAD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?newValueBuf@CDKeyHashMap@@QEAAPEAUSTValue@@HPEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+146
	DD	imagerel $unwind$?newValueBuf@CDKeyHashMap@@QEAAPEAUSTValue@@HPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?delValueBuf@CDKeyHashMap@@QEAAXPEAUSTValue@@@Z DD imagerel $LN4
	DD	imagerel $LN4+80
	DD	imagerel $unwind$?delValueBuf@CDKeyHashMap@@QEAAXPEAUSTValue@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isNode@CDKeyHashMap@@QEAA_NPEAD0@Z DD imagerel $LN5
	DD	imagerel $LN5+96
	DD	imagerel $unwind$?isNode@CDKeyHashMap@@QEAA_NPEAD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getHashMap@CDKeyHashMap@@QEAAPEAVCHash@@PEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$?getHashMap@CDKeyHashMap@@QEAAPEAVCHash@@PEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getNode@CDKeyHashMap@@QEAAPEAUSTHash_Node@@PEAD0@Z DD imagerel $LN4
	DD	imagerel $LN4+89
	DD	imagerel $unwind$?getNode@CDKeyHashMap@@QEAAPEAUSTHash_Node@@PEAD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$CBMemPool@USTValue@@@@QEAA@XZ DD imagerel $LN9
	DD	imagerel $LN9+155
	DD	imagerel $unwind$??1?$CBMemPool@USTValue@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?alloc@?$CBMemPool@USTValue@@@@QEAAHH@Z DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$?alloc@?$CBMemPool@USTValue@@@@QEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?newMem@?$CBMemPool@USTValue@@@@QEAAPEAUSTValue@@XZ DD imagerel $LN11
	DD	imagerel $LN11+279
	DD	imagerel $unwind$?newMem@?$CBMemPool@USTValue@@@@QEAAPEAUSTValue@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?delMem@?$CBMemPool@USTValue@@@@QEAA_NPEAUSTValue@@@Z DD imagerel $LN11
	DD	imagerel $LN11+243
	DD	imagerel $unwind$?delMem@?$CBMemPool@USTValue@@@@QEAA_NPEAUSTValue@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__unit_alloc@?$CBMemPool@USTValue@@@@AEAAPEAUSTValue@@XZ DD imagerel $LN8
	DD	imagerel $LN8+98
	DD	imagerel $unwind$?__unit_alloc@?$CBMemPool@USTValue@@@@AEAAPEAUSTValue@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__alloc@?$CBMemPool@USTValue@@@@AEAAHH@Z DD imagerel $LN10
	DD	imagerel $LN10+326
	DD	imagerel $unwind$?__alloc@?$CBMemPool@USTValue@@@@AEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__autoclassinit2@?$CBMemPool@USTValue@@@@QEAAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?__autoclassinit2@?$CBMemPool@USTValue@@@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$CBMemPool@USTValue@@@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_G?$CBMemPool@USTValue@@@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$CBMemPool@USThash_next@@@@QEAA@XZ DD imagerel $LN9
	DD	imagerel $LN9+155
	DD	imagerel $unwind$??1?$CBMemPool@USThash_next@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?alloc@?$CBMemPool@USThash_next@@@@QEAAHH@Z DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$?alloc@?$CBMemPool@USThash_next@@@@QEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?newMem@?$CBMemPool@USThash_next@@@@QEAAPEAUSThash_next@@XZ DD imagerel $LN11
	DD	imagerel $LN11+279
	DD	imagerel $unwind$?newMem@?$CBMemPool@USThash_next@@@@QEAAPEAUSThash_next@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?delMem@?$CBMemPool@USThash_next@@@@QEAA_NPEAUSThash_next@@@Z DD imagerel $LN11
	DD	imagerel $LN11+249
	DD	imagerel $unwind$?delMem@?$CBMemPool@USThash_next@@@@QEAA_NPEAUSThash_next@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__unit_alloc@?$CBMemPool@USThash_next@@@@AEAAPEAUSThash_next@@XZ DD imagerel $LN8
	DD	imagerel $LN8+98
	DD	imagerel $unwind$?__unit_alloc@?$CBMemPool@USThash_next@@@@AEAAPEAUSThash_next@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__alloc@?$CBMemPool@USThash_next@@@@AEAAHH@Z DD imagerel $LN10
	DD	imagerel $LN10+326
	DD	imagerel $unwind$?__alloc@?$CBMemPool@USThash_next@@@@AEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__autoclassinit2@?$CBMemPool@USThash_next@@@@QEAAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?__autoclassinit2@?$CBMemPool@USThash_next@@@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$CBMemPool@USThash_next@@@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_G?$CBMemPool@USThash_next@@@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$CBMemPool@USThash_next@@@@QEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__autoclassinit2@?$CBMemPool@USThash_next@@@@QEAAX_K@Z DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__alloc@?$CBMemPool@USThash_next@@@@AEAAHH@Z DD 020e01H
	DD	0700a920eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__unit_alloc@?$CBMemPool@USThash_next@@@@AEAAPEAUSThash_next@@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?delMem@?$CBMemPool@USThash_next@@@@QEAA_NPEAUSThash_next@@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?newMem@?$CBMemPool@USThash_next@@@@QEAAPEAUSThash_next@@XZ DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?alloc@?$CBMemPool@USThash_next@@@@QEAAHH@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$CBMemPool@USThash_next@@@@QEAA@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$CBMemPool@USTValue@@@@QEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__autoclassinit2@?$CBMemPool@USTValue@@@@QEAAX_K@Z DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__alloc@?$CBMemPool@USTValue@@@@AEAAHH@Z DD 020e01H
	DD	0700a920eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__unit_alloc@?$CBMemPool@USTValue@@@@AEAAPEAUSTValue@@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?delMem@?$CBMemPool@USTValue@@@@QEAA_NPEAUSTValue@@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?newMem@?$CBMemPool@USTValue@@@@QEAAPEAUSTValue@@XZ DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?alloc@?$CBMemPool@USTValue@@@@QEAAHH@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$CBMemPool@USTValue@@@@QEAA@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getNode@CDKeyHashMap@@QEAAPEAUSTHash_Node@@PEAD0@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getHashMap@CDKeyHashMap@@QEAAPEAVCHash@@PEAD@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isNode@CDKeyHashMap@@QEAA_NPEAD0@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?delValueBuf@CDKeyHashMap@@QEAAXPEAUSTValue@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?newValueBuf@CDKeyHashMap@@QEAAPEAUSTValue@@HPEAD@Z DD 012119H
	DD	08212H
	DD	imagerel __GSHandlerCheck
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deleteNode@CDKeyHashMap@@QEAA_NPEAD0@Z DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deleteHash@CDKeyHashMap@@QEAA_NPEAD@Z DD 021101H
	DD	0110111H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setValue@CDKeyHashMap@@QEAAHPEAD0PEAX@Z DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?addKeyValue@CDKeyHashMap@@QEAAHPEAD0PEAX1@Z DD 012719H
	DD	0a218H
	DD	imagerel __GSHandlerCheck
	DD	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z DD imagerel ?addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z
	DD	0ffffffffH
	DD	imagerel ?addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z+247
	DD	00H
	DD	imagerel ?addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z+320
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z
	DD	0c8H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z DD 022711H
	DD	01d011bH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1CDKeyHashMap@@QEAA@XZ DD imagerel ??1CDKeyHashMap@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1CDKeyHashMap@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1CDKeyHashMap@@QEAA@XZ
	DD	0c8H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1CDKeyHashMap@@QEAA@XZ DD 021819H
	DD	01b010cH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1CDKeyHashMap@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0CDKeyHashMap@@QEAA@HH_N@Z DD imagerel ??0CDKeyHashMap@@QEAA@HH_N@Z
	DD	0ffffffffH
	DD	imagerel ??0CDKeyHashMap@@QEAA@HH_N@Z+86
	DD	00H
	DD	imagerel ??0CDKeyHashMap@@QEAA@HH_N@Z+150
	DD	0ffffffffH
	DD	imagerel ??0CDKeyHashMap@@QEAA@HH_N@Z+217
	DD	01H
	DD	imagerel ??0CDKeyHashMap@@QEAA@HH_N@Z+283
	DD	0ffffffffH
	DD	imagerel ??0CDKeyHashMap@@QEAA@HH_N@Z+556
	DD	02H
	DD	imagerel ??0CDKeyHashMap@@QEAA@HH_N@Z+620
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0CDKeyHashMap@@QEAA@HH_N@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$1@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$2@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0CDKeyHashMap@@QEAA@HH_N@Z DD 019930522H
	DD	03H
	DD	imagerel $stateUnwindMap$??0CDKeyHashMap@@QEAA@HH_N@Z
	DD	00H
	DD	00H
	DD	07H
	DD	imagerel $ip2state$??0CDKeyHashMap@@QEAA@HH_N@Z
	DD	070H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0CDKeyHashMap@@QEAA@HH_N@Z DD 022311H
	DD	011011aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0CDKeyHashMap@@QEAA@HH_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?delBuf@CMemManager@@QEAAXPEADH@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?newBuf@CMemManager@@QEAAPEADHPEAH@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?newBuf@CMemManager@@QEAAPEADH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getIndex@@YAHH@Z DD 010801H
	DD	04208H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?c_memcpy@@YAPEAXPEAXPEBXH@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 012719H
	DD	08218H
	DD	imagerel __GSHandlerCheck
	DD	030H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GCHash@@QEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__autoclassinit2@CHash@@QEAAX_K@Z DD 010b01H
	DD	0700bH
xdata	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$CBMemPool@USThash_next@@@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$CBMemPool@USThash_next@@@@QEAAPEAXI@Z PROC	; CBMemPool<SThash_next>::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00012	e8 00 00 00 00	 call	 ??1?$CBMemPool@USThash_next@@@@QEAA@XZ ; CBMemPool<SThash_next>::~CBMemPool<SThash_next>
  00017	8b 44 24 38	 mov	 eax, DWORD PTR __flags$[rsp]
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 0f		 je	 SHORT $LN2@scalar
  00022	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
??_G?$CBMemPool@USThash_next@@@@QEAAPEAXI@Z ENDP	; CBMemPool<SThash_next>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit2@?$CBMemPool@USThash_next@@@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 16
classSize$ = 24
?__autoclassinit2@?$CBMemPool@USThash_next@@@@QEAAX_K@Z PROC ; CBMemPool<SThash_next>::__autoclassinit2, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 8b 7c 24 10	 mov	 rdi, QWORD PTR this$[rsp]
  00010	33 c0		 xor	 eax, eax
  00012	48 8b 4c 24 18	 mov	 rcx, QWORD PTR classSize$[rsp]
  00017	f3 aa		 rep stosb
  00019	5f		 pop	 rdi
  0001a	c3		 ret	 0
?__autoclassinit2@?$CBMemPool@USThash_next@@@@QEAAX_K@Z ENDP ; CBMemPool<SThash_next>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\combmempool.h
;	COMDAT ?__alloc@?$CBMemPool@USThash_next@@@@AEAAHH@Z
_TEXT	SEGMENT
tv65 = 32
pPool$ = 40
pFlag$ = 48
tv70 = 56
$T1 = 64
this$ = 96
nMaxCount$ = 104
?__alloc@?$CBMemPool@USThash_next@@@@AEAAHH@Z PROC	; CBMemPool<SThash_next>::__alloc, COMDAT

; 104  : {	

$LN10:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 105  : 	MEMTYPE* pPool;
; 106  : 	switch (m_nObjAllocType) {

  0000e	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00013	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00016	89 44 24 20	 mov	 DWORD PTR tv65[rsp], eax
  0001a	83 7c 24 20 02	 cmp	 DWORD PTR tv65[rsp], 2
  0001f	74 10		 je	 SHORT $LN4@alloc
  00021	83 7c 24 20 03	 cmp	 DWORD PTR tv65[rsp], 3
  00026	74 4b		 je	 SHORT $LN5@alloc
  00028	83 7c 24 20 05	 cmp	 DWORD PTR tv65[rsp], 5
  0002d	74 02		 je	 SHORT $LN4@alloc
  0002f	eb 5c		 jmp	 SHORT $LN6@alloc
$LN4@alloc:

; 107  : 	case eAlloc_Type_new		: 
; 108  : 	case eAlloc_Type_newArray	:	pPool = new (std::nothrow) MEMTYPE[nMaxCount]; break;

  00031	48 63 44 24 68	 movsxd	 rax, DWORD PTR nMaxCount$[rsp]
  00036	48 89 44 24 38	 mov	 QWORD PTR tv70[rsp], rax
  0003b	b8 18 00 00 00	 mov	 eax, 24
  00040	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv70[rsp]
  00045	48 f7 e1	 mul	 rcx
  00048	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  0004f	48 0f 40 c1	 cmovo	 rax, rcx
  00053	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  0005a	48 8b c8	 mov	 rcx, rax
  0005d	e8 00 00 00 00	 call	 ??_U@YAPEAX_KAEBUnothrow_t@std@@@Z ; operator new[]
  00062	48 89 44 24 40	 mov	 QWORD PTR $T1[rsp], rax
  00067	48 8b 44 24 40	 mov	 rax, QWORD PTR $T1[rsp]
  0006c	48 89 44 24 28	 mov	 QWORD PTR pPool$[rsp], rax
  00071	eb 23		 jmp	 SHORT $LN2@alloc
$LN5@alloc:

; 109  : 	case eAlloc_Type_alloc		:	pPool = (MEMTYPE *)calloc(nMaxCount, sizeof(MEMTYPE)); break;

  00073	48 63 44 24 68	 movsxd	 rax, DWORD PTR nMaxCount$[rsp]
  00078	ba 18 00 00 00	 mov	 edx, 24
  0007d	48 8b c8	 mov	 rcx, rax
  00080	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00086	48 89 44 24 28	 mov	 QWORD PTR pPool$[rsp], rax
  0008b	eb 09		 jmp	 SHORT $LN2@alloc
$LN6@alloc:

; 110  : 	default: pPool=NULL;

  0008d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR pPool$[rsp], 0
$LN2@alloc:

; 111  : 	}	
; 112  : 	if (!pPool) {

  00096	48 83 7c 24 28
	00		 cmp	 QWORD PTR pPool$[rsp], 0
  0009c	75 1a		 jne	 SHORT $LN7@alloc

; 113  : 		_stprintf(g_szMessage, _T("CBMemPool::pPool alloc ERROR"));

  0009e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45265
  000a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  000ac	e8 00 00 00 00	 call	 sprintf

; 114  : 		return 0;

  000b1	33 c0		 xor	 eax, eax
  000b3	e9 88 00 00 00	 jmp	 $LN1@alloc
$LN7@alloc:

; 115  : 	}
; 116  : 
; 117  : 	char* pFlag = (char*)calloc(nMaxCount, sizeof(char));

  000b8	48 63 44 24 68	 movsxd	 rax, DWORD PTR nMaxCount$[rsp]
  000bd	ba 01 00 00 00	 mov	 edx, 1
  000c2	48 8b c8	 mov	 rcx, rax
  000c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  000cb	48 89 44 24 30	 mov	 QWORD PTR pFlag$[rsp], rax

; 118  : 	if (!pFlag) {

  000d0	48 83 7c 24 30
	00		 cmp	 QWORD PTR pFlag$[rsp], 0
  000d6	75 22		 jne	 SHORT $LN8@alloc

; 119  : 		free(pPool);

  000d8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pPool$[rsp]
  000dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 120  : 		_stprintf(g_szMessage, _T("CBMemPool::pFlag alloc ERROR"));

  000e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45267
  000ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  000f1	e8 00 00 00 00	 call	 sprintf

; 121  : 		return 0;

  000f6	33 c0		 xor	 eax, eax
  000f8	eb 46		 jmp	 SHORT $LN1@alloc
$LN8@alloc:

; 122  : 	}
; 123  : 	memset(pFlag, 0, sizeof(pFlag));

  000fa	48 8b 7c 24 30	 mov	 rdi, QWORD PTR pFlag$[rsp]
  000ff	33 c0		 xor	 eax, eax
  00101	b9 08 00 00 00	 mov	 ecx, 8
  00106	f3 aa		 rep stosb

; 124  : 
; 125  : 	_stprintf(g_szMessage, _T("CBMemPool __alloc m_nAllocCount[%d]"), nMaxCount);

  00108	44 8b 44 24 68	 mov	 r8d, DWORD PTR nMaxCount$[rsp]
  0010d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45268
  00114	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  0011b	e8 00 00 00 00	 call	 sprintf

; 126  : 	m_pChunk = pPool;

  00120	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00125	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pPool$[rsp]
  0012a	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 127  : 	m_nFlagArray = pFlag;

  0012e	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00133	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pFlag$[rsp]
  00138	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 128  : 	return nMaxCount;

  0013c	8b 44 24 68	 mov	 eax, DWORD PTR nMaxCount$[rsp]
$LN1@alloc:

; 129  : }

  00140	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00144	5f		 pop	 rdi
  00145	c3		 ret	 0
?__alloc@?$CBMemPool@USThash_next@@@@AEAAHH@Z ENDP	; CBMemPool<SThash_next>::__alloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\combmempool.h
;	COMDAT ?__unit_alloc@?$CBMemPool@USThash_next@@@@AEAAPEAUSThash_next@@XZ
_TEXT	SEGMENT
tv65 = 32
$T1 = 40
this$ = 64
?__unit_alloc@?$CBMemPool@USThash_next@@@@AEAAPEAUSThash_next@@XZ PROC ; CBMemPool<SThash_next>::__unit_alloc, COMDAT

; 134  : {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 135  : 	switch (m_nObjAllocType) {

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0000e	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00011	89 44 24 20	 mov	 DWORD PTR tv65[rsp], eax
  00015	83 7c 24 20 02	 cmp	 DWORD PTR tv65[rsp], 2
  0001a	74 10		 je	 SHORT $LN4@unit_alloc
  0001c	83 7c 24 20 03	 cmp	 DWORD PTR tv65[rsp], 3
  00021	74 26		 je	 SHORT $LN5@unit_alloc
  00023	83 7c 24 20 05	 cmp	 DWORD PTR tv65[rsp], 5
  00028	74 02		 je	 SHORT $LN4@unit_alloc
  0002a	eb 2f		 jmp	 SHORT $LN6@unit_alloc
$LN4@unit_alloc:

; 136  : 	case eAlloc_Type_new		:	
; 137  : 	case eAlloc_Type_newArray	:	return new (std::nothrow) MEMTYPE;

  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00033	b9 18 00 00 00	 mov	 ecx, 24
  00038	e8 00 00 00 00	 call	 ??2@YAPEAX_KAEBUnothrow_t@std@@@Z ; operator new
  0003d	48 89 44 24 28	 mov	 QWORD PTR $T1[rsp], rax
  00042	48 8b 44 24 28	 mov	 rax, QWORD PTR $T1[rsp]
  00047	eb 14		 jmp	 SHORT $LN1@unit_alloc
$LN5@unit_alloc:

; 138  : 	case eAlloc_Type_alloc		:	return (MEMTYPE *)calloc(1, sizeof(MEMTYPE));

  00049	ba 18 00 00 00	 mov	 edx, 24
  0004e	b9 01 00 00 00	 mov	 ecx, 1
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00059	eb 02		 jmp	 SHORT $LN1@unit_alloc
$LN6@unit_alloc:

; 139  : 	default: return NULL;

  0005b	33 c0		 xor	 eax, eax
$LN1@unit_alloc:

; 140  : 	}
; 141  : }

  0005d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00061	c3		 ret	 0
?__unit_alloc@?$CBMemPool@USThash_next@@@@AEAAPEAUSThash_next@@XZ ENDP ; CBMemPool<SThash_next>::__unit_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\combmempool.h
;	COMDAT ?delMem@?$CBMemPool@USThash_next@@@@QEAA_NPEAUSThash_next@@@Z
_TEXT	SEGMENT
tv86 = 32
nIdx$ = 36
$T1 = 40
tv90 = 48
this$ = 80
pUsedMem$ = 88
?delMem@?$CBMemPool@USThash_next@@@@QEAA_NPEAUSThash_next@@@Z PROC ; CBMemPool<SThash_next>::delMem, COMDAT

; 193  : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 194  : 	int nIdx = int(pUsedMem - m_pChunk);

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00013	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00017	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pUsedMem$[rsp]
  0001c	48 2b c8	 sub	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 99		 cdq
  00024	b9 18 00 00 00	 mov	 ecx, 24
  00029	48 f7 f9	 idiv	 rcx
  0002c	89 44 24 24	 mov	 DWORD PTR nIdx$[rsp], eax

; 195  : 
; 196  : 	if (ISINCLUDE(nIdx, m_nAllocCount)) {

  00030	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00035	8b 50 08	 mov	 edx, DWORD PTR [rax+8]
  00038	8b 4c 24 24	 mov	 ecx, DWORD PTR nIdx$[rsp]
  0003c	e8 00 00 00 00	 call	 ?ISINCLUDE@@YA_NHH@Z	; ISINCLUDE
  00041	0f b6 c0	 movzx	 eax, al
  00044	85 c0		 test	 eax, eax
  00046	74 2b		 je	 SHORT $LN4@delMem

; 197  : 		m_nFlagArray[nIdx] = 0;

  00048	48 63 44 24 24	 movsxd	 rax, DWORD PTR nIdx$[rsp]
  0004d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00052	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00056	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 198  : 		m_nUseCnt--;

  0005a	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0005f	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00062	ff c8		 dec	 eax
  00064	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00069	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 199  : 		return true;

  0006c	b0 01		 mov	 al, 1
  0006e	e9 81 00 00 00	 jmp	 $LN1@delMem
$LN4@delMem:

; 200  : 	}
; 201  : 	if (m_bSlot) return false;

  00073	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00078	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0007b	85 c0		 test	 eax, eax
  0007d	74 04		 je	 SHORT $LN5@delMem
  0007f	32 c0		 xor	 al, al
  00081	eb 71		 jmp	 SHORT $LN1@delMem
$LN5@delMem:

; 202  : 	switch (m_nObjAllocType) {

  00083	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00088	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  0008b	89 44 24 20	 mov	 DWORD PTR tv86[rsp], eax
  0008f	83 7c 24 20 02	 cmp	 DWORD PTR tv86[rsp], 2
  00094	74 10		 je	 SHORT $LN6@delMem
  00096	83 7c 24 20 03	 cmp	 DWORD PTR tv86[rsp], 3
  0009b	74 4a		 je	 SHORT $LN7@delMem
  0009d	83 7c 24 20 05	 cmp	 DWORD PTR tv86[rsp], 5
  000a2	74 02		 je	 SHORT $LN6@delMem
  000a4	eb 4c		 jmp	 SHORT $LN2@delMem
$LN6@delMem:

; 203  : 	case eAlloc_Type_new:	
; 204  : 	case eAlloc_Type_newArray:	delete pUsedMem; break;

  000a6	48 8b 44 24 58	 mov	 rax, QWORD PTR pUsedMem$[rsp]
  000ab	48 89 44 24 28	 mov	 QWORD PTR $T1[rsp], rax
  000b0	ba 18 00 00 00	 mov	 edx, 24
  000b5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T1[rsp]
  000ba	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  000bf	48 83 7c 24 28
	00		 cmp	 QWORD PTR $T1[rsp], 0
  000c5	75 0b		 jne	 SHORT $LN9@delMem
  000c7	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tv90[rsp], 0
  000d0	eb 13		 jmp	 SHORT $LN10@delMem
$LN9@delMem:
  000d2	48 c7 44 24 58
	23 81 00 00	 mov	 QWORD PTR pUsedMem$[rsp], 33059 ; 00008123H
  000db	48 8b 44 24 58	 mov	 rax, QWORD PTR pUsedMem$[rsp]
  000e0	48 89 44 24 30	 mov	 QWORD PTR tv90[rsp], rax
$LN10@delMem:
  000e5	eb 0b		 jmp	 SHORT $LN2@delMem
$LN7@delMem:

; 205  : 	case eAlloc_Type_alloc:	free(pUsedMem); break;

  000e7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pUsedMem$[rsp]
  000ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN2@delMem:

; 206  : 	}
; 207  : 	return false;

  000f2	32 c0		 xor	 al, al
$LN1@delMem:

; 208  : }

  000f4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000f8	c3		 ret	 0
?delMem@?$CBMemPool@USThash_next@@@@QEAA_NPEAUSThash_next@@@Z ENDP ; CBMemPool<SThash_next>::delMem
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\combmempool.h
;	COMDAT ?newMem@?$CBMemPool@USThash_next@@@@QEAAPEAUSThash_next@@XZ
_TEXT	SEGMENT
i$ = 32
j$ = 36
this$ = 64
?newMem@?$CBMemPool@USThash_next@@@@QEAAPEAUSThash_next@@XZ PROC ; CBMemPool<SThash_next>::newMem, COMDAT

; 145  : {

$LN11:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 146  : 	int i = m_nUseCnt, j;

  0000a	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0000f	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00012	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax

; 147  : 	if (m_nUseCnt == m_nAllocCount) {

  00016	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0001b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00020	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  00023	39 48 04	 cmp	 DWORD PTR [rax+4], ecx
  00026	75 22		 jne	 SHORT $LN5@newMem

; 148  : 		if (m_bSlot) return NULL;

  00028	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0002d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00030	85 c0		 test	 eax, eax
  00032	74 07		 je	 SHORT $LN6@newMem
  00034	33 c0		 xor	 eax, eax
  00036	e9 d6 00 00 00	 jmp	 $LN1@newMem
$LN6@newMem:

; 149  : 		return __unit_alloc();

  0003b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00040	e8 00 00 00 00	 call	 ?__unit_alloc@?$CBMemPool@USThash_next@@@@AEAAPEAUSThash_next@@XZ ; CBMemPool<SThash_next>::__unit_alloc
  00045	e9 c7 00 00 00	 jmp	 $LN1@newMem
$LN5@newMem:

; 150  : 	}
; 151  : 	for (j = 0; j < m_nAllocCount; j++) {

  0004a	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00052	eb 0a		 jmp	 SHORT $LN4@newMem
$LN2@newMem:
  00054	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  00058	ff c0		 inc	 eax
  0005a	89 44 24 24	 mov	 DWORD PTR j$[rsp], eax
$LN4@newMem:
  0005e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00063	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00066	39 44 24 24	 cmp	 DWORD PTR j$[rsp], eax
  0006a	0f 8d 87 00 00
	00		 jge	 $LN3@newMem

; 152  : 		if (i >= m_nAllocCount) { i = 0; }

  00070	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00075	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00078	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0007c	7c 08		 jl	 SHORT $LN7@newMem
  0007e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
$LN7@newMem:

; 153  : 		if (!m_nFlagArray[i]) {

  00086	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0008b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00090	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00094	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00098	85 c0		 test	 eax, eax
  0009a	75 56		 jne	 SHORT $LN8@newMem

; 154  : 			m_nFlagArray[i] = 1;

  0009c	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000a1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000a6	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000aa	c6 04 01 01	 mov	 BYTE PTR [rcx+rax], 1

; 155  : 			memset(&m_pChunk[i], 0, sizeof(MEMTYPE));

  000ae	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000b3	48 6b c0 18	 imul	 rax, rax, 24
  000b7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000bc	48 03 41 18	 add	 rax, QWORD PTR [rcx+24]
  000c0	48 8b f8	 mov	 rdi, rax
  000c3	33 c0		 xor	 eax, eax
  000c5	b9 18 00 00 00	 mov	 ecx, 24
  000ca	f3 aa		 rep stosb

; 156  : 			m_nUseCnt++;

  000cc	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000d1	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  000d4	ff c0		 inc	 eax
  000d6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000db	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 157  : 			return &m_pChunk[i];

  000de	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000e3	48 6b c0 18	 imul	 rax, rax, 24
  000e7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000ec	48 03 41 18	 add	 rax, QWORD PTR [rcx+24]
  000f0	eb 1f		 jmp	 SHORT $LN1@newMem
$LN8@newMem:

; 158  : 		}
; 159  : 	}

  000f2	e9 5d ff ff ff	 jmp	 $LN2@newMem
$LN3@newMem:

; 160  : 	if (m_bSlot) return NULL;

  000f7	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000fc	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000ff	85 c0		 test	 eax, eax
  00101	74 04		 je	 SHORT $LN9@newMem
  00103	33 c0		 xor	 eax, eax
  00105	eb 0a		 jmp	 SHORT $LN1@newMem
$LN9@newMem:

; 161  : 	return __unit_alloc();

  00107	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0010c	e8 00 00 00 00	 call	 ?__unit_alloc@?$CBMemPool@USThash_next@@@@AEAAPEAUSThash_next@@XZ ; CBMemPool<SThash_next>::__unit_alloc
$LN1@newMem:

; 162  : }

  00111	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00115	5f		 pop	 rdi
  00116	c3		 ret	 0
?newMem@?$CBMemPool@USThash_next@@@@QEAAPEAUSThash_next@@XZ ENDP ; CBMemPool<SThash_next>::newMem
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\combmempool.h
;	COMDAT ?alloc@?$CBMemPool@USThash_next@@@@QEAAHH@Z
_TEXT	SEGMENT
this$ = 48
nMaxCount$ = 56
?alloc@?$CBMemPool@USThash_next@@@@QEAAHH@Z PROC	; CBMemPool<SThash_next>::alloc, COMDAT

; 32   : 	inline int alloc(int nMaxCount) { m_nAllocCount = __alloc(nMaxCount); return m_nAllocCount; }

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	8b 54 24 38	 mov	 edx, DWORD PTR nMaxCount$[rsp]
  00011	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00016	e8 00 00 00 00	 call	 ?__alloc@?$CBMemPool@USThash_next@@@@AEAAHH@Z ; CBMemPool<SThash_next>::__alloc
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00020	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  00023	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00028	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0002b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002f	c3		 ret	 0
?alloc@?$CBMemPool@USThash_next@@@@QEAAHH@Z ENDP	; CBMemPool<SThash_next>::alloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\combmempool.h
;	COMDAT ??1?$CBMemPool@USThash_next@@@@QEAA@XZ
_TEXT	SEGMENT
tv67 = 32
$T1 = 40
this$ = 64
??1?$CBMemPool@USThash_next@@@@QEAA@XZ PROC		; CBMemPool<SThash_next>::~CBMemPool<SThash_next>, COMDAT

; 85   : {

$LN9:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 86   : 	if (m_pChunk) {

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00013	74 59		 je	 SHORT $LN4@CBMemPool

; 87   : 		switch (m_nObjAllocType) {

  00015	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0001a	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  0001d	89 44 24 20	 mov	 DWORD PTR tv67[rsp], eax
  00021	83 7c 24 20 02	 cmp	 DWORD PTR tv67[rsp], 2
  00026	74 10		 je	 SHORT $LN5@CBMemPool
  00028	83 7c 24 20 03	 cmp	 DWORD PTR tv67[rsp], 3
  0002d	74 23		 je	 SHORT $LN6@CBMemPool
  0002f	83 7c 24 20 05	 cmp	 DWORD PTR tv67[rsp], 5
  00034	74 02		 je	 SHORT $LN5@CBMemPool
  00036	eb 29		 jmp	 SHORT $LN2@CBMemPool
$LN5@CBMemPool:

; 88   : 		case eAlloc_Type_new:		
; 89   : 		case eAlloc_Type_newArray:	delete[] m_pChunk;	break;

  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0003d	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00041	48 89 44 24 28	 mov	 QWORD PTR $T1[rsp], rax
  00046	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T1[rsp]
  0004b	e8 00 00 00 00	 call	 ??_V@YAXPEAX@Z		; operator delete[]
  00050	eb 0f		 jmp	 SHORT $LN2@CBMemPool
$LN6@CBMemPool:

; 90   : 		case eAlloc_Type_alloc:		free(m_pChunk);		break;

  00052	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00057	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN2@CBMemPool:

; 91   : 		}
; 92   : 
; 93   : 		m_pChunk = NULL;

  00061	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00066	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0
$LN4@CBMemPool:

; 94   : 	}
; 95   : 
; 96   : 	if (m_nFlagArray) {

  0006e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00073	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00078	74 1c		 je	 SHORT $LN7@CBMemPool

; 97   : 		free(m_nFlagArray);

  0007a	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0007f	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 98   : 		m_nFlagArray = NULL;

  00089	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0008e	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0
$LN7@CBMemPool:

; 99   : 	}
; 100  : }

  00096	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009a	c3		 ret	 0
??1?$CBMemPool@USThash_next@@@@QEAA@XZ ENDP		; CBMemPool<SThash_next>::~CBMemPool<SThash_next>
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\combmempool.h
;	COMDAT ??0?$CBMemPool@USThash_next@@@@QEAA@W4E_ALLOC_TYPE@@@Z
_TEXT	SEGMENT
this$ = 8
nType$ = 16
??0?$CBMemPool@USThash_next@@@@QEAA@W4E_ALLOC_TYPE@@@Z PROC ; CBMemPool<SThash_next>::CBMemPool<SThash_next>, COMDAT

; 74   : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 75   : 	m_nAllocCount = 0;

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000e	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0

; 76   : 	m_pChunk = NULL;

  00015	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0001a	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 77   : 	m_nUseCnt = 0;

  00022	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00027	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0

; 78   : 	m_nFlagArray = NULL;

  0002e	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00033	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 79   : 	m_nObjAllocType = nType;

  0003b	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00040	8b 4c 24 10	 mov	 ecx, DWORD PTR nType$[rsp]
  00044	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 80   : 	m_bSlot = false;

  00047	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0004c	c6 00 00	 mov	 BYTE PTR [rax], 0

; 81   : }

  0004f	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00054	c3		 ret	 0
??0?$CBMemPool@USThash_next@@@@QEAA@W4E_ALLOC_TYPE@@@Z ENDP ; CBMemPool<SThash_next>::CBMemPool<SThash_next>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$CBMemPool@USTValue@@@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$CBMemPool@USTValue@@@@QEAAPEAXI@Z PROC		; CBMemPool<STValue>::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00012	e8 00 00 00 00	 call	 ??1?$CBMemPool@USTValue@@@@QEAA@XZ ; CBMemPool<STValue>::~CBMemPool<STValue>
  00017	8b 44 24 38	 mov	 eax, DWORD PTR __flags$[rsp]
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 0f		 je	 SHORT $LN2@scalar
  00022	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
??_G?$CBMemPool@USTValue@@@@QEAAPEAXI@Z ENDP		; CBMemPool<STValue>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit2@?$CBMemPool@USTValue@@@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 16
classSize$ = 24
?__autoclassinit2@?$CBMemPool@USTValue@@@@QEAAX_K@Z PROC ; CBMemPool<STValue>::__autoclassinit2, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 8b 7c 24 10	 mov	 rdi, QWORD PTR this$[rsp]
  00010	33 c0		 xor	 eax, eax
  00012	48 8b 4c 24 18	 mov	 rcx, QWORD PTR classSize$[rsp]
  00017	f3 aa		 rep stosb
  00019	5f		 pop	 rdi
  0001a	c3		 ret	 0
?__autoclassinit2@?$CBMemPool@USTValue@@@@QEAAX_K@Z ENDP ; CBMemPool<STValue>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\combmempool.h
;	COMDAT ?__alloc@?$CBMemPool@USTValue@@@@AEAAHH@Z
_TEXT	SEGMENT
tv65 = 32
pPool$ = 40
pFlag$ = 48
tv70 = 56
$T1 = 64
this$ = 96
nMaxCount$ = 104
?__alloc@?$CBMemPool@USTValue@@@@AEAAHH@Z PROC		; CBMemPool<STValue>::__alloc, COMDAT

; 104  : {	

$LN10:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 105  : 	MEMTYPE* pPool;
; 106  : 	switch (m_nObjAllocType) {

  0000e	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00013	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00016	89 44 24 20	 mov	 DWORD PTR tv65[rsp], eax
  0001a	83 7c 24 20 02	 cmp	 DWORD PTR tv65[rsp], 2
  0001f	74 10		 je	 SHORT $LN4@alloc
  00021	83 7c 24 20 03	 cmp	 DWORD PTR tv65[rsp], 3
  00026	74 4b		 je	 SHORT $LN5@alloc
  00028	83 7c 24 20 05	 cmp	 DWORD PTR tv65[rsp], 5
  0002d	74 02		 je	 SHORT $LN4@alloc
  0002f	eb 5c		 jmp	 SHORT $LN6@alloc
$LN4@alloc:

; 107  : 	case eAlloc_Type_new		: 
; 108  : 	case eAlloc_Type_newArray	:	pPool = new (std::nothrow) MEMTYPE[nMaxCount]; break;

  00031	48 63 44 24 68	 movsxd	 rax, DWORD PTR nMaxCount$[rsp]
  00036	48 89 44 24 38	 mov	 QWORD PTR tv70[rsp], rax
  0003b	b8 10 00 00 00	 mov	 eax, 16
  00040	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv70[rsp]
  00045	48 f7 e1	 mul	 rcx
  00048	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  0004f	48 0f 40 c1	 cmovo	 rax, rcx
  00053	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  0005a	48 8b c8	 mov	 rcx, rax
  0005d	e8 00 00 00 00	 call	 ??_U@YAPEAX_KAEBUnothrow_t@std@@@Z ; operator new[]
  00062	48 89 44 24 40	 mov	 QWORD PTR $T1[rsp], rax
  00067	48 8b 44 24 40	 mov	 rax, QWORD PTR $T1[rsp]
  0006c	48 89 44 24 28	 mov	 QWORD PTR pPool$[rsp], rax
  00071	eb 23		 jmp	 SHORT $LN2@alloc
$LN5@alloc:

; 109  : 	case eAlloc_Type_alloc		:	pPool = (MEMTYPE *)calloc(nMaxCount, sizeof(MEMTYPE)); break;

  00073	48 63 44 24 68	 movsxd	 rax, DWORD PTR nMaxCount$[rsp]
  00078	ba 10 00 00 00	 mov	 edx, 16
  0007d	48 8b c8	 mov	 rcx, rax
  00080	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00086	48 89 44 24 28	 mov	 QWORD PTR pPool$[rsp], rax
  0008b	eb 09		 jmp	 SHORT $LN2@alloc
$LN6@alloc:

; 110  : 	default: pPool=NULL;

  0008d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR pPool$[rsp], 0
$LN2@alloc:

; 111  : 	}	
; 112  : 	if (!pPool) {

  00096	48 83 7c 24 28
	00		 cmp	 QWORD PTR pPool$[rsp], 0
  0009c	75 1a		 jne	 SHORT $LN7@alloc

; 113  : 		_stprintf(g_szMessage, _T("CBMemPool::pPool alloc ERROR"));

  0009e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45335
  000a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  000ac	e8 00 00 00 00	 call	 sprintf

; 114  : 		return 0;

  000b1	33 c0		 xor	 eax, eax
  000b3	e9 88 00 00 00	 jmp	 $LN1@alloc
$LN7@alloc:

; 115  : 	}
; 116  : 
; 117  : 	char* pFlag = (char*)calloc(nMaxCount, sizeof(char));

  000b8	48 63 44 24 68	 movsxd	 rax, DWORD PTR nMaxCount$[rsp]
  000bd	ba 01 00 00 00	 mov	 edx, 1
  000c2	48 8b c8	 mov	 rcx, rax
  000c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  000cb	48 89 44 24 30	 mov	 QWORD PTR pFlag$[rsp], rax

; 118  : 	if (!pFlag) {

  000d0	48 83 7c 24 30
	00		 cmp	 QWORD PTR pFlag$[rsp], 0
  000d6	75 22		 jne	 SHORT $LN8@alloc

; 119  : 		free(pPool);

  000d8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pPool$[rsp]
  000dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 120  : 		_stprintf(g_szMessage, _T("CBMemPool::pFlag alloc ERROR"));

  000e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45337
  000ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  000f1	e8 00 00 00 00	 call	 sprintf

; 121  : 		return 0;

  000f6	33 c0		 xor	 eax, eax
  000f8	eb 46		 jmp	 SHORT $LN1@alloc
$LN8@alloc:

; 122  : 	}
; 123  : 	memset(pFlag, 0, sizeof(pFlag));

  000fa	48 8b 7c 24 30	 mov	 rdi, QWORD PTR pFlag$[rsp]
  000ff	33 c0		 xor	 eax, eax
  00101	b9 08 00 00 00	 mov	 ecx, 8
  00106	f3 aa		 rep stosb

; 124  : 
; 125  : 	_stprintf(g_szMessage, _T("CBMemPool __alloc m_nAllocCount[%d]"), nMaxCount);

  00108	44 8b 44 24 68	 mov	 r8d, DWORD PTR nMaxCount$[rsp]
  0010d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG45338
  00114	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_szMessage@@3PADA ; g_szMessage
  0011b	e8 00 00 00 00	 call	 sprintf

; 126  : 	m_pChunk = pPool;

  00120	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00125	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pPool$[rsp]
  0012a	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 127  : 	m_nFlagArray = pFlag;

  0012e	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00133	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pFlag$[rsp]
  00138	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 128  : 	return nMaxCount;

  0013c	8b 44 24 68	 mov	 eax, DWORD PTR nMaxCount$[rsp]
$LN1@alloc:

; 129  : }

  00140	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00144	5f		 pop	 rdi
  00145	c3		 ret	 0
?__alloc@?$CBMemPool@USTValue@@@@AEAAHH@Z ENDP		; CBMemPool<STValue>::__alloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\combmempool.h
;	COMDAT ?__unit_alloc@?$CBMemPool@USTValue@@@@AEAAPEAUSTValue@@XZ
_TEXT	SEGMENT
tv65 = 32
$T1 = 40
this$ = 64
?__unit_alloc@?$CBMemPool@USTValue@@@@AEAAPEAUSTValue@@XZ PROC ; CBMemPool<STValue>::__unit_alloc, COMDAT

; 134  : {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 135  : 	switch (m_nObjAllocType) {

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0000e	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00011	89 44 24 20	 mov	 DWORD PTR tv65[rsp], eax
  00015	83 7c 24 20 02	 cmp	 DWORD PTR tv65[rsp], 2
  0001a	74 10		 je	 SHORT $LN4@unit_alloc
  0001c	83 7c 24 20 03	 cmp	 DWORD PTR tv65[rsp], 3
  00021	74 26		 je	 SHORT $LN5@unit_alloc
  00023	83 7c 24 20 05	 cmp	 DWORD PTR tv65[rsp], 5
  00028	74 02		 je	 SHORT $LN4@unit_alloc
  0002a	eb 2f		 jmp	 SHORT $LN6@unit_alloc
$LN4@unit_alloc:

; 136  : 	case eAlloc_Type_new		:	
; 137  : 	case eAlloc_Type_newArray	:	return new (std::nothrow) MEMTYPE;

  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00033	b9 10 00 00 00	 mov	 ecx, 16
  00038	e8 00 00 00 00	 call	 ??2@YAPEAX_KAEBUnothrow_t@std@@@Z ; operator new
  0003d	48 89 44 24 28	 mov	 QWORD PTR $T1[rsp], rax
  00042	48 8b 44 24 28	 mov	 rax, QWORD PTR $T1[rsp]
  00047	eb 14		 jmp	 SHORT $LN1@unit_alloc
$LN5@unit_alloc:

; 138  : 	case eAlloc_Type_alloc		:	return (MEMTYPE *)calloc(1, sizeof(MEMTYPE));

  00049	ba 10 00 00 00	 mov	 edx, 16
  0004e	b9 01 00 00 00	 mov	 ecx, 1
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00059	eb 02		 jmp	 SHORT $LN1@unit_alloc
$LN6@unit_alloc:

; 139  : 	default: return NULL;

  0005b	33 c0		 xor	 eax, eax
$LN1@unit_alloc:

; 140  : 	}
; 141  : }

  0005d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00061	c3		 ret	 0
?__unit_alloc@?$CBMemPool@USTValue@@@@AEAAPEAUSTValue@@XZ ENDP ; CBMemPool<STValue>::__unit_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\combmempool.h
;	COMDAT ?delMem@?$CBMemPool@USTValue@@@@QEAA_NPEAUSTValue@@@Z
_TEXT	SEGMENT
tv86 = 32
nIdx$ = 36
$T1 = 40
tv90 = 48
this$ = 80
pUsedMem$ = 88
?delMem@?$CBMemPool@USTValue@@@@QEAA_NPEAUSTValue@@@Z PROC ; CBMemPool<STValue>::delMem, COMDAT

; 193  : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 194  : 	int nIdx = int(pUsedMem - m_pChunk);

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00013	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00017	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pUsedMem$[rsp]
  0001c	48 2b c8	 sub	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 c1 f8 04	 sar	 rax, 4
  00026	89 44 24 24	 mov	 DWORD PTR nIdx$[rsp], eax

; 195  : 
; 196  : 	if (ISINCLUDE(nIdx, m_nAllocCount)) {

  0002a	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  0002f	8b 50 08	 mov	 edx, DWORD PTR [rax+8]
  00032	8b 4c 24 24	 mov	 ecx, DWORD PTR nIdx$[rsp]
  00036	e8 00 00 00 00	 call	 ?ISINCLUDE@@YA_NHH@Z	; ISINCLUDE
  0003b	0f b6 c0	 movzx	 eax, al
  0003e	85 c0		 test	 eax, eax
  00040	74 2b		 je	 SHORT $LN4@delMem

; 197  : 		m_nFlagArray[nIdx] = 0;

  00042	48 63 44 24 24	 movsxd	 rax, DWORD PTR nIdx$[rsp]
  00047	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  0004c	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00050	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 198  : 		m_nUseCnt--;

  00054	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00059	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0005c	ff c8		 dec	 eax
  0005e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR this$[rsp]
  00063	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 199  : 		return true;

  00066	b0 01		 mov	 al, 1
  00068	e9 81 00 00 00	 jmp	 $LN1@delMem
$LN4@delMem:

; 200  : 	}
; 201  : 	if (m_bSlot) return false;

  0006d	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00072	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00075	85 c0		 test	 eax, eax
  00077	74 04		 je	 SHORT $LN5@delMem
  00079	32 c0		 xor	 al, al
  0007b	eb 71		 jmp	 SHORT $LN1@delMem
$LN5@delMem:

; 202  : 	switch (m_nObjAllocType) {

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00082	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00085	89 44 24 20	 mov	 DWORD PTR tv86[rsp], eax
  00089	83 7c 24 20 02	 cmp	 DWORD PTR tv86[rsp], 2
  0008e	74 10		 je	 SHORT $LN6@delMem
  00090	83 7c 24 20 03	 cmp	 DWORD PTR tv86[rsp], 3
  00095	74 4a		 je	 SHORT $LN7@delMem
  00097	83 7c 24 20 05	 cmp	 DWORD PTR tv86[rsp], 5
  0009c	74 02		 je	 SHORT $LN6@delMem
  0009e	eb 4c		 jmp	 SHORT $LN2@delMem
$LN6@delMem:

; 203  : 	case eAlloc_Type_new:	
; 204  : 	case eAlloc_Type_newArray:	delete pUsedMem; break;

  000a0	48 8b 44 24 58	 mov	 rax, QWORD PTR pUsedMem$[rsp]
  000a5	48 89 44 24 28	 mov	 QWORD PTR $T1[rsp], rax
  000aa	ba 10 00 00 00	 mov	 edx, 16
  000af	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T1[rsp]
  000b4	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  000b9	48 83 7c 24 28
	00		 cmp	 QWORD PTR $T1[rsp], 0
  000bf	75 0b		 jne	 SHORT $LN9@delMem
  000c1	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tv90[rsp], 0
  000ca	eb 13		 jmp	 SHORT $LN10@delMem
$LN9@delMem:
  000cc	48 c7 44 24 58
	23 81 00 00	 mov	 QWORD PTR pUsedMem$[rsp], 33059 ; 00008123H
  000d5	48 8b 44 24 58	 mov	 rax, QWORD PTR pUsedMem$[rsp]
  000da	48 89 44 24 30	 mov	 QWORD PTR tv90[rsp], rax
$LN10@delMem:
  000df	eb 0b		 jmp	 SHORT $LN2@delMem
$LN7@delMem:

; 205  : 	case eAlloc_Type_alloc:	free(pUsedMem); break;

  000e1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pUsedMem$[rsp]
  000e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN2@delMem:

; 206  : 	}
; 207  : 	return false;

  000ec	32 c0		 xor	 al, al
$LN1@delMem:

; 208  : }

  000ee	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000f2	c3		 ret	 0
?delMem@?$CBMemPool@USTValue@@@@QEAA_NPEAUSTValue@@@Z ENDP ; CBMemPool<STValue>::delMem
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\combmempool.h
;	COMDAT ?newMem@?$CBMemPool@USTValue@@@@QEAAPEAUSTValue@@XZ
_TEXT	SEGMENT
i$ = 32
j$ = 36
this$ = 64
?newMem@?$CBMemPool@USTValue@@@@QEAAPEAUSTValue@@XZ PROC ; CBMemPool<STValue>::newMem, COMDAT

; 145  : {

$LN11:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 146  : 	int i = m_nUseCnt, j;

  0000a	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0000f	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00012	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax

; 147  : 	if (m_nUseCnt == m_nAllocCount) {

  00016	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0001b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00020	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  00023	39 48 04	 cmp	 DWORD PTR [rax+4], ecx
  00026	75 22		 jne	 SHORT $LN5@newMem

; 148  : 		if (m_bSlot) return NULL;

  00028	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0002d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00030	85 c0		 test	 eax, eax
  00032	74 07		 je	 SHORT $LN6@newMem
  00034	33 c0		 xor	 eax, eax
  00036	e9 d6 00 00 00	 jmp	 $LN1@newMem
$LN6@newMem:

; 149  : 		return __unit_alloc();

  0003b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00040	e8 00 00 00 00	 call	 ?__unit_alloc@?$CBMemPool@USTValue@@@@AEAAPEAUSTValue@@XZ ; CBMemPool<STValue>::__unit_alloc
  00045	e9 c7 00 00 00	 jmp	 $LN1@newMem
$LN5@newMem:

; 150  : 	}
; 151  : 	for (j = 0; j < m_nAllocCount; j++) {

  0004a	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00052	eb 0a		 jmp	 SHORT $LN4@newMem
$LN2@newMem:
  00054	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  00058	ff c0		 inc	 eax
  0005a	89 44 24 24	 mov	 DWORD PTR j$[rsp], eax
$LN4@newMem:
  0005e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00063	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00066	39 44 24 24	 cmp	 DWORD PTR j$[rsp], eax
  0006a	0f 8d 87 00 00
	00		 jge	 $LN3@newMem

; 152  : 		if (i >= m_nAllocCount) { i = 0; }

  00070	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00075	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00078	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0007c	7c 08		 jl	 SHORT $LN7@newMem
  0007e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
$LN7@newMem:

; 153  : 		if (!m_nFlagArray[i]) {

  00086	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0008b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00090	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00094	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00098	85 c0		 test	 eax, eax
  0009a	75 56		 jne	 SHORT $LN8@newMem

; 154  : 			m_nFlagArray[i] = 1;

  0009c	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000a1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000a6	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000aa	c6 04 01 01	 mov	 BYTE PTR [rcx+rax], 1

; 155  : 			memset(&m_pChunk[i], 0, sizeof(MEMTYPE));

  000ae	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000b3	48 6b c0 10	 imul	 rax, rax, 16
  000b7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000bc	48 03 41 18	 add	 rax, QWORD PTR [rcx+24]
  000c0	48 8b f8	 mov	 rdi, rax
  000c3	33 c0		 xor	 eax, eax
  000c5	b9 10 00 00 00	 mov	 ecx, 16
  000ca	f3 aa		 rep stosb

; 156  : 			m_nUseCnt++;

  000cc	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000d1	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  000d4	ff c0		 inc	 eax
  000d6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000db	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 157  : 			return &m_pChunk[i];

  000de	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000e3	48 6b c0 10	 imul	 rax, rax, 16
  000e7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000ec	48 03 41 18	 add	 rax, QWORD PTR [rcx+24]
  000f0	eb 1f		 jmp	 SHORT $LN1@newMem
$LN8@newMem:

; 158  : 		}
; 159  : 	}

  000f2	e9 5d ff ff ff	 jmp	 $LN2@newMem
$LN3@newMem:

; 160  : 	if (m_bSlot) return NULL;

  000f7	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000fc	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000ff	85 c0		 test	 eax, eax
  00101	74 04		 je	 SHORT $LN9@newMem
  00103	33 c0		 xor	 eax, eax
  00105	eb 0a		 jmp	 SHORT $LN1@newMem
$LN9@newMem:

; 161  : 	return __unit_alloc();

  00107	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0010c	e8 00 00 00 00	 call	 ?__unit_alloc@?$CBMemPool@USTValue@@@@AEAAPEAUSTValue@@XZ ; CBMemPool<STValue>::__unit_alloc
$LN1@newMem:

; 162  : }

  00111	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00115	5f		 pop	 rdi
  00116	c3		 ret	 0
?newMem@?$CBMemPool@USTValue@@@@QEAAPEAUSTValue@@XZ ENDP ; CBMemPool<STValue>::newMem
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\combmempool.h
;	COMDAT ?alloc@?$CBMemPool@USTValue@@@@QEAAHH@Z
_TEXT	SEGMENT
this$ = 48
nMaxCount$ = 56
?alloc@?$CBMemPool@USTValue@@@@QEAAHH@Z PROC		; CBMemPool<STValue>::alloc, COMDAT

; 32   : 	inline int alloc(int nMaxCount) { m_nAllocCount = __alloc(nMaxCount); return m_nAllocCount; }

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	8b 54 24 38	 mov	 edx, DWORD PTR nMaxCount$[rsp]
  00011	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00016	e8 00 00 00 00	 call	 ?__alloc@?$CBMemPool@USTValue@@@@AEAAHH@Z ; CBMemPool<STValue>::__alloc
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00020	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  00023	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00028	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0002b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002f	c3		 ret	 0
?alloc@?$CBMemPool@USTValue@@@@QEAAHH@Z ENDP		; CBMemPool<STValue>::alloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\combmempool.h
;	COMDAT ??1?$CBMemPool@USTValue@@@@QEAA@XZ
_TEXT	SEGMENT
tv67 = 32
$T1 = 40
this$ = 64
??1?$CBMemPool@USTValue@@@@QEAA@XZ PROC			; CBMemPool<STValue>::~CBMemPool<STValue>, COMDAT

; 85   : {

$LN9:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 86   : 	if (m_pChunk) {

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00013	74 59		 je	 SHORT $LN4@CBMemPool

; 87   : 		switch (m_nObjAllocType) {

  00015	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0001a	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  0001d	89 44 24 20	 mov	 DWORD PTR tv67[rsp], eax
  00021	83 7c 24 20 02	 cmp	 DWORD PTR tv67[rsp], 2
  00026	74 10		 je	 SHORT $LN5@CBMemPool
  00028	83 7c 24 20 03	 cmp	 DWORD PTR tv67[rsp], 3
  0002d	74 23		 je	 SHORT $LN6@CBMemPool
  0002f	83 7c 24 20 05	 cmp	 DWORD PTR tv67[rsp], 5
  00034	74 02		 je	 SHORT $LN5@CBMemPool
  00036	eb 29		 jmp	 SHORT $LN2@CBMemPool
$LN5@CBMemPool:

; 88   : 		case eAlloc_Type_new:		
; 89   : 		case eAlloc_Type_newArray:	delete[] m_pChunk;	break;

  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0003d	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00041	48 89 44 24 28	 mov	 QWORD PTR $T1[rsp], rax
  00046	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T1[rsp]
  0004b	e8 00 00 00 00	 call	 ??_V@YAXPEAX@Z		; operator delete[]
  00050	eb 0f		 jmp	 SHORT $LN2@CBMemPool
$LN6@CBMemPool:

; 90   : 		case eAlloc_Type_alloc:		free(m_pChunk);		break;

  00052	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00057	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN2@CBMemPool:

; 91   : 		}
; 92   : 
; 93   : 		m_pChunk = NULL;

  00061	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00066	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0
$LN4@CBMemPool:

; 94   : 	}
; 95   : 
; 96   : 	if (m_nFlagArray) {

  0006e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00073	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00078	74 1c		 je	 SHORT $LN7@CBMemPool

; 97   : 		free(m_nFlagArray);

  0007a	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0007f	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 98   : 		m_nFlagArray = NULL;

  00089	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0008e	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0
$LN7@CBMemPool:

; 99   : 	}
; 100  : }

  00096	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009a	c3		 ret	 0
??1?$CBMemPool@USTValue@@@@QEAA@XZ ENDP			; CBMemPool<STValue>::~CBMemPool<STValue>
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\combmempool.h
;	COMDAT ??0?$CBMemPool@USTValue@@@@QEAA@W4E_ALLOC_TYPE@@@Z
_TEXT	SEGMENT
this$ = 8
nType$ = 16
??0?$CBMemPool@USTValue@@@@QEAA@W4E_ALLOC_TYPE@@@Z PROC	; CBMemPool<STValue>::CBMemPool<STValue>, COMDAT

; 74   : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 75   : 	m_nAllocCount = 0;

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000e	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0

; 76   : 	m_pChunk = NULL;

  00015	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0001a	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 77   : 	m_nUseCnt = 0;

  00022	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00027	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0

; 78   : 	m_nFlagArray = NULL;

  0002e	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00033	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 79   : 	m_nObjAllocType = nType;

  0003b	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00040	8b 4c 24 10	 mov	 ecx, DWORD PTR nType$[rsp]
  00044	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 80   : 	m_bSlot = false;

  00047	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0004c	c6 00 00	 mov	 BYTE PTR [rax], 0

; 81   : }

  0004f	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00054	c3		 ret	 0
??0?$CBMemPool@USTValue@@@@QEAA@W4E_ALLOC_TYPE@@@Z ENDP	; CBMemPool<STValue>::CBMemPool<STValue>
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comdualkeyhash.cpp
;	COMDAT ?getNode@CDKeyHashMap@@QEAAPEAUSTHash_Node@@PEAD0@Z
_TEXT	SEGMENT
pNode$ = 32
pHash$1 = 40
this$ = 64
pKey1$ = 72
pKey2$ = 80
?getNode@CDKeyHashMap@@QEAAPEAUSTHash_Node@@PEAD0@Z PROC ; CDKeyHashMap::getNode, COMDAT

; 170  : {

$LN4:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 171  : 	STHash_Node *pNode = m_pHashGroup->hashLookup(pKey1);

  00013	48 8b 54 24 48	 mov	 rdx, QWORD PTR pKey1$[rsp]
  00018	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0001d	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00021	e8 00 00 00 00	 call	 ?hashLookup@CHash@@QEAAPEAUSTHash_Node@@PEAD@Z ; CHash::hashLookup
  00026	48 89 44 24 20	 mov	 QWORD PTR pNode$[rsp], rax

; 172  : 	if (pNode) {

  0002b	48 83 7c 24 20
	00		 cmp	 QWORD PTR pNode$[rsp], 0
  00031	74 1f		 je	 SHORT $LN2@getNode

; 173  : 		CHash *pHash = (CHash *)pNode->value;

  00033	48 8b 44 24 20	 mov	 rax, QWORD PTR pNode$[rsp]
  00038	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0003c	48 89 44 24 28	 mov	 QWORD PTR pHash$1[rsp], rax

; 174  : 		return pHash->hashLookup(pKey2);

  00041	48 8b 54 24 50	 mov	 rdx, QWORD PTR pKey2$[rsp]
  00046	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pHash$1[rsp]
  0004b	e8 00 00 00 00	 call	 ?hashLookup@CHash@@QEAAPEAUSTHash_Node@@PEAD@Z ; CHash::hashLookup
  00050	eb 02		 jmp	 SHORT $LN1@getNode
$LN2@getNode:

; 175  : 	}
; 176  : 	return NULL;

  00052	33 c0		 xor	 eax, eax
$LN1@getNode:

; 177  : }

  00054	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00058	c3		 ret	 0
?getNode@CDKeyHashMap@@QEAAPEAUSTHash_Node@@PEAD0@Z ENDP ; CDKeyHashMap::getNode
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comdualkeyhash.cpp
;	COMDAT ?getHashMap@CDKeyHashMap@@QEAAPEAVCHash@@PEAD@Z
_TEXT	SEGMENT
pNode$ = 32
this$ = 64
pKey1$ = 72
?getHashMap@CDKeyHashMap@@QEAAPEAVCHash@@PEAD@Z PROC	; CDKeyHashMap::getHashMap, COMDAT

; 164  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 165  : 	STHash_Node *pNode = m_pHashGroup->hashLookup(pKey1);

  0000e	48 8b 54 24 48	 mov	 rdx, QWORD PTR pKey1$[rsp]
  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00018	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0001c	e8 00 00 00 00	 call	 ?hashLookup@CHash@@QEAAPEAUSTHash_Node@@PEAD@Z ; CHash::hashLookup
  00021	48 89 44 24 20	 mov	 QWORD PTR pNode$[rsp], rax

; 166  : 	return (CHash *)pNode->value;		// return NULL 

  00026	48 8b 44 24 20	 mov	 rax, QWORD PTR pNode$[rsp]
  0002b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 167  : }

  0002f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00033	c3		 ret	 0
?getHashMap@CDKeyHashMap@@QEAAPEAVCHash@@PEAD@Z ENDP	; CDKeyHashMap::getHashMap
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comdualkeyhash.cpp
;	COMDAT ?isNode@CDKeyHashMap@@QEAA_NPEAD0@Z
_TEXT	SEGMENT
pNode$ = 32
pHash$1 = 40
this$ = 64
pKey1$ = 72
pKey2$ = 80
?isNode@CDKeyHashMap@@QEAA_NPEAD0@Z PROC		; CDKeyHashMap::isNode, COMDAT

; 154  : {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 155  : 	STHash_Node *pNode = m_pHashGroup->hashLookup(pKey1);

  00013	48 8b 54 24 48	 mov	 rdx, QWORD PTR pKey1$[rsp]
  00018	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0001d	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00021	e8 00 00 00 00	 call	 ?hashLookup@CHash@@QEAAPEAUSTHash_Node@@PEAD@Z ; CHash::hashLookup
  00026	48 89 44 24 20	 mov	 QWORD PTR pNode$[rsp], rax

; 156  : 	if (pNode) {

  0002b	48 83 7c 24 20
	00		 cmp	 QWORD PTR pNode$[rsp], 0
  00031	74 26		 je	 SHORT $LN2@isNode

; 157  : 		CHash *pHash = (CHash *)pNode->value;

  00033	48 8b 44 24 20	 mov	 rax, QWORD PTR pNode$[rsp]
  00038	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0003c	48 89 44 24 28	 mov	 QWORD PTR pHash$1[rsp], rax

; 158  : 		if (pHash->hashLookup(pKey2)) return true;

  00041	48 8b 54 24 50	 mov	 rdx, QWORD PTR pKey2$[rsp]
  00046	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pHash$1[rsp]
  0004b	e8 00 00 00 00	 call	 ?hashLookup@CHash@@QEAAPEAUSTHash_Node@@PEAD@Z ; CHash::hashLookup
  00050	48 85 c0	 test	 rax, rax
  00053	74 04		 je	 SHORT $LN3@isNode
  00055	b0 01		 mov	 al, 1
  00057	eb 02		 jmp	 SHORT $LN1@isNode
$LN3@isNode:
$LN2@isNode:

; 159  : 	}
; 160  : 	return false;

  00059	32 c0		 xor	 al, al
$LN1@isNode:

; 161  : }

  0005b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005f	c3		 ret	 0
?isNode@CDKeyHashMap@@QEAA_NPEAD0@Z ENDP		; CDKeyHashMap::isNode
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comdualkeyhash.cpp
;	COMDAT ?delValueBuf@CDKeyHashMap@@QEAAXPEAUSTValue@@@Z
_TEXT	SEGMENT
this$ = 48
pValue$ = 56
?delValueBuf@CDKeyHashMap@@QEAAXPEAUSTValue@@@Z PROC	; CDKeyHashMap::delValueBuf, COMDAT

; 248  : { 

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 249  : 	if (m_bValInternal) {

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00013	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  00017	85 c0		 test	 eax, eax
  00019	74 30		 je	 SHORT $LN2@delValueBu

; 250  : 		gs_pMMgr->delBufByIndex((TCHAR *)pValue->pValue, pValue->nIdx); m_pValue->delMem(pValue);

  0001b	48 8b 44 24 38	 mov	 rax, QWORD PTR pValue$[rsp]
  00020	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  00023	48 8b 44 24 38	 mov	 rax, QWORD PTR pValue$[rsp]
  00028	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0002c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  00033	e8 00 00 00 00	 call	 ?delBufByIndex@CMemManager@@QEAAXPEADH@Z ; CMemManager::delBufByIndex
  00038	48 8b 54 24 38	 mov	 rdx, QWORD PTR pValue$[rsp]
  0003d	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00042	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00046	e8 00 00 00 00	 call	 ?delMem@?$CBMemPool@USTValue@@@@QEAA_NPEAUSTValue@@@Z ; CBMemPool<STValue>::delMem
$LN2@delValueBu:

; 251  : 	}
; 252  : 
; 253  : 	//   ...  
; 254  : } // value     

  0004b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004f	c3		 ret	 0
?delValueBuf@CDKeyHashMap@@QEAAXPEAUSTValue@@@Z ENDP	; CDKeyHashMap::delValueBuf
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comdualkeyhash.cpp
;	COMDAT ?newValueBuf@CDKeyHashMap@@QEAAPEAUSTValue@@HPEAD@Z
_TEXT	SEGMENT
pSTValue$ = 32
pValueBuf$ = 40
nIdx$ = 48
__$ArrayPad$ = 56
this$ = 80
size$ = 88
pValue$ = 96
?newValueBuf@CDKeyHashMap@@QEAAPEAUSTValue@@HPEAD@Z PROC ; CDKeyHashMap::newValueBuf, COMDAT

; 235  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 44 24 38	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 236  : 	int nIdx;
; 237  : 	STValue *pSTValue = m_pValue->newMem();

  00021	48 8b 44 24 50	 mov	 rax, QWORD PTR this$[rsp]
  00026	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0002a	e8 00 00 00 00	 call	 ?newMem@?$CBMemPool@USTValue@@@@QEAAPEAUSTValue@@XZ ; CBMemPool<STValue>::newMem
  0002f	48 89 44 24 20	 mov	 QWORD PTR pSTValue$[rsp], rax

; 238  : 	TCHAR *pValueBuf = gs_pMMgr->newBuf(size, &nIdx);

  00034	4c 8d 44 24 30	 lea	 r8, QWORD PTR nIdx$[rsp]
  00039	8b 54 24 58	 mov	 edx, DWORD PTR size$[rsp]
  0003d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  00044	e8 00 00 00 00	 call	 ?newBuf@CMemManager@@QEAAPEADHPEAH@Z ; CMemManager::newBuf
  00049	48 89 44 24 28	 mov	 QWORD PTR pValueBuf$[rsp], rax

; 239  : 	c_memcpy(pValueBuf, pValue, size);

  0004e	44 8b 44 24 58	 mov	 r8d, DWORD PTR size$[rsp]
  00053	48 8b 54 24 60	 mov	 rdx, QWORD PTR pValue$[rsp]
  00058	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pValueBuf$[rsp]
  0005d	e8 00 00 00 00	 call	 ?c_memcpy@@YAPEAXPEAXPEBXH@Z ; c_memcpy

; 240  : 	pSTValue->nIdx = nIdx;

  00062	48 8b 44 24 20	 mov	 rax, QWORD PTR pSTValue$[rsp]
  00067	8b 4c 24 30	 mov	 ecx, DWORD PTR nIdx$[rsp]
  0006b	89 08		 mov	 DWORD PTR [rax], ecx

; 241  : 	pSTValue->pValue = pValueBuf;

  0006d	48 8b 44 24 20	 mov	 rax, QWORD PTR pSTValue$[rsp]
  00072	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pValueBuf$[rsp]
  00077	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 242  : 
; 243  : 	return pSTValue;

  0007b	48 8b 44 24 20	 mov	 rax, QWORD PTR pSTValue$[rsp]

; 244  : }

  00080	48 8b 4c 24 38	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00085	48 33 cc	 xor	 rcx, rsp
  00088	e8 00 00 00 00	 call	 __security_check_cookie
  0008d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00091	c3		 ret	 0
?newValueBuf@CDKeyHashMap@@QEAAPEAUSTValue@@HPEAD@Z ENDP ; CDKeyHashMap::newValueBuf
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comdualkeyhash.cpp
;	COMDAT ?deleteNode@CDKeyHashMap@@QEAA_NPEAD0@Z
_TEXT	SEGMENT
pCur2$ = 32
tv132 = 40
pNext1$ = 48
ppPrev$ = 56
pHash$1 = 64
tv131 = 72
this$ = 96
pKey1$ = 104
pKey2$ = 112
?deleteNode@CDKeyHashMap@@QEAA_NPEAD0@Z PROC		; CDKeyHashMap::deleteNode, COMDAT

; 212  : {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 213  : 	SThash_next **ppPrev=NULL;

  00013	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR ppPrev$[rsp], 0

; 214  : 	SThash_next *pNext1, *pCur2;
; 215  : 
; 216  : 	pNext1 = m_pHashGroup->getNext(pKey1);

  0001c	48 8b 54 24 68	 mov	 rdx, QWORD PTR pKey1$[rsp]
  00021	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  00026	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0002a	e8 00 00 00 00	 call	 ?getNext@CHash@@QEAAPEAUSThash_next@@PEAD@Z ; CHash::getNext
  0002f	48 89 44 24 30	 mov	 QWORD PTR pNext1$[rsp], rax

; 217  : 
; 218  : 	if (pNext1) {

  00034	48 83 7c 24 30
	00		 cmp	 QWORD PTR pNext1$[rsp], 0
  0003a	0f 84 c4 00 00
	00		 je	 $LN2@deleteNode

; 219  : 		CHash *pHash = (CHash *)pNext1->pNode.value;

  00040	48 8b 44 24 30	 mov	 rax, QWORD PTR pNext1$[rsp]
  00045	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00049	48 89 44 24 40	 mov	 QWORD PTR pHash$1[rsp], rax

; 220  : 		pCur2 = pHash->getNode(pKey2, ppPrev);

  0004e	4c 8b 44 24 38	 mov	 r8, QWORD PTR ppPrev$[rsp]
  00053	48 8b 54 24 70	 mov	 rdx, QWORD PTR pKey2$[rsp]
  00058	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pHash$1[rsp]
  0005d	e8 00 00 00 00	 call	 ?getNode@CHash@@QEAAPEAUSThash_next@@PEADPEAPEAU2@@Z ; CHash::getNode
  00062	48 89 44 24 20	 mov	 QWORD PTR pCur2$[rsp], rax

; 221  : 		if (pCur2) {

  00067	48 83 7c 24 20
	00		 cmp	 QWORD PTR pCur2$[rsp], 0
  0006d	0f 84 91 00 00
	00		 je	 $LN3@deleteNode

; 222  : 			*ppPrev = pCur2->next;  // NULL  .

  00073	48 8b 44 24 38	 mov	 rax, QWORD PTR ppPrev$[rsp]
  00078	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pCur2$[rsp]
  0007d	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00081	48 89 08	 mov	 QWORD PTR [rax], rcx

; 223  : 			gs_pMMgr->delBuf(pCur2->pNode.pKey, STRING_SIZE(pCur2->pNode.pKey));	// key2  

  00084	48 8b 44 24 20	 mov	 rax, QWORD PTR pCur2$[rsp]
  00089	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008c	48 89 44 24 48	 mov	 QWORD PTR tv131[rsp], rax
  00091	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR tv132[rsp], -1
$LL6@deleteNode:
  0009a	48 ff 44 24 28	 inc	 QWORD PTR tv132[rsp]
  0009f	48 8b 44 24 48	 mov	 rax, QWORD PTR tv131[rsp]
  000a4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv132[rsp]
  000a9	80 3c 08 00	 cmp	 BYTE PTR [rax+rcx], 0
  000ad	75 eb		 jne	 SHORT $LL6@deleteNode
  000af	48 8b 44 24 28	 mov	 rax, QWORD PTR tv132[rsp]
  000b4	48 ff c0	 inc	 rax
  000b7	44 8b c0	 mov	 r8d, eax
  000ba	48 8b 44 24 20	 mov	 rax, QWORD PTR pCur2$[rsp]
  000bf	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  000c2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  000c9	e8 00 00 00 00	 call	 ?delBuf@CMemManager@@QEAAXPEADH@Z ; CMemManager::delBuf

; 224  : 			if (m_bValInternal)delValueBuf((STValue *)pCur2->pNode.value);	// key2  value  

  000ce	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  000d3	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  000d7	85 c0		 test	 eax, eax
  000d9	74 13		 je	 SHORT $LN4@deleteNode
  000db	48 8b 44 24 20	 mov	 rax, QWORD PTR pCur2$[rsp]
  000e0	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  000e4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  000e9	e8 00 00 00 00	 call	 ?delValueBuf@CDKeyHashMap@@QEAAXPEAUSTValue@@@Z ; CDKeyHashMap::delValueBuf
$LN4@deleteNode:

; 225  : 			m_pHashNext->delMem(pCur2);										// key2,value,next  node 

  000ee	48 8b 54 24 20	 mov	 rdx, QWORD PTR pCur2$[rsp]
  000f3	48 8b 44 24 60	 mov	 rax, QWORD PTR this$[rsp]
  000f8	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000fb	e8 00 00 00 00	 call	 ?delMem@?$CBMemPool@USThash_next@@@@QEAA_NPEAUSThash_next@@@Z ; CBMemPool<SThash_next>::delMem

; 226  : 
; 227  : 			return true;

  00100	b0 01		 mov	 al, 1
  00102	eb 02		 jmp	 SHORT $LN1@deleteNode
$LN3@deleteNode:
$LN2@deleteNode:

; 228  : 		}
; 229  : 	}
; 230  : 	return false;

  00104	32 c0		 xor	 al, al
$LN1@deleteNode:

; 231  : }

  00106	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0010a	c3		 ret	 0
?deleteNode@CDKeyHashMap@@QEAA_NPEAD0@Z ENDP		; CDKeyHashMap::deleteNode
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comdualkeyhash.cpp
;	COMDAT ?deleteHash@CDKeyHashMap@@QEAA_NPEAD@Z
_TEXT	SEGMENT
j$ = 32
pNext2$ = 40
pCur$ = 48
tv163 = 56
tv156 = 64
ppPrev$ = 72
pHash$ = 80
$T1 = 88
tv162 = 96
tv155 = 104
$T2 = 112
tv149 = 120
this$ = 144
pKey1$ = 152
?deleteHash@CDKeyHashMap@@QEAA_NPEAD@Z PROC		; CDKeyHashMap::deleteHash, COMDAT

; 180  : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 181  : 	SThash_next **ppPrev=NULL;

  00011	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR ppPrev$[rsp], 0

; 182  : 	SThash_next *pNext2;
; 183  : 	SThash_next *pCur = m_pHashGroup->getNode(pKey1, ppPrev);

  0001a	4c 8b 44 24 48	 mov	 r8, QWORD PTR ppPrev$[rsp]
  0001f	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR pKey1$[rsp]
  00027	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0002f	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00033	e8 00 00 00 00	 call	 ?getNode@CHash@@QEAAPEAUSThash_next@@PEADPEAPEAU2@@Z ; CHash::getNode
  00038	48 89 44 24 30	 mov	 QWORD PTR pCur$[rsp], rax

; 184  : 	CHash *pHash;
; 185  : 	unsigned int j;
; 186  : 
; 187  : 	if (pCur) {

  0003d	48 83 7c 24 30
	00		 cmp	 QWORD PTR pCur$[rsp], 0
  00043	0f 84 a2 01 00
	00		 je	 $LN7@deleteHash

; 188  : 		*ppPrev = pCur->next; // NULL  .

  00049	48 8b 44 24 48	 mov	 rax, QWORD PTR ppPrev$[rsp]
  0004e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pCur$[rsp]
  00053	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00057	48 89 08	 mov	 QWORD PTR [rax], rcx

; 189  : 
; 190  : 		pHash = (CHash *)pCur->pNode.value;

  0005a	48 8b 44 24 30	 mov	 rax, QWORD PTR pCur$[rsp]
  0005f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00063	48 89 44 24 50	 mov	 QWORD PTR pHash$[rsp], rax

; 191  : 		for (j = 0; j < m_nMaxCount2; j++) {

  00068	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00070	eb 0a		 jmp	 SHORT $LN4@deleteHash
$LN2@deleteHash:
  00072	8b 44 24 20	 mov	 eax, DWORD PTR j$[rsp]
  00076	ff c0		 inc	 eax
  00078	89 44 24 20	 mov	 DWORD PTR j$[rsp], eax
$LN4@deleteHash:
  0007c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00084	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00087	39 44 24 20	 cmp	 DWORD PTR j$[rsp], eax
  0008b	0f 83 bc 00 00
	00		 jae	 $LN3@deleteHash

; 192  : 			pNext2 = pHash->getNext(j);

  00091	8b 54 24 20	 mov	 edx, DWORD PTR j$[rsp]
  00095	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pHash$[rsp]
  0009a	e8 00 00 00 00	 call	 ?getNext@CHash@@QEAAPEAUSThash_next@@I@Z ; CHash::getNext
  0009f	48 89 44 24 28	 mov	 QWORD PTR pNext2$[rsp], rax
$LN5@deleteHash:

; 193  : 			while (pNext2) {

  000a4	48 83 7c 24 28
	00		 cmp	 QWORD PTR pNext2$[rsp], 0
  000aa	0f 84 98 00 00
	00		 je	 $LN6@deleteHash

; 194  : 				gs_pMMgr->delBuf(pNext2->pNode.pKey, STRING_SIZE(pNext2->pNode.pKey));	// key2  

  000b0	48 8b 44 24 28	 mov	 rax, QWORD PTR pNext2$[rsp]
  000b5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000b8	48 89 44 24 60	 mov	 QWORD PTR tv162[rsp], rax
  000bd	48 c7 44 24 38
	ff ff ff ff	 mov	 QWORD PTR tv163[rsp], -1
$LL13@deleteHash:
  000c6	48 ff 44 24 38	 inc	 QWORD PTR tv163[rsp]
  000cb	48 8b 44 24 60	 mov	 rax, QWORD PTR tv162[rsp]
  000d0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv163[rsp]
  000d5	80 3c 08 00	 cmp	 BYTE PTR [rax+rcx], 0
  000d9	75 eb		 jne	 SHORT $LL13@deleteHash
  000db	48 8b 44 24 38	 mov	 rax, QWORD PTR tv163[rsp]
  000e0	48 ff c0	 inc	 rax
  000e3	44 8b c0	 mov	 r8d, eax
  000e6	48 8b 44 24 28	 mov	 rax, QWORD PTR pNext2$[rsp]
  000eb	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  000ee	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  000f5	e8 00 00 00 00	 call	 ?delBuf@CMemManager@@QEAAXPEADH@Z ; CMemManager::delBuf

; 195  : 				if (m_bValInternal) delValueBuf((STValue *)pNext2->pNode.value);	// key2  value  

  000fa	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00102	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  00106	85 c0		 test	 eax, eax
  00108	74 16		 je	 SHORT $LN8@deleteHash
  0010a	48 8b 44 24 28	 mov	 rax, QWORD PTR pNext2$[rsp]
  0010f	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00113	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0011b	e8 00 00 00 00	 call	 ?delValueBuf@CDKeyHashMap@@QEAAXPEAUSTValue@@@Z ; CDKeyHashMap::delValueBuf
$LN8@deleteHash:

; 196  : 				m_pHashNext->delMem(pNext2);										// key2,value,next  node 

  00120	48 8b 54 24 28	 mov	 rdx, QWORD PTR pNext2$[rsp]
  00125	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0012d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00130	e8 00 00 00 00	 call	 ?delMem@?$CBMemPool@USThash_next@@@@QEAA_NPEAUSThash_next@@@Z ; CBMemPool<SThash_next>::delMem

; 197  : 				pNext2 = pNext2->next;

  00135	48 8b 44 24 28	 mov	 rax, QWORD PTR pNext2$[rsp]
  0013a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0013e	48 89 44 24 28	 mov	 QWORD PTR pNext2$[rsp], rax

; 198  : 			}

  00143	e9 5c ff ff ff	 jmp	 $LN5@deleteHash
$LN6@deleteHash:

; 199  : 		}

  00148	e9 25 ff ff ff	 jmp	 $LN2@deleteHash
$LN3@deleteHash:

; 200  : 		gs_pMMgr->delBuf(pCur->pNode.pKey, STRING_SIZE(pCur->pNode.pKey));	// key1  

  0014d	48 8b 44 24 30	 mov	 rax, QWORD PTR pCur$[rsp]
  00152	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00155	48 89 44 24 68	 mov	 QWORD PTR tv155[rsp], rax
  0015a	48 c7 44 24 40
	ff ff ff ff	 mov	 QWORD PTR tv156[rsp], -1
$LL12@deleteHash:
  00163	48 ff 44 24 40	 inc	 QWORD PTR tv156[rsp]
  00168	48 8b 44 24 68	 mov	 rax, QWORD PTR tv155[rsp]
  0016d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv156[rsp]
  00172	80 3c 08 00	 cmp	 BYTE PTR [rax+rcx], 0
  00176	75 eb		 jne	 SHORT $LL12@deleteHash
  00178	48 8b 44 24 40	 mov	 rax, QWORD PTR tv156[rsp]
  0017d	48 ff c0	 inc	 rax
  00180	44 8b c0	 mov	 r8d, eax
  00183	48 8b 44 24 30	 mov	 rax, QWORD PTR pCur$[rsp]
  00188	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0018b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  00192	e8 00 00 00 00	 call	 ?delBuf@CMemManager@@QEAAXPEADH@Z ; CMemManager::delBuf

; 201  : 		delete pHash;															// key1  value  

  00197	48 8b 44 24 50	 mov	 rax, QWORD PTR pHash$[rsp]
  0019c	48 89 44 24 70	 mov	 QWORD PTR $T2[rsp], rax
  001a1	48 8b 44 24 70	 mov	 rax, QWORD PTR $T2[rsp]
  001a6	48 89 44 24 58	 mov	 QWORD PTR $T1[rsp], rax
  001ab	48 83 7c 24 58
	00		 cmp	 QWORD PTR $T1[rsp], 0
  001b1	74 16		 je	 SHORT $LN10@deleteHash
  001b3	ba 01 00 00 00	 mov	 edx, 1
  001b8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR $T1[rsp]
  001bd	e8 00 00 00 00	 call	 ??_GCHash@@QEAAPEAXI@Z
  001c2	48 89 44 24 78	 mov	 QWORD PTR tv149[rsp], rax
  001c7	eb 09		 jmp	 SHORT $LN11@deleteHash
$LN10@deleteHash:
  001c9	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR tv149[rsp], 0
$LN11@deleteHash:

; 202  : 		m_pHashNext->delMem(pCur);												// key1,value,next  node 

  001d2	48 8b 54 24 30	 mov	 rdx, QWORD PTR pCur$[rsp]
  001d7	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  001df	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  001e2	e8 00 00 00 00	 call	 ?delMem@?$CBMemPool@USThash_next@@@@QEAA_NPEAUSThash_next@@@Z ; CBMemPool<SThash_next>::delMem

; 203  : 
; 204  : 		return true;

  001e7	b0 01		 mov	 al, 1
  001e9	eb 02		 jmp	 SHORT $LN1@deleteHash
$LN7@deleteHash:

; 205  : 	}		
; 206  : 	return false;

  001eb	32 c0		 xor	 al, al
$LN1@deleteHash:

; 207  : }

  001ed	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  001f4	c3		 ret	 0
?deleteHash@CDKeyHashMap@@QEAA_NPEAD@Z ENDP		; CDKeyHashMap::deleteHash
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comdualkeyhash.cpp
;	COMDAT ?setValue@CDKeyHashMap@@QEAAHPEAD0PEAX@Z
_TEXT	SEGMENT
pNode$ = 32
pHash$ = 40
this$ = 64
pKey1$ = 72
pKey2$ = 80
pValue$ = 88
?setValue@CDKeyHashMap@@QEAAHPEAD0PEAX@Z PROC		; CDKeyHashMap::setValue, COMDAT

; 137  : {

$LN6:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 138  : 	CHash *pHash;
; 139  : 	STHash_Node *pNode = m_pHashGroup->hashLookup(pKey1);

  00018	48 8b 54 24 48	 mov	 rdx, QWORD PTR pKey1$[rsp]
  0001d	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00022	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00026	e8 00 00 00 00	 call	 ?hashLookup@CHash@@QEAAPEAUSTHash_Node@@PEAD@Z ; CHash::hashLookup
  0002b	48 89 44 24 20	 mov	 QWORD PTR pNode$[rsp], rax

; 140  : 	if (pNode) {

  00030	48 83 7c 24 20
	00		 cmp	 QWORD PTR pNode$[rsp], 0
  00036	74 5b		 je	 SHORT $LN2@setValue

; 141  : 		pHash = (CHash *)pNode->value;

  00038	48 8b 44 24 20	 mov	 rax, QWORD PTR pNode$[rsp]
  0003d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00041	48 89 44 24 28	 mov	 QWORD PTR pHash$[rsp], rax

; 142  : 		pNode = pHash->hashLookup(pKey2);

  00046	48 8b 54 24 50	 mov	 rdx, QWORD PTR pKey2$[rsp]
  0004b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pHash$[rsp]
  00050	e8 00 00 00 00	 call	 ?hashLookup@CHash@@QEAAPEAUSTHash_Node@@PEAD@Z ; CHash::hashLookup
  00055	48 89 44 24 20	 mov	 QWORD PTR pNode$[rsp], rax

; 143  : 		if (pNode) {

  0005a	48 83 7c 24 20
	00		 cmp	 QWORD PTR pNode$[rsp], 0
  00060	74 31		 je	 SHORT $LN3@setValue

; 144  : 			if (pNode->value) { delValueBuf((STValue *)pNode->value); }

  00062	48 8b 44 24 20	 mov	 rax, QWORD PTR pNode$[rsp]
  00067	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0006c	74 13		 je	 SHORT $LN4@setValue
  0006e	48 8b 44 24 20	 mov	 rax, QWORD PTR pNode$[rsp]
  00073	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00077	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0007c	e8 00 00 00 00	 call	 ?delValueBuf@CDKeyHashMap@@QEAAXPEAUSTValue@@@Z ; CDKeyHashMap::delValueBuf
$LN4@setValue:

; 145  : 			pNode->value = pValue; 

  00081	48 8b 44 24 20	 mov	 rax, QWORD PTR pNode$[rsp]
  00086	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pValue$[rsp]
  0008b	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 146  : 			return eHASH_RESULT_SUCESS;

  0008f	33 c0		 xor	 eax, eax
  00091	eb 05		 jmp	 SHORT $LN1@setValue
$LN3@setValue:
$LN2@setValue:

; 147  : 		}
; 148  : 	}
; 149  : 	return eHASH_RESULT_INVALID_KEY;

  00093	b8 fd ff ff ff	 mov	 eax, -3
$LN1@setValue:

; 150  : }

  00098	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009c	c3		 ret	 0
?setValue@CDKeyHashMap@@QEAAHPEAD0PEAX@Z ENDP		; CDKeyHashMap::setValue
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comdualkeyhash.cpp
;	COMDAT ?addKeyValue@CDKeyHashMap@@QEAAHPEAD0PEAX1@Z
_TEXT	SEGMENT
nRes$ = 48
pHash$ = 56
__$ArrayPad$ = 64
this$ = 96
pKey1$ = 104
pKey2$ = 112
pValue$ = 120
pHashValue$ = 128
?addKeyValue@CDKeyHashMap@@QEAAHPEAD0PEAX1@Z PROC	; CDKeyHashMap::addKeyValue, COMDAT

; 123  : {

$LN6:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 124  : 	CHash *pHash;
; 125  : 	int nRes; // 1. key2's hashKey -> 2. nRes
; 126  : 	nRes = addKey(pKey1, pKey2, &pHash);

  00027	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00030	4c 8d 4c 24 38	 lea	 r9, QWORD PTR pHash$[rsp]
  00035	4c 8b 44 24 70	 mov	 r8, QWORD PTR pKey2$[rsp]
  0003a	48 8b 54 24 68	 mov	 rdx, QWORD PTR pKey1$[rsp]
  0003f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR this$[rsp]
  00044	e8 00 00 00 00	 call	 ?addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z ; CDKeyHashMap::addKey
  00049	89 44 24 30	 mov	 DWORD PTR nRes$[rsp], eax

; 127  : 	if (pHash) {

  0004d	48 83 7c 24 38
	00		 cmp	 QWORD PTR pHash$[rsp], 0
  00053	74 40		 je	 SHORT $LN2@addKeyValu

; 128  : 		if(pHashValue) pHash->setHashValue(pHashValue);

  00055	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR pHashValue$[rsp], 0
  0005e	74 12		 je	 SHORT $LN3@addKeyValu
  00060	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR pHashValue$[rsp]
  00068	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pHash$[rsp]
  0006d	e8 00 00 00 00	 call	 ?setHashValue@CHash@@QEAAXPEAX@Z ; CHash::setHashValue
$LN3@addKeyValu:

; 129  : 		if (nRes >= 0) {

  00072	83 7c 24 30 00	 cmp	 DWORD PTR nRes$[rsp], 0
  00077	7c 1c		 jl	 SHORT $LN4@addKeyValu

; 130  : 			nRes = pHash->setValue(nRes, pKey2, pValue);

  00079	4c 8b 4c 24 78	 mov	 r9, QWORD PTR pValue$[rsp]
  0007e	4c 8b 44 24 70	 mov	 r8, QWORD PTR pKey2$[rsp]
  00083	8b 54 24 30	 mov	 edx, DWORD PTR nRes$[rsp]
  00087	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pHash$[rsp]
  0008c	e8 00 00 00 00	 call	 ?setValue@CHash@@QEAA?AW4HASH_RETURN_CODE@@IPEADPEAX@Z ; CHash::setValue
  00091	89 44 24 30	 mov	 DWORD PTR nRes$[rsp], eax
$LN4@addKeyValu:
$LN2@addKeyValu:

; 131  : 		}
; 132  : 	}
; 133  : 	return nRes;

  00095	8b 44 24 30	 mov	 eax, DWORD PTR nRes$[rsp]

; 134  : }

  00099	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0009e	48 33 cc	 xor	 rcx, rsp
  000a1	e8 00 00 00 00	 call	 __security_check_cookie
  000a6	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000aa	c3		 ret	 0
?addKeyValue@CDKeyHashMap@@QEAAHPEAD0PEAX1@Z ENDP	; CDKeyHashMap::addKeyValue
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comdualkeyhash.cpp
;	COMDAT ?addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z
_TEXT	SEGMENT
tv144 = 64
tv187 = 65
nRes1$ = 68
nRes2$ = 72
pBuf$ = 80
pHash$ = 88
pNext$ = 96
tv224 = 104
tv142 = 112
tv213 = 120
tv185 = 128
tv141 = 136
tv184 = 144
pNode$ = 152
$T1 = 160
tv95 = 168
$T2 = 176
tv223 = 184
tv212 = 192
$T3 = 200
tv143 = 208
tv186 = 216
this$ = 240
pKey1$ = 248
pKey2$ = 256
pTarget$ = 264
pHashValue$ = 272
?addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z PROC ; CDKeyHashMap::addKey, COMDAT

; 75   : {

$LN22:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0001b	48 c7 84 24 c8
	00 00 00 fe ff
	ff ff		 mov	 QWORD PTR $T3[rsp], -2

; 76   : 	SThash_next *pNext;
; 77   : 	CHash *pHash;
; 78   : 	TCHAR *pBuf;
; 79   : 	int nRes1=0, nRes2=0;

  00027	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR nRes1$[rsp], 0
  0002f	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR nRes2$[rsp], 0

; 80   : 
; 81   : 
; 82   : 	STHash_Node *pNode = m_pHashGroup->hashLookup(pKey1);

  00037	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR pKey1$[rsp]
  0003f	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00047	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0004b	e8 00 00 00 00	 call	 ?hashLookup@CHash@@QEAAPEAUSTHash_Node@@PEAD@Z ; CHash::hashLookup
  00050	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR pNode$[rsp], rax

; 83   : 	if (pNode) {

  00058	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR pNode$[rsp], 0
  00061	74 7b		 je	 SHORT $LN2@addKey

; 84   : 		pHash = (CHash *)pNode->value;

  00063	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pNode$[rsp]
  0006b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0006f	48 89 44 24 58	 mov	 QWORD PTR pHash$[rsp], rax

; 85   : 		if (pHash->hashLookup(pKey2)) {

  00074	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR pKey2$[rsp]
  0007c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pHash$[rsp]
  00081	e8 00 00 00 00	 call	 ?hashLookup@CHash@@QEAAPEAUSTHash_Node@@PEAD@Z ; CHash::hashLookup
  00086	48 85 c0	 test	 rax, rax
  00089	74 4e		 je	 SHORT $LN4@addKey

; 86   : 			gs_cLogger.DebugLog(LEVEL_ERROR, "DUPLICATE_KEYS pKey1[%s] pHash->hashLookup(pKey2[%s])", pKey1, pKey2);

  0008b	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR pKey2$[rsp]
  00093	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00098	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR pKey1$[rsp]
  000a0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000a5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG44991
  000ac	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b1	41 b9 56 00 00
	00		 mov	 r9d, 86			; 00000056H
  000b7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG44992
  000be	ba 05 00 00 00	 mov	 edx, 5
  000c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  000ca	e8 00 00 00 00	 call	 ?__debugLog@CLogger@@QEAAXHPEBDH0ZZ ; CLogger::__debugLog

; 87   : 			return eHASH_RESULT_DUPLICATE_KEYS;

  000cf	b8 ff ff ff ff	 mov	 eax, -1
  000d4	e9 b1 03 00 00	 jmp	 $LN1@addKey
$LN4@addKey:

; 88   : 		}
; 89   : 	}
; 90   : 	else {

  000d9	e9 24 02 00 00	 jmp	 $LN3@addKey
$LN2@addKey:

; 91   : 		pHash = new (std::nothrow)CHash(m_nMaxCount2);					// key1  value  

  000de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  000e5	b9 18 00 00 00	 mov	 ecx, 24
  000ea	e8 00 00 00 00	 call	 ??2@YAPEAX_KAEBUnothrow_t@std@@@Z ; operator new
  000ef	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR $T1[rsp], rax
  000f7	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR $T1[rsp], 0
  00100	74 22		 je	 SHORT $LN15@addKey
  00102	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0010a	8b 50 1c	 mov	 edx, DWORD PTR [rax+28]
  0010d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR $T1[rsp]
  00115	e8 00 00 00 00	 call	 ??0CHash@@QEAA@I@Z	; CHash::CHash
  0011a	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv95[rsp], rax
  00122	eb 0c		 jmp	 SHORT $LN16@addKey
$LN15@addKey:
  00124	48 c7 84 24 a8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv95[rsp], 0
$LN16@addKey:
  00130	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR tv95[rsp]
  00138	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR $T2[rsp], rax
  00140	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR $T2[rsp]
  00148	48 89 44 24 58	 mov	 QWORD PTR pHash$[rsp], rax

; 92   : 		if (!pHash) return eHASH_RESULT_FAIL_ALLOCATION;

  0014d	48 83 7c 24 58
	00		 cmp	 QWORD PTR pHash$[rsp], 0
  00153	75 0a		 jne	 SHORT $LN5@addKey
  00155	b8 fb ff ff ff	 mov	 eax, -5
  0015a	e9 2b 03 00 00	 jmp	 $LN1@addKey
$LN5@addKey:

; 93   : 		pNext = m_pHashNext->newMem();						// key1,value,next  node 

  0015f	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00167	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0016a	e8 00 00 00 00	 call	 ?newMem@?$CBMemPool@USThash_next@@@@QEAAPEAUSThash_next@@XZ ; CBMemPool<SThash_next>::newMem
  0016f	48 89 44 24 60	 mov	 QWORD PTR pNext$[rsp], rax

; 94   : 		if(!pNext) return eHASH_RESULT_FAIL_ALLOCATION;

  00174	48 83 7c 24 60
	00		 cmp	 QWORD PTR pNext$[rsp], 0
  0017a	75 0a		 jne	 SHORT $LN6@addKey
  0017c	b8 fb ff ff ff	 mov	 eax, -5
  00181	e9 04 03 00 00	 jmp	 $LN1@addKey
$LN6@addKey:

; 95   : 		pBuf = (TCHAR*)gs_pMMgr->newBuf(STRING_SIZE(pKey1));				// key1  

  00186	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR pKey1$[rsp]
  0018e	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv223[rsp], rax
  00196	48 c7 44 24 68
	ff ff ff ff	 mov	 QWORD PTR tv224[rsp], -1
$LL21@addKey:
  0019f	48 ff 44 24 68	 inc	 QWORD PTR tv224[rsp]
  001a4	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR tv223[rsp]
  001ac	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv224[rsp]
  001b1	80 3c 08 00	 cmp	 BYTE PTR [rax+rcx], 0
  001b5	75 e8		 jne	 SHORT $LL21@addKey
  001b7	48 8b 44 24 68	 mov	 rax, QWORD PTR tv224[rsp]
  001bc	48 ff c0	 inc	 rax
  001bf	8b d0		 mov	 edx, eax
  001c1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  001c8	e8 00 00 00 00	 call	 ?newBuf@CMemManager@@QEAAPEADH@Z ; CMemManager::newBuf
  001cd	48 89 44 24 50	 mov	 QWORD PTR pBuf$[rsp], rax

; 96   : 		if(!pBuf) return eHASH_RESULT_FAIL_ALLOCATION;

  001d2	48 83 7c 24 50
	00		 cmp	 QWORD PTR pBuf$[rsp], 0
  001d8	75 0a		 jne	 SHORT $LN7@addKey
  001da	b8 fb ff ff ff	 mov	 eax, -5
  001df	e9 a6 02 00 00	 jmp	 $LN1@addKey
$LN7@addKey:

; 97   : 		_tcscpy(pBuf, pKey1);

  001e4	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR pKey1$[rsp]
  001ec	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv141[rsp], rax
  001f4	48 8b 44 24 50	 mov	 rax, QWORD PTR pBuf$[rsp]
  001f9	48 89 44 24 70	 mov	 QWORD PTR tv142[rsp], rax
  001fe	48 8b 44 24 70	 mov	 rax, QWORD PTR tv142[rsp]
  00203	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv143[rsp], rax
$LN17@addKey:
  0020b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR tv141[rsp]
  00213	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00216	88 44 24 40	 mov	 BYTE PTR tv144[rsp], al
  0021a	48 8b 44 24 70	 mov	 rax, QWORD PTR tv142[rsp]
  0021f	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR tv144[rsp]
  00224	88 08		 mov	 BYTE PTR [rax], cl
  00226	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR tv141[rsp]
  0022e	48 ff c0	 inc	 rax
  00231	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv141[rsp], rax
  00239	48 8b 44 24 70	 mov	 rax, QWORD PTR tv142[rsp]
  0023e	48 ff c0	 inc	 rax
  00241	48 89 44 24 70	 mov	 QWORD PTR tv142[rsp], rax
  00246	80 7c 24 40 00	 cmp	 BYTE PTR tv144[rsp], 0
  0024b	75 be		 jne	 SHORT $LN17@addKey

; 98   : 		nRes1 = m_pHashGroup->addNode(pNext, pBuf, (void *)pHash);	// 1  

  0024d	4c 8b 4c 24 58	 mov	 r9, QWORD PTR pHash$[rsp]
  00252	4c 8b 44 24 50	 mov	 r8, QWORD PTR pBuf$[rsp]
  00257	48 8b 54 24 60	 mov	 rdx, QWORD PTR pNext$[rsp]
  0025c	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00264	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00268	e8 00 00 00 00	 call	 ?addNode@CHash@@QEAAHPEAUSThash_next@@PEADPEAX@Z ; CHash::addNode
  0026d	89 44 24 44	 mov	 DWORD PTR nRes1$[rsp], eax

; 99   : 		if (nRes1 < 0) {

  00271	83 7c 24 44 00	 cmp	 DWORD PTR nRes1$[rsp], 0
  00276	7d 54		 jge	 SHORT $LN8@addKey

; 100  : 			gs_cLogger.DebugLog(LEVEL_ERROR, "errorNo[%d] new CHash(max:%d) key1:%s", nRes1, m_nMaxCount2, pBuf);

  00278	48 8b 44 24 50	 mov	 rax, QWORD PTR pBuf$[rsp]
  0027d	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00282	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0028a	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  0028d	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00291	8b 44 24 44	 mov	 eax, DWORD PTR nRes1$[rsp]
  00295	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00299	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG44998
  002a0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002a5	41 b9 64 00 00
	00		 mov	 r9d, 100		; 00000064H
  002ab	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG44999
  002b2	ba 05 00 00 00	 mov	 edx, 5
  002b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  002be	e8 00 00 00 00	 call	 ?__debugLog@CLogger@@QEAAXHPEBDH0ZZ ; CLogger::__debugLog

; 101  : 			return nRes1;

  002c3	8b 44 24 44	 mov	 eax, DWORD PTR nRes1$[rsp]
  002c7	e9 be 01 00 00	 jmp	 $LN1@addKey
$LN8@addKey:

; 102  : 		}
; 103  : 		gs_cLogger.PutLogQueue(LEVEL_DEBUG, _T("new CHash(max:%d) key1:%s hashNo[%d]"), m_nMaxCount2, pBuf, nRes1);

  002cc	8b 44 24 44	 mov	 eax, DWORD PTR nRes1$[rsp]
  002d0	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  002d4	48 8b 44 24 50	 mov	 rax, QWORD PTR pBuf$[rsp]
  002d9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002de	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  002e6	44 8b 48 1c	 mov	 r9d, DWORD PTR [rax+28]
  002ea	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG45000
  002f1	ba 01 00 00 00	 mov	 edx, 1
  002f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  002fd	e8 00 00 00 00	 call	 ?PutLogQueue@CLogger@@QEAAXHPEBDZZ ; CLogger::PutLogQueue
$LN3@addKey:

; 104  : 	}
; 105  : 
; 106  : 	pNext = m_pHashNext->newMem();						// key2, value, next  node 

  00302	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0030a	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0030d	e8 00 00 00 00	 call	 ?newMem@?$CBMemPool@USThash_next@@@@QEAAPEAUSThash_next@@XZ ; CBMemPool<SThash_next>::newMem
  00312	48 89 44 24 60	 mov	 QWORD PTR pNext$[rsp], rax

; 107  : 	if (!pNext) return eHASH_RESULT_FAIL_ALLOCATION;

  00317	48 83 7c 24 60
	00		 cmp	 QWORD PTR pNext$[rsp], 0
  0031d	75 0a		 jne	 SHORT $LN9@addKey
  0031f	b8 fb ff ff ff	 mov	 eax, -5
  00324	e9 61 01 00 00	 jmp	 $LN1@addKey
$LN9@addKey:

; 108  : 	pBuf = (TCHAR*)gs_pMMgr->newBuf(STRING_SIZE(pKey2));				// key2  

  00329	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR pKey2$[rsp]
  00331	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv212[rsp], rax
  00339	48 c7 44 24 78
	ff ff ff ff	 mov	 QWORD PTR tv213[rsp], -1
$LL20@addKey:
  00342	48 ff 44 24 78	 inc	 QWORD PTR tv213[rsp]
  00347	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tv212[rsp]
  0034f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv213[rsp]
  00354	80 3c 08 00	 cmp	 BYTE PTR [rax+rcx], 0
  00358	75 e8		 jne	 SHORT $LL20@addKey
  0035a	48 8b 44 24 78	 mov	 rax, QWORD PTR tv213[rsp]
  0035f	48 ff c0	 inc	 rax
  00362	8b d0		 mov	 edx, eax
  00364	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  0036b	e8 00 00 00 00	 call	 ?newBuf@CMemManager@@QEAAPEADH@Z ; CMemManager::newBuf
  00370	48 89 44 24 50	 mov	 QWORD PTR pBuf$[rsp], rax

; 109  : 	if (!pBuf) return eHASH_RESULT_FAIL_ALLOCATION;

  00375	48 83 7c 24 50
	00		 cmp	 QWORD PTR pBuf$[rsp], 0
  0037b	75 0a		 jne	 SHORT $LN10@addKey
  0037d	b8 fb ff ff ff	 mov	 eax, -5
  00382	e9 03 01 00 00	 jmp	 $LN1@addKey
$LN10@addKey:

; 110  : 	_tcscpy(pBuf, pKey2);

  00387	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR pKey2$[rsp]
  0038f	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv184[rsp], rax
  00397	48 8b 44 24 50	 mov	 rax, QWORD PTR pBuf$[rsp]
  0039c	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv185[rsp], rax
  003a4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv185[rsp]
  003ac	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv186[rsp], rax
$LN18@addKey:
  003b4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tv184[rsp]
  003bc	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  003bf	88 44 24 41	 mov	 BYTE PTR tv187[rsp], al
  003c3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv185[rsp]
  003cb	0f b6 4c 24 41	 movzx	 ecx, BYTE PTR tv187[rsp]
  003d0	88 08		 mov	 BYTE PTR [rax], cl
  003d2	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tv184[rsp]
  003da	48 ff c0	 inc	 rax
  003dd	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv184[rsp], rax
  003e5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv185[rsp]
  003ed	48 ff c0	 inc	 rax
  003f0	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv185[rsp], rax
  003f8	80 7c 24 41 00	 cmp	 BYTE PTR tv187[rsp], 0
  003fd	75 b5		 jne	 SHORT $LN18@addKey

; 111  : 	if (pHashValue) pHash->setHashValue(pHashValue);

  003ff	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR pHashValue$[rsp], 0
  00408	74 12		 je	 SHORT $LN11@addKey
  0040a	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR pHashValue$[rsp]
  00412	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pHash$[rsp]
  00417	e8 00 00 00 00	 call	 ?setHashValue@CHash@@QEAAXPEAX@Z ; CHash::setHashValue
$LN11@addKey:

; 112  : 	if(pTarget) *pTarget = pHash;

  0041c	48 83 bc 24 08
	01 00 00 00	 cmp	 QWORD PTR pTarget$[rsp], 0
  00425	74 10		 je	 SHORT $LN12@addKey
  00427	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR pTarget$[rsp]
  0042f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pHash$[rsp]
  00434	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN12@addKey:

; 113  : 	// 2   (key2  value   )
; 114  : 	nRes2 = pHash->addNode(pNext, pBuf); // 2   (key2  value   )

  00437	45 33 c9	 xor	 r9d, r9d
  0043a	4c 8b 44 24 50	 mov	 r8, QWORD PTR pBuf$[rsp]
  0043f	48 8b 54 24 60	 mov	 rdx, QWORD PTR pNext$[rsp]
  00444	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pHash$[rsp]
  00449	e8 00 00 00 00	 call	 ?addNode@CHash@@QEAAHPEAUSThash_next@@PEADPEAX@Z ; CHash::addNode
  0044e	89 44 24 48	 mov	 DWORD PTR nRes2$[rsp], eax

; 115  : 	if (nRes2 < 0) {

  00452	83 7c 24 48 00	 cmp	 DWORD PTR nRes2$[rsp], 0
  00457	7d 2d		 jge	 SHORT $LN13@addKey

; 116  : 		gs_cLogger.PutQueue(LEVEL_ERROR, "errorNo[%d] pHash->addNode(pNext, %s)", nRes2, pBuf);

  00459	48 8b 44 24 50	 mov	 rax, QWORD PTR pBuf$[rsp]
  0045e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00463	44 8b 4c 24 48	 mov	 r9d, DWORD PTR nRes2$[rsp]
  00468	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG45006
  0046f	ba 05 00 00 00	 mov	 edx, 5
  00474	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  0047b	e8 00 00 00 00	 call	 ?PutLogQueue@CLogger@@QEAAXHPEBDZZ ; CLogger::PutLogQueue

; 117  : 		return nRes2;

  00480	8b 44 24 48	 mov	 eax, DWORD PTR nRes2$[rsp]
  00484	eb 04		 jmp	 SHORT $LN1@addKey
$LN13@addKey:

; 118  : 	}
; 119  : 	return nRes2;

  00486	8b 44 24 48	 mov	 eax, DWORD PTR nRes2$[rsp]
$LN1@addKey:

; 120  : }

  0048a	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  00491	c3		 ret	 0
?addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z ENDP ; CDKeyHashMap::addKey
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
tv144 = 64
tv187 = 65
nRes1$ = 68
nRes2$ = 72
pBuf$ = 80
pHash$ = 88
pNext$ = 96
tv224 = 104
tv142 = 112
tv213 = 120
tv185 = 128
tv141 = 136
tv184 = 144
pNode$ = 152
$T1 = 160
tv95 = 168
$T2 = 176
tv223 = 184
tv212 = 192
$T3 = 200
tv143 = 208
tv186 = 216
this$ = 240
pKey1$ = 248
pKey2$ = 256
pTarget$ = 264
pHashValue$ = 272
?dtor$0@?0??addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z@4HA PROC ; `CDKeyHashMap::addKey'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00010	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR $T1[rbp]
  00017	e8 00 00 00 00	 call	 ??3@YAXPEAXAEBUnothrow_t@std@@@Z ; operator delete
  0001c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00020	5d		 pop	 rbp
  00021	c3		 ret	 0
?dtor$0@?0??addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z@4HA ENDP ; `CDKeyHashMap::addKey'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv144 = 64
tv187 = 65
nRes1$ = 68
nRes2$ = 72
pBuf$ = 80
pHash$ = 88
pNext$ = 96
tv224 = 104
tv142 = 112
tv213 = 120
tv185 = 128
tv141 = 136
tv184 = 144
pNode$ = 152
$T1 = 160
tv95 = 168
$T2 = 176
tv223 = 184
tv212 = 192
$T3 = 200
tv143 = 208
tv186 = 216
this$ = 240
pKey1$ = 248
pKey2$ = 256
pTarget$ = 264
pHashValue$ = 272
?dtor$0@?0??addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z@4HA PROC ; `CDKeyHashMap::addKey'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00010	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR $T1[rbp]
  00017	e8 00 00 00 00	 call	 ??3@YAXPEAXAEBUnothrow_t@std@@@Z ; operator delete
  0001c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00020	5d		 pop	 rbp
  00021	c3		 ret	 0
?dtor$0@?0??addKey@CDKeyHashMap@@QEAAHPEAD0PEAPEAVCHash@@PEAX@Z@4HA ENDP ; `CDKeyHashMap::addKey'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comdualkeyhash.cpp
;	COMDAT ??1CDKeyHashMap@@QEAA@XZ
_TEXT	SEGMENT
i$ = 32
j$ = 36
pNext2$ = 40
pNext1$ = 48
tv186 = 56
tv179 = 64
pDelNode$ = 72
pHash$ = 80
$T1 = 88
$T2 = 96
$T3 = 104
$T4 = 112
tv185 = 120
tv178 = 128
$T5 = 136
tv150 = 144
$T6 = 152
tv160 = 160
$T7 = 168
tv166 = 176
$T8 = 184
tv172 = 192
$T9 = 200
this$ = 224
??1CDKeyHashMap@@QEAA@XZ PROC				; CDKeyHashMap::~CDKeyHashMap, COMDAT

; 37   : {

$LN24:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  0000c	48 c7 84 24 c8
	00 00 00 fe ff
	ff ff		 mov	 QWORD PTR $T9[rsp], -2

; 38   : 	SThash_next *pNext1, *pNext2, *pDelNode;
; 39   : 	CHash *pHash;
; 40   : 	unsigned int i,j;
; 41   : 	
; 42   : 	//      ,       . OS    .
; 43   : 	//                     .
; 44   : 	//              .
; 45   : 	for (i = 0; i < m_nMaxCount1; i++) {

  00018	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00020	eb 0a		 jmp	 SHORT $LN4@CDKeyHashM
$LN2@CDKeyHashM:
  00022	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00026	ff c0		 inc	 eax
  00028	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@CDKeyHashM:
  0002c	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00034	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00037	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0003b	0f 83 f9 01 00
	00		 jae	 $LN3@CDKeyHashM

; 46   : 		pNext1 = m_pHashGroup->getNext(i);

  00041	8b 54 24 20	 mov	 edx, DWORD PTR i$[rsp]
  00045	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0004d	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00051	e8 00 00 00 00	 call	 ?getNext@CHash@@QEAAPEAUSThash_next@@I@Z ; CHash::getNext
  00056	90		 npad	 1
  00057	48 89 44 24 30	 mov	 QWORD PTR pNext1$[rsp], rax
$LN5@CDKeyHashM:

; 47   : 		while (pNext1) {

  0005c	48 83 7c 24 30
	00		 cmp	 QWORD PTR pNext1$[rsp], 0
  00062	0f 84 cd 01 00
	00		 je	 $LN6@CDKeyHashM

; 48   : 			pHash = (CHash *)pNext1->pNode.value;

  00068	48 8b 44 24 30	 mov	 rax, QWORD PTR pNext1$[rsp]
  0006d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00071	48 89 44 24 50	 mov	 QWORD PTR pHash$[rsp], rax

; 49   : 			for (j = 0; j < m_nMaxCount2; j++) {

  00076	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  0007e	eb 0a		 jmp	 SHORT $LN9@CDKeyHashM
$LN7@CDKeyHashM:
  00080	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  00084	ff c0		 inc	 eax
  00086	89 44 24 24	 mov	 DWORD PTR j$[rsp], eax
$LN9@CDKeyHashM:
  0008a	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00092	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00095	39 44 24 24	 cmp	 DWORD PTR j$[rsp], eax
  00099	0f 83 ca 00 00
	00		 jae	 $LN8@CDKeyHashM

; 50   : 				pNext2 = pHash->getNext(j);

  0009f	8b 54 24 24	 mov	 edx, DWORD PTR j$[rsp]
  000a3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pHash$[rsp]
  000a8	e8 00 00 00 00	 call	 ?getNext@CHash@@QEAAPEAUSThash_next@@I@Z ; CHash::getNext
  000ad	90		 npad	 1
  000ae	48 89 44 24 28	 mov	 QWORD PTR pNext2$[rsp], rax
$LN10@CDKeyHashM:

; 51   : 				while (pNext2) {

  000b3	48 83 7c 24 28
	00		 cmp	 QWORD PTR pNext2$[rsp], 0
  000b9	0f 84 a5 00 00
	00		 je	 $LN11@CDKeyHashM

; 52   : 					gs_pMMgr->delBuf(pNext2->pNode.pKey, STRING_SIZE(pNext2->pNode.pKey));	// key2  

  000bf	48 8b 44 24 28	 mov	 rax, QWORD PTR pNext2$[rsp]
  000c4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000c7	48 89 44 24 78	 mov	 QWORD PTR tv185[rsp], rax
  000cc	48 c7 44 24 38
	ff ff ff ff	 mov	 QWORD PTR tv186[rsp], -1
$LL23@CDKeyHashM:
  000d5	48 ff 44 24 38	 inc	 QWORD PTR tv186[rsp]
  000da	48 8b 44 24 78	 mov	 rax, QWORD PTR tv185[rsp]
  000df	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv186[rsp]
  000e4	80 3c 08 00	 cmp	 BYTE PTR [rax+rcx], 0
  000e8	75 eb		 jne	 SHORT $LL23@CDKeyHashM
  000ea	48 8b 44 24 38	 mov	 rax, QWORD PTR tv186[rsp]
  000ef	48 ff c0	 inc	 rax
  000f2	44 8b c0	 mov	 r8d, eax
  000f5	48 8b 44 24 28	 mov	 rax, QWORD PTR pNext2$[rsp]
  000fa	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  000fd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  00104	e8 00 00 00 00	 call	 ?delBuf@CMemManager@@QEAAXPEADH@Z ; CMemManager::delBuf
  00109	90		 npad	 1

; 53   : 					if(m_bValInternal)delValueBuf((STValue *)pNext2->pNode.value);					// key2  value  

  0010a	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00112	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  00116	85 c0		 test	 eax, eax
  00118	74 17		 je	 SHORT $LN12@CDKeyHashM
  0011a	48 8b 44 24 28	 mov	 rax, QWORD PTR pNext2$[rsp]
  0011f	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00123	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR this$[rsp]
  0012b	e8 00 00 00 00	 call	 ?delValueBuf@CDKeyHashMap@@QEAAXPEAUSTValue@@@Z ; CDKeyHashMap::delValueBuf
  00130	90		 npad	 1
$LN12@CDKeyHashM:

; 54   : 					pDelNode = pNext2;

  00131	48 8b 44 24 28	 mov	 rax, QWORD PTR pNext2$[rsp]
  00136	48 89 44 24 48	 mov	 QWORD PTR pDelNode$[rsp], rax

; 55   : 					pNext2 = pNext2->next;

  0013b	48 8b 44 24 28	 mov	 rax, QWORD PTR pNext2$[rsp]
  00140	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00144	48 89 44 24 28	 mov	 QWORD PTR pNext2$[rsp], rax

; 56   : 					m_pHashNext->delMem(pDelNode);												// key2,value,next  node 

  00149	48 8b 54 24 48	 mov	 rdx, QWORD PTR pDelNode$[rsp]
  0014e	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00156	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00159	e8 00 00 00 00	 call	 ?delMem@?$CBMemPool@USThash_next@@@@QEAA_NPEAUSThash_next@@@Z ; CBMemPool<SThash_next>::delMem
  0015e	90		 npad	 1

; 57   : 				}

  0015f	e9 4f ff ff ff	 jmp	 $LN10@CDKeyHashM
$LN11@CDKeyHashM:

; 58   : 			}

  00164	e9 17 ff ff ff	 jmp	 $LN7@CDKeyHashM
$LN8@CDKeyHashM:

; 59   : 			gs_pMMgr->delBuf(pNext1->pNode.pKey, STRING_SIZE(pNext1->pNode.pKey));	// key1  

  00169	48 8b 44 24 30	 mov	 rax, QWORD PTR pNext1$[rsp]
  0016e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00171	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv178[rsp], rax
  00179	48 c7 44 24 40
	ff ff ff ff	 mov	 QWORD PTR tv179[rsp], -1
$LL22@CDKeyHashM:
  00182	48 ff 44 24 40	 inc	 QWORD PTR tv179[rsp]
  00187	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv178[rsp]
  0018f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv179[rsp]
  00194	80 3c 08 00	 cmp	 BYTE PTR [rax+rcx], 0
  00198	75 e8		 jne	 SHORT $LL22@CDKeyHashM
  0019a	48 8b 44 24 40	 mov	 rax, QWORD PTR tv179[rsp]
  0019f	48 ff c0	 inc	 rax
  001a2	44 8b c0	 mov	 r8d, eax
  001a5	48 8b 44 24 30	 mov	 rax, QWORD PTR pNext1$[rsp]
  001aa	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  001ad	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  001b4	e8 00 00 00 00	 call	 ?delBuf@CMemManager@@QEAAXPEADH@Z ; CMemManager::delBuf
  001b9	90		 npad	 1

; 60   : 			delete pHash;																	// key1  value  

  001ba	48 8b 44 24 50	 mov	 rax, QWORD PTR pHash$[rsp]
  001bf	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR $T5[rsp], rax
  001c7	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR $T5[rsp]
  001cf	48 89 44 24 58	 mov	 QWORD PTR $T1[rsp], rax
  001d4	48 83 7c 24 58
	00		 cmp	 QWORD PTR $T1[rsp], 0
  001da	74 1a		 je	 SHORT $LN14@CDKeyHashM
  001dc	ba 01 00 00 00	 mov	 edx, 1
  001e1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR $T1[rsp]
  001e6	e8 00 00 00 00	 call	 ??_GCHash@@QEAAPEAXI@Z
  001eb	90		 npad	 1
  001ec	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv150[rsp], rax
  001f4	eb 0c		 jmp	 SHORT $LN15@CDKeyHashM
$LN14@CDKeyHashM:
  001f6	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv150[rsp], 0
$LN15@CDKeyHashM:

; 61   : 			pDelNode = pNext1;

  00202	48 8b 44 24 30	 mov	 rax, QWORD PTR pNext1$[rsp]
  00207	48 89 44 24 48	 mov	 QWORD PTR pDelNode$[rsp], rax

; 62   : 			pNext1 = pNext1->next;

  0020c	48 8b 44 24 30	 mov	 rax, QWORD PTR pNext1$[rsp]
  00211	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00215	48 89 44 24 30	 mov	 QWORD PTR pNext1$[rsp], rax

; 63   : 			m_pHashNext->delMem(pDelNode);												// key1,value,next  node 

  0021a	48 8b 54 24 48	 mov	 rdx, QWORD PTR pDelNode$[rsp]
  0021f	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00227	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0022a	e8 00 00 00 00	 call	 ?delMem@?$CBMemPool@USThash_next@@@@QEAA_NPEAUSThash_next@@@Z ; CBMemPool<SThash_next>::delMem
  0022f	90		 npad	 1

; 64   : 		}

  00230	e9 27 fe ff ff	 jmp	 $LN5@CDKeyHashM
$LN6@CDKeyHashM:

; 65   : 	}

  00235	e9 e8 fd ff ff	 jmp	 $LN2@CDKeyHashM
$LN3@CDKeyHashM:

; 66   : 
; 67   : 	//        .
; 68   : 	delete m_pValue;

  0023a	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00242	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00246	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR $T6[rsp], rax
  0024e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR $T6[rsp]
  00256	48 89 44 24 60	 mov	 QWORD PTR $T2[rsp], rax
  0025b	48 83 7c 24 60
	00		 cmp	 QWORD PTR $T2[rsp], 0
  00261	74 1a		 je	 SHORT $LN16@CDKeyHashM
  00263	ba 01 00 00 00	 mov	 edx, 1
  00268	48 8b 4c 24 60	 mov	 rcx, QWORD PTR $T2[rsp]
  0026d	e8 00 00 00 00	 call	 ??_G?$CBMemPool@USTValue@@@@QEAAPEAXI@Z
  00272	90		 npad	 1
  00273	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv160[rsp], rax
  0027b	eb 0c		 jmp	 SHORT $LN17@CDKeyHashM
$LN16@CDKeyHashM:
  0027d	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv160[rsp], 0
$LN17@CDKeyHashM:

; 69   : 	delete m_pHashNext;

  00289	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00291	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00294	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR $T7[rsp], rax
  0029c	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR $T7[rsp]
  002a4	48 89 44 24 68	 mov	 QWORD PTR $T3[rsp], rax
  002a9	48 83 7c 24 68
	00		 cmp	 QWORD PTR $T3[rsp], 0
  002af	74 1a		 je	 SHORT $LN18@CDKeyHashM
  002b1	ba 01 00 00 00	 mov	 edx, 1
  002b6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR $T3[rsp]
  002bb	e8 00 00 00 00	 call	 ??_G?$CBMemPool@USThash_next@@@@QEAAPEAXI@Z
  002c0	90		 npad	 1
  002c1	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv166[rsp], rax
  002c9	eb 0c		 jmp	 SHORT $LN19@CDKeyHashM
$LN18@CDKeyHashM:
  002cb	48 c7 84 24 b0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv166[rsp], 0
$LN19@CDKeyHashM:

; 70   : 	delete m_pHashGroup;

  002d7	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  002df	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  002e3	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR $T8[rsp], rax
  002eb	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR $T8[rsp]
  002f3	48 89 44 24 70	 mov	 QWORD PTR $T4[rsp], rax
  002f8	48 83 7c 24 70
	00		 cmp	 QWORD PTR $T4[rsp], 0
  002fe	74 1a		 je	 SHORT $LN20@CDKeyHashM
  00300	ba 01 00 00 00	 mov	 edx, 1
  00305	48 8b 4c 24 70	 mov	 rcx, QWORD PTR $T4[rsp]
  0030a	e8 00 00 00 00	 call	 ??_GCHash@@QEAAPEAXI@Z
  0030f	90		 npad	 1
  00310	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv172[rsp], rax
  00318	eb 0c		 jmp	 SHORT $LN21@CDKeyHashM
$LN20@CDKeyHashM:
  0031a	48 c7 84 24 c0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv172[rsp], 0
$LN21@CDKeyHashM:

; 71   : }

  00326	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  0032d	c3		 ret	 0
??1CDKeyHashMap@@QEAA@XZ ENDP				; CDKeyHashMap::~CDKeyHashMap
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\src\comdualkeyhash.cpp
;	COMDAT ??0CDKeyHashMap@@QEAA@HH_N@Z
_TEXT	SEGMENT
nBasicCount$ = 32
$T1 = 40
$T2 = 48
$T3 = 56
tv81 = 64
tv133 = 72
tv180 = 80
$T4 = 88
$T5 = 96
$T6 = 104
$T7 = 112
this$ = 144
nKey1Max$ = 152
nKey2Max$ = 160
bValInternal$ = 168
??0CDKeyHashMap@@QEAA@HH_N@Z PROC			; CDKeyHashMap::CDKeyHashMap, COMDAT

; 9    : {

$LN14:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  0001a	48 c7 44 24 70
	fe ff ff ff	 mov	 QWORD PTR $T7[rsp], -2

; 10   : 	m_nMaxCount1 = nKey1Max;

  00023	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0002b	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR nKey1Max$[rsp]
  00032	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 11   : 	m_nMaxCount2 = nKey2Max;

  00035	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0003d	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR nKey2Max$[rsp]
  00044	89 48 1c	 mov	 DWORD PTR [rax+28], ecx

; 12   : 	m_pHashNext = new CBMemPool<SThash_next>(eAlloc_Type_alloc);

  00047	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0004c	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00051	48 89 44 24 28	 mov	 QWORD PTR $T1[rsp], rax
  00056	48 83 7c 24 28
	00		 cmp	 QWORD PTR $T1[rsp], 0
  0005c	74 25		 je	 SHORT $LN5@CDKeyHashM
  0005e	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00063	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T1[rsp]
  00068	e8 00 00 00 00	 call	 ?__autoclassinit2@?$CBMemPool@USThash_next@@@@QEAAX_K@Z
  0006d	ba 03 00 00 00	 mov	 edx, 3
  00072	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T1[rsp]
  00077	e8 00 00 00 00	 call	 ??0?$CBMemPool@USThash_next@@@@QEAA@W4E_ALLOC_TYPE@@@Z ; CBMemPool<SThash_next>::CBMemPool<SThash_next>
  0007c	48 89 44 24 40	 mov	 QWORD PTR tv81[rsp], rax
  00081	eb 09		 jmp	 SHORT $LN6@CDKeyHashM
$LN5@CDKeyHashM:
  00083	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv81[rsp], 0
$LN6@CDKeyHashM:
  0008c	48 8b 44 24 40	 mov	 rax, QWORD PTR tv81[rsp]
  00091	48 89 44 24 58	 mov	 QWORD PTR $T4[rsp], rax
  00096	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  0009e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR $T4[rsp]
  000a3	48 89 08	 mov	 QWORD PTR [rax], rcx

; 13   : 	m_pHashNext->alloc(nKey1Max + nKey2Max + 50);

  000a6	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR nKey1Max$[rsp]
  000ad	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR nKey2Max$[rsp]
  000b4	8d 44 08 32	 lea	 eax, DWORD PTR [rax+rcx+50]
  000b8	8b d0		 mov	 edx, eax
  000ba	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  000c2	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000c5	e8 00 00 00 00	 call	 ?alloc@?$CBMemPool@USThash_next@@@@QEAAHH@Z ; CBMemPool<SThash_next>::alloc

; 14   : 	m_pHashGroup = new CHash(nKey1Max);

  000ca	b9 18 00 00 00	 mov	 ecx, 24
  000cf	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  000d4	48 89 44 24 30	 mov	 QWORD PTR $T2[rsp], rax
  000d9	48 83 7c 24 30
	00		 cmp	 QWORD PTR $T2[rsp], 0
  000df	74 27		 je	 SHORT $LN7@CDKeyHashM
  000e1	ba 18 00 00 00	 mov	 edx, 24
  000e6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR $T2[rsp]
  000eb	e8 00 00 00 00	 call	 ?__autoclassinit2@CHash@@QEAAX_K@Z
  000f0	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR nKey1Max$[rsp]
  000f7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR $T2[rsp]
  000fc	e8 00 00 00 00	 call	 ??0CHash@@QEAA@I@Z	; CHash::CHash
  00101	48 89 44 24 48	 mov	 QWORD PTR tv133[rsp], rax
  00106	eb 09		 jmp	 SHORT $LN8@CDKeyHashM
$LN7@CDKeyHashM:
  00108	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR tv133[rsp], 0
$LN8@CDKeyHashM:
  00111	48 8b 44 24 48	 mov	 rax, QWORD PTR tv133[rsp]
  00116	48 89 44 24 60	 mov	 QWORD PTR $T5[rsp], rax
  0011b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00123	48 8b 4c 24 60	 mov	 rcx, QWORD PTR $T5[rsp]
  00128	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 15   : 
; 16   : 	int nBasicCount = nKey2Max << 1;	//(nKey2Max * 2)

  0012c	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR nKey2Max$[rsp]
  00133	d1 e0		 shl	 eax, 1
  00135	89 44 24 20	 mov	 DWORD PTR nBasicCount$[rsp], eax

; 17   : 	gs_pMMgr->init(IDX_BUF_4, nBasicCount);

  00139	44 8b 44 24 20	 mov	 r8d, DWORD PTR nBasicCount$[rsp]
  0013e	ba 02 00 00 00	 mov	 edx, 2
  00143	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  0014a	e8 00 00 00 00	 call	 ?init@CMemManager@@QEAAXW4E_IDX_BUF@@H@Z ; CMemManager::init

; 18   : 	gs_pMMgr->init(IDX_BUF_8, nBasicCount + 50);

  0014f	8b 44 24 20	 mov	 eax, DWORD PTR nBasicCount$[rsp]
  00153	83 c0 32	 add	 eax, 50			; 00000032H
  00156	44 8b c0	 mov	 r8d, eax
  00159	ba 03 00 00 00	 mov	 edx, 3
  0015e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  00165	e8 00 00 00 00	 call	 ?init@CMemManager@@QEAAXW4E_IDX_BUF@@H@Z ; CMemManager::init

; 19   : 	gs_pMMgr->init(IDX_BUF_16, nBasicCount + 50);

  0016a	8b 44 24 20	 mov	 eax, DWORD PTR nBasicCount$[rsp]
  0016e	83 c0 32	 add	 eax, 50			; 00000032H
  00171	44 8b c0	 mov	 r8d, eax
  00174	ba 04 00 00 00	 mov	 edx, 4
  00179	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  00180	e8 00 00 00 00	 call	 ?init@CMemManager@@QEAAXW4E_IDX_BUF@@H@Z ; CMemManager::init

; 20   : 	gs_pMMgr->init(IDX_BUF_32, nBasicCount + 50);

  00185	8b 44 24 20	 mov	 eax, DWORD PTR nBasicCount$[rsp]
  00189	83 c0 32	 add	 eax, 50			; 00000032H
  0018c	44 8b c0	 mov	 r8d, eax
  0018f	ba 05 00 00 00	 mov	 edx, 5
  00194	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  0019b	e8 00 00 00 00	 call	 ?init@CMemManager@@QEAAXW4E_IDX_BUF@@H@Z ; CMemManager::init

; 21   : 	gs_pMMgr->init(IDX_BUF_64, nBasicCount);

  001a0	44 8b 44 24 20	 mov	 r8d, DWORD PTR nBasicCount$[rsp]
  001a5	ba 06 00 00 00	 mov	 edx, 6
  001aa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  001b1	e8 00 00 00 00	 call	 ?init@CMemManager@@QEAAXW4E_IDX_BUF@@H@Z ; CMemManager::init

; 22   : 	gs_pMMgr->init(IDX_BUF_128, nBasicCount);

  001b6	44 8b 44 24 20	 mov	 r8d, DWORD PTR nBasicCount$[rsp]
  001bb	ba 07 00 00 00	 mov	 edx, 7
  001c0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  001c7	e8 00 00 00 00	 call	 ?init@CMemManager@@QEAAXW4E_IDX_BUF@@H@Z ; CMemManager::init

; 23   : 	gs_pMMgr->init(IDX_BUF_256, 10);

  001cc	41 b8 0a 00 00
	00		 mov	 r8d, 10
  001d2	ba 08 00 00 00	 mov	 edx, 8
  001d7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  001de	e8 00 00 00 00	 call	 ?init@CMemManager@@QEAAXW4E_IDX_BUF@@H@Z ; CMemManager::init

; 24   : 	gs_pMMgr->init(IDX_BUF_512, 10);

  001e3	41 b8 0a 00 00
	00		 mov	 r8d, 10
  001e9	ba 09 00 00 00	 mov	 edx, 9
  001ee	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?gs_pMMgr@@3PEAVCMemManager@@EA ; gs_pMMgr
  001f5	e8 00 00 00 00	 call	 ?init@CMemManager@@QEAAXW4E_IDX_BUF@@H@Z ; CMemManager::init

; 25   : 
; 26   : 	m_bValInternal = bValInternal;

  001fa	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00202	0f b6 8c 24 a8
	00 00 00	 movzx	 ecx, BYTE PTR bValInternal$[rsp]
  0020a	88 48 20	 mov	 BYTE PTR [rax+32], cl

; 27   : 
; 28   : 	if (m_bValInternal) {

  0020d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00215	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  00219	85 c0		 test	 eax, eax
  0021b	74 7f		 je	 SHORT $LN2@CDKeyHashM

; 29   : 		m_pValue = new CBMemPool<STValue>(eAlloc_Type_alloc);

  0021d	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00222	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00227	48 89 44 24 38	 mov	 QWORD PTR $T3[rsp], rax
  0022c	48 83 7c 24 38
	00		 cmp	 QWORD PTR $T3[rsp], 0
  00232	74 25		 je	 SHORT $LN9@CDKeyHashM
  00234	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00239	48 8b 4c 24 38	 mov	 rcx, QWORD PTR $T3[rsp]
  0023e	e8 00 00 00 00	 call	 ?__autoclassinit2@?$CBMemPool@USTValue@@@@QEAAX_K@Z
  00243	ba 03 00 00 00	 mov	 edx, 3
  00248	48 8b 4c 24 38	 mov	 rcx, QWORD PTR $T3[rsp]
  0024d	e8 00 00 00 00	 call	 ??0?$CBMemPool@USTValue@@@@QEAA@W4E_ALLOC_TYPE@@@Z ; CBMemPool<STValue>::CBMemPool<STValue>
  00252	48 89 44 24 50	 mov	 QWORD PTR tv180[rsp], rax
  00257	eb 09		 jmp	 SHORT $LN10@CDKeyHashM
$LN9@CDKeyHashM:
  00259	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR tv180[rsp], 0
$LN10@CDKeyHashM:
  00262	48 8b 44 24 50	 mov	 rax, QWORD PTR tv180[rsp]
  00267	48 89 44 24 68	 mov	 QWORD PTR $T6[rsp], rax
  0026c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00274	48 8b 4c 24 68	 mov	 rcx, QWORD PTR $T6[rsp]
  00279	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 30   : 		m_pValue->alloc(nKey2Max + 50);

  0027d	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR nKey2Max$[rsp]
  00284	83 c0 32	 add	 eax, 50			; 00000032H
  00287	8b d0		 mov	 edx, eax
  00289	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  00291	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00295	e8 00 00 00 00	 call	 ?alloc@?$CBMemPool@USTValue@@@@QEAAHH@Z ; CBMemPool<STValue>::alloc
  0029a	eb 10		 jmp	 SHORT $LN3@CDKeyHashM
$LN2@CDKeyHashM:

; 31   : 	}
; 32   : 	else m_pValue = NULL;

  0029c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  002a4	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
$LN3@CDKeyHashM:

; 33   : }

  002ac	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR this$[rsp]
  002b4	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  002bb	c3		 ret	 0
??0CDKeyHashMap@@QEAA@HH_N@Z ENDP			; CDKeyHashMap::CDKeyHashMap
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
nBasicCount$ = 32
$T1 = 40
$T2 = 48
$T3 = 56
tv81 = 64
tv133 = 72
tv180 = 80
$T4 = 88
$T5 = 96
$T6 = 104
$T7 = 112
this$ = 144
nKey1Max$ = 152
nKey2Max$ = 160
bValInternal$ = 168
?dtor$0@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA PROC	; `CDKeyHashMap::CDKeyHashMap'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0000e	48 8b 4d 28	 mov	 rcx, QWORD PTR $T1[rbp]
  00012	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5d		 pop	 rbp
  0001c	c3		 ret	 0
?dtor$0@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA ENDP	; `CDKeyHashMap::CDKeyHashMap'::`1'::dtor$0
nBasicCount$ = 32
$T1 = 40
$T2 = 48
$T3 = 56
tv81 = 64
tv133 = 72
tv180 = 80
$T4 = 88
$T5 = 96
$T6 = 104
$T7 = 112
this$ = 144
nKey1Max$ = 152
nKey2Max$ = 160
bValInternal$ = 168
?dtor$1@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA PROC	; `CDKeyHashMap::CDKeyHashMap'::`1'::dtor$1
  0001d	40 55		 push	 rbp
  0001f	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00023	48 8b ea	 mov	 rbp, rdx
  00026	ba 18 00 00 00	 mov	 edx, 24
  0002b	48 8b 4d 30	 mov	 rcx, QWORD PTR $T2[rbp]
  0002f	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5d		 pop	 rbp
  00039	c3		 ret	 0
?dtor$1@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA ENDP	; `CDKeyHashMap::CDKeyHashMap'::`1'::dtor$1
nBasicCount$ = 32
$T1 = 40
$T2 = 48
$T3 = 56
tv81 = 64
tv133 = 72
tv180 = 80
$T4 = 88
$T5 = 96
$T6 = 104
$T7 = 112
this$ = 144
nKey1Max$ = 152
nKey2Max$ = 160
bValInternal$ = 168
?dtor$2@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA PROC	; `CDKeyHashMap::CDKeyHashMap'::`1'::dtor$2
  0003a	40 55		 push	 rbp
  0003c	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00040	48 8b ea	 mov	 rbp, rdx
  00043	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00048	48 8b 4d 38	 mov	 rcx, QWORD PTR $T3[rbp]
  0004c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00051	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00055	5d		 pop	 rbp
  00056	c3		 ret	 0
?dtor$2@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA ENDP	; `CDKeyHashMap::CDKeyHashMap'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
nBasicCount$ = 32
$T1 = 40
$T2 = 48
$T3 = 56
tv81 = 64
tv133 = 72
tv180 = 80
$T4 = 88
$T5 = 96
$T6 = 104
$T7 = 112
this$ = 144
nKey1Max$ = 152
nKey2Max$ = 160
bValInternal$ = 168
?dtor$0@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA PROC	; `CDKeyHashMap::CDKeyHashMap'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0000e	48 8b 4d 28	 mov	 rcx, QWORD PTR $T1[rbp]
  00012	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5d		 pop	 rbp
  0001c	c3		 ret	 0
?dtor$0@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA ENDP	; `CDKeyHashMap::CDKeyHashMap'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
nBasicCount$ = 32
$T1 = 40
$T2 = 48
$T3 = 56
tv81 = 64
tv133 = 72
tv180 = 80
$T4 = 88
$T5 = 96
$T6 = 104
$T7 = 112
this$ = 144
nKey1Max$ = 152
nKey2Max$ = 160
bValInternal$ = 168
?dtor$1@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA PROC	; `CDKeyHashMap::CDKeyHashMap'::`1'::dtor$1
  0001d	40 55		 push	 rbp
  0001f	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00023	48 8b ea	 mov	 rbp, rdx
  00026	ba 18 00 00 00	 mov	 edx, 24
  0002b	48 8b 4d 30	 mov	 rcx, QWORD PTR $T2[rbp]
  0002f	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5d		 pop	 rbp
  00039	c3		 ret	 0
?dtor$1@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA ENDP	; `CDKeyHashMap::CDKeyHashMap'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
nBasicCount$ = 32
$T1 = 40
$T2 = 48
$T3 = 56
tv81 = 64
tv133 = 72
tv180 = 80
$T4 = 88
$T5 = 96
$T6 = 104
$T7 = 112
this$ = 144
nKey1Max$ = 152
nKey2Max$ = 160
bValInternal$ = 168
?dtor$2@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA PROC	; `CDKeyHashMap::CDKeyHashMap'::`1'::dtor$2
  0003a	40 55		 push	 rbp
  0003c	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00040	48 8b ea	 mov	 rbp, rdx
  00043	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00048	48 8b 4d 38	 mov	 rcx, QWORD PTR $T3[rbp]
  0004c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00051	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00055	5d		 pop	 rbp
  00056	c3		 ret	 0
?dtor$2@?0???0CDKeyHashMap@@QEAA@HH_N@Z@4HA ENDP	; `CDKeyHashMap::CDKeyHashMap'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\commemmanager.h
;	COMDAT ?delBuf@CMemManager@@QEAAXPEADH@Z
_TEXT	SEGMENT
nIdx$ = 32
this$ = 64
pBuf$ = 72
nSize$ = 80
?delBuf@CMemManager@@QEAAXPEADH@Z PROC			; CMemManager::delBuf, COMDAT

; 38   : 	inline void delBuf(char *pBuf, int nSize) { int nIdx = getIndex(nSize); delBufByIndex(pBuf, nIdx); }

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00013	8b 4c 24 50	 mov	 ecx, DWORD PTR nSize$[rsp]
  00017	e8 00 00 00 00	 call	 ?getIndex@@YAHH@Z	; getIndex
  0001c	89 44 24 20	 mov	 DWORD PTR nIdx$[rsp], eax
  00020	44 8b 44 24 20	 mov	 r8d, DWORD PTR nIdx$[rsp]
  00025	48 8b 54 24 48	 mov	 rdx, QWORD PTR pBuf$[rsp]
  0002a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0002f	e8 00 00 00 00	 call	 ?delBufByIndex@CMemManager@@QEAAXPEADH@Z ; CMemManager::delBufByIndex
  00034	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00038	c3		 ret	 0
?delBuf@CMemManager@@QEAAXPEADH@Z ENDP			; CMemManager::delBuf
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\commemmanager.h
;	COMDAT ?newBuf@CMemManager@@QEAAPEADHPEAH@Z
_TEXT	SEGMENT
this$ = 48
nSize$ = 56
pIndex$ = 64
?newBuf@CMemManager@@QEAAPEADHPEAH@Z PROC		; CMemManager::newBuf, COMDAT

; 35   : 	inline char *newBuf(int nSize, int *pIndex) { *pIndex = getIndex(nSize);  return __newBuf(*pIndex, nSize); }

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00012	8b 4c 24 38	 mov	 ecx, DWORD PTR nSize$[rsp]
  00016	e8 00 00 00 00	 call	 ?getIndex@@YAHH@Z	; getIndex
  0001b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pIndex$[rsp]
  00020	89 01		 mov	 DWORD PTR [rcx], eax
  00022	48 63 44 24 38	 movsxd	 rax, DWORD PTR nSize$[rsp]
  00027	4c 8b c0	 mov	 r8, rax
  0002a	48 8b 44 24 40	 mov	 rax, QWORD PTR pIndex$[rsp]
  0002f	8b 10		 mov	 edx, DWORD PTR [rax]
  00031	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00036	e8 00 00 00 00	 call	 ?__newBuf@CMemManager@@AEAAPEADH_K@Z ; CMemManager::__newBuf
  0003b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003f	c3		 ret	 0
?newBuf@CMemManager@@QEAAPEADHPEAH@Z ENDP		; CMemManager::newBuf
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\commemmanager.h
;	COMDAT ?newBuf@CMemManager@@QEAAPEADH@Z
_TEXT	SEGMENT
nIdx$ = 32
this$ = 64
nSize$ = 72
?newBuf@CMemManager@@QEAAPEADH@Z PROC			; CMemManager::newBuf, COMDAT

; 34   : 	inline char *newBuf(int nSize) { int nIdx = getIndex(nSize);  return __newBuf(nIdx, nSize); }

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  0000d	8b 4c 24 48	 mov	 ecx, DWORD PTR nSize$[rsp]
  00011	e8 00 00 00 00	 call	 ?getIndex@@YAHH@Z	; getIndex
  00016	89 44 24 20	 mov	 DWORD PTR nIdx$[rsp], eax
  0001a	48 63 44 24 48	 movsxd	 rax, DWORD PTR nSize$[rsp]
  0001f	4c 8b c0	 mov	 r8, rax
  00022	8b 54 24 20	 mov	 edx, DWORD PTR nIdx$[rsp]
  00026	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0002b	e8 00 00 00 00	 call	 ?__newBuf@CMemManager@@AEAAPEADH_K@Z ; CMemManager::__newBuf
  00030	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00034	c3		 ret	 0
?newBuf@CMemManager@@QEAAPEADH@Z ENDP			; CMemManager::newBuf
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\commemmanager.h
;	COMDAT ?init@CMemManager@@QEAAXW4E_IDX_BUF@@H@Z
_TEXT	SEGMENT
this$ = 8
eIdx$ = 16
nMax$ = 24
?init@CMemManager@@QEAAXW4E_IDX_BUF@@H@Z PROC		; CMemManager::init, COMDAT

; 29   : 	inline void init(E_IDX_BUF eIdx, int nMax) { m_stConfig.nMaxList[eIdx] += nMax; }

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 63 44 24 10	 movsxd	 rax, DWORD PTR eIdx$[rsp]
  00013	48 8b 4c 24 08	 mov	 rcx, QWORD PTR this$[rsp]
  00018	8b 84 81 b0 00
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+176]
  0001f	03 44 24 18	 add	 eax, DWORD PTR nMax$[rsp]
  00023	48 63 4c 24 10	 movsxd	 rcx, DWORD PTR eIdx$[rsp]
  00028	48 8b 54 24 08	 mov	 rdx, QWORD PTR this$[rsp]
  0002d	89 84 8a b0 00
	00 00		 mov	 DWORD PTR [rdx+rcx*4+176], eax
  00034	c3		 ret	 0
?init@CMemManager@@QEAAXW4E_IDX_BUF@@H@Z ENDP		; CMemManager::init
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\combufpool.h
;	COMDAT ?getIndex@@YAHH@Z
_TEXT	SEGMENT
tv73 = 0
m$ = 4
tv80 = 8
$S1$ = 16
s$ = 48
?getIndex@@YAHH@Z PROC					; getIndex, COMDAT

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

$LN5:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00008	f2 0f 2a 44 24
	30		 cvtsi2sd xmm0, DWORD PTR s$[rsp]
  0000e	f2 0f 11 44 24
	10		 movsd	 QWORD PTR $S1$[rsp], xmm0
  00014	b8 04 00 00 00	 mov	 eax, 4
  00019	48 6b c0 01	 imul	 rax, rax, 1
  0001d	8b 44 04 10	 mov	 eax, DWORD PTR $S1$[rsp+rax]
  00021	c1 f8 14	 sar	 eax, 20
  00024	2d ff 03 00 00	 sub	 eax, 1023		; 000003ffH
  00029	89 44 24 04	 mov	 DWORD PTR m$[rsp], eax
  0002d	8b 44 24 04	 mov	 eax, DWORD PTR m$[rsp]
  00031	b9 01 00 00 00	 mov	 ecx, 1
  00036	89 4c 24 08	 mov	 DWORD PTR tv80[rsp], ecx
  0003a	0f b6 c8	 movzx	 ecx, al
  0003d	8b 44 24 08	 mov	 eax, DWORD PTR tv80[rsp]
  00041	d3 e0		 shl	 eax, cl
  00043	8b 4c 24 30	 mov	 ecx, DWORD PTR s$[rsp]
  00047	2b c8		 sub	 ecx, eax
  00049	8b c1		 mov	 eax, ecx
  0004b	8b 4c 24 30	 mov	 ecx, DWORD PTR s$[rsp]
  0004f	23 c8		 and	 ecx, eax
  00051	8b c1		 mov	 eax, ecx
  00053	85 c0		 test	 eax, eax
  00055	74 09		 je	 SHORT $LN3@getIndex
  00057	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv73[rsp], 1
  0005e	eb 07		 jmp	 SHORT $LN4@getIndex
$LN3@getIndex:
  00060	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv73[rsp], 0
$LN4@getIndex:
  00067	8b 04 24	 mov	 eax, DWORD PTR tv73[rsp]
  0006a	8b 4c 24 04	 mov	 ecx, DWORD PTR m$[rsp]
  0006e	03 c8		 add	 ecx, eax
  00070	8b c1		 mov	 eax, ecx
  00072	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00076	c3		 ret	 0
?getIndex@@YAHH@Z ENDP					; getIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtypes.h
;	COMDAT ?ISINCLUDE@@YA_NHH@Z
_TEXT	SEGMENT
i$ = 8
max$ = 16
?ISINCLUDE@@YA_NHH@Z PROC				; ISINCLUDE, COMDAT

; 322  : inline bool ISINCLUDE(int i, int max) { if (0 <= i && i < max) return true; return false; }

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	83 7c 24 08 00	 cmp	 DWORD PTR i$[rsp], 0
  0000d	7c 0e		 jl	 SHORT $LN2@ISINCLUDE
  0000f	8b 44 24 10	 mov	 eax, DWORD PTR max$[rsp]
  00013	39 44 24 08	 cmp	 DWORD PTR i$[rsp], eax
  00017	7d 04		 jge	 SHORT $LN2@ISINCLUDE
  00019	b0 01		 mov	 al, 1
  0001b	eb 02		 jmp	 SHORT $LN1@ISINCLUDE
$LN2@ISINCLUDE:
  0001d	32 c0		 xor	 al, al
$LN1@ISINCLUDE:
  0001f	c3		 ret	 0
?ISINCLUDE@@YA_NHH@Z ENDP				; ISINCLUDE
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comtypes.h
;	COMDAT ?c_memcpy@@YAPEAXPEAXPEBXH@Z
_TEXT	SEGMENT
tv66 = 0
d$ = 8
s$ = 16
de$ = 48
so$ = 56
l$ = 64
?c_memcpy@@YAPEAXPEAXPEBXH@Z PROC			; c_memcpy, COMDAT

; 309  : inline void *c_memcpy(void *de, const void *so, int l) { char *d = (char*)de; const char *s = (char*)so; while (l--) *d++ = *s++; return de;}

$LN5:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR de$[rsp]
  00018	48 89 44 24 08	 mov	 QWORD PTR d$[rsp], rax
  0001d	48 8b 44 24 38	 mov	 rax, QWORD PTR so$[rsp]
  00022	48 89 44 24 10	 mov	 QWORD PTR s$[rsp], rax
$LN2@c_memcpy:
  00027	8b 44 24 40	 mov	 eax, DWORD PTR l$[rsp]
  0002b	89 04 24	 mov	 DWORD PTR tv66[rsp], eax
  0002e	8b 44 24 40	 mov	 eax, DWORD PTR l$[rsp]
  00032	ff c8		 dec	 eax
  00034	89 44 24 40	 mov	 DWORD PTR l$[rsp], eax
  00038	83 3c 24 00	 cmp	 DWORD PTR tv66[rsp], 0
  0003c	74 2b		 je	 SHORT $LN3@c_memcpy
  0003e	48 8b 44 24 08	 mov	 rax, QWORD PTR d$[rsp]
  00043	48 8b 4c 24 10	 mov	 rcx, QWORD PTR s$[rsp]
  00048	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0004b	88 08		 mov	 BYTE PTR [rax], cl
  0004d	48 8b 44 24 08	 mov	 rax, QWORD PTR d$[rsp]
  00052	48 ff c0	 inc	 rax
  00055	48 89 44 24 08	 mov	 QWORD PTR d$[rsp], rax
  0005a	48 8b 44 24 10	 mov	 rax, QWORD PTR s$[rsp]
  0005f	48 ff c0	 inc	 rax
  00062	48 89 44 24 10	 mov	 QWORD PTR s$[rsp], rax
  00067	eb be		 jmp	 SHORT $LN2@c_memcpy
$LN3@c_memcpy:
  00069	48 8b 44 24 30	 mov	 rax, QWORD PTR de$[rsp]
  0006e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00072	c3		 ret	 0
?c_memcpy@@YAPEAXPEAXPEBXH@Z ENDP			; c_memcpy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
__$ArrayPad$ = 48
_Buffer$ = 80
_Format$ = 88
sprintf	PROC						; COMDAT

; 1776 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 44 24 30	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

  00027	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
  0002c	48 8d 44 24 60	 lea	 rax, QWORD PTR _Format$[rsp+8]
  00031	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  00036	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  0003b	45 33 c0	 xor	 r8d, r8d
  0003e	48 8b 54 24 58	 mov	 rdx, QWORD PTR _Format$[rsp]
  00043	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00048	e8 00 00 00 00	 call	 _vsprintf_l
  0004d	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

  00051	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 1787 :     return _Result;

  0005a	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 1788 : }

  0005e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00063	48 33 cc	 xor	 rcx, rsp
  00066	e8 00 00 00 00	 call	 __security_check_cookie
  0006b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0006f	c3		 ret	 0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1455 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00018	48 8b 44 24 58	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00022	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  00027	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  0002c	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  00033	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00038	e8 00 00 00 00	 call	 _vsnprintf_l

; 1459 :     #pragma warning(pop)
; 1460 : }

  0003d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00041	c3		 ret	 0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1385 : {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00020	48 83 c8 01	 or	 rax, 1
  00024	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00029	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0002e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00033	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00038	4c 8b 4c 24 60	 mov	 r9, QWORD PTR _Format$[rsp]
  0003d	4c 8b 44 24 58	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  00042	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00047	48 8b c8	 mov	 rcx, rax
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsprintf
  00050	89 44 24 30	 mov	 DWORD PTR _Result$[rsp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00054	83 7c 24 30 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00059	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  0005b	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  00063	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00065	8b 44 24 30	 mov	 eax, DWORD PTR _Result$[rsp]
  00069	89 44 24 34	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  0006d	8b 44 24 34	 mov	 eax, DWORD PTR tv74[rsp]

; 1391 : }

  00071	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00075	c3		 ret	 0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ PROC ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ENDP ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GCHash@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GCHash@@QEAAPEAXI@Z PROC				; CHash::`scalar deleting destructor', COMDAT
$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00012	e8 00 00 00 00	 call	 ??1CHash@@QEAA@XZ	; CHash::~CHash
  00017	8b 44 24 38	 mov	 eax, DWORD PTR __flags$[rsp]
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 0f		 je	 SHORT $LN2@scalar
  00022	ba 18 00 00 00	 mov	 edx, 24
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0002c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN2@scalar:
  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
??_GCHash@@QEAAPEAXI@Z ENDP				; CHash::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit2@CHash@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 16
classSize$ = 24
?__autoclassinit2@CHash@@QEAAX_K@Z PROC			; CHash::__autoclassinit2, COMDAT
$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 8b 7c 24 10	 mov	 rdi, QWORD PTR this$[rsp]
  00010	33 c0		 xor	 eax, eax
  00012	48 8b 4c 24 18	 mov	 rcx, QWORD PTR classSize$[rsp]
  00017	f3 aa		 rep stosb
  00019	5f		 pop	 rdi
  0001a	c3		 ret	 0
?__autoclassinit2@CHash@@QEAAX_K@Z ENDP			; CHash::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\infinia-library-3.0\com\include\comhash.h
;	COMDAT ?setHashValue@CHash@@QEAAXPEAX@Z
_TEXT	SEGMENT
this$ = 8
p$ = 16
?setHashValue@CHash@@QEAAXPEAX@Z PROC			; CHash::setHashValue, COMDAT

; 86   : 	inline void setHashValue(void *p) { m_pHashValue = p; }

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR p$[rsp]
  00014	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
  00018	c3		 ret	 0
?setHashValue@CHash@@QEAAXPEAX@Z ENDP			; CHash::setHashValue
_TEXT	ENDS
END
