; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	E:\InfiniA-Library-3.0\com\src\comLogger.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?g_szKeepDuratrion@@3PADA			; g_szKeepDuratrion
PUBLIC	?g_szLogExtension@@3PADA			; g_szLogExtension
_DATA	SEGMENT
?g_szKeepDuratrion@@3PADA DB '15D', 00H			; g_szKeepDuratrion
	ORG $+4
?g_szLogExtension@@3PADA DB 'log', 00H			; g_szLogExtension
	ORG $+4
_DATA	ENDS
CONST	SEGMENT
?gs_fmtStr@@3QAY0M@$$CBDA DB 00H			; gs_fmtStr
	ORG $+11
	DB	'[DEBUG] ', 00H
	ORG $+3
	DB	'[TRACE] ', 00H
	ORG $+3
	DB	'[INFO] ', 00H
	ORG $+4
	DB	'[WARNING] ', 00H
	ORG $+1
	DB	'[ERROR] ', 00H
	ORG $+3
	DB	'[FATAL] ', 00H
	ORG $+3
	DB	'[ALARM] ', 00H
	ORG $+3
CONST	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_fprintf
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	_printf
PUBLIC	_sprintf
PUBLIC	?comGlobalErrorProc@@YAXPADPBDH@Z		; comGlobalErrorProc
PUBLIC	?newBuf@CMemManager@@QAEPADH@Z			; CMemManager::newBuf
PUBLIC	??0CTimeExpManager@@QAE@XZ			; CTimeExpManager::CTimeExpManager
PUBLIC	??1CTimeExpManager@@QAE@XZ			; CTimeExpManager::~CTimeExpManager
PUBLIC	?initConfig@CTimeExpManager@@QAE_NPAD@Z		; CTimeExpManager::initConfig
PUBLIC	?getDTE@CTimeExpManager@@QAEPAUSTLogDateTimeExp@@H@Z ; CTimeExpManager::getDTE
PUBLIC	??0CLogger@@QAE@XZ				; CLogger::CLogger
PUBLIC	??1CLogger@@QAE@XZ				; CLogger::~CLogger
PUBLIC	?initDefault@CLogger@@QAE_NPAD0HHH0@Z		; CLogger::initDefault
PUBLIC	?initConfig@CLogger@@QAE?AW4E_LOG_INIT_RES@@PAD0@Z ; CLogger::initConfig
PUBLIC	?OpenLogger@CLogger@@QAEXXZ			; CLogger::OpenLogger
PUBLIC	?setHeader@CLogger@@QAEHPADH@Z			; CLogger::setHeader
PUBLIC	?PutLogQueue@CLogger@@QAAXHPBDZZ		; CLogger::PutLogQueue
PUBLIC	?PutLogQueue@CLogger@@QAEXHPAD@Z		; CLogger::PutLogQueue
PUBLIC	?Log@CLogger@@QAEXHPBD00_N@Z			; CLogger::Log
PUBLIC	?LogPrint@CLogger@@QAEXPAD@Z			; CLogger::LogPrint
PUBLIC	?LogPrint@CLogger@@QAAXHPBDZZ			; CLogger::LogPrint
PUBLIC	?WritePacket@CLogger@@QAEXHHHPADH@Z		; CLogger::WritePacket
PUBLIC	?disable@CLogger@@QAEXXZ			; CLogger::disable
PUBLIC	?checkChangeProc@CLogger@@QAEXH@Z		; CLogger::checkChangeProc
PUBLIC	?__debugLog@CLogger@@QAAXHPBDH0ZZ		; CLogger::__debugLog
PUBLIC	?getString@CLogger@@QAEHPAD@Z			; CLogger::getString
PUBLIC	?_initCom@CLogger@@AAEXPAD000@Z			; CLogger::_initCom
PUBLIC	?_setHeaderFormat@CLogger@@AAE_NH@Z		; CLogger::_setHeaderFormat
PUBLIC	?_setLoggerBasic@CLogger@@AAEXHHH@Z		; CLogger::_setLoggerBasic
PUBLIC	?_setLoggerQueue@CLogger@@AAE_NH@Z		; CLogger::_setLoggerQueue
PUBLIC	?setLogName@CLogger@@AAEXPAD@Z			; CLogger::setLogName
PUBLIC	?setDateTimeFormat@CLogger@@AAEXPAUSTLogDateTimeExp@@@Z ; CLogger::setDateTimeFormat
PUBLIC	?GetKeepInfo@CLogger@@AAEHPBD@Z			; CLogger::GetKeepInfo
PUBLIC	?checkDeleteProc@CLogger@@AAEXXZ		; CLogger::checkDeleteProc
PUBLIC	?__openLogger@CLogger@@AAEXPBDH@Z		; CLogger::__openLogger
PUBLIC	?changeToAbsolutePath@@YAXPADPBD@Z		; changeToAbsolutePath
PUBLIC	?changeToAbsolutePathFile@@YAXPADPBD@Z		; changeToAbsolutePathFile
PUBLIC	?GetProfilePath@@YAHPBD00PAD0@Z			; GetProfilePath
PUBLIC	?detachFullPath@@YAXPBDPAD1@Z			; detachFullPath
PUBLIC	??$__vcrt_va_start_verify_argument_type@PBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const *>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_0BD@KEHDJCKJ@ERROR?$CB?5?$FL?$CFs?3?$CFd?$FN?5?$CFs?6?$AA@ ; `string'
PUBLIC	?gs_cLogger@@3VCLogger@@A			; gs_cLogger
PUBLIC	?gs_DTEManager@@3VCTimeExpManager@@A		; gs_DTEManager
PUBLIC	??_C@_08ECKHJDBO@LIST_MAX?$AA@			; `string'
PUBLIC	??_C@_0BE@OHGDFFFE@DATETIME_EXPRESSION?$AA@	; `string'
PUBLIC	??_C@_0BM@HEFKLFAD@CTimeExpManager?3?3initConfig?$AA@ ; `string'
PUBLIC	??_C@_0BL@BAFPIJBO@new?5CList?$CI?$CJ?5is?5NULL?$CB?7?$CFs?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0CI@PPNBAKOP@m_pTimeExpList?9?$DOalloc?5has?5Failed@ ; `string'
PUBLIC	??_C@_0BH@NELLCKCE@DATETIME_EXPRESSION_?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0BC@OCOKOBEC@IS_TIME_DELIMETER?$AA@	; `string'
PUBLIC	??_C@_0P@LDLGAHN@DATE_DELIMETER?$AA@		; `string'
PUBLIC	??_C@_0BE@BMLAJOJB@IS_BRACKET_ENCLOSED?$AA@	; `string'
PUBLIC	??_C@_09DKNFFIJD@LAST_TYPE?$AA@			; `string'
PUBLIC	??_C@_08HGGKJFPL@YEAR_LEN?$AA@			; `string'
PUBLIC	??_C@_07KLOIGNKC@TZ_TYPE?$AA@			; `string'
PUBLIC	??_C@_0BF@GMHDDGKB@CLogger?3?3initDefault?$AA@	; `string'
PUBLIC	??_C@_0N@JBKCPMI@pDir?5is?5NULL?$AA@		; `string'
PUBLIC	??_C@_0BL@JBFNJKAK@_setLoggerQueue?5has?5Failed?$AA@ ; `string'
PUBLIC	??_C@_0BM@KHAIMODA@_setHeaderFormat?5has?5Failed?$AA@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_07HFNGLEND@LOGNAME?$AA@			; `string'
PUBLIC	??_C@_0BE@BNJIBEDO@CLogger?3?3initConfig?$AA@	; `string'
PUBLIC	??_C@_0BB@FPEJDJAJ@LOGNAME?5is?5NULL?$CB?$AA@	; `string'
PUBLIC	??_C@_08DDAPLFEB@ISENABLE?$AA@			; `string'
PUBLIC	??_C@_03GGEOLGBL@Log?$AA@			; `string'
PUBLIC	??_C@_06BGFFEFJP@LOGDIR?$AA@			; `string'
PUBLIC	??_C@_09NDPCHOCH@EXTENSION?$AA@			; `string'
PUBLIC	??_C@_0O@MIEDPAKJ@KEEP_DURATION?$AA@		; `string'
PUBLIC	??_C@_0N@GIODBBCL@TIMESTEMP_NO?$AA@		; `string'
PUBLIC	??_C@_0CA@KJGNIKCD@invalid?5value?$FL?$CFd?$FN?$CB?5pSection?$FL?$CFs?$FN?$AA@ ; `string'
PUBLIC	??_C@_06OEDJMAPG@STL_NO?$AA@			; `string'
PUBLIC	??_C@_07NONFHEKD@LOGTYPE?$AA@			; `string'
PUBLIC	??_C@_0L@KBIMBJLD@SIZE_LIMIT?$AA@		; `string'
PUBLIC	??_C@_0P@KBOADAAO@IS_PRINT_LEVEL?$AA@		; `string'
PUBLIC	??_C@_08GJGBIIAH@IS_PRINT?$AA@			; `string'
PUBLIC	??_C@_08HMDDICIG@LOGLEVEL?$AA@			; `string'
PUBLIC	??_C@_0BL@IJEAKGLO@Logger?5is?5not?5Initialized?$CB?$AA@ ; `string'
PUBLIC	??_C@_0L@NKBDOFBL@TYPE_DAILY?$AA@		; `string'
PUBLIC	??_C@_0M@BDFHAMKE@TYPE_HOURLY?$AA@		; `string'
PUBLIC	??_C@_09JJHCABG@TYPE_FILE?$AA@			; `string'
PUBLIC	??_C@_0DC@OEKGBEFC@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@ ; `string'
PUBLIC	??_C@_0CK@ECACAJHH@Logger?5Path?$FL?$CFs?$FN?5Prefix?$FL?$CFs?$FN?5Exten@ ; `string'
PUBLIC	??_C@_0CP@MGGIJGGO@Logger?5SizeLimit?$FL?$CFd?$FN?5LogLevel?$FL?$CFd@ ; `string'
PUBLIC	??_C@_0CI@KBAFAHEJ@KeepDuration?5?3?5?$CF02d?5days?5?$CF02d?3?$CF0@ ; `string'
PUBLIC	??_C@_0BJ@KMFBEMJL@Logger?5KeepDuration?$FL?$CFs?$FN?6?$AA@ ; `string'
PUBLIC	??_C@_0DG@BMOIDOJO@m_sLogQueue?4alloc?$CI20?0?5eAlloc_Typ@ ; `string'
PUBLIC	??_C@_0BJ@LGANJDEJ@CLogger?3?3_setLoggerQueue?$AA@ ; `string'
PUBLIC	??_C@_0CI@NKNMCADK@m_sLogQueue?4realloc?$CI?$CFd?0true?$CJ?5has@ ; `string'
PUBLIC	??_C@_0CB@KMNIJCOL@m_pDTE?5is?5NULL?$CB?5nTimeStempNo?$FL?$CFd?$FN@ ; `string'
PUBLIC	??_C@_0BK@CNLJKEGB@CLogger?3?3_setHeaderFormat?$AA@ ; `string'
PUBLIC	??_C@_0L@KEPNNLEH@?$CFs?$CFd_?$CFs?4?$CFs?$AA@	; `string'
PUBLIC	??_C@_0BB@MEMPEKDH@?$CFs?$CFd?$CFc?$CFs_?$CF02d?4?$CFs?$AA@ ; `string'
PUBLIC	??_C@_07GFKBPOLL@?$CFs?$CFs?4?$CFs?$AA@		; `string'
PUBLIC	??_C@_04OCCELDNI@?$CF04d?$AA@			; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	??_C@_02HAOIJKIC@?$CFc?$AA@			; `string'
PUBLIC	??_C@_04OGKJMPGK@?$CF02d?$AA@			; `string'
PUBLIC	??_C@_05DIAFAFCL@?$CF02d?5?$AA@			; `string'
PUBLIC	??_C@_0P@PLMNPDMB@?$CF02d?3?$CF02d?3?$CF02d?$AA@ ; `string'
PUBLIC	??_C@_0N@NMLPILGG@?$CF02d?$CF02d?$CF02d?$AA@	; `string'
PUBLIC	??_C@_05KNCNJHKF@?4?$CF03d?$AA@			; `string'
PUBLIC	??_C@_05KLOGFFEO@?4?$CF06d?$AA@			; `string'
PUBLIC	??_C@_05KALKBCHD@?4?$CF09d?$AA@			; `string'
PUBLIC	??_C@_03EEBNCBOD@?5?$CFs?$AA@			; `string'
PUBLIC	??_C@_05NINEKCGD@?$CFs?4?$CFd?$AA@		; `string'
PUBLIC	??_C@_02DPNLHKJD@a?$CL?$AA@			; `string'
PUBLIC	??_C@_0BM@OIDAMIDF@Can?8t?5create?5log?5file?5?$FL?$CFs?$FN?6?$AA@ ; `string'
PUBLIC	??_C@_04KMMDIKEB@?5?$CFs?5?$AA@			; `string'
PUBLIC	??_C@_0CA@JGBPHLEH@?5nSIdx?$FL?$CFd?$FN?5Send?5?$FL?$CFd?$FN?5PKIdx?$FL?$CFd?$FN?5?$AA@ ; `string'
PUBLIC	??_C@_0CA@BFJJFPHN@?5nSIdx?$FL?$CFd?$FN?5Recv?5?$FL?$CFd?$FN?5PKIdx?$FL?$CFd?$FN?5?$AA@ ; `string'
PUBLIC	??_C@_0CG@LDDEIIP@?5nSIdx?$FL?$CFd?$FN?5send?5Queue?5?$FL?$CFd?$FN?5PKIdx@ ; `string'
PUBLIC	??_C@_0CG@LBNCKJLO@?5nSIdx?$FL?$CFd?$FN?5recv?5Queue?5?$FL?$CFd?$FN?5PKIdx@ ; `string'
PUBLIC	??_C@_0CE@OJOMLNHA@?5Undefind?5nkind?$FL?$CFd?$FN?5?$FL?$CFd?$FN?5PKIdx?$FL?$CF@ ; `string'
PUBLIC	??_C@_05CNDJFPDP@?$CF02x?5?$AA@			; `string'
PUBLIC	??_C@_0N@FICIEIEF@?5?$CFs?0?5?$CFd?0?5?$CFs?5?$AA@ ; `string'
PUBLIC	??_C@_0M@HBOHBIN@?$CFs?1?$CFd_?$CFs?4?$CFs?$AA@	; `string'
PUBLIC	??_C@_0BB@CKAEJDPJ@?$CFs?1?$CFd?1?$CFs_?$CF02d?4?$CFs?$AA@ ; `string'
PUBLIC	??_C@_08FIJDAHHJ@?$CFs?1?$CFd_?$CFs?$AA@	; `string'
PUBLIC	??_C@_05GFOLEBJA@?$CFs?1?$CFs?$AA@		; `string'
PUBLIC	??_C@_0BJ@CKMLCFMH@GetKeepInfo?5nStrLen?5?$DM?52?6?$AA@ ; `string'
PUBLIC	??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@		; `string'
PUBLIC	??_C@_06HCFNFKLM@?$CFs?$CFs?$CFc?$AA@		; `string'
PUBLIC	??_C@_04DJCABLIL@?$CFs?$CFc?$AA@		; `string'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	_atexit:PROC
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__imp___strdup:PROC
EXTRN	__imp___mbscmp:PROC
EXTRN	__imp___mbsnbcpy:PROC
EXTRN	__imp___mbsrchr:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fflush:PROC
EXTRN	__imp__fopen:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	__imp__GetPrivateProfileIntA@16:PROC
EXTRN	__imp__GetPrivateProfileStringA@24:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp__atoi:PROC
EXTRN	__imp___time64:PROC
EXTRN	??0CQueueS@@QAE@XZ:PROC				; CQueueS::CQueueS
EXTRN	??1CQueueS@@QAE@XZ:PROC				; CQueueS::~CQueueS
EXTRN	?alloc@CQueueS@@QAE_NHW4E_ALLOC_TYPE@@@Z:PROC	; CQueueS::alloc
EXTRN	?realloc@CQueueS@@QAE_NH_N@Z:PROC		; CQueueS::realloc
EXTRN	?push@CQueueS@@QAE_NPAX@Z:PROC			; CQueueS::push
EXTRN	??0CFileTime@@QAE@XZ:PROC			; CFileTime::CFileTime
EXTRN	??1CFileTime@@QAE@XZ:PROC			; CFileTime::~CFileTime
EXTRN	?setFileTime@CFileTime@@QAEHPA_J@Z:PROC		; CFileTime::setFileTime
EXTRN	??0CDateTime@@QAE@W4DT_TYPE@@W4TZ_TYPE@@@Z:PROC	; CDateTime::CDateTime
EXTRN	??1CDateTime@@QAE@XZ:PROC			; CDateTime::~CDateTime
EXTRN	?SetSecondsValue@CDateTime@@QAEXH@Z:PROC	; CDateTime::SetSecondsValue
EXTRN	?setString@CDateTime@@QAEHPAD0W4DT_FORMAT@@@Z:PROC ; CDateTime::setString
EXTRN	?__newBuf@CMemManager@@AAEPADHI@Z:PROC		; CMemManager::__newBuf
EXTRN	??0CSList@@QAE@XZ:PROC				; CSList::CSList
EXTRN	??1CSList@@QAE@XZ:PROC				; CSList::~CSList
EXTRN	?push_back@CSList@@QAE_NPAXPAH@Z:PROC		; CSList::push_back
EXTRN	?__alloc@CSList@@AAEHH@Z:PROC			; CSList::__alloc
EXTRN	?filter_dateTimeCompare@@YA_NPADPAX1@Z:PROC	; filter_dateTimeCompare
EXTRN	?delDirectory@CFileUtil@@SAHPAUSTDelInfo@@PAUSTFilterData@@@Z:PROC ; CFileUtil::delDirectory
EXTRN	?MakeDirectory@CFileUtil@@SA_NPBD@Z:PROC	; CFileUtil::MakeDirectory
EXTRN	?renameFile@CFileUtil@@SA_NPBD0@Z:PROC		; CFileUtil::renameFile
EXTRN	?initSystem@CEnv@@SAHPAD@Z:PROC			; CEnv::initSystem
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__chkstk:PROC
EXTRN	_memset:PROC
EXTRN	?g_pWorkDir@@3PADA:DWORD			; g_pWorkDir
EXTRN	?g_szSystemError@@3PADA:BYTE			; g_szSystemError
EXTRN	?g_szMessage@@3PADA:BYTE			; g_szMessage
EXTRN	?gs_pMMgr@@3PAVCMemManager@@A:DWORD		; gs_pMMgr
EXTRN	?gs_today_time@@3USTTodayTime@@A:BYTE		; gs_today_time
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
?gs_cLogger@@3VCLogger@@A DB 0d8H DUP (?)		; gs_cLogger
?gs_DTEManager@@3VCTimeExpManager@@A DD 01H DUP (?)	; gs_DTEManager
_BSS	ENDS
CRT$XCU	SEGMENT
?gs_cLogger$initializer$@@3P6AXXZA DD FLAT:??__Egs_cLogger@@YAXXZ ; gs_cLogger$initializer$
CRT$XCU	ENDS
;	COMDAT ??_C@_04DJCABLIL@?$CFs?$CFc?$AA@
CONST	SEGMENT
??_C@_04DJCABLIL@?$CFs?$CFc?$AA@ DB '%s%c', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HCFNFKLM@?$CFs?$CFs?$CFc?$AA@
CONST	SEGMENT
??_C@_06HCFNFKLM@?$CFs?$CFs?$CFc?$AA@ DB '%s%s%c', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
CONST	SEGMENT
??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@ DB '%s%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CKMLCFMH@GetKeepInfo?5nStrLen?5?$DM?52?6?$AA@
CONST	SEGMENT
??_C@_0BJ@CKMLCFMH@GetKeepInfo?5nStrLen?5?$DM?52?6?$AA@ DB 'GetKeepInfo n'
	DB	'StrLen < 2', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05GFOLEBJA@?$CFs?1?$CFs?$AA@
CONST	SEGMENT
??_C@_05GFOLEBJA@?$CFs?1?$CFs?$AA@ DB '%s/%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08FIJDAHHJ@?$CFs?1?$CFd_?$CFs?$AA@
CONST	SEGMENT
??_C@_08FIJDAHHJ@?$CFs?1?$CFd_?$CFs?$AA@ DB '%s/%d_%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CKAEJDPJ@?$CFs?1?$CFd?1?$CFs_?$CF02d?4?$CFs?$AA@
CONST	SEGMENT
??_C@_0BB@CKAEJDPJ@?$CFs?1?$CFd?1?$CFs_?$CF02d?4?$CFs?$AA@ DB '%s/%d/%s_%'
	DB	'02d.%s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HBOHBIN@?$CFs?1?$CFd_?$CFs?4?$CFs?$AA@
CONST	SEGMENT
??_C@_0M@HBOHBIN@?$CFs?1?$CFd_?$CFs?4?$CFs?$AA@ DB '%s/%d_%s.%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FICIEIEF@?5?$CFs?0?5?$CFd?0?5?$CFs?5?$AA@
CONST	SEGMENT
??_C@_0N@FICIEIEF@?5?$CFs?0?5?$CFd?0?5?$CFs?5?$AA@ DB ' %s, %d, %s ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05CNDJFPDP@?$CF02x?5?$AA@
CONST	SEGMENT
??_C@_05CNDJFPDP@?$CF02x?5?$AA@ DB '%02x ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@OJOMLNHA@?5Undefind?5nkind?$FL?$CFd?$FN?5?$FL?$CFd?$FN?5PKIdx?$FL?$CF@
CONST	SEGMENT
??_C@_0CE@OJOMLNHA@?5Undefind?5nkind?$FL?$CFd?$FN?5?$FL?$CFd?$FN?5PKIdx?$FL?$CF@ DB ' '
	DB	'Undefind nkind[%d] [%d] PKIdx[%d] ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@LBNCKJLO@?5nSIdx?$FL?$CFd?$FN?5recv?5Queue?5?$FL?$CFd?$FN?5PKIdx@
CONST	SEGMENT
??_C@_0CG@LBNCKJLO@?5nSIdx?$FL?$CFd?$FN?5recv?5Queue?5?$FL?$CFd?$FN?5PKIdx@ DB ' '
	DB	'nSIdx[%d] recv Queue [%d] PKIdx[%d] ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@LDDEIIP@?5nSIdx?$FL?$CFd?$FN?5send?5Queue?5?$FL?$CFd?$FN?5PKIdx@
CONST	SEGMENT
??_C@_0CG@LDDEIIP@?5nSIdx?$FL?$CFd?$FN?5send?5Queue?5?$FL?$CFd?$FN?5PKIdx@ DB ' '
	DB	'nSIdx[%d] send Queue [%d] PKIdx[%d] ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@BFJJFPHN@?5nSIdx?$FL?$CFd?$FN?5Recv?5?$FL?$CFd?$FN?5PKIdx?$FL?$CFd?$FN?5?$AA@
CONST	SEGMENT
??_C@_0CA@BFJJFPHN@?5nSIdx?$FL?$CFd?$FN?5Recv?5?$FL?$CFd?$FN?5PKIdx?$FL?$CFd?$FN?5?$AA@ DB ' '
	DB	'nSIdx[%d] Recv [%d] PKIdx[%d] ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JGBPHLEH@?5nSIdx?$FL?$CFd?$FN?5Send?5?$FL?$CFd?$FN?5PKIdx?$FL?$CFd?$FN?5?$AA@
CONST	SEGMENT
??_C@_0CA@JGBPHLEH@?5nSIdx?$FL?$CFd?$FN?5Send?5?$FL?$CFd?$FN?5PKIdx?$FL?$CFd?$FN?5?$AA@ DB ' '
	DB	'nSIdx[%d] Send [%d] PKIdx[%d] ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04KMMDIKEB@?5?$CFs?5?$AA@
CONST	SEGMENT
??_C@_04KMMDIKEB@?5?$CFs?5?$AA@ DB ' %s ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@OIDAMIDF@Can?8t?5create?5log?5file?5?$FL?$CFs?$FN?6?$AA@
CONST	SEGMENT
??_C@_0BM@OIDAMIDF@Can?8t?5create?5log?5file?5?$FL?$CFs?$FN?6?$AA@ DB 'Ca'
	DB	'n''t create log file [%s]', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPNLHKJD@a?$CL?$AA@
CONST	SEGMENT
??_C@_02DPNLHKJD@a?$CL?$AA@ DB 'a+', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05NINEKCGD@?$CFs?4?$CFd?$AA@
CONST	SEGMENT
??_C@_05NINEKCGD@?$CFs?4?$CFd?$AA@ DB '%s.%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03EEBNCBOD@?5?$CFs?$AA@
CONST	SEGMENT
??_C@_03EEBNCBOD@?5?$CFs?$AA@ DB ' %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05KALKBCHD@?4?$CF09d?$AA@
CONST	SEGMENT
??_C@_05KALKBCHD@?4?$CF09d?$AA@ DB '.%09d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05KLOGFFEO@?4?$CF06d?$AA@
CONST	SEGMENT
??_C@_05KLOGFFEO@?4?$CF06d?$AA@ DB '.%06d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05KNCNJHKF@?4?$CF03d?$AA@
CONST	SEGMENT
??_C@_05KNCNJHKF@?4?$CF03d?$AA@ DB '.%03d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NMLPILGG@?$CF02d?$CF02d?$CF02d?$AA@
CONST	SEGMENT
??_C@_0N@NMLPILGG@?$CF02d?$CF02d?$CF02d?$AA@ DB '%02d%02d%02d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PLMNPDMB@?$CF02d?3?$CF02d?3?$CF02d?$AA@
CONST	SEGMENT
??_C@_0P@PLMNPDMB@?$CF02d?3?$CF02d?3?$CF02d?$AA@ DB '%02d:%02d:%02d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05DIAFAFCL@?$CF02d?5?$AA@
CONST	SEGMENT
??_C@_05DIAFAFCL@?$CF02d?5?$AA@ DB '%02d ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04OGKJMPGK@?$CF02d?$AA@
CONST	SEGMENT
??_C@_04OGKJMPGK@?$CF02d?$AA@ DB '%02d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02HAOIJKIC@?$CFc?$AA@
CONST	SEGMENT
??_C@_02HAOIJKIC@?$CFc?$AA@ DB '%c', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04OCCELDNI@?$CF04d?$AA@
CONST	SEGMENT
??_C@_04OCCELDNI@?$CF04d?$AA@ DB '%04d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07GFKBPOLL@?$CFs?$CFs?4?$CFs?$AA@
CONST	SEGMENT
??_C@_07GFKBPOLL@?$CFs?$CFs?4?$CFs?$AA@ DB '%s%s.%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MEMPEKDH@?$CFs?$CFd?$CFc?$CFs_?$CF02d?4?$CFs?$AA@
CONST	SEGMENT
??_C@_0BB@MEMPEKDH@?$CFs?$CFd?$CFc?$CFs_?$CF02d?4?$CFs?$AA@ DB '%s%d%c%s_'
	DB	'%02d.%s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KEPNNLEH@?$CFs?$CFd_?$CFs?4?$CFs?$AA@
CONST	SEGMENT
??_C@_0L@KEPNNLEH@?$CFs?$CFd_?$CFs?4?$CFs?$AA@ DB '%s%d_%s.%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CNLJKEGB@CLogger?3?3_setHeaderFormat?$AA@
CONST	SEGMENT
??_C@_0BK@CNLJKEGB@CLogger?3?3_setHeaderFormat?$AA@ DB 'CLogger::_setHead'
	DB	'erFormat', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KMNIJCOL@m_pDTE?5is?5NULL?$CB?5nTimeStempNo?$FL?$CFd?$FN@
CONST	SEGMENT
??_C@_0CB@KMNIJCOL@m_pDTE?5is?5NULL?$CB?5nTimeStempNo?$FL?$CFd?$FN@ DB 'm'
	DB	'_pDTE is NULL! nTimeStempNo[%d]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@NKNMCADK@m_sLogQueue?4realloc?$CI?$CFd?0true?$CJ?5has@
CONST	SEGMENT
??_C@_0CI@NKNMCADK@m_sLogQueue?4realloc?$CI?$CFd?0true?$CJ?5has@ DB 'm_sL'
	DB	'ogQueue.realloc(%d,true) has Failed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@LGANJDEJ@CLogger?3?3_setLoggerQueue?$AA@
CONST	SEGMENT
??_C@_0BJ@LGANJDEJ@CLogger?3?3_setLoggerQueue?$AA@ DB 'CLogger::_setLogge'
	DB	'rQueue', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@BMOIDOJO@m_sLogQueue?4alloc?$CI20?0?5eAlloc_Typ@
CONST	SEGMENT
??_C@_0DG@BMOIDOJO@m_sLogQueue?4alloc?$CI20?0?5eAlloc_Typ@ DB 'm_sLogQueu'
	DB	'e.alloc(20, eAlloc_Type_BufPool) has Failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KMFBEMJL@Logger?5KeepDuration?$FL?$CFs?$FN?6?$AA@
CONST	SEGMENT
??_C@_0BJ@KMFBEMJL@Logger?5KeepDuration?$FL?$CFs?$FN?6?$AA@ DB 'Logger Ke'
	DB	'epDuration[%s]', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@KBAFAHEJ@KeepDuration?5?3?5?$CF02d?5days?5?$CF02d?3?$CF0@
CONST	SEGMENT
??_C@_0CI@KBAFAHEJ@KeepDuration?5?3?5?$CF02d?5days?5?$CF02d?3?$CF0@ DB 'K'
	DB	'eepDuration : %02d days %02d:%02d:%02d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@MGGIJGGO@Logger?5SizeLimit?$FL?$CFd?$FN?5LogLevel?$FL?$CFd@
CONST	SEGMENT
??_C@_0CP@MGGIJGGO@Logger?5SizeLimit?$FL?$CFd?$FN?5LogLevel?$FL?$CFd@ DB 'L'
	DB	'ogger SizeLimit[%d] LogLevel[%d] LogType[%s]', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@ECACAJHH@Logger?5Path?$FL?$CFs?$FN?5Prefix?$FL?$CFs?$FN?5Exten@
CONST	SEGMENT
??_C@_0CK@ECACAJHH@Logger?5Path?$FL?$CFs?$FN?5Prefix?$FL?$CFs?$FN?5Exten@ DB 'L'
	DB	'ogger Path[%s] Prefix[%s] Extension[%s]', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@OEKGBEFC@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@
CONST	SEGMENT
??_C@_0DC@OEKGBEFC@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@ DB '='
	DB	'===============================================', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09JJHCABG@TYPE_FILE?$AA@
CONST	SEGMENT
??_C@_09JJHCABG@TYPE_FILE?$AA@ DB 'TYPE_FILE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BDFHAMKE@TYPE_HOURLY?$AA@
CONST	SEGMENT
??_C@_0M@BDFHAMKE@TYPE_HOURLY?$AA@ DB 'TYPE_HOURLY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NKBDOFBL@TYPE_DAILY?$AA@
CONST	SEGMENT
??_C@_0L@NKBDOFBL@TYPE_DAILY?$AA@ DB 'TYPE_DAILY', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IJEAKGLO@Logger?5is?5not?5Initialized?$CB?$AA@
CONST	SEGMENT
??_C@_0BL@IJEAKGLO@Logger?5is?5not?5Initialized?$CB?$AA@ DB 'Logger is no'
	DB	't Initialized!', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08HMDDICIG@LOGLEVEL?$AA@
CONST	SEGMENT
??_C@_08HMDDICIG@LOGLEVEL?$AA@ DB 'LOGLEVEL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08GJGBIIAH@IS_PRINT?$AA@
CONST	SEGMENT
??_C@_08GJGBIIAH@IS_PRINT?$AA@ DB 'IS_PRINT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KBOADAAO@IS_PRINT_LEVEL?$AA@
CONST	SEGMENT
??_C@_0P@KBOADAAO@IS_PRINT_LEVEL?$AA@ DB 'IS_PRINT_LEVEL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KBIMBJLD@SIZE_LIMIT?$AA@
CONST	SEGMENT
??_C@_0L@KBIMBJLD@SIZE_LIMIT?$AA@ DB 'SIZE_LIMIT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07NONFHEKD@LOGTYPE?$AA@
CONST	SEGMENT
??_C@_07NONFHEKD@LOGTYPE?$AA@ DB 'LOGTYPE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06OEDJMAPG@STL_NO?$AA@
CONST	SEGMENT
??_C@_06OEDJMAPG@STL_NO?$AA@ DB 'STL_NO', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@KJGNIKCD@invalid?5value?$FL?$CFd?$FN?$CB?5pSection?$FL?$CFs?$FN?$AA@
CONST	SEGMENT
??_C@_0CA@KJGNIKCD@invalid?5value?$FL?$CFd?$FN?$CB?5pSection?$FL?$CFs?$FN?$AA@ DB 'i'
	DB	'nvalid value[%d]! pSection[%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GIODBBCL@TIMESTEMP_NO?$AA@
CONST	SEGMENT
??_C@_0N@GIODBBCL@TIMESTEMP_NO?$AA@ DB 'TIMESTEMP_NO', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MIEDPAKJ@KEEP_DURATION?$AA@
CONST	SEGMENT
??_C@_0O@MIEDPAKJ@KEEP_DURATION?$AA@ DB 'KEEP_DURATION', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09NDPCHOCH@EXTENSION?$AA@
CONST	SEGMENT
??_C@_09NDPCHOCH@EXTENSION?$AA@ DB 'EXTENSION', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06BGFFEFJP@LOGDIR?$AA@
CONST	SEGMENT
??_C@_06BGFFEFJP@LOGDIR?$AA@ DB 'LOGDIR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03GGEOLGBL@Log?$AA@
CONST	SEGMENT
??_C@_03GGEOLGBL@Log?$AA@ DB 'Log', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08DDAPLFEB@ISENABLE?$AA@
CONST	SEGMENT
??_C@_08DDAPLFEB@ISENABLE?$AA@ DB 'ISENABLE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FPEJDJAJ@LOGNAME?5is?5NULL?$CB?$AA@
CONST	SEGMENT
??_C@_0BB@FPEJDJAJ@LOGNAME?5is?5NULL?$CB?$AA@ DB 'LOGNAME is NULL!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BNJIBEDO@CLogger?3?3initConfig?$AA@
CONST	SEGMENT
??_C@_0BE@BNJIBEDO@CLogger?3?3initConfig?$AA@ DB 'CLogger::initConfig', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07HFNGLEND@LOGNAME?$AA@
CONST	SEGMENT
??_C@_07HFNGLEND@LOGNAME?$AA@ DB 'LOGNAME', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@KHAIMODA@_setHeaderFormat?5has?5Failed?$AA@
CONST	SEGMENT
??_C@_0BM@KHAIMODA@_setHeaderFormat?5has?5Failed?$AA@ DB '_setHeaderForma'
	DB	't has Failed', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@JBFNJKAK@_setLoggerQueue?5has?5Failed?$AA@
CONST	SEGMENT
??_C@_0BL@JBFNJKAK@_setLoggerQueue?5has?5Failed?$AA@ DB '_setLoggerQueue '
	DB	'has Failed', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JBKCPMI@pDir?5is?5NULL?$AA@
CONST	SEGMENT
??_C@_0N@JBKCPMI@pDir?5is?5NULL?$AA@ DB 'pDir is NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GMHDDGKB@CLogger?3?3initDefault?$AA@
CONST	SEGMENT
??_C@_0BF@GMHDDGKB@CLogger?3?3initDefault?$AA@ DB 'CLogger::initDefault', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07KLOIGNKC@TZ_TYPE?$AA@
CONST	SEGMENT
??_C@_07KLOIGNKC@TZ_TYPE?$AA@ DB 'TZ_TYPE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08HGGKJFPL@YEAR_LEN?$AA@
CONST	SEGMENT
??_C@_08HGGKJFPL@YEAR_LEN?$AA@ DB 'YEAR_LEN', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09DKNFFIJD@LAST_TYPE?$AA@
CONST	SEGMENT
??_C@_09DKNFFIJD@LAST_TYPE?$AA@ DB 'LAST_TYPE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BMLAJOJB@IS_BRACKET_ENCLOSED?$AA@
CONST	SEGMENT
??_C@_0BE@BMLAJOJB@IS_BRACKET_ENCLOSED?$AA@ DB 'IS_BRACKET_ENCLOSED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LDLGAHN@DATE_DELIMETER?$AA@
CONST	SEGMENT
??_C@_0P@LDLGAHN@DATE_DELIMETER?$AA@ DB 'DATE_DELIMETER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OCOKOBEC@IS_TIME_DELIMETER?$AA@
CONST	SEGMENT
??_C@_0BC@OCOKOBEC@IS_TIME_DELIMETER?$AA@ DB 'IS_TIME_DELIMETER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@NELLCKCE@DATETIME_EXPRESSION_?$CFd?$AA@
CONST	SEGMENT
??_C@_0BH@NELLCKCE@DATETIME_EXPRESSION_?$CFd?$AA@ DB 'DATETIME_EXPRESSION'
	DB	'_%d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@PPNBAKOP@m_pTimeExpList?9?$DOalloc?5has?5Failed@
CONST	SEGMENT
??_C@_0CI@PPNBAKOP@m_pTimeExpList?9?$DOalloc?5has?5Failed@ DB 'm_pTimeExp'
	DB	'List->alloc has Failed!', 09H, '%s%d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@BAFPIJBO@new?5CList?$CI?$CJ?5is?5NULL?$CB?7?$CFs?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BL@BAFPIJBO@new?5CList?$CI?$CJ?5is?5NULL?$CB?7?$CFs?$CFd?6?$AA@ DB 'n'
	DB	'ew CList() is NULL!', 09H, '%s%d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@HEFKLFAD@CTimeExpManager?3?3initConfig?$AA@
CONST	SEGMENT
??_C@_0BM@HEFKLFAD@CTimeExpManager?3?3initConfig?$AA@ DB 'CTimeExpManager'
	DB	'::initConfig', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OHGDFFFE@DATETIME_EXPRESSION?$AA@
CONST	SEGMENT
??_C@_0BE@OHGDFFFE@DATETIME_EXPRESSION?$AA@ DB 'DATETIME_EXPRESSION', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08ECKHJDBO@LIST_MAX?$AA@
CONST	SEGMENT
??_C@_08ECKHJDBO@LIST_MAX?$AA@ DB 'LIST_MAX', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KEHDJCKJ@ERROR?$CB?5?$FL?$CFs?3?$CFd?$FN?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BD@KEHDJCKJ@ERROR?$CB?5?$FL?$CFs?3?$CFd?$FN?5?$CFs?6?$AA@ DB 'ERRO'
	DB	'R! [%s:%d] %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?checkDeleteProc@CLogger@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?checkDeleteProc@CLogger@@AAEXXZ$0
__ehfuncinfo$?checkDeleteProc@CLogger@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?checkDeleteProc@CLogger@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?getString@CLogger@@QAEHPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getString@CLogger@@QAEHPAD@Z$0
__ehfuncinfo$?getString@CLogger@@QAEHPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?getString@CLogger@@QAEHPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?setHeader@CLogger@@QAEHPADH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?setHeader@CLogger@@QAEHPADH@Z$0
__ehfuncinfo$?setHeader@CLogger@@QAEHPADH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?setHeader@CLogger@@QAEHPADH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?initConfig@CTimeExpManager@@QAE_NPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?initConfig@CTimeExpManager@@QAE_NPAD@Z$0
__ehfuncinfo$?initConfig@CTimeExpManager@@QAE_NPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?initConfig@CTimeExpManager@@QAE_NPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
CRT$XCU	SEGMENT
?gs_DTEManager$initializer$@@3P6AXXZA DD FLAT:??__Egs_DTEManager@@YAXXZ ; gs_DTEManager$initializer$
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@PBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@PBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const *>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@PBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comlogger.cpp
;	COMDAT ??__Fgs_DTEManager@@YAXXZ
text$yd	SEGMENT
??__Fgs_DTEManager@@YAXXZ PROC				; `dynamic atexit destructor for 'gs_DTEManager'', COMDAT
  00000	56		 push	 esi

; 35   : 	if (m_pTimeExpList) delete m_pTimeExpList; // 내부 malloc 까지 전부 destroy

  00001	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gs_DTEManager@@3VCTimeExpManager@@A ; gs_DTEManager
  00007	85 f6		 test	 esi, esi
  00009	74 12		 je	 SHORT $LN10@dynamic
  0000b	8b ce		 mov	 ecx, esi
  0000d	e8 00 00 00 00	 call	 ??1CSList@@QAE@XZ	; CSList::~CSList
  00012	6a 18		 push	 24			; 00000018H
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001a	83 c4 08	 add	 esp, 8
$LN10@dynamic:
  0001d	5e		 pop	 esi
  0001e	c3		 ret	 0
??__Fgs_DTEManager@@YAXXZ ENDP				; `dynamic atexit destructor for 'gs_DTEManager''
text$yd	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comlogger.cpp
;	COMDAT ??__Egs_DTEManager@@YAXXZ
text$di	SEGMENT
??__Egs_DTEManager@@YAXXZ PROC				; `dynamic initializer for 'gs_DTEManager'', COMDAT

; 24   : CTimeExpManager gs_DTEManager;

  00000	68 00 00 00 00	 push	 OFFSET ??__Fgs_DTEManager@@YAXXZ ; `dynamic atexit destructor for 'gs_DTEManager''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__Egs_DTEManager@@YAXXZ ENDP				; `dynamic initializer for 'gs_DTEManager''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__Fgs_cLogger@@YAXXZ
text$yd	SEGMENT
??__Fgs_cLogger@@YAXXZ PROC				; `dynamic atexit destructor for 'gs_cLogger'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  00005	e9 00 00 00 00	 jmp	 ??1CLogger@@QAE@XZ	; CLogger::~CLogger
??__Fgs_cLogger@@YAXXZ ENDP				; `dynamic atexit destructor for 'gs_cLogger''
text$yd	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comlogger.cpp
;	COMDAT ??__Egs_cLogger@@YAXXZ
text$di	SEGMENT
??__Egs_cLogger@@YAXXZ PROC				; `dynamic initializer for 'gs_cLogger'', COMDAT

; 23   : CLogger gs_cLogger;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  00005	e8 00 00 00 00	 call	 ??0CLogger@@QAE@XZ	; CLogger::CLogger
  0000a	68 00 00 00 00	 push	 OFFSET ??__Fgs_cLogger@@YAXXZ ; `dynamic atexit destructor for 'gs_cLogger''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__Egs_cLogger@@YAXXZ ENDP				; `dynamic initializer for 'gs_cLogger''
text$di	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\comfileutil.h
;	COMDAT ?init@STDelInfo@@QAEXPAD_N1PAX@Z
_TEXT	SEGMENT
_dir$ = 8						; size = 4
_isRecursive$ = 12					; size = 1
_bDelDir$ = 16						; size = 1
_p$ = 20						; size = 4
?init@STDelInfo@@QAEXPAD_N1PAX@Z PROC			; STDelInfo::init, COMDAT
; _this$ = ecx

; 39   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 40   : 		pData = p;

  00003	8b 45 14	 mov	 eax, DWORD PTR _p$[ebp]

; 41   : 		root = dir;
; 42   : 		nFlag = 0;
; 43   : 		if (isRecursive) nFlag = DIR_RECURSIVE;

  00006	ba 01 00 00 00	 mov	 edx, 1
  0000b	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0000e	8b 45 08	 mov	 eax, DWORD PTR _dir$[ebp]
  00011	89 01		 mov	 DWORD PTR [ecx], eax
  00013	33 c0		 xor	 eax, eax
  00015	38 45 0c	 cmp	 BYTE PTR _isRecursive$[ebp], al
  00018	0f 45 c2	 cmovne	 eax, edx

; 44   : 		if (bDelDir) nFlag |= DEL_DIRECTORY;

  0001b	80 7d 10 00	 cmp	 BYTE PTR _bDelDir$[ebp], 0
  0001f	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00022	74 04		 je	 SHORT $LN3@init
  00024	83 49 04 02	 or	 DWORD PTR [ecx+4], 2
$LN3@init:

; 45   : 	}

  00028	5d		 pop	 ebp
  00029	c2 10 00	 ret	 16			; 00000010H
?init@STDelInfo@@QAEXPAD_N1PAX@Z ENDP			; STDelInfo::init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
;	COMDAT ?detachFullPath@@YAXPBDPAD1@Z
_TEXT	SEGMENT
_fullpath$ = 8						; size = 4
_dir$ = 12						; size = 4
_name$ = 16						; size = 4
?detachFullPath@@YAXPBDPAD1@Z PROC			; detachFullPath, COMDAT

; 859  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h

; 1569 : _Check_return_ __inline _CRPC _tcsrchr(_In_ _CPC _s1,_In_ _UI _c) {return (_CRPC)_mbsrchr((_CPUC)_s1,_c);}

  00005	8b 75 08	 mov	 esi, DWORD PTR _fullpath$[ebp]
  00008	57		 push	 edi
  00009	6a 5c		 push	 92			; 0000005cH
  0000b	56		 push	 esi
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mbsrchr
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 862  : 	const TCHAR *pRear = _tcsrchr(fullpath, g_s);

  00012	8b d8		 mov	 ebx, eax

; 863  : 	nLen = pRear - fullpath + 1;

  00014	8b fb		 mov	 edi, ebx
  00016	2b fe		 sub	 edi, esi
  00018	47		 inc	 edi
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h

; 1545 :     return (char *)_mbsnbcpy((unsigned char *)_Dst,(const unsigned char *)_Source,_Count);

  00019	57		 push	 edi
  0001a	56		 push	 esi
  0001b	8b 75 0c	 mov	 esi, DWORD PTR _dir$[ebp]
  0001e	56		 push	 esi
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mbsnbcpy
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 866  : 	_tcscpy(name, pRear+1);

  00025	8b 55 10	 mov	 edx, DWORD PTR _name$[ebp]
  00028	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h

; 1545 :     return (char *)_mbsnbcpy((unsigned char *)_Dst,(const unsigned char *)_Source,_Count);

  0002b	83 c4 14	 add	 esp, 20			; 00000014H
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 865  : 	dir[nLen] = 0;

  0002e	c6 04 37 00	 mov	 BYTE PTR [edi+esi], 0

; 866  : 	_tcscpy(name, pRear+1);

  00032	2b d0		 sub	 edx, eax
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
$LL3@detachFull:
  00037	8a 08		 mov	 cl, BYTE PTR [eax]
  00039	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  0003c	88 4c 02 ff	 mov	 BYTE PTR [edx+eax-1], cl
  00040	84 c9		 test	 cl, cl
  00042	75 f3		 jne	 SHORT $LL3@detachFull

; 867  : }

  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
?detachFullPath@@YAXPBDPAD1@Z ENDP			; detachFullPath
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comlogger.cpp
;	COMDAT ?GetProfilePath@@YAHPBD00PAD0@Z
_TEXT	SEGMENT
_szDir$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_section$ = 8						; size = 4
_key$ = 12						; size = 4
_initVal$ = 16						; size = 4
_ret$ = 20						; size = 4
_fName$ = 24						; size = 4
?GetProfilePath@@YAHPBD00PAD0@Z PROC			; GetProfilePath, COMDAT

; 839  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 18	 mov	 eax, DWORD PTR _fName$[ebp]
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR _key$[ebp]
  00019	8b 55 08	 mov	 edx, DWORD PTR _section$[ebp]
  0001c	53		 push	 ebx
  0001d	8b 5d 10	 mov	 ebx, DWORD PTR _initVal$[ebp]
  00020	56		 push	 esi
  00021	57		 push	 edi
  00022	8b 7d 14	 mov	 edi, DWORD PTR _ret$[ebp]

; 840  : 	TCHAR szDir[256];
; 841  : 	int nRes = GetPrivateProfileString(section, key, _T(""), szDir, sizeof(szDir), fName);

  00025	50		 push	 eax
  00026	68 00 01 00 00	 push	 256			; 00000100H
  0002b	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szDir$[ebp]
  00031	50		 push	 eax
  00032	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00037	51		 push	 ecx
  00038	52		 push	 edx
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileStringA@24
  0003f	8b f0		 mov	 esi, eax

; 842  : 
; 843  : 	if (!nRes) {

  00041	85 f6		 test	 esi, esi
  00043	75 51		 jne	 SHORT $LN2@GetProfile

; 844  : 		if (initVal) {
; 845  : 			nRes = _stprintf(ret, "%s%s%c", g_pWorkDir, initVal, g_s);

  00045	6a 5c		 push	 92			; 0000005cH
  00047	85 db		 test	 ebx, ebx
  00049	74 26		 je	 SHORT $LN4@GetProfile
  0004b	53		 push	 ebx
  0004c	ff 35 00 00 00
	00		 push	 DWORD PTR ?g_pWorkDir@@3PADA ; g_pWorkDir
  00052	68 00 00 00 00	 push	 OFFSET ??_C@_06HCFNFKLM@?$CFs?$CFs?$CFc?$AA@
  00057	57		 push	 edi
  00058	e8 00 00 00 00	 call	 _sprintf
  0005d	83 c4 14	 add	 esp, 20			; 00000014H
  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx

; 855  : }

  00063	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00066	33 cd		 xor	 ecx, ebp
  00068	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
$LN4@GetProfile:

; 846  : 		}
; 847  : 		else {
; 848  : 			nRes = _stprintf(ret, "%s%c", g_pWorkDir, g_s);

  00071	ff 35 00 00 00
	00		 push	 DWORD PTR ?g_pWorkDir@@3PADA ; g_pWorkDir
  00077	68 00 00 00 00	 push	 OFFSET ??_C@_04DJCABLIL@?$CFs?$CFc?$AA@
  0007c	57		 push	 edi
  0007d	e8 00 00 00 00	 call	 _sprintf
  00082	83 c4 10	 add	 esp, 16			; 00000010H
  00085	5f		 pop	 edi
  00086	5e		 pop	 esi
  00087	5b		 pop	 ebx

; 855  : }

  00088	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008b	33 cd		 xor	 ecx, ebp
  0008d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c3		 ret	 0
$LN2@GetProfile:

; 849  : 		}
; 850  : 	}
; 851  : 	else if (szDir[0] == '~') {

  00096	80 bd fc fe ff
	ff 7e		 cmp	 BYTE PTR _szDir$[ebp], 126 ; 0000007eH
  0009d	75 12		 jne	 SHORT $LN6@GetProfile

; 852  : 		changeToAbsolutePath(ret, szDir);

  0009f	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szDir$[ebp]
  000a5	50		 push	 eax
  000a6	57		 push	 edi
  000a7	e8 00 00 00 00	 call	 ?changeToAbsolutePath@@YAXPADPBD@Z ; changeToAbsolutePath
  000ac	83 c4 08	 add	 esp, 8

; 853  : 	}
; 854  : 	return nRes;

  000af	8b c6		 mov	 eax, esi
$LN6@GetProfile:

; 855  : }

  000b1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b4	5f		 pop	 edi
  000b5	5e		 pop	 esi
  000b6	33 cd		 xor	 ecx, ebp
  000b8	5b		 pop	 ebx
  000b9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c3		 ret	 0
?GetProfilePath@@YAHPBD00PAD0@Z ENDP			; GetProfilePath
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comlogger.cpp
;	COMDAT ?changeToAbsolutePathFile@@YAXPADPBD@Z
_TEXT	SEGMENT
_szBuf$ = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_ret$ = 8						; size = 4
_path$ = 12						; size = 4
?changeToAbsolutePathFile@@YAXPADPBD@Z PROC		; changeToAbsolutePathFile, COMDAT

; 800  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 04 00
	00		 sub	 esp, 1028		; 00000404H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 801  : 	TCHAR szBuf[1024];
; 802  : 	TCHAR *pBuf = (TCHAR *)szBuf;
; 803  : 	_tcscpy(szBuf, path);

  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _path$[ebp]
  00016	8d 95 fc fb ff
	ff		 lea	 edx, DWORD PTR _szBuf$[ebp]
  0001c	56		 push	 esi
  0001d	8b 75 08	 mov	 esi, DWORD PTR _ret$[ebp]
  00020	2b d1		 sub	 edx, ecx
$LL7@changeToAb:
  00022	8a 01		 mov	 al, BYTE PTR [ecx]
  00024	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  00027	41		 inc	 ecx
  00028	84 c0		 test	 al, al
  0002a	75 f6		 jne	 SHORT $LL7@changeToAb

; 804  : 	int nRes = 0;
; 805  : 	CEnv::initSystem();

  0002c	6a 00		 push	 0
  0002e	e8 00 00 00 00	 call	 ?initSystem@CEnv@@SAHPAD@Z ; CEnv::initSystem
  00033	83 c4 04	 add	 esp, 4

; 806  : 	if (pBuf[0] == '~') {

  00036	80 bd fc fb ff
	ff 7e		 cmp	 BYTE PTR _szBuf$[ebp], 126 ; 0000007eH
  0003d	75 31		 jne	 SHORT $LN4@changeToAb

; 807  : 		pBuf++;

  0003f	8d 85 fd fb ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp+1]
$LL2@changeToAb:

; 808  : 		while (*pBuf == '\\' || *pBuf == '/') {

  00045	8a 08		 mov	 cl, BYTE PTR [eax]
  00047	80 f9 5c	 cmp	 cl, 92			; 0000005cH
  0004a	74 05		 je	 SHORT $LN5@changeToAb
  0004c	80 f9 2f	 cmp	 cl, 47			; 0000002fH
  0004f	75 06		 jne	 SHORT $LN3@changeToAb
$LN5@changeToAb:

; 809  : 			*pBuf = g_s;

  00051	c6 00 5c	 mov	 BYTE PTR [eax], 92	; 0000005cH

; 810  : 			pBuf++;

  00054	40		 inc	 eax

; 811  : 		}

  00055	eb ee		 jmp	 SHORT $LL2@changeToAb
$LN3@changeToAb:

; 812  : 		nRes = _stprintf(ret, _T("%s%s"), g_pWorkDir, pBuf);

  00057	50		 push	 eax
  00058	ff 35 00 00 00
	00		 push	 DWORD PTR ?g_pWorkDir@@3PADA ; g_pWorkDir
  0005e	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  00063	56		 push	 esi
  00064	e8 00 00 00 00	 call	 _sprintf
  00069	83 c4 10	 add	 esp, 16			; 00000010H

; 813  : 		ret[nRes] = 0;

  0006c	c6 04 30 00	 mov	 BYTE PTR [eax+esi], 0
$LN4@changeToAb:

; 814  : 	}
; 815  : }

  00070	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00073	33 cd		 xor	 ecx, ebp
  00075	5e		 pop	 esi
  00076	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
?changeToAbsolutePathFile@@YAXPADPBD@Z ENDP		; changeToAbsolutePathFile
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comlogger.cpp
;	COMDAT ?changeToAbsolutePath@@YAXPADPBD@Z
_TEXT	SEGMENT
_szBuf$ = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_ret$ = 8						; size = 4
_path$ = 12						; size = 4
?changeToAbsolutePath@@YAXPADPBD@Z PROC			; changeToAbsolutePath, COMDAT

; 818  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 04 00
	00		 sub	 esp, 1028		; 00000404H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 819  : 	TCHAR szBuf[1024];
; 820  : 	TCHAR *pBuf = (TCHAR *)szBuf;
; 821  : 	_tcscpy(szBuf, path);

  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _path$[ebp]
  00016	8d 95 fc fb ff
	ff		 lea	 edx, DWORD PTR _szBuf$[ebp]
  0001c	56		 push	 esi
  0001d	8b 75 08	 mov	 esi, DWORD PTR _ret$[ebp]
  00020	2b d1		 sub	 edx, ecx
$LL10@changeToAb:
  00022	8a 01		 mov	 al, BYTE PTR [ecx]
  00024	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  00027	41		 inc	 ecx
  00028	84 c0		 test	 al, al
  0002a	75 f6		 jne	 SHORT $LL10@changeToAb

; 822  : 	int nRes=0;
; 823  : 	CEnv::initSystem();

  0002c	6a 00		 push	 0
  0002e	e8 00 00 00 00	 call	 ?initSystem@CEnv@@SAHPAD@Z ; CEnv::initSystem
  00033	83 c4 04	 add	 esp, 4

; 824  : 	if (pBuf[0] == '~') {

  00036	80 bd fc fb ff
	ff 7e		 cmp	 BYTE PTR _szBuf$[ebp], 126 ; 0000007eH
  0003d	75 44		 jne	 SHORT $LN4@changeToAb

; 825  : 		pBuf++;

  0003f	8d 85 fd fb ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp+1]
$LL2@changeToAb:

; 826  : 		while (*pBuf == '\\' || *pBuf == '/') {

  00045	8a 08		 mov	 cl, BYTE PTR [eax]
  00047	80 f9 5c	 cmp	 cl, 92			; 0000005cH
  0004a	74 05		 je	 SHORT $LN5@changeToAb
  0004c	80 f9 2f	 cmp	 cl, 47			; 0000002fH
  0004f	75 06		 jne	 SHORT $LN3@changeToAb
$LN5@changeToAb:

; 827  : 			*pBuf = g_s;

  00051	c6 00 5c	 mov	 BYTE PTR [eax], 92	; 0000005cH

; 828  : 			pBuf++;

  00054	40		 inc	 eax

; 829  : 		}

  00055	eb ee		 jmp	 SHORT $LL2@changeToAb
$LN3@changeToAb:

; 830  : 		nRes = _stprintf(ret, _T("%s%s"), g_pWorkDir, pBuf);

  00057	50		 push	 eax
  00058	ff 35 00 00 00
	00		 push	 DWORD PTR ?g_pWorkDir@@3PADA ; g_pWorkDir
  0005e	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  00063	56		 push	 esi
  00064	e8 00 00 00 00	 call	 _sprintf

; 831  : 		pBuf = ret+(nRes - 1);

  00069	48		 dec	 eax
  0006a	83 c4 10	 add	 esp, 16			; 00000010H
  0006d	03 c6		 add	 eax, esi

; 832  : 		if(*pBuf == '\\' || *pBuf == '/') *pBuf = g_s;

  0006f	8a 08		 mov	 cl, BYTE PTR [eax]
  00071	80 f9 5c	 cmp	 cl, 92			; 0000005cH
  00074	74 06		 je	 SHORT $LN8@changeToAb
  00076	80 f9 2f	 cmp	 cl, 47			; 0000002fH
  00079	74 01		 je	 SHORT $LN8@changeToAb

; 833  : 		else { pBuf++; *pBuf = g_s;	}

  0007b	40		 inc	 eax
$LN8@changeToAb:

; 832  : 		if(*pBuf == '\\' || *pBuf == '/') *pBuf = g_s;

  0007c	c6 00 5c	 mov	 BYTE PTR [eax], 92	; 0000005cH

; 834  : 		*(pBuf + 1) = 0;

  0007f	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0
$LN4@changeToAb:

; 835  : 	}
; 836  : }

  00083	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00086	33 cd		 xor	 ecx, ebp
  00088	5e		 pop	 esi
  00089	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c3		 ret	 0
?changeToAbsolutePath@@YAXPADPBD@Z ENDP			; changeToAbsolutePath
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ?__autoclassinit2@CLogger@@QAEXI@Z
_TEXT	SEGMENT
_classSize$ = 8						; size = 4
?__autoclassinit2@CLogger@@QAEXI@Z PROC			; CLogger::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	ff 75 08	 push	 DWORD PTR _classSize$[ebp]
  00006	6a 00		 push	 0
  00008	51		 push	 ecx
  00009	e8 00 00 00 00	 call	 _memset
  0000e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?__autoclassinit2@CLogger@@QAEXI@Z ENDP			; CLogger::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File e:\infinia-library-3.0\com\include\comlogger.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File e:\infinia-library-3.0\com\include\comlogger.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
;	COMDAT ?__openLogger@CLogger@@AAEXPBDH@Z
_TEXT	SEGMENT
_szFileName$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_pFileName$ = 8						; size = 4
_nSeq$ = 12						; size = 4
?__openLogger@CLogger@@AAEXPBDH@Z PROC			; CLogger::__openLogger, COMDAT
; _this$ = ecx

; 429  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b f1		 mov	 esi, ecx
  00016	57		 push	 edi
  00017	8b 7d 08	 mov	 edi, DWORD PTR _pFileName$[ebp]

; 430  : 	// 기본적으로 현 파일 닫음
; 431  : 	TCHAR szFileName[256];
; 432  : 	bool bres;
; 433  : 
; 434  : 	//m_cLock.enter();
; 435  : 
; 436  : 	if (m_hFile) {

  0001a	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  0001d	85 c0		 test	 eax, eax
  0001f	74 18		 je	 SHORT $LN2@openLogger
; File e:\infinia-library-3.0\com\include\comlogger.h

; 184  : 	inline void clearLogFlag(E_LOG_FLAG nFlag) { m_nLogFlag &= ~nFlag; }

  00021	81 66 74 ff ff
	fb ff		 and	 DWORD PTR [esi+116], -262145 ; fffbffffH
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 438  : 		fclose(m_hFile); m_hFile = NULL;

  00028	50		 push	 eax
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  0002f	83 c4 04	 add	 esp, 4
  00032	c7 46 58 00 00
	00 00		 mov	 DWORD PTR [esi+88], 0
$LN2@openLogger:

; 439  : 	}
; 440  : 
; 441  : 	memset(szFileName, 0, sizeof(szFileName));

  00039	68 00 01 00 00	 push	 256			; 00000100H
  0003e	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szFileName$[ebp]
  00044	6a 00		 push	 0
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _memset

; 442  : 	if (nSeq) { // 기존 파일 이름을 변경.

  0004c	8b 45 0c	 mov	 eax, DWORD PTR _nSeq$[ebp]
  0004f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00052	85 c0		 test	 eax, eax
  00054	74 29		 je	 SHORT $LN3@openLogger

; 443  : 		_stprintf(szFileName, _T("%s.%d"), pFileName, nSeq); // pFileName == m_pFName

  00056	50		 push	 eax
  00057	57		 push	 edi
  00058	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szFileName$[ebp]
  0005e	68 00 00 00 00	 push	 OFFSET ??_C@_05NINEKCGD@?$CFs?4?$CFd?$AA@
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 _sprintf

; 444  : 
; 445  : 		bres = CFileUtil::renameFile(pFileName, szFileName);

  00069	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szFileName$[ebp]
  0006f	50		 push	 eax
  00070	57		 push	 edi
  00071	e8 00 00 00 00	 call	 ?renameFile@CFileUtil@@SA_NPBD0@Z ; CFileUtil::renameFile
  00076	83 c4 18	 add	 esp, 24			; 00000018H

; 446  : 		// 기존 파일 이름으로 아래에서 새로 생성하여 파일 오픈.
; 447  : 		if (!bres) {

  00079	84 c0		 test	 al, al
  0007b	74 74		 je	 SHORT $LN7@openLogger

; 448  : 			//m_cLock.leave();
; 449  : 			return;
; 450  : 		}		
; 451  : 	}
; 452  : 	else {

  0007d	eb 1e		 jmp	 SHORT $LN4@openLogger
$LN3@openLogger:

; 453  : 		if (m_pFName) free(m_pFName);

  0007f	8b 46 5c	 mov	 eax, DWORD PTR [esi+92]
  00082	85 c0		 test	 eax, eax
  00084	74 0a		 je	 SHORT $LN6@openLogger
  00086	50		 push	 eax
  00087	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0008d	83 c4 04	 add	 esp, 4
$LN6@openLogger:

; 454  : 		m_pFName = _tcsdup(pFileName);

  00090	57		 push	 edi
  00091	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___strdup
  00097	83 c4 04	 add	 esp, 4
  0009a	89 46 5c	 mov	 DWORD PTR [esi+92], eax
$LN4@openLogger:

; 455  : 	}
; 456  : 
; 457  : 	bres = CFileUtil::MakeDirectory(pFileName);

  0009d	57		 push	 edi
  0009e	e8 00 00 00 00	 call	 ?MakeDirectory@CFileUtil@@SA_NPBD@Z ; CFileUtil::MakeDirectory
  000a3	83 c4 04	 add	 esp, 4

; 458  : 
; 459  : 	if (bres) {

  000a6	84 c0		 test	 al, al
  000a8	74 47		 je	 SHORT $LN7@openLogger

; 460  : 		m_hFile = _tfopen(pFileName, _T("a+"));

  000aa	68 00 00 00 00	 push	 OFFSET ??_C@_02DPNLHKJD@a?$CL?$AA@
  000af	57		 push	 edi
  000b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  000b6	83 c4 08	 add	 esp, 8
  000b9	89 46 58	 mov	 DWORD PTR [esi+88], eax

; 461  : 		if (m_hFile == NULL) {

  000bc	85 c0		 test	 eax, eax
  000be	75 20		 jne	 SHORT $LN8@openLogger

; 462  : 			_tprintf(_T("Can't create log file [%s]\n"), pFileName);

  000c0	57		 push	 edi
  000c1	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@OIDAMIDF@Can?8t?5create?5log?5file?5?$FL?$CFs?$FN?6?$AA@
  000c6	e8 00 00 00 00	 call	 _printf
  000cb	83 c4 08	 add	 esp, 8
  000ce	5f		 pop	 edi
  000cf	5e		 pop	 esi

; 468  : 		setLogFlag(IS_LOG_OPEN);
; 469  : 	}
; 470  : 	//m_cLock.leave();
; 471  : }

  000d0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d3	33 cd		 xor	 ecx, ebp
  000d5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c2 08 00	 ret	 8
$LN8@openLogger:
; File e:\infinia-library-3.0\com\include\comlogger.h

; 183  : 	inline void setLogFlag(E_LOG_FLAG nFlag) { m_nLogFlag |= nFlag; }

  000e0	81 4e 74 00 00
	04 00		 or	 DWORD PTR [esi+116], 262144 ; 00040000H
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 467  : 		m_nLogSize = 0;

  000e7	c7 86 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+132], 0
$LN7@openLogger:

; 468  : 		setLogFlag(IS_LOG_OPEN);
; 469  : 	}
; 470  : 	//m_cLock.leave();
; 471  : }

  000f1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f4	5f		 pop	 edi
  000f5	33 cd		 xor	 ecx, ebp
  000f7	5e		 pop	 esi
  000f8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000fd	8b e5		 mov	 esp, ebp
  000ff	5d		 pop	 ebp
  00100	c2 08 00	 ret	 8
?__openLogger@CLogger@@AAEXPBDH@Z ENDP			; CLogger::__openLogger
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File e:\infinia-library-3.0\com\include\comfileutil.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File e:\infinia-library-3.0\com\include\comfileutil.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File e:\infinia-library-3.0\com\include\comfileutil.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
;	COMDAT ?checkDeleteProc@CLogger@@AAEXXZ
_TEXT	SEGMENT
_stFilter$2 = -52					; size = 8
_stDelInfo$3 = -44					; size = 12
_basic$ = -32						; size = 8
_cFileTime$ = -24					; size = 8
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?checkDeleteProc@CLogger@@AAEXXZ PROC			; CLogger::checkDeleteProc, COMDAT
; _this$ = ecx

; 720  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?checkDeleteProc@CLogger@@AAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 28	 sub	 esp, 40			; 00000028H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b f1		 mov	 esi, ecx

; 722  : 	CFileTime cFileTime;

  0002d	8d 4d e8	 lea	 ecx, DWORD PTR _cFileTime$[ebp]
  00030	e8 00 00 00 00	 call	 ??0CFileTime@@QAE@XZ	; CFileTime::CFileTime
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h

; 535  :             return _time64(_Time);

  00035	6a 00		 push	 0
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 722  : 	CFileTime cFileTime;

  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h

; 535  :             return _time64(_Time);

  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___time64
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 723  : 	t = time(NULL);

  00044	8b da		 mov	 ebx, edx
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h

; 535  :             return _time64(_Time);

  00046	83 c4 04	 add	 esp, 4
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 723  : 	t = time(NULL);

  00049	8b f8		 mov	 edi, eax

; 724  : 	if (m_tDeleteGoal <= t) { // proc delete

  0004b	39 9e cc 00 00
	00		 cmp	 DWORD PTR [esi+204], ebx
  00051	7f 73		 jg	 SHORT $LN2@checkDelet
  00053	7c 08		 jl	 SHORT $LN11@checkDelet
  00055	39 be c8 00 00
	00		 cmp	 DWORD PTR [esi+200], edi
  0005b	77 69		 ja	 SHORT $LN2@checkDelet
$LN11@checkDelet:

; 725  : 		basic = t - m_nDeleteInterval;

  0005d	8b 86 d0 00 00
	00		 mov	 eax, DWORD PTR [esi+208]
  00063	8b cf		 mov	 ecx, edi
  00065	99		 cdq
  00066	2b c8		 sub	 ecx, eax
  00068	8b c3		 mov	 eax, ebx
  0006a	89 4d e0	 mov	 DWORD PTR _basic$[ebp], ecx

; 726  : 		cFileTime.setFileTime(&basic);

  0006d	8d 4d e8	 lea	 ecx, DWORD PTR _cFileTime$[ebp]
  00070	1b c2		 sbb	 eax, edx
  00072	89 45 e4	 mov	 DWORD PTR _basic$[ebp+4], eax
  00075	8d 45 e0	 lea	 eax, DWORD PTR _basic$[ebp]
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 ?setFileTime@CFileTime@@QAEHPA_J@Z ; CFileTime::setFileTime
; File e:\infinia-library-3.0\com\include\comfileutil.h

; 41   : 		root = dir;

  0007e	8b 46 60	 mov	 eax, DWORD PTR [esi+96]
  00081	89 45 d4	 mov	 DWORD PTR _stDelInfo$3[ebp], eax
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 730  : 		stFilter.pData = &cFileTime;

  00084	8d 45 e8	 lea	 eax, DWORD PTR _cFileTime$[ebp]
  00087	89 45 d0	 mov	 DWORD PTR _stFilter$2[ebp+4], eax

; 732  : 		CFileUtil::delDirectory(&stDelInfo, &stFilter);

  0008a	8d 45 cc	 lea	 eax, DWORD PTR _stFilter$2[ebp]
  0008d	50		 push	 eax
  0008e	8d 45 d4	 lea	 eax, DWORD PTR _stDelInfo$3[ebp]
; File e:\infinia-library-3.0\com\include\comfileutil.h

; 40   : 		pData = p;

  00091	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _stDelInfo$3[ebp+8], 0
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 732  : 		CFileUtil::delDirectory(&stDelInfo, &stFilter);

  00098	50		 push	 eax
; File e:\infinia-library-3.0\com\include\comfileutil.h

; 44   : 		if (bDelDir) nFlag |= DEL_DIRECTORY;

  00099	c7 45 d8 03 00
	00 00		 mov	 DWORD PTR _stDelInfo$3[ebp+4], 3
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 731  : 		stFilter.pFunc = filter_dateTimeCompare;

  000a0	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _stFilter$2[ebp], OFFSET ?filter_dateTimeCompare@@YA_NPADPAX1@Z ; filter_dateTimeCompare

; 732  : 		CFileUtil::delDirectory(&stDelInfo, &stFilter);

  000a7	e8 00 00 00 00	 call	 ?delDirectory@CFileUtil@@SAHPAUSTDelInfo@@PAUSTFilterData@@@Z ; CFileUtil::delDirectory

; 733  : 		m_tDeleteGoal = t + m_nDeleteInterval;

  000ac	8b 86 d0 00 00
	00		 mov	 eax, DWORD PTR [esi+208]
  000b2	83 c4 08	 add	 esp, 8
  000b5	99		 cdq
  000b6	03 c7		 add	 eax, edi
  000b8	89 86 c8 00 00
	00		 mov	 DWORD PTR [esi+200], eax
  000be	13 d3		 adc	 edx, ebx
  000c0	89 96 cc 00 00
	00		 mov	 DWORD PTR [esi+204], edx
$LN2@checkDelet:

; 734  : 	}
; 735  : }

  000c6	8d 4d e8	 lea	 ecx, DWORD PTR _cFileTime$[ebp]
  000c9	e8 00 00 00 00	 call	 ??1CFileTime@@QAE@XZ	; CFileTime::~CFileTime
  000ce	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d8	59		 pop	 ecx
  000d9	5f		 pop	 edi
  000da	5e		 pop	 esi
  000db	5b		 pop	 ebx
  000dc	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000df	33 cd		 xor	 ecx, ebp
  000e1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?checkDeleteProc@CLogger@@AAEXXZ$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR _cFileTime$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CFileTime@@QAE@XZ	; CFileTime::~CFileTime
__ehhandler$?checkDeleteProc@CLogger@@AAEXXZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?checkDeleteProc@CLogger@@AAEXXZ
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?checkDeleteProc@CLogger@@AAEXXZ ENDP			; CLogger::checkDeleteProc
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
;	COMDAT ?GetKeepInfo@CLogger@@AAEHPBD@Z
_TEXT	SEGMENT
_szBuf$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_pValue$ = 8						; size = 4
?GetKeepInfo@CLogger@@AAEHPBD@Z PROC			; CLogger::GetKeepInfo, COMDAT
; _this$ = ecx

; 753  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 754  : 	char szBuf[32];
; 755  : 	char chKeepFileUnit;
; 756  : 	int nStrLen;
; 757  : 	int nUnitSecond, nNum;
; 758  : 
; 759  : 	strcpy(szBuf, pValue);

  00010	8b 55 08	 mov	 edx, DWORD PTR _pValue$[ebp]
  00013	56		 push	 esi
  00014	8d 75 dc	 lea	 esi, DWORD PTR _szBuf$[ebp]
  00017	57		 push	 edi
  00018	8b f9		 mov	 edi, ecx
  0001a	2b f2		 sub	 esi, edx
  0001c	0f 1f 40 00	 npad	 4
$LL21@GetKeepInf:
  00020	8a 02		 mov	 al, BYTE PTR [edx]
  00022	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00025	88 44 16 ff	 mov	 BYTE PTR [esi+edx-1], al
  00029	84 c0		 test	 al, al
  0002b	75 f3		 jne	 SHORT $LL21@GetKeepInf

; 760  : 	nStrLen = (int)strlen(szBuf);

  0002d	8d 45 dc	 lea	 eax, DWORD PTR _szBuf$[ebp]
  00030	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL34@GetKeepInf:
  00033	8a 08		 mov	 cl, BYTE PTR [eax]
  00035	40		 inc	 eax
  00036	84 c9		 test	 cl, cl
  00038	75 f9		 jne	 SHORT $LL34@GetKeepInf
  0003a	2b c2		 sub	 eax, edx

; 761  : 	if (nStrLen < 2)

  0003c	83 f8 02	 cmp	 eax, 2
  0003f	7d 22		 jge	 SHORT $LN5@GetKeepInf

; 762  : 	{
; 763  : 		printf("GetKeepInfo nStrLen < 2\n");

  00041	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@CKMLCFMH@GetKeepInfo?5nStrLen?5?$DM?52?6?$AA@
  00046	e8 00 00 00 00	 call	 _printf
  0004b	83 c4 04	 add	 esp, 4

; 764  : 		return -1;

  0004e	83 c8 ff	 or	 eax, -1
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi

; 796  : 	return 0;
; 797  : }

  00053	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00056	33 cd		 xor	 ecx, ebp
  00058	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
$LN5@GetKeepInf:

; 765  : 	}
; 766  : 
; 767  : 	nStrLen = nStrLen - 1;

  00063	48		 dec	 eax
  00064	53		 push	 ebx

; 768  : 	chKeepFileUnit = szBuf[nStrLen];

  00065	8a 5c 05 dc	 mov	 bl, BYTE PTR _szBuf$[ebp+eax]

; 769  : 	szBuf[nStrLen] = '\0';

  00069	83 f8 20	 cmp	 eax, 32			; 00000020H
  0006c	0f 83 e6 00 00
	00		 jae	 $LN37@GetKeepInf

; 770  : 
; 771  : 	int i;
; 772  : 	for (i = 0; i < nStrLen; i++) {

  00072	33 c9		 xor	 ecx, ecx
  00074	c6 44 05 dc 00	 mov	 BYTE PTR _szBuf$[ebp+eax], 0
  00079	85 c0		 test	 eax, eax
  0007b	7e 16		 jle	 SHORT $LN3@GetKeepInf
  0007d	0f 1f 00	 npad	 3
$LL4@GetKeepInf:

; 773  : 		if ((szBuf[i] < '0') || (szBuf[i] > '9')) return -2;

  00080	8a 54 0d dc	 mov	 dl, BYTE PTR _szBuf$[ebp+ecx]
  00084	80 fa 30	 cmp	 dl, 48			; 00000030H
  00087	7c 59		 jl	 SHORT $LN28@GetKeepInf
  00089	80 fa 39	 cmp	 dl, 57			; 00000039H
  0008c	7f 54		 jg	 SHORT $LN28@GetKeepInf

; 770  : 
; 771  : 	int i;
; 772  : 	for (i = 0; i < nStrLen; i++) {

  0008e	41		 inc	 ecx
  0008f	3b c8		 cmp	 ecx, eax
  00091	7c ed		 jl	 SHORT $LL4@GetKeepInf
$LN3@GetKeepInf:

; 774  : 	}
; 775  : 
; 776  : 	nNum = atoi(szBuf);

  00093	8d 45 dc	 lea	 eax, DWORD PTR _szBuf$[ebp]
  00096	50		 push	 eax
  00097	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  0009d	83 c4 04	 add	 esp, 4
  000a0	8b c8		 mov	 ecx, eax

; 777  : 
; 778  : 	if ((chKeepFileUnit == 's') || (chKeepFileUnit == 'S')) {

  000a2	80 fb 73	 cmp	 bl, 115			; 00000073H
  000a5	74 68		 je	 SHORT $LN10@GetKeepInf
  000a7	80 fb 53	 cmp	 bl, 83			; 00000053H
  000aa	74 63		 je	 SHORT $LN10@GetKeepInf

; 780  : 	}
; 781  : 	else if ((chKeepFileUnit == 'm') || (chKeepFileUnit == 'M')) {

  000ac	80 fb 6d	 cmp	 bl, 109			; 0000006dH
  000af	74 57		 je	 SHORT $LN13@GetKeepInf
  000b1	80 fb 4d	 cmp	 bl, 77			; 0000004dH
  000b4	74 52		 je	 SHORT $LN13@GetKeepInf

; 783  : 	}
; 784  : 	else if ((chKeepFileUnit == 'h') || (chKeepFileUnit == 'H')) {

  000b6	80 fb 68	 cmp	 bl, 104			; 00000068H
  000b9	74 46		 je	 SHORT $LN16@GetKeepInf
  000bb	80 fb 48	 cmp	 bl, 72			; 00000048H
  000be	74 41		 je	 SHORT $LN16@GetKeepInf

; 786  : 	}
; 787  : 	else if ((chKeepFileUnit == 'd') || (chKeepFileUnit == 'D')) {

  000c0	80 fb 64	 cmp	 bl, 100			; 00000064H
  000c3	74 35		 je	 SHORT $LN19@GetKeepInf
  000c5	80 fb 44	 cmp	 bl, 68			; 00000044H
  000c8	74 30		 je	 SHORT $LN19@GetKeepInf

; 791  : 	{
; 792  : 		return -5;

  000ca	5b		 pop	 ebx
  000cb	5f		 pop	 edi
  000cc	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  000d1	5e		 pop	 esi

; 796  : 	return 0;
; 797  : }

  000d2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d5	33 cd		 xor	 ecx, ebp
  000d7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000dc	8b e5		 mov	 esp, ebp
  000de	5d		 pop	 ebp
  000df	c2 04 00	 ret	 4
$LN28@GetKeepInf:
  000e2	5b		 pop	 ebx
  000e3	5f		 pop	 edi

; 773  : 		if ((szBuf[i] < '0') || (szBuf[i] > '9')) return -2;

  000e4	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  000e9	5e		 pop	 esi

; 796  : 	return 0;
; 797  : }

  000ea	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ed	33 cd		 xor	 ecx, ebp
  000ef	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f4	8b e5		 mov	 esp, ebp
  000f6	5d		 pop	 ebp
  000f7	c2 04 00	 ret	 4
$LN19@GetKeepInf:

; 788  : 		nUnitSecond = 60 * 60 * 24;

  000fa	b8 80 51 01 00	 mov	 eax, 86400		; 00015180H

; 789  : 	}
; 790  : 	else

  000ff	eb 13		 jmp	 SHORT $LN18@GetKeepInf
$LN16@GetKeepInf:

; 785  : 		nUnitSecond = 60 * 60;

  00101	b8 10 0e 00 00	 mov	 eax, 3600		; 00000e10H
  00106	eb 0c		 jmp	 SHORT $LN18@GetKeepInf
$LN13@GetKeepInf:

; 782  : 		nUnitSecond = 60;

  00108	b8 3c 00 00 00	 mov	 eax, 60			; 0000003cH
  0010d	eb 05		 jmp	 SHORT $LN18@GetKeepInf
$LN10@GetKeepInf:

; 779  : 		nUnitSecond = 1;

  0010f	b8 01 00 00 00	 mov	 eax, 1
$LN18@GetKeepInf:

; 794  : 	m_nDeleteInterval = nNum * nUnitSecond;

  00114	0f af c1	 imul	 eax, ecx
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h

; 535  :             return _time64(_Time);

  00117	6a 00		 push	 0
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 794  : 	m_nDeleteInterval = nNum * nUnitSecond;

  00119	89 87 d0 00 00
	00		 mov	 DWORD PTR [edi+208], eax
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h

; 535  :             return _time64(_Time);

  0011f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___time64
  00125	8b c8		 mov	 ecx, eax
  00127	83 c4 04	 add	 esp, 4
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 795  : 	m_tDeleteGoal = time(NULL) + m_nDeleteInterval;

  0012a	8b 87 d0 00 00
	00		 mov	 eax, DWORD PTR [edi+208]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h

; 535  :             return _time64(_Time);

  00130	8b f2		 mov	 esi, edx
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 795  : 	m_tDeleteGoal = time(NULL) + m_nDeleteInterval;

  00132	99		 cdq
  00133	03 c1		 add	 eax, ecx

; 796  : 	return 0;
; 797  : }

  00135	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00138	5b		 pop	 ebx
  00139	13 d6		 adc	 edx, esi
  0013b	89 87 c8 00 00
	00		 mov	 DWORD PTR [edi+200], eax
  00141	89 97 cc 00 00
	00		 mov	 DWORD PTR [edi+204], edx
  00147	33 cd		 xor	 ecx, ebp
  00149	5f		 pop	 edi
  0014a	33 c0		 xor	 eax, eax
  0014c	5e		 pop	 esi
  0014d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00152	8b e5		 mov	 esp, ebp
  00154	5d		 pop	 ebp
  00155	c2 04 00	 ret	 4
$LN37@GetKeepInf:

; 769  : 	szBuf[nStrLen] = '\0';

  00158	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN38@GetKeepInf:
$LN36@GetKeepInf:
  0015d	cc		 int	 3
?GetKeepInfo@CLogger@@AAEHPBD@Z ENDP			; CLogger::GetKeepInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comlogger.cpp
;	COMDAT ?setDateTimeFormat@CLogger@@AAEXPAUSTLogDateTimeExp@@@Z
_TEXT	SEGMENT
_pLogDTE$ = 8						; size = 4
?setDateTimeFormat@CLogger@@AAEXPAUSTLogDateTimeExp@@@Z PROC ; CLogger::setDateTimeFormat, COMDAT
; _this$ = ecx

; 367  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 368  : 	int nRes = 0;
; 369  : 
; 370  : 	if (pLogDTE->bBracketEnclosed) m_szHeaderFormat[nRes++] = _T('[');

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _pLogDTE$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	33 ff		 xor	 edi, edi
  0000b	8b f1		 mov	 esi, ecx
  0000d	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  00010	74 0c		 je	 SHORT $LN8@setDateTim
  00012	c6 86 88 00 00
	00 5b		 mov	 BYTE PTR [esi+136], 91	; 0000005bH
  00019	bf 01 00 00 00	 mov	 edi, 1
$LN8@setDateTim:

; 371  : 
; 372  : 	if (pLogDTE->nYearLen == 4) {

  0001e	8a 43 03	 mov	 al, BYTE PTR [ebx+3]
  00021	3c 04		 cmp	 al, 4
  00023	75 53		 jne	 SHORT $LN9@setDateTim

; 373  : 		_tcscpy(m_szHeaderFormat + nRes, _T("%04d")); nRes += 4;

  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_04OCCELDNI@?$CF04d?$AA@
  0002a	89 84 37 88 00
	00 00		 mov	 DWORD PTR [edi+esi+136], eax
  00031	a0 04 00 00 00	 mov	 al, BYTE PTR ??_C@_04OCCELDNI@?$CF04d?$AA@+4
  00036	88 84 37 8c 00
	00 00		 mov	 BYTE PTR [edi+esi+140], al
  0003d	83 c7 04	 add	 edi, 4

; 374  : 		switch (pLogDTE->nLastType) {

  00040	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00043	48		 dec	 eax
  00044	83 f8 03	 cmp	 eax, 3
  00047	0f 87 87 00 00
	00		 ja	 $LN16@setDateTim
  0004d	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN33@setDateTim[eax*4]
$LN11@setDateTim:

; 375  : 		case DT_SEC: m_nDateTimeFormat = LOG_DATE_YYYYMMDDHHMMSS; break;

  00054	c7 46 50 01 00
	00 00		 mov	 DWORD PTR [esi+80], 1
  0005b	eb 77		 jmp	 SHORT $LN16@setDateTim
$LN12@setDateTim:

; 376  : 		case DT_MILLISEC: m_nDateTimeFormat = LOG_DATE_YYYYMMDDHHMMSS3; break;

  0005d	c7 46 50 02 00
	00 00		 mov	 DWORD PTR [esi+80], 2
  00064	eb 6e		 jmp	 SHORT $LN16@setDateTim
$LN13@setDateTim:

; 377  : 		case DT_MICROSEC: m_nDateTimeFormat = LOG_DATE_YYYYMMDDHHMMSS6; break;

  00066	c7 46 50 03 00
	00 00		 mov	 DWORD PTR [esi+80], 3
  0006d	eb 65		 jmp	 SHORT $LN16@setDateTim
$LN14@setDateTim:

; 378  : 		case DT_NANOSEC: m_nDateTimeFormat = LOG_DATE_YYYYMMDDHHMMSS9; break;

  0006f	c7 46 50 04 00
	00 00		 mov	 DWORD PTR [esi+80], 4

; 379  : 		}
; 380  : 	}
; 381  : 	else if (pLogDTE->nYearLen == 2) {

  00076	eb 5c		 jmp	 SHORT $LN16@setDateTim
$LN9@setDateTim:
  00078	3c 02		 cmp	 al, 2
  0007a	75 51		 jne	 SHORT $LN15@setDateTim

; 382  : 		_tcscpy(m_szHeaderFormat + nRes, _T("%s")); nRes += 2;

  0007c	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_02DKCKIIND@?$CFs?$AA@
  00082	66 89 84 37 88
	00 00 00	 mov	 WORD PTR [edi+esi+136], ax
  0008a	a0 02 00 00 00	 mov	 al, BYTE PTR ??_C@_02DKCKIIND@?$CFs?$AA@+2
  0008f	88 84 37 8a 00
	00 00		 mov	 BYTE PTR [edi+esi+138], al
  00096	83 c7 02	 add	 edi, 2

; 383  : 		switch (pLogDTE->nLastType) {

  00099	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0009c	48		 dec	 eax
  0009d	83 f8 03	 cmp	 eax, 3
  000a0	77 32		 ja	 SHORT $LN16@setDateTim
  000a2	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN34@setDateTim[eax*4]
$LN17@setDateTim:

; 384  : 		case DT_SEC: m_nDateTimeFormat = LOG_DATE_YYMMDDHHMMSS; break;

  000a9	c7 46 50 05 00
	00 00		 mov	 DWORD PTR [esi+80], 5
  000b0	eb 22		 jmp	 SHORT $LN16@setDateTim
$LN18@setDateTim:

; 385  : 		case DT_MILLISEC: m_nDateTimeFormat = LOG_DATE_YYMMDDHHMMSS3; break;

  000b2	c7 46 50 06 00
	00 00		 mov	 DWORD PTR [esi+80], 6
  000b9	eb 19		 jmp	 SHORT $LN16@setDateTim
$LN19@setDateTim:

; 386  : 		case DT_MICROSEC: m_nDateTimeFormat = LOG_DATE_YYMMDDHHMMSS6; break;

  000bb	c7 46 50 07 00
	00 00		 mov	 DWORD PTR [esi+80], 7
  000c2	eb 10		 jmp	 SHORT $LN16@setDateTim
$LN20@setDateTim:

; 387  : 		case DT_NANOSEC: m_nDateTimeFormat = LOG_DATE_YYMMDDHHMMSS9; break;

  000c4	c7 46 50 08 00
	00 00		 mov	 DWORD PTR [esi+80], 8

; 388  : 		}
; 389  : 	}
; 390  : 	else {

  000cb	eb 07		 jmp	 SHORT $LN16@setDateTim
$LN15@setDateTim:

; 391  : 		m_nDateTimeFormat = LOG_DATE_NONE;

  000cd	c7 46 50 00 00
	00 00		 mov	 DWORD PTR [esi+80], 0
$LN16@setDateTim:

; 392  : 	}
; 393  : 
; 394  : 	if (pLogDTE->cDateDelimeter) nRes += _stprintf(m_szHeaderFormat + nRes, "%c", pLogDTE->cDateDelimeter);

  000d4	8a 43 01	 mov	 al, BYTE PTR [ebx+1]
  000d7	84 c0		 test	 al, al
  000d9	74 1c		 je	 SHORT $LN21@setDateTim
  000db	0f be c0	 movsx	 eax, al
  000de	50		 push	 eax
  000df	8d 86 88 00 00
	00		 lea	 eax, DWORD PTR [esi+136]
  000e5	03 c7		 add	 eax, edi
  000e7	68 00 00 00 00	 push	 OFFSET ??_C@_02HAOIJKIC@?$CFc?$AA@
  000ec	50		 push	 eax
  000ed	e8 00 00 00 00	 call	 _sprintf
  000f2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f5	03 f8		 add	 edi, eax
$LN21@setDateTim:

; 395  : 	_tcscpy(m_szHeaderFormat + nRes, _T("%02d")); nRes += 4;

  000f7	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_04OGKJMPGK@?$CF02d?$AA@
  000fc	89 84 37 88 00
	00 00		 mov	 DWORD PTR [edi+esi+136], eax
  00103	0f b6 05 04 00
	00 00		 movzx	 eax, BYTE PTR ??_C@_04OGKJMPGK@?$CF02d?$AA@+4
  0010a	88 84 37 8c 00
	00 00		 mov	 BYTE PTR [edi+esi+140], al
  00111	83 c7 04	 add	 edi, 4

; 396  : 	if (pLogDTE->cDateDelimeter) nRes += _stprintf(m_szHeaderFormat + nRes, "%c", pLogDTE->cDateDelimeter);

  00114	8a 43 01	 mov	 al, BYTE PTR [ebx+1]
  00117	84 c0		 test	 al, al
  00119	74 1c		 je	 SHORT $LN22@setDateTim
  0011b	0f be c0	 movsx	 eax, al
  0011e	50		 push	 eax
  0011f	8d 86 88 00 00
	00		 lea	 eax, DWORD PTR [esi+136]
  00125	03 c7		 add	 eax, edi
  00127	68 00 00 00 00	 push	 OFFSET ??_C@_02HAOIJKIC@?$CFc?$AA@
  0012c	50		 push	 eax
  0012d	e8 00 00 00 00	 call	 _sprintf
  00132	83 c4 0c	 add	 esp, 12			; 0000000cH
  00135	03 f8		 add	 edi, eax
$LN22@setDateTim:

; 397  : 	_tcscpy(m_szHeaderFormat + nRes, _T("%02d ")); nRes += 5;

  00137	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_05DIAFAFCL@?$CF02d?5?$AA@
  0013c	8d 7f 05	 lea	 edi, DWORD PTR [edi+5]
  0013f	89 84 37 83 00
	00 00		 mov	 DWORD PTR [edi+esi+131], eax
  00146	66 a1 04 00 00
	00		 mov	 ax, WORD PTR ??_C@_05DIAFAFCL@?$CF02d?5?$AA@+4
  0014c	66 89 84 37 87
	00 00 00	 mov	 WORD PTR [edi+esi+135], ax

; 398  : 
; 399  : 	if (pLogDTE->bTimeDelimeter) { _tcscpy(m_szHeaderFormat + nRes, _T("%02d:%02d:%02d")); nRes += 14; }

  00154	80 7b 02 00	 cmp	 BYTE PTR [ebx+2], 0
  00158	74 3e		 je	 SHORT $LN23@setDateTim
  0015a	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0P@PLMNPDMB@?$CF02d?3?$CF02d?3?$CF02d?$AA@
  00162	66 0f d6 84 37
	88 00 00 00	 movq	 QWORD PTR [edi+esi+136], xmm0
  0016b	a1 08 00 00 00	 mov	 eax, DWORD PTR ??_C@_0P@PLMNPDMB@?$CF02d?3?$CF02d?3?$CF02d?$AA@+8
  00170	89 84 37 90 00
	00 00		 mov	 DWORD PTR [edi+esi+144], eax
  00177	66 a1 0c 00 00
	00		 mov	 ax, WORD PTR ??_C@_0P@PLMNPDMB@?$CF02d?3?$CF02d?3?$CF02d?$AA@+12
  0017d	66 89 84 37 94
	00 00 00	 mov	 WORD PTR [edi+esi+148], ax
  00185	a0 0e 00 00 00	 mov	 al, BYTE PTR ??_C@_0P@PLMNPDMB@?$CF02d?3?$CF02d?3?$CF02d?$AA@+14
  0018a	88 84 37 96 00
	00 00		 mov	 BYTE PTR [edi+esi+150], al
  00191	b8 0e 00 00 00	 mov	 eax, 14			; 0000000eH
  00196	eb 2e		 jmp	 SHORT $LN24@setDateTim
$LN23@setDateTim:

; 400  : 	else { _tcscpy(m_szHeaderFormat + nRes, _T("%02d%02d%02d")); nRes += 12; }

  00198	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0N@NMLPILGG@?$CF02d?$CF02d?$CF02d?$AA@
  001a0	66 0f d6 84 37
	88 00 00 00	 movq	 QWORD PTR [edi+esi+136], xmm0
  001a9	a1 08 00 00 00	 mov	 eax, DWORD PTR ??_C@_0N@NMLPILGG@?$CF02d?$CF02d?$CF02d?$AA@+8
  001ae	89 84 37 90 00
	00 00		 mov	 DWORD PTR [edi+esi+144], eax
  001b5	a0 0c 00 00 00	 mov	 al, BYTE PTR ??_C@_0N@NMLPILGG@?$CF02d?$CF02d?$CF02d?$AA@+12
  001ba	88 84 37 94 00
	00 00		 mov	 BYTE PTR [edi+esi+148], al
  001c1	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
$LN24@setDateTim:

; 401  : 
; 402  : 	switch (pLogDTE->nLastType) {

  001c6	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]
  001c9	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  001cc	83 e8 02	 sub	 eax, 2
  001cf	74 32		 je	 SHORT $LN25@setDateTim
  001d1	83 e8 01	 sub	 eax, 1
  001d4	74 19		 je	 SHORT $LN26@setDateTim
  001d6	83 e8 01	 sub	 eax, 1
  001d9	75 45		 jne	 SHORT $LN6@setDateTim

; 405  : 	case DT_NANOSEC: _tcscpy(m_szHeaderFormat + nRes, _T(".%09d")); nRes += 5; break;

  001db	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_05KALKBCHD@?4?$CF09d?$AA@
  001e0	89 84 31 88 00
	00 00		 mov	 DWORD PTR [ecx+esi+136], eax
  001e7	66 a1 04 00 00
	00		 mov	 ax, WORD PTR ??_C@_05KALKBCHD@?4?$CF09d?$AA@+4
  001ed	eb 26		 jmp	 SHORT $LN31@setDateTim
$LN26@setDateTim:

; 404  : 	case DT_MICROSEC: _tcscpy(m_szHeaderFormat + nRes, _T(".%06d")); nRes += 5; break;

  001ef	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_05KLOGFFEO@?4?$CF06d?$AA@
  001f4	89 84 31 88 00
	00 00		 mov	 DWORD PTR [ecx+esi+136], eax
  001fb	66 a1 04 00 00
	00		 mov	 ax, WORD PTR ??_C@_05KLOGFFEO@?4?$CF06d?$AA@+4
  00201	eb 12		 jmp	 SHORT $LN31@setDateTim
$LN25@setDateTim:

; 403  : 	case DT_MILLISEC: _tcscpy(m_szHeaderFormat + nRes, _T(".%03d")); nRes += 5; break;

  00203	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_05KNCNJHKF@?4?$CF03d?$AA@
  00208	89 84 31 88 00
	00 00		 mov	 DWORD PTR [ecx+esi+136], eax
  0020f	66 a1 04 00 00
	00		 mov	 ax, WORD PTR ??_C@_05KNCNJHKF@?4?$CF03d?$AA@+4
$LN31@setDateTim:
  00215	66 89 84 31 8c
	00 00 00	 mov	 WORD PTR [ecx+esi+140], ax
  0021d	83 c1 05	 add	 ecx, 5
$LN6@setDateTim:

; 406  : 	}
; 407  : 
; 408  : 	if (pLogDTE->bBracketEnclosed) m_szHeaderFormat[nRes++] = _T(']');

  00220	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  00223	74 11		 je	 SHORT $LN30@setDateTim
  00225	5f		 pop	 edi
  00226	66 c7 84 31 88
	00 00 00 5d 00	 mov	 WORD PTR [ecx+esi+136], 93 ; 0000005dH
  00230	5e		 pop	 esi
  00231	5b		 pop	 ebx

; 410  : }

  00232	5d		 pop	 ebp
  00233	c2 04 00	 ret	 4
$LN30@setDateTim:
  00236	5f		 pop	 edi

; 409  : 	m_szHeaderFormat[nRes] = 0;

  00237	c6 84 31 88 00
	00 00 00	 mov	 BYTE PTR [ecx+esi+136], 0
  0023f	5e		 pop	 esi
  00240	5b		 pop	 ebx

; 410  : }

  00241	5d		 pop	 ebp
  00242	c2 04 00	 ret	 4
  00245	0f 1f 00	 npad	 3
$LN33@setDateTim:
  00248	00 00 00 00	 DD	 $LN11@setDateTim
  0024c	00 00 00 00	 DD	 $LN12@setDateTim
  00250	00 00 00 00	 DD	 $LN13@setDateTim
  00254	00 00 00 00	 DD	 $LN14@setDateTim
$LN34@setDateTim:
  00258	00 00 00 00	 DD	 $LN17@setDateTim
  0025c	00 00 00 00	 DD	 $LN18@setDateTim
  00260	00 00 00 00	 DD	 $LN19@setDateTim
  00264	00 00 00 00	 DD	 $LN20@setDateTim
?setDateTimeFormat@CLogger@@AAEXPAUSTLogDateTimeExp@@@Z ENDP ; CLogger::setDateTimeFormat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comlogger.cpp
;	COMDAT ?setLogName@CLogger@@AAEXPAD@Z
_TEXT	SEGMENT
_szBuf$ = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
_pTarget$ = 8						; size = 4
?setLogName@CLogger@@AAEXPAD@Z PROC			; CLogger::setLogName, COMDAT
; _this$ = ecx

; 738  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 739  : 	TCHAR szBuf[128];
; 740  : 	if (m_nLogFlag & LOG_FLAG_DAILY) {

  00013	8b 41 74	 mov	 eax, DWORD PTR [ecx+116]
  00016	a9 00 02 00 00	 test	 eax, 512		; 00000200H
  0001b	74 30		 je	 SHORT $LN2@setLogName

; 741  : 		_stprintf(szBuf, _T("%s/%d_%s"), m_pLogDir, gs_today_time.date, m_pLogName);

  0001d	ff 71 64	 push	 DWORD PTR [ecx+100]
  00020	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  00026	ff 35 18 00 00
	00		 push	 DWORD PTR ?gs_today_time@@3USTTodayTime@@A+24
  0002c	ff 71 60	 push	 DWORD PTR [ecx+96]
  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_08FIJDAHHJ@?$CFs?1?$CFd_?$CFs?$AA@
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 _sprintf
  0003a	83 c4 14	 add	 esp, 20			; 00000014H

; 748  : 	}
; 749  : }

  0003d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00040	33 cd		 xor	 ecx, ebp
  00042	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
$LN2@setLogName:

; 742  : 	}
; 743  : 	else if (m_nLogFlag & LOG_FLAG_HOURLY) {

  0004d	a9 00 04 00 00	 test	 eax, 1024		; 00000400H
  00052	74 3a		 je	 SHORT $LN4@setLogName

; 744  : 		_stprintf(szBuf, _T("%s/%d/%s_%02d.%s"), m_pLogDir, gs_today_time.date, m_pLogName, gs_today_time.hour, m_szFileExtension);

  00054	8d 41 68	 lea	 eax, DWORD PTR [ecx+104]
  00057	50		 push	 eax
  00058	ff 35 0c 00 00
	00		 push	 DWORD PTR ?gs_today_time@@3USTTodayTime@@A+12
  0005e	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  00064	ff 71 64	 push	 DWORD PTR [ecx+100]
  00067	ff 35 18 00 00
	00		 push	 DWORD PTR ?gs_today_time@@3USTTodayTime@@A+24
  0006d	ff 71 60	 push	 DWORD PTR [ecx+96]
  00070	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@CKAEJDPJ@?$CFs?1?$CFd?1?$CFs_?$CF02d?4?$CFs?$AA@
  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 _sprintf
  0007b	83 c4 1c	 add	 esp, 28			; 0000001cH

; 748  : 	}
; 749  : }

  0007e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00081	33 cd		 xor	 ecx, ebp
  00083	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c2 04 00	 ret	 4
$LN4@setLogName:

; 745  : 	}
; 746  : 	else if (m_nLogFlag & LOG_FLAG_FILE) {

  0008e	a9 00 08 00 00	 test	 eax, 2048		; 00000800H
  00093	74 1a		 je	 SHORT $LN6@setLogName

; 747  : 		_stprintf(szBuf, _T("%s/%s"), m_pLogDir, m_pLogName);

  00095	ff 71 64	 push	 DWORD PTR [ecx+100]
  00098	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  0009e	ff 71 60	 push	 DWORD PTR [ecx+96]
  000a1	68 00 00 00 00	 push	 OFFSET ??_C@_05GFOLEBJA@?$CFs?1?$CFs?$AA@
  000a6	50		 push	 eax
  000a7	e8 00 00 00 00	 call	 _sprintf
  000ac	83 c4 10	 add	 esp, 16			; 00000010H
$LN6@setLogName:

; 748  : 	}
; 749  : }

  000af	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b2	33 cd		 xor	 ecx, ebp
  000b4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c2 04 00	 ret	 4
?setLogName@CLogger@@AAEXPAD@Z ENDP			; CLogger::setLogName
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File e:\infinia-library-3.0\com\include\comqueue.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File e:\infinia-library-3.0\com\include\comtypes.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File e:\infinia-library-3.0\com\include\comtypes.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
;	COMDAT ?_setLoggerQueue@CLogger@@AAE_NH@Z
_TEXT	SEGMENT
_nMax$ = 8						; size = 4
?_setLoggerQueue@CLogger@@AAE_NH@Z PROC			; CLogger::_setLoggerQueue, COMDAT
; _this$ = ecx

; 297  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File e:\infinia-library-3.0\com\include\comqueue.h

; 43   :     inline int  capacity()   { return m_nMax; }

  00003	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00006	56		 push	 esi
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 299  : 	if (!nQueueMax) { // empty

  00007	85 c0		 test	 eax, eax
  00009	75 53		 jne	 SHORT $LN2@setLoggerQ

; 300  : 		if (!m_sLogQueue.alloc(nMax, eAlloc_Type_BufPool)) {

  0000b	6a 04		 push	 4
  0000d	ff 75 08	 push	 DWORD PTR _nMax$[ebp]
  00010	e8 00 00 00 00	 call	 ?alloc@CQueueS@@QAE_NHW4E_ALLOC_TYPE@@@Z ; CQueueS::alloc
  00015	84 c0		 test	 al, al
  00017	0f 85 96 00 00
	00		 jne	 $LN6@setLoggerQ

; 301  : 			_stprintf(g_szMessage, _T("m_sLogQueue.alloc(20, eAlloc_Type_BufPool) has Failed"));

  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@BMOIDOJO@m_sLogQueue?4alloc?$CI20?0?5eAlloc_Typ@
  00022	68 00 00 00 00	 push	 OFFSET ?g_szMessage@@3PADA ; g_szMessage
  00027	e8 00 00 00 00	 call	 _sprintf
; File e:\infinia-library-3.0\com\include\comtypes.h

; 325  : 	sprintf(g_szSystemError, "ERROR! [%s:%d] %s\n", _szFunc, _nLine, pMsg);

  0002c	68 00 00 00 00	 push	 OFFSET ?g_szMessage@@3PADA ; g_szMessage
  00031	68 2e 01 00 00	 push	 302			; 0000012eH
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@LGANJDEJ@CLogger?3?3_setLoggerQueue?$AA@
  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@KEHDJCKJ@ERROR?$CB?5?$FL?$CFs?3?$CFd?$FN?5?$CFs?6?$AA@
  00040	68 00 00 00 00	 push	 OFFSET ?g_szSystemError@@3PADA ; g_szSystemError
  00045	e8 00 00 00 00	 call	 _sprintf

; 326  : 	printf(g_szSystemError);

  0004a	68 00 00 00 00	 push	 OFFSET ?g_szSystemError@@3PADA ; g_szSystemError
  0004f	e8 00 00 00 00	 call	 _printf
  00054	83 c4 20	 add	 esp, 32			; 00000020H
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 303  : 			return false;

  00057	32 c0		 xor	 al, al
  00059	5e		 pop	 esi

; 314  : }

  0005a	5d		 pop	 ebp
  0005b	c2 04 00	 ret	 4
$LN2@setLoggerQ:

; 304  : 		}
; 305  : 	}
; 306  : 	else if (nQueueMax < nMax) {

  0005e	8b 75 08	 mov	 esi, DWORD PTR _nMax$[ebp]
  00061	3b c6		 cmp	 eax, esi
  00063	7d 4e		 jge	 SHORT $LN6@setLoggerQ

; 307  : 		if (!m_sLogQueue.realloc(nMax, true)) {

  00065	6a 01		 push	 1
  00067	56		 push	 esi
  00068	e8 00 00 00 00	 call	 ?realloc@CQueueS@@QAE_NH_N@Z ; CQueueS::realloc
  0006d	84 c0		 test	 al, al
  0006f	75 42		 jne	 SHORT $LN6@setLoggerQ

; 308  : 			_stprintf(g_szMessage, _T("m_sLogQueue.realloc(%d,true) has Failed"), nMax);

  00071	56		 push	 esi
  00072	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@NKNMCADK@m_sLogQueue?4realloc?$CI?$CFd?0true?$CJ?5has@
  00077	68 00 00 00 00	 push	 OFFSET ?g_szMessage@@3PADA ; g_szMessage
  0007c	e8 00 00 00 00	 call	 _sprintf
; File e:\infinia-library-3.0\com\include\comtypes.h

; 325  : 	sprintf(g_szSystemError, "ERROR! [%s:%d] %s\n", _szFunc, _nLine, pMsg);

  00081	68 00 00 00 00	 push	 OFFSET ?g_szMessage@@3PADA ; g_szMessage
  00086	68 35 01 00 00	 push	 309			; 00000135H
  0008b	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@LGANJDEJ@CLogger?3?3_setLoggerQueue?$AA@
  00090	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@KEHDJCKJ@ERROR?$CB?5?$FL?$CFs?3?$CFd?$FN?5?$CFs?6?$AA@
  00095	68 00 00 00 00	 push	 OFFSET ?g_szSystemError@@3PADA ; g_szSystemError
  0009a	e8 00 00 00 00	 call	 _sprintf

; 326  : 	printf(g_szSystemError);

  0009f	68 00 00 00 00	 push	 OFFSET ?g_szSystemError@@3PADA ; g_szSystemError
  000a4	e8 00 00 00 00	 call	 _printf
  000a9	83 c4 24	 add	 esp, 36			; 00000024H
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 310  : 			return false;

  000ac	32 c0		 xor	 al, al
  000ae	5e		 pop	 esi

; 314  : }

  000af	5d		 pop	 ebp
  000b0	c2 04 00	 ret	 4
$LN6@setLoggerQ:

; 311  : 		}
; 312  : 	}
; 313  : 	return true;

  000b3	b0 01		 mov	 al, 1
  000b5	5e		 pop	 esi

; 314  : }

  000b6	5d		 pop	 ebp
  000b7	c2 04 00	 ret	 4
?_setLoggerQueue@CLogger@@AAE_NH@Z ENDP			; CLogger::_setLoggerQueue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comlogger.cpp
;	COMDAT ?_setLoggerBasic@CLogger@@AAEXHHH@Z
_TEXT	SEGMENT
_nLogType$ = 8						; size = 4
_nPrintLevel$ = 12					; size = 4
_nSizeLimit$ = 16					; size = 4
?_setLoggerBasic@CLogger@@AAEXHHH@Z PROC		; CLogger::_setLoggerBasic, COMDAT
; _this$ = ecx

; 316  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 317  : 	switch (nLogType){

  00003	8b 45 08	 mov	 eax, DWORD PTR _nLogType$[ebp]
  00006	83 e8 01	 sub	 eax, 1
  00009	74 28		 je	 SHORT $LN4@setLoggerB
  0000b	83 e8 01	 sub	 eax, 1
  0000e	74 14		 je	 SHORT $LN5@setLoggerB
  00010	83 e8 01	 sub	 eax, 1
  00013	75 2e		 jne	 SHORT $LN2@setLoggerB

; 324  : 		case LOG_TYPE_FILE: {
; 325  : 			m_nLogFlag |= LOG_FLAG_FILE; m_nLogFlag &= ~(LOG_FLAG_DAILY | LOG_FLAG_HOURLY);

  00015	8b 41 74	 mov	 eax, DWORD PTR [ecx+116]
  00018	25 ff f9 ff ff	 and	 eax, -1537		; fffff9ffH
  0001d	0d 00 08 00 00	 or	 eax, 2048		; 00000800H
  00022	eb 1c		 jmp	 SHORT $LN12@setLoggerB
$LN5@setLoggerB:

; 320  : 		} break;
; 321  : 		case LOG_TYPE_HOURLY: {
; 322  : 			m_nLogFlag |= LOG_FLAG_HOURLY; m_nLogFlag &= ~(LOG_FLAG_DAILY | LOG_FLAG_FILE);

  00024	8b 41 74	 mov	 eax, DWORD PTR [ecx+116]
  00027	25 ff f5 ff ff	 and	 eax, -2561		; fffff5ffH
  0002c	0d 00 04 00 00	 or	 eax, 1024		; 00000400H

; 323  : 		}  break;

  00031	eb 0d		 jmp	 SHORT $LN12@setLoggerB
$LN4@setLoggerB:

; 318  : 		case LOG_TYPE_DAILY: {
; 319  : 			m_nLogFlag |= LOG_FLAG_DAILY; m_nLogFlag &= ~(LOG_FLAG_HOURLY | LOG_FLAG_FILE);

  00033	8b 41 74	 mov	 eax, DWORD PTR [ecx+116]
  00036	25 ff f3 ff ff	 and	 eax, -3073		; fffff3ffH
  0003b	0d 00 02 00 00	 or	 eax, 512		; 00000200H
$LN12@setLoggerB:
  00040	89 41 74	 mov	 DWORD PTR [ecx+116], eax
$LN2@setLoggerB:

; 326  : 		} break;
; 327  : 	}
; 328  : 	if (nPrintLevel) m_nLogFlag |= IS_PRINT_LEVEL;

  00043	83 7d 0c 00	 cmp	 DWORD PTR _nPrintLevel$[ebp], 0
  00047	74 09		 je	 SHORT $LN7@setLoggerB
  00049	81 49 74 00 40
	00 00		 or	 DWORD PTR [ecx+116], 16384 ; 00004000H
  00050	eb 07		 jmp	 SHORT $LN8@setLoggerB
$LN7@setLoggerB:

; 329  : 	else m_nLogFlag &= ~IS_PRINT_LEVEL;

  00052	81 61 74 ff bf
	ff ff		 and	 DWORD PTR [ecx+116], -16385 ; ffffbfffH
$LN8@setLoggerB:

; 330  : 
; 331  : 	if (nSizeLimit) m_nLogFlag |= LOG_FLAG_SIZEOVER;

  00059	8b 45 10	 mov	 eax, DWORD PTR _nSizeLimit$[ebp]

; 333  : 	m_nSizeLimit = nSizeLimit;

  0005c	89 81 80 00 00
	00		 mov	 DWORD PTR [ecx+128], eax
  00062	85 c0		 test	 eax, eax
  00064	74 0b		 je	 SHORT $LN9@setLoggerB

; 330  : 
; 331  : 	if (nSizeLimit) m_nLogFlag |= LOG_FLAG_SIZEOVER;

  00066	81 49 74 00 10
	00 00		 or	 DWORD PTR [ecx+116], 4096 ; 00001000H

; 334  : }

  0006d	5d		 pop	 ebp
  0006e	c2 0c 00	 ret	 12			; 0000000cH
$LN9@setLoggerB:

; 332  : 	else m_nLogFlag &= ~LOG_FLAG_SIZEOVER;

  00071	81 61 74 ff ef
	ff ff		 and	 DWORD PTR [ecx+116], -4097 ; ffffefffH

; 334  : }

  00078	5d		 pop	 ebp
  00079	c2 0c 00	 ret	 12			; 0000000cH
?_setLoggerBasic@CLogger@@AAEXHHH@Z ENDP		; CLogger::_setLoggerBasic
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File e:\infinia-library-3.0\com\include\comtypes.h
; File e:\infinia-library-3.0\com\include\comlist.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File e:\infinia-library-3.0\com\include\comtypes.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
;	COMDAT ?_setHeaderFormat@CLogger@@AAE_NH@Z
_TEXT	SEGMENT
_nTimeStempNo$ = 8					; size = 4
?_setHeaderFormat@CLogger@@AAE_NH@Z PROC		; CLogger::_setHeaderFormat, COMDAT
; _this$ = ecx

; 336  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 38   : STLogDateTimeExp *CTimeExpManager::getDTE(int nIdx) { if (!m_pTimeExpList) return NULL;  return (STLogDateTimeExp *)m_pTimeExpList->getObj(nIdx); }

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gs_DTEManager@@3VCTimeExpManager@@A ; gs_DTEManager
  00008	8b 55 08	 mov	 edx, DWORD PTR _nTimeStempNo$[ebp]
  0000b	56		 push	 esi
  0000c	57		 push	 edi

; 336  : {

  0000d	8b f9		 mov	 edi, ecx

; 38   : STLogDateTimeExp *CTimeExpManager::getDTE(int nIdx) { if (!m_pTimeExpList) return NULL;  return (STLogDateTimeExp *)m_pTimeExpList->getObj(nIdx); }

  0000f	85 c0		 test	 eax, eax
  00011	74 28		 je	 SHORT $LN17@setHeaderF
; File e:\infinia-library-3.0\com\include\comtypes.h

; 322  : inline bool ISINCLUDE(int i, int max) { if (0 <= i && i < max) return true; return false; }

  00013	85 d2		 test	 edx, edx
  00015	78 24		 js	 SHORT $LN17@setHeaderF
  00017	3b 50 10	 cmp	 edx, DWORD PTR [eax+16]
  0001a	7d 1f		 jge	 SHORT $LN17@setHeaderF
; File e:\infinia-library-3.0\com\include\comlist.h

; 33   : 	inline void* getObj(int i) { if (ISINCLUDE(i, m_nMax)) return m_pArray[i]; return NULL; }

  0001c	8b 00		 mov	 eax, DWORD PTR [eax]
  0001e	8b 34 90	 mov	 esi, DWORD PTR [eax+edx*4]
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 338  : 	if (!pDTE) {

  00021	85 f6		 test	 esi, esi
  00023	74 16		 je	 SHORT $LN17@setHeaderF

; 342  : 	}
; 343  : 	else if (m_pDTE != pDTE) {

  00025	39 77 54	 cmp	 DWORD PTR [edi+84], esi
  00028	74 09		 je	 SHORT $LN4@setHeaderF

; 344  : 		setDateTimeFormat(pDTE);

  0002a	56		 push	 esi
  0002b	e8 00 00 00 00	 call	 ?setDateTimeFormat@CLogger@@AAEXPAUSTLogDateTimeExp@@@Z ; CLogger::setDateTimeFormat

; 345  : 		m_pDTE = pDTE;

  00030	89 77 54	 mov	 DWORD PTR [edi+84], esi
$LN4@setHeaderF:

; 346  : 	}
; 347  : 	return true;

  00033	5f		 pop	 edi
  00034	b0 01		 mov	 al, 1
  00036	5e		 pop	 esi

; 348  : }

  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
$LN17@setHeaderF:

; 339  : 		_stprintf(g_szMessage, _T("m_pDTE is NULL! nTimeStempNo[%d]"), nTimeStempNo);

  0003b	52		 push	 edx
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@KMNIJCOL@m_pDTE?5is?5NULL?$CB?5nTimeStempNo?$FL?$CFd?$FN@
  00041	68 00 00 00 00	 push	 OFFSET ?g_szMessage@@3PADA ; g_szMessage
  00046	e8 00 00 00 00	 call	 _sprintf
; File e:\infinia-library-3.0\com\include\comtypes.h

; 325  : 	sprintf(g_szSystemError, "ERROR! [%s:%d] %s\n", _szFunc, _nLine, pMsg);

  0004b	68 00 00 00 00	 push	 OFFSET ?g_szMessage@@3PADA ; g_szMessage
  00050	68 54 01 00 00	 push	 340			; 00000154H
  00055	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@CNLJKEGB@CLogger?3?3_setHeaderFormat?$AA@
  0005a	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@KEHDJCKJ@ERROR?$CB?5?$FL?$CFs?3?$CFd?$FN?5?$CFs?6?$AA@
  0005f	68 00 00 00 00	 push	 OFFSET ?g_szSystemError@@3PADA ; g_szSystemError
  00064	e8 00 00 00 00	 call	 _sprintf

; 326  : 	printf(g_szSystemError);

  00069	68 00 00 00 00	 push	 OFFSET ?g_szSystemError@@3PADA ; g_szSystemError
  0006e	e8 00 00 00 00	 call	 _printf
  00073	83 c4 24	 add	 esp, 36			; 00000024H
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 341  : 		return false;

  00076	32 c0		 xor	 al, al
  00078	5f		 pop	 edi
  00079	5e		 pop	 esi

; 348  : }

  0007a	5d		 pop	 ebp
  0007b	c2 04 00	 ret	 4
?_setHeaderFormat@CLogger@@AAE_NH@Z ENDP		; CLogger::_setHeaderFormat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
;	COMDAT ?_initCom@CLogger@@AAEXPAD000@Z
_TEXT	SEGMENT
_pDir$ = 8						; size = 4
_pName$ = 12						; size = 4
_pFileExtension$ = 16					; size = 4
_pKeepDuration$ = 20					; size = 4
?_initCom@CLogger@@AAEXPAD000@Z PROC			; CLogger::_initCom, COMDAT
; _this$ = ecx

; 261  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 262  : 	size_t nStrLen = _tcslen(pDir);

  00006	8b 7d 08	 mov	 edi, DWORD PTR _pDir$[ebp]
  00009	8b d9		 mov	 ebx, ecx
  0000b	8b f7		 mov	 esi, edi
  0000d	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
$LL32@initCom:
  00010	8a 06		 mov	 al, BYTE PTR [esi]
  00012	46		 inc	 esi
  00013	84 c0		 test	 al, al
  00015	75 f9		 jne	 SHORT $LL32@initCom

; 263  : 	bool bSet = true;
; 264  : 	if (m_pLogDir) {

  00017	8b 43 60	 mov	 eax, DWORD PTR [ebx+96]
  0001a	2b f1		 sub	 esi, ecx
  0001c	85 c0		 test	 eax, eax
  0001e	74 1a		 je	 SHORT $LN30@initCom
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h

; 1669 : _Check_return_ __inline int _tcscmp(_In_ _CPC _s1,_In_ _CPC _s2) {return _mbscmp((_CPUC)_s1,(_CPUC)_s2);}

  00020	50		 push	 eax
  00021	57		 push	 edi
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mbscmp
  00028	83 c4 08	 add	 esp, 8
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 265  : 		if (_tcscmp(pDir, m_pLogDir)) {

  0002b	85 c0		 test	 eax, eax
  0002d	74 2f		 je	 SHORT $LN5@initCom

; 266  : 			delete[] m_pLogDir;

  0002f	ff 73 60	 push	 DWORD PTR [ebx+96]
  00032	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00037	83 c4 04	 add	 esp, 4
$LN30@initCom:

; 267  : 		}
; 268  : 		else bSet = false;
; 269  : 	}
; 270  : 
; 271  : 	if (bSet) {
; 272  : 		m_pLogDir = new TCHAR[nStrLen + 1];

  0003a	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00043	83 c4 04	 add	 esp, 4
  00046	89 43 60	 mov	 DWORD PTR [ebx+96], eax

; 273  : 		_tcscpy(m_pLogDir, pDir);

  00049	8b d7		 mov	 edx, edi
  0004b	0f 1f 44 00 00	 npad	 5
$LL12@initCom:
  00050	8a 0a		 mov	 cl, BYTE PTR [edx]
  00052	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00055	88 08		 mov	 BYTE PTR [eax], cl
  00057	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  0005a	84 c9		 test	 cl, cl
  0005c	75 f2		 jne	 SHORT $LL12@initCom
$LN5@initCom:

; 274  : 	}
; 275  : 
; 276  : 	bSet = true;
; 277  : 	if (m_pLogName) {

  0005e	8b 43 64	 mov	 eax, DWORD PTR [ebx+100]
  00061	85 c0		 test	 eax, eax
  00063	74 1a		 je	 SHORT $LN31@initCom
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h

; 1669 : _Check_return_ __inline int _tcscmp(_In_ _CPC _s1,_In_ _CPC _s2) {return _mbscmp((_CPUC)_s1,(_CPUC)_s2);}

  00065	50		 push	 eax
  00066	57		 push	 edi
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mbscmp
  0006d	83 c4 08	 add	 esp, 8
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 278  : 		if (_tcscmp(pDir, m_pLogName)) {

  00070	85 c0		 test	 eax, eax
  00072	74 3a		 je	 SHORT $LN9@initCom

; 279  : 			delete[] m_pLogName;

  00074	ff 73 64	 push	 DWORD PTR [ebx+100]
  00077	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0007c	83 c4 04	 add	 esp, 4
$LN31@initCom:

; 280  : 		}
; 281  : 		else bSet = false;
; 282  : 	}
; 283  : 
; 284  : 	if (bSet) {
; 285  : 		nStrLen = _tcslen(pName);

  0007f	8b 75 0c	 mov	 esi, DWORD PTR _pName$[ebp]
  00082	8b ce		 mov	 ecx, esi
  00084	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL33@initCom:
  00087	8a 01		 mov	 al, BYTE PTR [ecx]
  00089	41		 inc	 ecx
  0008a	84 c0		 test	 al, al
  0008c	75 f9		 jne	 SHORT $LL33@initCom
  0008e	2b ca		 sub	 ecx, edx

; 286  : 		m_pLogName = new TCHAR[nStrLen + 1];

  00090	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00099	83 c4 04	 add	 esp, 4
  0009c	89 43 64	 mov	 DWORD PTR [ebx+100], eax
  0009f	90		 npad	 1
$LL13@initCom:

; 287  : 		_tcscpy(m_pLogName, pName);

  000a0	8a 0e		 mov	 cl, BYTE PTR [esi]
  000a2	8d 76 01	 lea	 esi, DWORD PTR [esi+1]
  000a5	88 08		 mov	 BYTE PTR [eax], cl
  000a7	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  000aa	84 c9		 test	 cl, cl
  000ac	75 f2		 jne	 SHORT $LL13@initCom
$LN9@initCom:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h

; 1669 : _Check_return_ __inline int _tcscmp(_In_ _CPC _s1,_In_ _CPC _s2) {return _mbscmp((_CPUC)_s1,(_CPUC)_s2);}

  000ae	8b 75 10	 mov	 esi, DWORD PTR _pFileExtension$[ebp]
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 290  : 	if (_tcscmp(pFileExtension, m_szFileExtension)) {

  000b1	8d 7b 68	 lea	 edi, DWORD PTR [ebx+104]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h

; 1669 : _Check_return_ __inline int _tcscmp(_In_ _CPC _s1,_In_ _CPC _s2) {return _mbscmp((_CPUC)_s1,(_CPUC)_s2);}

  000b4	57		 push	 edi
  000b5	56		 push	 esi
  000b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mbscmp
  000bc	83 c4 08	 add	 esp, 8
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 290  : 	if (_tcscmp(pFileExtension, m_szFileExtension)) {

  000bf	85 c0		 test	 eax, eax
  000c1	74 0f		 je	 SHORT $LN10@initCom

; 291  : 		_tcscpy(m_szFileExtension, pFileExtension);

  000c3	2b fe		 sub	 edi, esi
$LL14@initCom:
  000c5	8a 06		 mov	 al, BYTE PTR [esi]
  000c7	8d 76 01	 lea	 esi, DWORD PTR [esi+1]
  000ca	88 44 37 ff	 mov	 BYTE PTR [edi+esi-1], al
  000ce	84 c0		 test	 al, al
  000d0	75 f3		 jne	 SHORT $LL14@initCom
$LN10@initCom:

; 292  : 	}
; 293  : 
; 294  : 	GetKeepInfo(pKeepDuration);

  000d2	ff 75 14	 push	 DWORD PTR _pKeepDuration$[ebp]
  000d5	8b cb		 mov	 ecx, ebx
  000d7	e8 00 00 00 00	 call	 ?GetKeepInfo@CLogger@@AAEHPBD@Z ; CLogger::GetKeepInfo
  000dc	5f		 pop	 edi
  000dd	5e		 pop	 esi
  000de	5b		 pop	 ebx

; 295  : }

  000df	5d		 pop	 ebp
  000e0	c2 10 00	 ret	 16			; 00000010H
?_initCom@CLogger@@AAEXPAD000@Z ENDP			; CLogger::_initCom
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\comlogger.h
;	COMDAT ?putQueue@CLogger@@QAEXPAD@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?putQueue@CLogger@@QAEXPAD@Z PROC			; CLogger::putQueue, COMDAT
; _this$ = ecx

; 207  : 	void putQueue(TCHAR *p) { if (m_sLogQueue.push(p)) m_pCondition->signal(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	ff 75 08	 push	 DWORD PTR _p$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	e8 00 00 00 00	 call	 ?push@CQueueS@@QAE_NPAX@Z ; CQueueS::push
  0000e	84 c0		 test	 al, al
  00010	74 08		 je	 SHORT $LN2@putQueue
  00012	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  00015	8b 01		 mov	 eax, DWORD PTR [ecx]
  00017	ff 50 04	 call	 DWORD PTR [eax+4]
$LN2@putQueue:
  0001a	5e		 pop	 esi
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?putQueue@CLogger@@QAEXPAD@Z ENDP			; CLogger::putQueue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comlogger.cpp
;	COMDAT ?getString@CLogger@@QAEHPAD@Z
_TEXT	SEGMENT
_cDateTime$ = -184					; size = 104
_szBuf$ = -80						; size = 64
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pDest$ = 8						; size = 4
?getString@CLogger@@QAEHPAD@Z PROC			; CLogger::getString, COMDAT
; _this$ = ecx

; 229  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?getString@CLogger@@QAEHPAD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b d9		 mov	 ebx, ecx

; 230  : 	int nLen;
; 231  : 	if (!isLogFlag(IS_LOG_SET_COMPLETE)) {

  00030	8b 43 74	 mov	 eax, DWORD PTR [ebx+116]
  00033	8b 7d 08	 mov	 edi, DWORD PTR _pDest$[ebp]
  00036	c1 e8 11	 shr	 eax, 17			; 00000011H
  00039	a8 01		 test	 al, 1
  0003b	75 29		 jne	 SHORT $LN2@getString

; 232  : 		_tcscpy(pDest, _T("Logger is not Initialized!"));

  0003d	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR ??_C@_0BL@IJEAKGLO@Logger?5is?5not?5Initialized?$CB?$AA@
  00044	0f 11 07	 movups	 XMMWORD PTR [edi], xmm0
  00047	f3 0f 7e 05 10
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0BL@IJEAKGLO@Logger?5is?5not?5Initialized?$CB?$AA@+16
  0004f	66 0f d6 47 10	 movq	 QWORD PTR [edi+16], xmm0
  00054	66 a1 18 00 00
	00		 mov	 ax, WORD PTR ??_C@_0BL@IJEAKGLO@Logger?5is?5not?5Initialized?$CB?$AA@+24
  0005a	66 89 47 18	 mov	 WORD PTR [edi+24], ax
  0005e	a0 1a 00 00 00	 mov	 al, BYTE PTR ??_C@_0BL@IJEAKGLO@Logger?5is?5not?5Initialized?$CB?$AA@+26
  00063	88 47 1a	 mov	 BYTE PTR [edi+26], al
$LN2@getString:

; 233  : 	}
; 234  : 
; 235  : 	TCHAR szBuf[64];
; 236  : 	CDateTime cDateTime(DT_NONE);

  00066	6a 00		 push	 0
  00068	6a 00		 push	 0
  0006a	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _cDateTime$[ebp]
  00070	e8 00 00 00 00	 call	 ??0CDateTime@@QAE@W4DT_TYPE@@W4TZ_TYPE@@@Z ; CDateTime::CDateTime

; 237  : 
; 238  : 	if (m_nLogFlag & LOG_FLAG_DAILY) {

  00075	8b 43 74	 mov	 eax, DWORD PTR [ebx+116]
  00078	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0007f	a9 00 02 00 00	 test	 eax, 512		; 00000200H
  00084	74 1c		 je	 SHORT $LN3@getString

; 239  : 		_tcscpy(szBuf, _T("TYPE_DAILY"));

  00086	66 a1 08 00 00
	00		 mov	 ax, WORD PTR ??_C@_0L@NKBDOFBL@TYPE_DAILY?$AA@+8
  0008c	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0L@NKBDOFBL@TYPE_DAILY?$AA@
  00094	66 89 45 b8	 mov	 WORD PTR _szBuf$[ebp+8], ax
  00098	a0 0a 00 00 00	 mov	 al, BYTE PTR ??_C@_0L@NKBDOFBL@TYPE_DAILY?$AA@+10
  0009d	88 45 ba	 mov	 BYTE PTR _szBuf$[ebp+10], al
  000a0	eb 32		 jmp	 SHORT $LN13@getString
$LN3@getString:

; 240  : 	}
; 241  : 	else if (m_nLogFlag & LOG_FLAG_HOURLY) {

  000a2	a9 00 04 00 00	 test	 eax, 1024		; 00000400H
  000a7	74 12		 je	 SHORT $LN5@getString

; 242  : 		_tcscpy(szBuf, _T("TYPE_HOURLY"));

  000a9	a1 08 00 00 00	 mov	 eax, DWORD PTR ??_C@_0M@BDFHAMKE@TYPE_HOURLY?$AA@+8
  000ae	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0M@BDFHAMKE@TYPE_HOURLY?$AA@
  000b6	89 45 b8	 mov	 DWORD PTR _szBuf$[ebp+8], eax
  000b9	eb 19		 jmp	 SHORT $LN13@getString
$LN5@getString:

; 243  : 	}
; 244  : 	else if (m_nLogFlag & LOG_FLAG_FILE) {

  000bb	a9 00 08 00 00	 test	 eax, 2048		; 00000800H
  000c0	74 17		 je	 SHORT $LN7@getString

; 245  : 		_tcscpy(szBuf, _T("TYPE_FILE"));

  000c2	66 a1 08 00 00
	00		 mov	 ax, WORD PTR ??_C@_09JJHCABG@TYPE_FILE?$AA@+8
  000c8	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_09JJHCABG@TYPE_FILE?$AA@
  000d0	66 89 45 b8	 mov	 WORD PTR _szBuf$[ebp+8], ax
$LN13@getString:
  000d4	66 0f d6 45 b0	 movq	 QWORD PTR _szBuf$[ebp], xmm0
$LN7@getString:

; 246  : 	}
; 247  : 
; 248  : 	nLen = _stprintf(pDest, _T("================================================\n"));

  000d9	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@OEKGBEFC@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@
  000de	57		 push	 edi
  000df	e8 00 00 00 00	 call	 _sprintf

; 249  : 	nLen += _stprintf(pDest + nLen, _T("Logger Path[%s] Prefix[%s] Extension[%s]\n"), m_pLogDir, m_pLogName, m_szFileExtension);

  000e4	8d 4b 68	 lea	 ecx, DWORD PTR [ebx+104]
  000e7	8b f0		 mov	 esi, eax
  000e9	51		 push	 ecx
  000ea	ff 73 64	 push	 DWORD PTR [ebx+100]
  000ed	ff 73 60	 push	 DWORD PTR [ebx+96]
  000f0	8d 0c 37	 lea	 ecx, DWORD PTR [edi+esi]
  000f3	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@ECACAJHH@Logger?5Path?$FL?$CFs?$FN?5Prefix?$FL?$CFs?$FN?5Exten@
  000f8	51		 push	 ecx
  000f9	e8 00 00 00 00	 call	 _sprintf
  000fe	03 f0		 add	 esi, eax

; 250  : 	nLen += _stprintf(pDest + nLen, _T("Logger SizeLimit[%d] LogLevel[%d] LogType[%s]\n"), m_nSizeLimit, m_nLogLevel, szBuf);

  00100	8d 45 b0	 lea	 eax, DWORD PTR _szBuf$[ebp]
  00103	50		 push	 eax
  00104	ff 73 4c	 push	 DWORD PTR [ebx+76]
  00107	ff b3 80 00 00
	00		 push	 DWORD PTR [ebx+128]
  0010d	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  00110	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@MGGIJGGO@Logger?5SizeLimit?$FL?$CFd?$FN?5LogLevel?$FL?$CFd@
  00115	50		 push	 eax
  00116	e8 00 00 00 00	 call	 _sprintf
  0011b	83 c4 30	 add	 esp, 48			; 00000030H

; 251  : 
; 252  : 	cDateTime.SetSecondsValue(m_nDeleteInterval);

  0011e	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _cDateTime$[ebp]
  00124	03 f0		 add	 esi, eax
  00126	ff b3 d0 00 00
	00		 push	 DWORD PTR [ebx+208]
  0012c	e8 00 00 00 00	 call	 ?SetSecondsValue@CDateTime@@QAEXH@Z ; CDateTime::SetSecondsValue

; 253  : 	cDateTime.setString(szBuf, _T("KeepDuration : %02d days %02d:%02d:%02d"), LOG_DATE_DDHHMMSS);

  00131	6a 09		 push	 9
  00133	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@KBAFAHEJ@KeepDuration?5?3?5?$CF02d?5days?5?$CF02d?3?$CF0@
  00138	8d 45 b0	 lea	 eax, DWORD PTR _szBuf$[ebp]
  0013b	50		 push	 eax
  0013c	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _cDateTime$[ebp]
  00142	e8 00 00 00 00	 call	 ?setString@CDateTime@@QAEHPAD0W4DT_FORMAT@@@Z ; CDateTime::setString

; 254  : 
; 255  : 	nLen += _stprintf(pDest + nLen, _T("Logger KeepDuration[%s]\n"), szBuf);

  00147	8d 45 b0	 lea	 eax, DWORD PTR _szBuf$[ebp]
  0014a	50		 push	 eax
  0014b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0014e	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@KMFBEMJL@Logger?5KeepDuration?$FL?$CFs?$FN?6?$AA@
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 _sprintf
  00159	03 f0		 add	 esi, eax

; 256  : 	nLen += _stprintf(pDest + nLen, _T("================================================\n"));

  0015b	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@OEKGBEFC@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@
  00160	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  00163	50		 push	 eax
  00164	e8 00 00 00 00	 call	 _sprintf
  00169	83 c4 14	 add	 esp, 20			; 00000014H

; 257  : 	return nLen;

  0016c	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _cDateTime$[ebp]
  00172	03 f0		 add	 esi, eax
  00174	e8 00 00 00 00	 call	 ??1CDateTime@@QAE@XZ	; CDateTime::~CDateTime
  00179	8b c6		 mov	 eax, esi

; 258  : }

  0017b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0017e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00185	59		 pop	 ecx
  00186	5f		 pop	 edi
  00187	5e		 pop	 esi
  00188	5b		 pop	 ebx
  00189	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0018c	33 cd		 xor	 ecx, ebp
  0018e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00193	8b e5		 mov	 esp, ebp
  00195	5d		 pop	 ebp
  00196	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getString@CLogger@@QAEHPAD@Z$0:
  00000	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _cDateTime$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CDateTime@@QAE@XZ	; CDateTime::~CDateTime
__ehhandler$?getString@CLogger@@QAEHPAD@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a 44 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-188]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?getString@CLogger@@QAEHPAD@Z
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?getString@CLogger@@QAEHPAD@Z ENDP			; CLogger::getString
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\include\commemmanager.h
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\include\commemmanager.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File e:\infinia-library-3.0\com\include\comlogger.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File e:\infinia-library-3.0\com\include\comlogger.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
;	COMDAT ?__debugLog@CLogger@@QAAXHPBDH0ZZ
_TEXT	SEGMENT
_$S1$1 = -8716						; size = 8
_msgBuf$ = -8708					; size = 8192
_header$ = -516						; size = 512
__$ArrayPad$ = -4					; size = 4
_this$ = 8						; size = 4
_level$ = 12						; size = 4
__szFunc$ = 16						; size = 4
__nLine$ = 20						; size = 4
__szFormat$ = 24					; size = 4
?__debugLog@CLogger@@QAAXHPBDH0ZZ PROC			; CLogger::__debugLog, COMDAT

; 607  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 0c 22 00 00	 mov	 eax, 8716		; 0000220cH
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	56		 push	 esi
  00018	8b 75 10	 mov	 esi, DWORD PTR __szFunc$[ebp]
  0001b	57		 push	 edi
  0001c	8b 7d 08	 mov	 edi, DWORD PTR _this$[ebp]

; 608  : 	if (!isLogFlag(IS_LOG_ENABLE)) return;

  0001f	8b 47 74	 mov	 eax, DWORD PTR [edi+116]
  00022	c1 e8 13	 shr	 eax, 19			; 00000013H
  00025	a8 01		 test	 al, 1
  00027	0f 84 eb 00 00
	00		 je	 $LN17@debugLog

; 609  : 	if (level < m_nLogLevel) return;

  0002d	8b 45 0c	 mov	 eax, DWORD PTR _level$[ebp]
  00030	3b 47 4c	 cmp	 eax, DWORD PTR [edi+76]
  00033	0f 8c df 00 00
	00		 jl	 $LN17@debugLog

; 610  : 
; 611  : //	TCHAR tmpBuf[512];
; 612  : 	int nLen, nLen2=0;
; 613  : 
; 614  : 	TCHAR	msgBuf[MAX_LOGBUF_LEN];
; 615  : 	TCHAR	header[512];
; 616  : 	va_list	ap;
; 617  : 
; 618  : 	nLen2 = setHeader(header, level);

  00039	53		 push	 ebx
  0003a	50		 push	 eax
  0003b	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  00041	8b cf		 mov	 ecx, edi
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 ?setHeader@CLogger@@QAEHPADH@Z ; CLogger::setHeader

; 619  : 	sprintf(header+nLen2, " %s, %d, %s ", _szFunc, _nLine, _szFormat);

  00049	ff 75 18	 push	 DWORD PTR __szFormat$[ebp]
  0004c	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _header$[ebp]
  00052	ff 75 14	 push	 DWORD PTR __nLine$[ebp]
  00055	03 c1		 add	 eax, ecx
  00057	56		 push	 esi
  00058	68 00 00 00 00	 push	 OFFSET ??_C@_0N@FICIEIEF@?5?$CFs?0?5?$CFd?0?5?$CFs?5?$AA@
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 _sprintf
  00063	83 c4 14	 add	 esp, 20			; 00000014H
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h

; 1436 :     int const _Result = __stdio_common_vsprintf(

  00066	8d 45 1c	 lea	 eax, DWORD PTR __szFormat$[ebp+4]
  00069	50		 push	 eax
  0006a	6a 00		 push	 0
  0006c	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  00072	50		 push	 eax
  00073	8d 85 fc dd ff
	ff		 lea	 eax, DWORD PTR _msgBuf$[ebp]
  00079	68 ff 1f 00 00	 push	 8191			; 00001fffH
  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00084	8b 08		 mov	 ecx, DWORD PTR [eax]
  00086	ff 70 04	 push	 DWORD PTR [eax+4]
  00089	83 c9 02	 or	 ecx, 2
  0008c	51		 push	 ecx
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf
  00093	8b d8		 mov	 ebx, eax
  00095	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1437 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1438 :         _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1439 : 
; 1440 :     return _Result < 0 ? -1 : _Result;

  00098	83 c8 ff	 or	 eax, -1
  0009b	85 db		 test	 ebx, ebx
  0009d	0f 48 d8	 cmovs	 ebx, eax
; File e:\infinia-library-3.0\com\include\combufpool.h

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  000a0	b8 01 00 00 00	 mov	 eax, 1
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 624  : 	TCHAR *pBuf = (TCHAR *)gs_pMMgr->newBuf(LEN_TO_SIZE(nLen + 2));

  000a5	8d 73 02	 lea	 esi, DWORD PTR [ebx+2]
  000a8	66 0f 6e c6	 movd	 xmm0, esi
; File e:\infinia-library-3.0\com\include\combufpool.h

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  000ac	8b d6		 mov	 edx, esi
  000ae	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
; File e:\infinia-library-3.0\com\include\commemmanager.h

; 34   : 	inline char *newBuf(int nSize) { int nIdx = getIndex(nSize);  return __newBuf(nIdx, nSize); }

  000b2	56		 push	 esi
; File e:\infinia-library-3.0\com\include\combufpool.h

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  000b3	f2 0f 11 85 f4
	dd ff ff	 movsd	 QWORD PTR _$S1$1[ebp], xmm0
  000bb	8b 8d f8 dd ff
	ff		 mov	 ecx, DWORD PTR _$S1$1[ebp+4]
  000c1	c1 f9 14	 sar	 ecx, 20			; 00000014H
  000c4	81 e9 ff 03 00
	00		 sub	 ecx, 1023		; 000003ffH
  000ca	d3 e0		 shl	 eax, cl
  000cc	2b d0		 sub	 edx, eax
  000ce	23 d6		 and	 edx, esi
  000d0	f7 da		 neg	 edx
  000d2	1b d2		 sbb	 edx, edx
  000d4	f7 da		 neg	 edx
  000d6	03 d1		 add	 edx, ecx
; File e:\infinia-library-3.0\com\include\commemmanager.h

; 34   : 	inline char *newBuf(int nSize) { int nIdx = getIndex(nSize);  return __newBuf(nIdx, nSize); }

  000d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pMMgr@@3PAVCMemManager@@A ; gs_pMMgr
  000de	52		 push	 edx
  000df	e8 00 00 00 00	 call	 ?__newBuf@CMemManager@@AAEPADHI@Z ; CMemManager::__newBuf
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 625  : 	_tcscpy(pBuf, msgBuf);

  000e4	8d 95 fc dd ff
	ff		 lea	 edx, DWORD PTR _msgBuf$[ebp]
  000ea	8b f0		 mov	 esi, eax
  000ec	8b ca		 mov	 ecx, edx
  000ee	2b f1		 sub	 esi, ecx
$LL5@debugLog:
  000f0	8a 0a		 mov	 cl, BYTE PTR [edx]
  000f2	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  000f5	88 4c 16 ff	 mov	 BYTE PTR [esi+edx-1], cl
  000f9	84 c9		 test	 cl, cl
  000fb	75 f3		 jne	 SHORT $LL5@debugLog
; File e:\infinia-library-3.0\com\include\comlogger.h

; 207  : 	void putQueue(TCHAR *p) { if (m_sLogQueue.push(p)) m_pCondition->signal(); }

  000fd	50		 push	 eax
  000fe	8b cf		 mov	 ecx, edi
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 626  : 	pBuf[nLen] = '\n';

  00100	66 c7 04 18 0a
	00		 mov	 WORD PTR [eax+ebx], 10	; 0000000aH
; File e:\infinia-library-3.0\com\include\comlogger.h

; 207  : 	void putQueue(TCHAR *p) { if (m_sLogQueue.push(p)) m_pCondition->signal(); }

  00106	e8 00 00 00 00	 call	 ?push@CQueueS@@QAE_NPAX@Z ; CQueueS::push
  0010b	5b		 pop	 ebx
  0010c	84 c0		 test	 al, al
  0010e	74 08		 je	 SHORT $LN17@debugLog
  00110	8b 4f 44	 mov	 ecx, DWORD PTR [edi+68]
  00113	8b 01		 mov	 eax, DWORD PTR [ecx]
  00115	ff 50 04	 call	 DWORD PTR [eax+4]
$LN17@debugLog:
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 630  : }

  00118	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0011b	5f		 pop	 edi
  0011c	33 cd		 xor	 ecx, ebp
  0011e	5e		 pop	 esi
  0011f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00124	8b e5		 mov	 esp, ebp
  00126	5d		 pop	 ebp
  00127	c3		 ret	 0
?__debugLog@CLogger@@QAAXHPBDH0ZZ ENDP			; CLogger::__debugLog
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comlogger.cpp
;	COMDAT ?checkChangeProc@CLogger@@QAEXH@Z
_TEXT	SEGMENT
_szFile$ = -516						; size = 512
__$ArrayPad$ = -4					; size = 4
_nFlag$ = 8						; size = 4
?checkChangeProc@CLogger@@QAEXH@Z PROC			; CLogger::checkChangeProc, COMDAT
; _this$ = ecx

; 685  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 02 00
	00		 sub	 esp, 516		; 00000204H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b f1		 mov	 esi, ecx

; 686  : 	TCHAR szFile[512];
; 687  : 
; 688  : 	// delete proc
; 689  : 	if (m_nDeleteInterval) checkDeleteProc();

  00016	83 be d0 00 00
	00 00		 cmp	 DWORD PTR [esi+208], 0
  0001d	74 05		 je	 SHORT $LN2@checkChang
  0001f	e8 00 00 00 00	 call	 ?checkDeleteProc@CLogger@@AAEXXZ ; CLogger::checkDeleteProc
$LN2@checkChang:

; 690  : 
; 691  : 	if (nFlag & LOG_FLAG_DAYCHANGE) {

  00024	8b 45 08	 mov	 eax, DWORD PTR _nFlag$[ebp]
  00027	a8 01		 test	 al, 1
  00029	74 55		 je	 SHORT $LN4@checkChang

; 692  : 		if (m_nLogFlag & LOG_FLAG_DAILY) { 

  0002b	f7 46 74 00 02
	00 00		 test	 DWORD PTR [esi+116], 512 ; 00000200H
  00032	74 4c		 je	 SHORT $LN4@checkChang

; 693  : 			_stprintf(szFile, _T("%s/%d_%s.%s"), m_pLogDir, gs_today_time.date, m_pLogName, m_szFileExtension);

  00034	8d 46 68	 lea	 eax, DWORD PTR [esi+104]
  00037	50		 push	 eax
  00038	ff 76 64	 push	 DWORD PTR [esi+100]
  0003b	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _szFile$[ebp]
  00041	ff 35 18 00 00
	00		 push	 DWORD PTR ?gs_today_time@@3USTTodayTime@@A+24
  00047	ff 76 60	 push	 DWORD PTR [esi+96]
  0004a	68 00 00 00 00	 push	 OFFSET ??_C@_0M@HBOHBIN@?$CFs?1?$CFd_?$CFs?4?$CFs?$AA@
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 _sprintf
  00055	83 c4 18	 add	 esp, 24			; 00000018H

; 694  : 			__openLogger(szFile);

  00058	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _szFile$[ebp]
  0005e	8b ce		 mov	 ecx, esi
  00060	6a 00		 push	 0
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 ?__openLogger@CLogger@@AAEXPBDH@Z ; CLogger::__openLogger

; 695  : 			m_nSeq = 0;

  00068	c7 46 78 00 00
	00 00		 mov	 DWORD PTR [esi+120], 0
  0006f	5e		 pop	 esi

; 711  : 		}
; 712  : 	}
; 713  : 
; 714  : 	// LOG_FLAG_FILE
; 715  : 	// no need to open a new file
; 716  : 
; 717  : }

  00070	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00073	33 cd		 xor	 ecx, ebp
  00075	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c2 04 00	 ret	 4
$LN4@checkChang:

; 696  : 			return;
; 697  : 		}
; 698  : 	}
; 699  : 	if (nFlag & LOG_FLAG_HOURCHANGE) {

  00080	a8 02		 test	 al, 2
  00082	74 5b		 je	 SHORT $LN6@checkChang

; 700  : 		if (m_nLogFlag & LOG_FLAG_HOURLY) {

  00084	f7 46 74 00 04
	00 00		 test	 DWORD PTR [esi+116], 1024 ; 00000400H
  0008b	74 52		 je	 SHORT $LN6@checkChang

; 701  : 			_stprintf(szFile, _T("%s/%d/%s_%02d.%s"), m_pLogDir, gs_today_time.date, m_pLogName, gs_today_time.hour, m_szFileExtension);

  0008d	8d 46 68	 lea	 eax, DWORD PTR [esi+104]
  00090	50		 push	 eax
  00091	ff 35 0c 00 00
	00		 push	 DWORD PTR ?gs_today_time@@3USTTodayTime@@A+12
  00097	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _szFile$[ebp]
  0009d	ff 76 64	 push	 DWORD PTR [esi+100]
  000a0	ff 35 18 00 00
	00		 push	 DWORD PTR ?gs_today_time@@3USTTodayTime@@A+24
  000a6	ff 76 60	 push	 DWORD PTR [esi+96]
  000a9	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@CKAEJDPJ@?$CFs?1?$CFd?1?$CFs_?$CF02d?4?$CFs?$AA@
  000ae	50		 push	 eax
  000af	e8 00 00 00 00	 call	 _sprintf
  000b4	83 c4 1c	 add	 esp, 28			; 0000001cH

; 702  : 			__openLogger(szFile);

  000b7	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _szFile$[ebp]
  000bd	8b ce		 mov	 ecx, esi
  000bf	6a 00		 push	 0
  000c1	50		 push	 eax
  000c2	e8 00 00 00 00	 call	 ?__openLogger@CLogger@@AAEXPBDH@Z ; CLogger::__openLogger

; 703  : 			m_nSeq = 0;

  000c7	c7 46 78 00 00
	00 00		 mov	 DWORD PTR [esi+120], 0
  000ce	5e		 pop	 esi

; 711  : 		}
; 712  : 	}
; 713  : 
; 714  : 	// LOG_FLAG_FILE
; 715  : 	// no need to open a new file
; 716  : 
; 717  : }

  000cf	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d2	33 cd		 xor	 ecx, ebp
  000d4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d9	8b e5		 mov	 esp, ebp
  000db	5d		 pop	 ebp
  000dc	c2 04 00	 ret	 4
$LN6@checkChang:

; 704  : 			return;
; 705  : 		}
; 706  : 	}
; 707  : 	if(m_nSizeLimit) {

  000df	8b 86 80 00 00
	00		 mov	 eax, DWORD PTR [esi+128]
  000e5	85 c0		 test	 eax, eax
  000e7	74 18		 je	 SHORT $LN8@checkChang

; 708  : 		if (m_nSizeLimit < m_nLogSize) {

  000e9	3b 86 84 00 00
	00		 cmp	 eax, DWORD PTR [esi+132]
  000ef	73 10		 jae	 SHORT $LN8@checkChang

; 709  : 			m_nSeq++;

  000f1	ff 46 78	 inc	 DWORD PTR [esi+120]

; 710  : 			__openLogger(m_pFName, m_nSeq);

  000f4	8b ce		 mov	 ecx, esi
  000f6	ff 76 78	 push	 DWORD PTR [esi+120]
  000f9	ff 76 5c	 push	 DWORD PTR [esi+92]
  000fc	e8 00 00 00 00	 call	 ?__openLogger@CLogger@@AAEXPBDH@Z ; CLogger::__openLogger
$LN8@checkChang:

; 711  : 		}
; 712  : 	}
; 713  : 
; 714  : 	// LOG_FLAG_FILE
; 715  : 	// no need to open a new file
; 716  : 
; 717  : }

  00101	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00104	33 cd		 xor	 ecx, ebp
  00106	5e		 pop	 esi
  00107	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010c	8b e5		 mov	 esp, ebp
  0010e	5d		 pop	 ebp
  0010f	c2 04 00	 ret	 4
?checkChangeProc@CLogger@@QAEXH@Z ENDP			; CLogger::checkChangeProc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File e:\infinia-library-3.0\com\include\comlogger.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File e:\infinia-library-3.0\com\include\comlogger.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
;	COMDAT ?disable@CLogger@@QAEXXZ
_TEXT	SEGMENT
?disable@CLogger@@QAEXXZ PROC				; CLogger::disable, COMDAT
; _this$ = ecx

; 474  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File e:\infinia-library-3.0\com\include\comlogger.h

; 184  : 	inline void clearLogFlag(E_LOG_FLAG nFlag) { m_nLogFlag &= ~nFlag; }

  00003	81 66 74 ff ff
	f7 ff		 and	 DWORD PTR [esi+116], -524289 ; fff7ffffH
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 476  : 	if (m_hFile) {

  0000a	8b 4e 58	 mov	 ecx, DWORD PTR [esi+88]
  0000d	85 c9		 test	 ecx, ecx
  0000f	74 18		 je	 SHORT $LN2@disable
; File e:\infinia-library-3.0\com\include\comlogger.h

; 184  : 	inline void clearLogFlag(E_LOG_FLAG nFlag) { m_nLogFlag &= ~nFlag; }

  00011	81 66 74 ff ff
	fb ff		 and	 DWORD PTR [esi+116], -262145 ; fffbffffH
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 478  : 		fclose(m_hFile); m_hFile = NULL;

  00018	51		 push	 ecx
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  0001f	83 c4 04	 add	 esp, 4
  00022	c7 46 58 00 00
	00 00		 mov	 DWORD PTR [esi+88], 0
$LN2@disable:
  00029	5e		 pop	 esi

; 479  : 	}
; 480  : }

  0002a	c3		 ret	 0
?disable@CLogger@@QAEXXZ ENDP				; CLogger::disable
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\include\commemmanager.h
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\include\commemmanager.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File e:\infinia-library-3.0\com\include\comlogger.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File e:\infinia-library-3.0\com\include\comlogger.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
;	COMDAT ?WritePacket@CLogger@@QAEXHHHPADH@Z
_TEXT	SEGMENT
_fmtStr$ = -104						; size = 20
_this$GSCopy$1$ = -84					; size = 4
_szBuffer$GSCopy$1$ = -80				; size = 4
_$S1$1 = -76						; size = 8
_nKind$GSCopy$1$ = -72					; size = 4
_pBuf$1$ = -72						; size = 4
_header$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_nLevel$ = 8						; size = 4
_nKind$ = 12						; size = 4
_nSocket$ = 16						; size = 4
_szBuffer$ = 20						; size = 4
_nPacketSize$ = 24					; size = 4
?WritePacket@CLogger@@QAEXHHHPADH@Z PROC		; CLogger::WritePacket, COMDAT
; _this$ = ecx

; 569  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 570  : 	if (!isLogFlag(IS_LOG_ENABLE)) return;

  00010	8b 41 74	 mov	 eax, DWORD PTR [ecx+116]
  00013	53		 push	 ebx
  00014	8b 5d 0c	 mov	 ebx, DWORD PTR _nKind$[ebp]
  00017	c1 e8 13	 shr	 eax, 19			; 00000013H
  0001a	89 4d ac	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx
  0001d	89 5d b8	 mov	 DWORD PTR _nKind$GSCopy$1$[ebp], ebx
  00020	56		 push	 esi
  00021	8b 75 14	 mov	 esi, DWORD PTR _szBuffer$[ebp]
  00024	89 75 b0	 mov	 DWORD PTR _szBuffer$GSCopy$1$[ebp], esi
  00027	a8 01		 test	 al, 1
  00029	0f 84 24 01 00
	00		 je	 $LN17@WritePacke

; 571  : 	if (nLevel < m_nLogLevel) return;

  0002f	8b 45 08	 mov	 eax, DWORD PTR _nLevel$[ebp]
  00032	3b 41 4c	 cmp	 eax, DWORD PTR [ecx+76]
  00035	0f 8c 18 01 00
	00		 jl	 $LN17@WritePacke

; 572  : 
; 573  : 	TCHAR header[LEN_LOG_HEADER];
; 574  : 	const TCHAR	*fmtStr[5] = {
; 575  : 		_T(" nSIdx[%d] Send [%d] PKIdx[%d] "),

  0003b	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _fmtStr$[ebp], OFFSET ??_C@_0CA@JGBPHLEH@?5nSIdx?$FL?$CFd?$FN?5Send?5?$FL?$CFd?$FN?5PKIdx?$FL?$CFd?$FN?5?$AA@

; 576  : 		_T(" nSIdx[%d] Recv [%d] PKIdx[%d] "),

  00042	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _fmtStr$[ebp+4], OFFSET ??_C@_0CA@BFJJFPHN@?5nSIdx?$FL?$CFd?$FN?5Recv?5?$FL?$CFd?$FN?5PKIdx?$FL?$CFd?$FN?5?$AA@

; 577  : 		_T(" nSIdx[%d] send Queue [%d] PKIdx[%d] "),

  00049	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _fmtStr$[ebp+8], OFFSET ??_C@_0CG@LDDEIIP@?5nSIdx?$FL?$CFd?$FN?5send?5Queue?5?$FL?$CFd?$FN?5PKIdx@

; 578  : 		_T(" nSIdx[%d] recv Queue [%d] PKIdx[%d] "),

  00050	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _fmtStr$[ebp+12], OFFSET ??_C@_0CG@LBNCKJLO@?5nSIdx?$FL?$CFd?$FN?5recv?5Queue?5?$FL?$CFd?$FN?5PKIdx@

; 579  : 		_T(" Undefind nkind[%d] [%d] PKIdx[%d] ")

  00057	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _fmtStr$[ebp+16], OFFSET ??_C@_0CE@OJOMLNHA@?5Undefind?5nkind?$FL?$CFd?$FN?5?$FL?$CFd?$FN?5PKIdx?$FL?$CF@

; 580  : 	};
; 581  : 
; 582  : 	if (nKind < 0 || nKind > 4) nKind = 4;

  0005e	85 db		 test	 ebx, ebx
  00060	78 05		 js	 SHORT $LN7@WritePacke
  00062	83 fb 04	 cmp	 ebx, 4
  00065	7e 08		 jle	 SHORT $LN6@WritePacke
$LN7@WritePacke:
  00067	bb 04 00 00 00	 mov	 ebx, 4
  0006c	89 5d b8	 mov	 DWORD PTR _nKind$GSCopy$1$[ebp], ebx
$LN6@WritePacke:

; 583  : 
; 584  : 	int	i=0, nLCompare, nLen;
; 585  : 	nLen = setHeader(header, nLevel);

  0006f	57		 push	 edi
  00070	50		 push	 eax
  00071	8d 45 bc	 lea	 eax, DWORD PTR _header$[ebp]
  00074	50		 push	 eax
  00075	e8 00 00 00 00	 call	 ?setHeader@CLogger@@QAEHPADH@Z ; CLogger::setHeader

; 586  : 
; 587  : 
; 588  : 	nLen += _stprintf(header +nLen, fmtStr[nKind], nSocket, nPacketSize, nKind);

  0007a	53		 push	 ebx
  0007b	8b 5d 18	 mov	 ebx, DWORD PTR _nPacketSize$[ebp]
  0007e	8d 4d bc	 lea	 ecx, DWORD PTR _header$[ebp]
  00081	8b f8		 mov	 edi, eax
  00083	8b 45 b8	 mov	 eax, DWORD PTR _nKind$GSCopy$1$[ebp]
  00086	53		 push	 ebx
  00087	ff 75 10	 push	 DWORD PTR _nSocket$[ebp]
  0008a	03 cf		 add	 ecx, edi
  0008c	ff 74 85 98	 push	 DWORD PTR _fmtStr$[ebp+eax*4]
  00090	51		 push	 ecx
  00091	e8 00 00 00 00	 call	 _sprintf
  00096	83 c4 14	 add	 esp, 20			; 00000014H

; 589  : 	nLCompare = (int)_tcslen(szBuffer);

  00099	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  0009c	03 f8		 add	 edi, eax
  0009e	66 90		 npad	 2
$LL27@WritePacke:
  000a0	8a 06		 mov	 al, BYTE PTR [esi]
  000a2	46		 inc	 esi
  000a3	84 c0		 test	 al, al
  000a5	75 f9		 jne	 SHORT $LL27@WritePacke
  000a7	2b f1		 sub	 esi, ecx
; File e:\infinia-library-3.0\com\include\combufpool.h

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  000a9	b8 01 00 00 00	 mov	 eax, 1
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 591  : 	TCHAR *pBuf = (TCHAR *)gs_pMMgr->newBuf(LEN_TO_SIZE(nLen + nLCompare + 2));

  000ae	83 c6 02	 add	 esi, 2
  000b1	03 f7		 add	 esi, edi
; File e:\infinia-library-3.0\com\include\combufpool.h

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  000b3	8b d6		 mov	 edx, esi
; File e:\infinia-library-3.0\com\include\commemmanager.h

; 34   : 	inline char *newBuf(int nSize) { int nIdx = getIndex(nSize);  return __newBuf(nIdx, nSize); }

  000b5	56		 push	 esi
  000b6	66 0f 6e c6	 movd	 xmm0, esi
; File e:\infinia-library-3.0\com\include\combufpool.h

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  000ba	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  000be	f2 0f 11 45 b4	 movsd	 QWORD PTR _$S1$1[ebp], xmm0
  000c3	8b 4d b8	 mov	 ecx, DWORD PTR _$S1$1[ebp+4]
  000c6	c1 f9 14	 sar	 ecx, 20			; 00000014H
  000c9	81 e9 ff 03 00
	00		 sub	 ecx, 1023		; 000003ffH
  000cf	d3 e0		 shl	 eax, cl
  000d1	2b d0		 sub	 edx, eax
  000d3	23 d6		 and	 edx, esi
  000d5	f7 da		 neg	 edx
  000d7	1b d2		 sbb	 edx, edx
  000d9	f7 da		 neg	 edx
  000db	03 d1		 add	 edx, ecx
; File e:\infinia-library-3.0\com\include\commemmanager.h

; 34   : 	inline char *newBuf(int nSize) { int nIdx = getIndex(nSize);  return __newBuf(nIdx, nSize); }

  000dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pMMgr@@3PAVCMemManager@@A ; gs_pMMgr
  000e3	52		 push	 edx
  000e4	e8 00 00 00 00	 call	 ?__newBuf@CMemManager@@AAEPADHI@Z ; CMemManager::__newBuf
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 593  : 	_tcscpy(pBuf, header);

  000e9	8d 55 bc	 lea	 edx, DWORD PTR _header$[ebp]
  000ec	89 45 b8	 mov	 DWORD PTR _pBuf$1$[ebp], eax
  000ef	8b f0		 mov	 esi, eax
  000f1	8b ca		 mov	 ecx, edx
  000f3	2b f1		 sub	 esi, ecx
$LL9@WritePacke:
  000f5	8a 0a		 mov	 cl, BYTE PTR [edx]
  000f7	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  000fa	88 4c 16 ff	 mov	 BYTE PTR [esi+edx-1], cl
  000fe	84 c9		 test	 cl, cl
  00100	75 f3		 jne	 SHORT $LL9@WritePacke

; 594  : 
; 595  : 	while (nPacketSize--) {

  00102	85 db		 test	 ebx, ebx
  00104	74 2f		 je	 SHORT $LN21@WritePacke
  00106	8b 75 b0	 mov	 esi, DWORD PTR _szBuffer$GSCopy$1$[ebp]
  00109	0f 1f 80 00 00
	00 00		 npad	 7
$LL2@WritePacke:

; 596  : 		_stprintf(pBuf+nLen, _T("%02x "), szBuffer[i] & 0x0ff);

  00110	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00113	50		 push	 eax
  00114	8b 45 b8	 mov	 eax, DWORD PTR _pBuf$1$[ebp]
  00117	03 c7		 add	 eax, edi
  00119	68 00 00 00 00	 push	 OFFSET ??_C@_05CNDJFPDP@?$CF02x?5?$AA@
  0011e	50		 push	 eax
  0011f	e8 00 00 00 00	 call	 _sprintf
  00124	83 c4 0c	 add	 esp, 12			; 0000000cH

; 597  : 		nLen += 3; i++;

  00127	8d 76 01	 lea	 esi, DWORD PTR [esi+1]
  0012a	83 c7 03	 add	 edi, 3
  0012d	83 eb 01	 sub	 ebx, 1
  00130	75 de		 jne	 SHORT $LL2@WritePacke
  00132	8b 45 b8	 mov	 eax, DWORD PTR _pBuf$1$[ebp]
$LN21@WritePacke:
; File e:\infinia-library-3.0\com\include\comlogger.h

; 207  : 	void putQueue(TCHAR *p) { if (m_sLogQueue.push(p)) m_pCondition->signal(); }

  00135	8b 75 ac	 mov	 esi, DWORD PTR _this$GSCopy$1$[ebp]
  00138	8b ce		 mov	 ecx, esi
  0013a	50		 push	 eax
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 599  : 	pBuf[nLen] = '\n';

  0013b	66 c7 04 38 0a
	00		 mov	 WORD PTR [eax+edi], 10	; 0000000aH
; File e:\infinia-library-3.0\com\include\comlogger.h

; 207  : 	void putQueue(TCHAR *p) { if (m_sLogQueue.push(p)) m_pCondition->signal(); }

  00141	e8 00 00 00 00	 call	 ?push@CQueueS@@QAE_NPAX@Z ; CQueueS::push
  00146	5f		 pop	 edi
  00147	84 c0		 test	 al, al
  00149	74 08		 je	 SHORT $LN17@WritePacke
  0014b	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  0014e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00150	ff 50 04	 call	 DWORD PTR [eax+4]
$LN17@WritePacke:
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 603  : }

  00153	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00156	5e		 pop	 esi
  00157	33 cd		 xor	 ecx, ebp
  00159	5b		 pop	 ebx
  0015a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015f	8b e5		 mov	 esp, ebp
  00161	5d		 pop	 ebp
  00162	c2 14 00	 ret	 20			; 00000014H
?WritePacket@CLogger@@QAEXHHHPADH@Z ENDP		; CLogger::WritePacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\include\commemmanager.h
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\include\commemmanager.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
;	COMDAT ?LogPrint@CLogger@@QAAXHPBDZZ
_TEXT	SEGMENT
_$S1$1 = -8716						; size = 8
_msgBuf$ = -8708					; size = 8192
_header$ = -516						; size = 512
__$ArrayPad$ = -4					; size = 4
_this$ = 8						; size = 4
_level$ = 12						; size = 4
__szFormat$ = 16					; size = 4
?LogPrint@CLogger@@QAAXHPBDZZ PROC			; CLogger::LogPrint, COMDAT

; 542  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 0c 22 00 00	 mov	 eax, 8716		; 0000220cH
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	57		 push	 edi
  00018	8b 7d 08	 mov	 edi, DWORD PTR _this$[ebp]

; 543  : 	if (!isLogFlag(IS_LOG_ENABLE)) return;

  0001b	8b 47 74	 mov	 eax, DWORD PTR [edi+116]
  0001e	c1 e8 13	 shr	 eax, 19			; 00000013H
  00021	a8 01		 test	 al, 1
  00023	0f 84 e4 00 00
	00		 je	 $LN1@LogPrint

; 544  : 	if (level < m_nLogLevel) return;

  00029	8b 45 0c	 mov	 eax, DWORD PTR _level$[ebp]
  0002c	3b 47 4c	 cmp	 eax, DWORD PTR [edi+76]
  0002f	0f 8c d8 00 00
	00		 jl	 $LN1@LogPrint

; 545  : 
; 546  : //	char tmpBuf[512];
; 547  : 	int nLen;
; 548  : 
; 549  : 	TCHAR	msgBuf[MAX_LOGBUF_LEN];
; 550  : 	TCHAR	header[512];
; 551  : 	va_list	ap;
; 552  : 
; 553  : 	nLen = setHeader(header, level);

  00035	53		 push	 ebx
  00036	56		 push	 esi
  00037	50		 push	 eax
  00038	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  0003e	8b cf		 mov	 ecx, edi
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ?setHeader@CLogger@@QAEHPADH@Z ; CLogger::setHeader

; 554  : 	sprintf(header + nLen, " %s ", _szFormat);

  00046	ff 75 10	 push	 DWORD PTR __szFormat$[ebp]
  00049	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _header$[ebp]
  0004f	03 c1		 add	 eax, ecx
  00051	68 00 00 00 00	 push	 OFFSET ??_C@_04KMMDIKEB@?5?$CFs?5?$AA@
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 _sprintf
  0005c	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h

; 1436 :     int const _Result = __stdio_common_vsprintf(

  0005f	8d 45 14	 lea	 eax, DWORD PTR __szFormat$[ebp+4]
  00062	50		 push	 eax
  00063	6a 00		 push	 0
  00065	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  0006b	50		 push	 eax
  0006c	8d 85 fc dd ff
	ff		 lea	 eax, DWORD PTR _msgBuf$[ebp]
  00072	68 ff 1f 00 00	 push	 8191			; 00001fffH
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0007d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007f	ff 70 04	 push	 DWORD PTR [eax+4]
  00082	83 c9 02	 or	 ecx, 2
  00085	51		 push	 ecx
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf
  0008c	8b d8		 mov	 ebx, eax
  0008e	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1437 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1438 :         _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1439 : 
; 1440 :     return _Result < 0 ? -1 : _Result;

  00091	83 c8 ff	 or	 eax, -1
  00094	85 db		 test	 ebx, ebx
  00096	0f 48 d8	 cmovs	 ebx, eax
; File e:\infinia-library-3.0\com\include\combufpool.h

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  00099	b8 01 00 00 00	 mov	 eax, 1
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 559  : 	TCHAR *pBuf = (TCHAR *)gs_pMMgr->newBuf(LEN_TO_SIZE(nLen + 2));

  0009e	8d 73 02	 lea	 esi, DWORD PTR [ebx+2]
  000a1	66 0f 6e c6	 movd	 xmm0, esi
; File e:\infinia-library-3.0\com\include\combufpool.h

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  000a5	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
; File e:\infinia-library-3.0\com\include\commemmanager.h

; 34   : 	inline char *newBuf(int nSize) { int nIdx = getIndex(nSize);  return __newBuf(nIdx, nSize); }

  000a9	56		 push	 esi
; File e:\infinia-library-3.0\com\include\combufpool.h

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  000aa	f2 0f 11 85 f4
	dd ff ff	 movsd	 QWORD PTR _$S1$1[ebp], xmm0
  000b2	8b 95 f8 dd ff
	ff		 mov	 edx, DWORD PTR _$S1$1[ebp+4]
  000b8	c1 fa 14	 sar	 edx, 20			; 00000014H
  000bb	81 ea ff 03 00
	00		 sub	 edx, 1023		; 000003ffH
  000c1	8b ca		 mov	 ecx, edx
  000c3	d3 e0		 shl	 eax, cl
  000c5	8b ce		 mov	 ecx, esi
  000c7	2b c8		 sub	 ecx, eax
  000c9	23 ce		 and	 ecx, esi
  000cb	f7 d9		 neg	 ecx
  000cd	1b c9		 sbb	 ecx, ecx
  000cf	f7 d9		 neg	 ecx
  000d1	03 ca		 add	 ecx, edx
; File e:\infinia-library-3.0\com\include\commemmanager.h

; 34   : 	inline char *newBuf(int nSize) { int nIdx = getIndex(nSize);  return __newBuf(nIdx, nSize); }

  000d3	51		 push	 ecx
  000d4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pMMgr@@3PAVCMemManager@@A ; gs_pMMgr
  000da	e8 00 00 00 00	 call	 ?__newBuf@CMemManager@@AAEPADHI@Z ; CMemManager::__newBuf
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 560  : 	_tcscpy(pBuf, msgBuf);

  000df	8d b5 fc dd ff
	ff		 lea	 esi, DWORD PTR _msgBuf$[ebp]
  000e5	8b c8		 mov	 ecx, eax
  000e7	8b d6		 mov	 edx, esi
  000e9	2b ca		 sub	 ecx, edx
  000eb	0f 1f 44 00 00	 npad	 5
$LL5@LogPrint:
  000f0	8a 16		 mov	 dl, BYTE PTR [esi]
  000f2	8d 76 01	 lea	 esi, DWORD PTR [esi+1]
  000f5	88 54 31 ff	 mov	 BYTE PTR [ecx+esi-1], dl
  000f9	84 d2		 test	 dl, dl
  000fb	75 f3		 jne	 SHORT $LL5@LogPrint

; 561  : 	pBuf[nLen] = '\n';
; 562  : 	pBuf[nLen + 1] = 0;
; 563  : 
; 564  : 	LogPrint(pBuf);

  000fd	50		 push	 eax
  000fe	8b cf		 mov	 ecx, edi
  00100	66 c7 04 18 0a
	00		 mov	 WORD PTR [eax+ebx], 10	; 0000000aH
  00106	e8 00 00 00 00	 call	 ?LogPrint@CLogger@@QAEXPAD@Z ; CLogger::LogPrint
  0010b	5e		 pop	 esi
  0010c	5b		 pop	 ebx
$LN1@LogPrint:

; 565  : }

  0010d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00110	33 cd		 xor	 ecx, ebp
  00112	5f		 pop	 edi
  00113	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00118	8b e5		 mov	 esp, ebp
  0011a	5d		 pop	 ebp
  0011b	c3		 ret	 0
?LogPrint@CLogger@@QAAXHPBDZZ ENDP			; CLogger::LogPrint
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comlogger.cpp
;	COMDAT ?LogPrint@CLogger@@QAEXPAD@Z
_TEXT	SEGMENT
_pLog$ = 8						; size = 4
?LogPrint@CLogger@@QAEXPAD@Z PROC			; CLogger::LogPrint, COMDAT
; _this$ = ecx

; 483  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 484  : 	if (m_fpDataProc) m_fpDataProc(pLog, m_pObj);

  00007	8b 7d 08	 mov	 edi, DWORD PTR _pLog$[ebp]
  0000a	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  0000d	85 c0		 test	 eax, eax
  0000f	74 09		 je	 SHORT $LN2@LogPrint
  00011	ff 76 48	 push	 DWORD PTR [esi+72]
  00014	57		 push	 edi
  00015	ff d0		 call	 eax
  00017	83 c4 08	 add	 esp, 8
$LN2@LogPrint:

; 485  : 	if (m_hFile) {

  0001a	83 7e 58 00	 cmp	 DWORD PTR [esi+88], 0
  0001e	74 31		 je	 SHORT $LN5@LogPrint

; 486  : 		if (m_nLogFlag & IS_PRINT) _tprintf(pLog);

  00020	f7 46 74 00 20
	00 00		 test	 DWORD PTR [esi+116], 8192 ; 00002000H
  00027	74 09		 je	 SHORT $LN4@LogPrint
  00029	57		 push	 edi
  0002a	e8 00 00 00 00	 call	 _printf
  0002f	83 c4 04	 add	 esp, 4
$LN4@LogPrint:

; 487  : 		if (isLogFlag(IS_LOG_OPEN)) {

  00032	8b 46 74	 mov	 eax, DWORD PTR [esi+116]
  00035	c1 e8 12	 shr	 eax, 18			; 00000012H
  00038	a8 01		 test	 al, 1
  0003a	74 15		 je	 SHORT $LN5@LogPrint

; 488  : 			_ftprintf(m_hFile, pLog);

  0003c	57		 push	 edi
  0003d	ff 76 58	 push	 DWORD PTR [esi+88]
  00040	e8 00 00 00 00	 call	 _fprintf

; 489  : 			fflush(m_hFile);

  00045	ff 76 58	 push	 DWORD PTR [esi+88]
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fflush
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@LogPrint:
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi

; 490  : 		}
; 491  : 		//else {
; 492  : 		//	//m_cLock.enter();
; 493  : 		//	_ftprintf(m_hFile, pLog);
; 494  : 		//	fflush(m_hFile);
; 495  : 		//	//m_cLock.leave();
; 496  : 		//}
; 497  : 
; 498  : 	}
; 499  : }

  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
?LogPrint@CLogger@@QAEXPAD@Z ENDP			; CLogger::LogPrint
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File e:\infinia-library-3.0\com\include\comlogger.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
;	COMDAT ?Log@CLogger@@QAEXHPBD00_N@Z
_TEXT	SEGMENT
_totlen$1$ = -8216					; size = 4
tv449 = -8212						; size = 4
_this$GSCopy$1$ = -8208					; size = 4
tv443 = -8204						; size = 4
_pBuf$1$ = -8204					; size = 4
_headerLen$1$ = -8200					; size = 4
_headerBuf$ = -8196					; size = 8192
__$ArrayPad$ = -4					; size = 4
_level$ = 8						; size = 4
_body$ = 12						; size = 4
_header$ = 16						; size = 4
_tail$ = 20						; size = 4
_bToFile$ = 24						; size = 1
?Log@CLogger@@QAEXHPBD00_N@Z PROC			; CLogger::Log, COMDAT
; _this$ = ecx

; 502  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 18 20 00 00	 mov	 eax, 8216		; 00002018H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 503  : 	if (!isLogFlag(IS_LOG_ENABLE)) return;

  00017	8b 41 74	 mov	 eax, DWORD PTR [ecx+116]
  0001a	53		 push	 ebx
  0001b	8b 5d 10	 mov	 ebx, DWORD PTR _header$[ebp]
  0001e	56		 push	 esi
  0001f	8b 75 0c	 mov	 esi, DWORD PTR _body$[ebp]
  00022	c1 e8 13	 shr	 eax, 19			; 00000013H
  00025	89 8d f0 df ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx
  0002b	57		 push	 edi
  0002c	8b 7d 14	 mov	 edi, DWORD PTR _tail$[ebp]
  0002f	a8 01		 test	 al, 1
  00031	0f 84 91 01 00
	00		 je	 $LN18@Log

; 504  : 	if (level < m_nLogLevel) return;

  00037	8b 45 08	 mov	 eax, DWORD PTR _level$[ebp]
  0003a	3b 41 4c	 cmp	 eax, DWORD PTR [ecx+76]
  0003d	0f 8c 85 01 00
	00		 jl	 $LN18@Log

; 505  : 
; 506  : 	int headerLen, bodyLen=0, totlen=0;
; 507  : 
; 508  : 	TCHAR    headerBuf[MAX_LOGBUF_LEN];
; 509  : 	TCHAR *pBuf;
; 510  : 
; 511  : 	headerLen = setHeader(headerBuf, level);

  00043	50		 push	 eax
  00044	8d 85 fc df ff
	ff		 lea	 eax, DWORD PTR _headerBuf$[ebp]
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 ?setHeader@CLogger@@QAEHPADH@Z ; CLogger::setHeader
  00050	8b d0		 mov	 edx, eax
  00052	89 95 f8 df ff
	ff		 mov	 DWORD PTR _headerLen$1$[ebp], edx

; 512  : 
; 513  : 	// calculate total length ----------------
; 514  : 	if (header) {

  00058	85 db		 test	 ebx, ebx
  0005a	74 32		 je	 SHORT $LN4@Log

; 515  : 		_tcscpy(headerBuf + headerLen, header); headerLen += (int)_tcslen(header);;

  0005c	8d 94 15 fc df
	ff ff		 lea	 edx, DWORD PTR _headerBuf$[ebp+edx]
  00063	8b cb		 mov	 ecx, ebx
  00065	2b d3		 sub	 edx, ebx
$LL9@Log:
  00067	8a 01		 mov	 al, BYTE PTR [ecx]
  00069	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  0006c	88 44 0a ff	 mov	 BYTE PTR [edx+ecx-1], al
  00070	84 c0		 test	 al, al
  00072	75 f3		 jne	 SHORT $LL9@Log
  00074	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
$LL38@Log:
  00077	8a 03		 mov	 al, BYTE PTR [ebx]
  00079	43		 inc	 ebx
  0007a	84 c0		 test	 al, al
  0007c	75 f9		 jne	 SHORT $LL38@Log
  0007e	8b 95 f8 df ff
	ff		 mov	 edx, DWORD PTR _headerLen$1$[ebp]
  00084	2b d9		 sub	 ebx, ecx
  00086	03 d3		 add	 edx, ebx
  00088	89 95 f8 df ff
	ff		 mov	 DWORD PTR _headerLen$1$[ebp], edx
$LN4@Log:

; 516  : 	}
; 517  : 	bodyLen = (int)_tcslen(body);

  0008e	8b de		 mov	 ebx, esi
  00090	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
$LL39@Log:
  00093	8a 03		 mov	 al, BYTE PTR [ebx]
  00095	43		 inc	 ebx
  00096	84 c0		 test	 al, al
  00098	75 f9		 jne	 SHORT $LL39@Log
  0009a	2b d9		 sub	 ebx, ecx

; 518  : 	if (tail) { 

  0009c	85 ff		 test	 edi, edi
  0009e	0f 84 99 00 00
	00		 je	 $LN5@Log

; 519  : 		totlen = headerLen + bodyLen + (int)_tcslen(tail);

  000a4	8b cf		 mov	 ecx, edi
  000a6	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  000a9	89 85 f4 df ff
	ff		 mov	 DWORD PTR tv443[ebp], eax
  000af	90		 npad	 1
$LL40@Log:
  000b0	8a 01		 mov	 al, BYTE PTR [ecx]
  000b2	41		 inc	 ecx
  000b3	84 c0		 test	 al, al
  000b5	75 f9		 jne	 SHORT $LL40@Log
  000b7	2b 8d f4 df ff
	ff		 sub	 ecx, DWORD PTR tv443[ebp]
  000bd	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]

; 520  : 		pBuf = (TCHAR *)gs_pMMgr->newBuf(LEN_TO_SIZE(totlen + 2));

  000c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pMMgr@@3PAVCMemManager@@A ; gs_pMMgr
  000c6	03 c3		 add	 eax, ebx
  000c8	89 85 e8 df ff
	ff		 mov	 DWORD PTR _totlen$1$[ebp], eax
  000ce	83 c0 02	 add	 eax, 2
  000d1	50		 push	 eax
  000d2	e8 00 00 00 00	 call	 ?newBuf@CMemManager@@QAEPADH@Z ; CMemManager::newBuf

; 521  : 		_tcscpy(pBuf, headerBuf);

  000d7	8b c8		 mov	 ecx, eax
  000d9	89 85 f4 df ff
	ff		 mov	 DWORD PTR _pBuf$1$[ebp], eax
  000df	8d 95 fc df ff
	ff		 lea	 edx, DWORD PTR _headerBuf$[ebp]
  000e5	8b c2		 mov	 eax, edx
  000e7	2b c8		 sub	 ecx, eax
  000e9	89 8d ec df ff
	ff		 mov	 DWORD PTR tv449[ebp], ecx
  000ef	8b c1		 mov	 eax, ecx
$LL10@Log:
  000f1	8a 0a		 mov	 cl, BYTE PTR [edx]
  000f3	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  000f6	88 4c 10 ff	 mov	 BYTE PTR [eax+edx-1], cl
  000fa	84 c9		 test	 cl, cl
  000fc	75 f3		 jne	 SHORT $LL10@Log

; 522  : 		_tcscpy(pBuf + headerLen, body);

  000fe	8b 95 f4 df ff
	ff		 mov	 edx, DWORD PTR _pBuf$1$[ebp]
  00104	03 95 f8 df ff
	ff		 add	 edx, DWORD PTR _headerLen$1$[ebp]
  0010a	8b ca		 mov	 ecx, edx
  0010c	2b ce		 sub	 ecx, esi
  0010e	66 90		 npad	 2
$LL11@Log:
  00110	8a 06		 mov	 al, BYTE PTR [esi]
  00112	8d 76 01	 lea	 esi, DWORD PTR [esi+1]
  00115	88 44 31 ff	 mov	 BYTE PTR [ecx+esi-1], al
  00119	84 c0		 test	 al, al
  0011b	75 f3		 jne	 SHORT $LL11@Log

; 523  : 		_tcscpy(pBuf + headerLen + bodyLen, tail);

  0011d	8d 0c 1a	 lea	 ecx, DWORD PTR [edx+ebx]
  00120	2b cf		 sub	 ecx, edi
$LL12@Log:
  00122	8a 07		 mov	 al, BYTE PTR [edi]
  00124	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  00127	88 44 39 ff	 mov	 BYTE PTR [ecx+edi-1], al
  0012b	84 c0		 test	 al, al
  0012d	75 f3		 jne	 SHORT $LL12@Log

; 524  : 	}
; 525  : 	else {

  0012f	8b 9d f4 df ff
	ff		 mov	 ebx, DWORD PTR _pBuf$1$[ebp]
  00135	8b bd e8 df ff
	ff		 mov	 edi, DWORD PTR _totlen$1$[ebp]
  0013b	eb 47		 jmp	 SHORT $LN6@Log
$LN5@Log:

; 526  : 		totlen = headerLen + bodyLen;
; 527  : 		pBuf = (TCHAR *)gs_pMMgr->newBuf(LEN_TO_SIZE(totlen + 2));

  0013d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pMMgr@@3PAVCMemManager@@A ; gs_pMMgr
  00143	8d 3c 1a	 lea	 edi, DWORD PTR [edx+ebx]
  00146	8d 47 02	 lea	 eax, DWORD PTR [edi+2]
  00149	50		 push	 eax
  0014a	e8 00 00 00 00	 call	 ?newBuf@CMemManager@@QAEPADH@Z ; CMemManager::newBuf
  0014f	8b d8		 mov	 ebx, eax

; 528  : 		_tcscpy(pBuf, headerBuf);

  00151	8d 8d fc df ff
	ff		 lea	 ecx, DWORD PTR _headerBuf$[ebp]
  00157	8b d3		 mov	 edx, ebx
  00159	8b c1		 mov	 eax, ecx
  0015b	2b d0		 sub	 edx, eax
  0015d	0f 1f 00	 npad	 3
$LL13@Log:
  00160	8a 01		 mov	 al, BYTE PTR [ecx]
  00162	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00165	88 44 0a ff	 mov	 BYTE PTR [edx+ecx-1], al
  00169	84 c0		 test	 al, al
  0016b	75 f3		 jne	 SHORT $LL13@Log

; 529  : 		_tcscpy(pBuf + headerLen, body);

  0016d	8b 8d f8 df ff
	ff		 mov	 ecx, DWORD PTR _headerLen$1$[ebp]
  00173	03 cb		 add	 ecx, ebx
  00175	2b ce		 sub	 ecx, esi
$LL14@Log:
  00177	8a 06		 mov	 al, BYTE PTR [esi]
  00179	8d 76 01	 lea	 esi, DWORD PTR [esi+1]
  0017c	88 44 31 ff	 mov	 BYTE PTR [ecx+esi-1], al
  00180	84 c0		 test	 al, al
  00182	75 f3		 jne	 SHORT $LL14@Log
$LN6@Log:

; 530  : 	}
; 531  : 	// calcuate end -------------------------
; 532  : 
; 533  : 	pBuf[totlen] = '\n';
; 534  : 	pBuf[totlen+1] = 0;
; 535  : 	if (bToFile) {

  00184	80 7d 18 00	 cmp	 BYTE PTR _bToFile$[ebp], 0
  00188	66 c7 04 3b 0a
	00		 mov	 WORD PTR [ebx+edi], 10	; 0000000aH

; 536  : 		LogPrint(pBuf); return;

  0018e	53		 push	 ebx
  0018f	74 1e		 je	 SHORT $LN7@Log
  00191	8b 8d f0 df ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00197	e8 00 00 00 00	 call	 ?LogPrint@CLogger@@QAEXPAD@Z ; CLogger::LogPrint
  0019c	5f		 pop	 edi
  0019d	5e		 pop	 esi
  0019e	5b		 pop	 ebx

; 539  : }

  0019f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a2	33 cd		 xor	 ecx, ebp
  001a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a9	8b e5		 mov	 esp, ebp
  001ab	5d		 pop	 ebp
  001ac	c2 14 00	 ret	 20			; 00000014H
$LN7@Log:
; File e:\infinia-library-3.0\com\include\comlogger.h

; 207  : 	void putQueue(TCHAR *p) { if (m_sLogQueue.push(p)) m_pCondition->signal(); }

  001af	8b b5 f0 df ff
	ff		 mov	 esi, DWORD PTR _this$GSCopy$1$[ebp]
  001b5	8b ce		 mov	 ecx, esi
  001b7	e8 00 00 00 00	 call	 ?push@CQueueS@@QAE_NPAX@Z ; CQueueS::push
  001bc	84 c0		 test	 al, al
  001be	74 08		 je	 SHORT $LN18@Log
  001c0	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  001c3	8b 01		 mov	 eax, DWORD PTR [ecx]
  001c5	ff 50 04	 call	 DWORD PTR [eax+4]
$LN18@Log:
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 539  : }

  001c8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001cb	5f		 pop	 edi
  001cc	5e		 pop	 esi
  001cd	33 cd		 xor	 ecx, ebp
  001cf	5b		 pop	 ebx
  001d0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001d5	8b e5		 mov	 esp, ebp
  001d7	5d		 pop	 ebp
  001d8	c2 14 00	 ret	 20			; 00000014H
?Log@CLogger@@QAEXHPBD00_N@Z ENDP			; CLogger::Log
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\include\commemmanager.h
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\include\commemmanager.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File e:\infinia-library-3.0\com\include\comlogger.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File e:\infinia-library-3.0\com\include\comlogger.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
;	COMDAT ?PutLogQueue@CLogger@@QAEXHPAD@Z
_TEXT	SEGMENT
_nLen$1$ = -532						; size = 4
_$S1$1 = -528						; size = 8
_pBuf$1$ = -524						; size = 4
_nLen2$1$ = -520					; size = 4
_header$ = -516						; size = 512
__$ArrayPad$ = -4					; size = 4
_level$ = 8						; size = 4
_pBody$ = 12						; size = 4
?PutLogQueue@CLogger@@QAEXHPAD@Z PROC			; CLogger::PutLogQueue, COMDAT
; _this$ = ecx

; 667  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 02 00
	00		 sub	 esp, 532		; 00000214H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b d9		 mov	 ebx, ecx
  00016	57		 push	 edi
  00017	8b 7d 0c	 mov	 edi, DWORD PTR _pBody$[ebp]

; 668  : 	if (!isLogFlag(IS_LOG_ENABLE)) return;

  0001a	8b 43 74	 mov	 eax, DWORD PTR [ebx+116]
  0001d	c1 e8 13	 shr	 eax, 19			; 00000013H
  00020	a8 01		 test	 al, 1
  00022	0f 84 db 00 00
	00		 je	 $LN14@PutLogQueu

; 669  : 	if (level < m_nLogLevel) return;

  00028	8b 45 08	 mov	 eax, DWORD PTR _level$[ebp]
  0002b	3b 43 4c	 cmp	 eax, DWORD PTR [ebx+76]
  0002e	0f 8c cf 00 00
	00		 jl	 $LN14@PutLogQueu

; 670  : 	
; 671  : 	TCHAR	header[512];
; 672  : 
; 673  : 	int nLen2	= setHeader(header, level);

  00034	56		 push	 esi
  00035	50		 push	 eax
  00036	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ?setHeader@CLogger@@QAEHPADH@Z ; CLogger::setHeader

; 674  : 	int nLen = (int)_tcslen(pBody) + nLen2;

  00042	8b d7		 mov	 edx, edi
  00044	89 85 f8 fd ff
	ff		 mov	 DWORD PTR _nLen2$1$[ebp], eax
  0004a	8d 72 01	 lea	 esi, DWORD PTR [edx+1]
  0004d	0f 1f 00	 npad	 3
$LL22@PutLogQueu:
  00050	8a 0a		 mov	 cl, BYTE PTR [edx]
  00052	42		 inc	 edx
  00053	84 c9		 test	 cl, cl
  00055	75 f9		 jne	 SHORT $LL22@PutLogQueu
  00057	2b d6		 sub	 edx, esi
  00059	03 c2		 add	 eax, edx
  0005b	89 85 ec fd ff
	ff		 mov	 DWORD PTR _nLen$1$[ebp], eax

; 675  : 
; 676  : 	TCHAR *pBuf = (TCHAR *)gs_pMMgr->newBuf(LEN_TO_SIZE(nLen + 2));

  00061	8d 70 02	 lea	 esi, DWORD PTR [eax+2]
; File e:\infinia-library-3.0\com\include\combufpool.h

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  00064	b8 01 00 00 00	 mov	 eax, 1
  00069	66 0f 6e c6	 movd	 xmm0, esi
  0006d	8b d6		 mov	 edx, esi
  0006f	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
; File e:\infinia-library-3.0\com\include\commemmanager.h

; 34   : 	inline char *newBuf(int nSize) { int nIdx = getIndex(nSize);  return __newBuf(nIdx, nSize); }

  00073	56		 push	 esi
; File e:\infinia-library-3.0\com\include\combufpool.h

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  00074	f2 0f 11 85 f0
	fd ff ff	 movsd	 QWORD PTR _$S1$1[ebp], xmm0
  0007c	8b 8d f4 fd ff
	ff		 mov	 ecx, DWORD PTR _$S1$1[ebp+4]
  00082	c1 f9 14	 sar	 ecx, 20			; 00000014H
  00085	81 e9 ff 03 00
	00		 sub	 ecx, 1023		; 000003ffH
  0008b	d3 e0		 shl	 eax, cl
  0008d	2b d0		 sub	 edx, eax
  0008f	23 d6		 and	 edx, esi
  00091	f7 da		 neg	 edx
  00093	1b d2		 sbb	 edx, edx
  00095	f7 da		 neg	 edx
  00097	03 d1		 add	 edx, ecx
; File e:\infinia-library-3.0\com\include\commemmanager.h

; 34   : 	inline char *newBuf(int nSize) { int nIdx = getIndex(nSize);  return __newBuf(nIdx, nSize); }

  00099	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pMMgr@@3PAVCMemManager@@A ; gs_pMMgr
  0009f	52		 push	 edx
  000a0	e8 00 00 00 00	 call	 ?__newBuf@CMemManager@@AAEPADHI@Z ; CMemManager::__newBuf
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 677  : 	_tcscpy(pBuf, header);

  000a5	8d 95 fc fd ff
	ff		 lea	 edx, DWORD PTR _header$[ebp]
  000ab	89 85 f4 fd ff
	ff		 mov	 DWORD PTR _pBuf$1$[ebp], eax
  000b1	8b f0		 mov	 esi, eax
  000b3	8b ca		 mov	 ecx, edx
  000b5	2b f1		 sub	 esi, ecx
$LL5@PutLogQueu:
  000b7	8a 0a		 mov	 cl, BYTE PTR [edx]
  000b9	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  000bc	88 4c 16 ff	 mov	 BYTE PTR [esi+edx-1], cl
  000c0	84 c9		 test	 cl, cl
  000c2	75 f3		 jne	 SHORT $LL5@PutLogQueu

; 678  : 	_tcscpy(pBuf + nLen2, pBody);

  000c4	8b 8d f8 fd ff
	ff		 mov	 ecx, DWORD PTR _nLen2$1$[ebp]
  000ca	03 c8		 add	 ecx, eax
  000cc	2b cf		 sub	 ecx, edi
  000ce	5e		 pop	 esi
  000cf	90		 npad	 1
$LL6@PutLogQueu:
  000d0	8a 07		 mov	 al, BYTE PTR [edi]
  000d2	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  000d5	88 44 39 ff	 mov	 BYTE PTR [ecx+edi-1], al
  000d9	84 c0		 test	 al, al
  000db	75 f3		 jne	 SHORT $LL6@PutLogQueu

; 679  : 	pBuf[nLen] = '\n';

  000dd	8b 85 f4 fd ff
	ff		 mov	 eax, DWORD PTR _pBuf$1$[ebp]
  000e3	8b 8d ec fd ff
	ff		 mov	 ecx, DWORD PTR _nLen$1$[ebp]
; File e:\infinia-library-3.0\com\include\comlogger.h

; 207  : 	void putQueue(TCHAR *p) { if (m_sLogQueue.push(p)) m_pCondition->signal(); }

  000e9	50		 push	 eax
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 679  : 	pBuf[nLen] = '\n';

  000ea	66 c7 04 08 0a
	00		 mov	 WORD PTR [eax+ecx], 10	; 0000000aH
; File e:\infinia-library-3.0\com\include\comlogger.h

; 207  : 	void putQueue(TCHAR *p) { if (m_sLogQueue.push(p)) m_pCondition->signal(); }

  000f0	8b cb		 mov	 ecx, ebx
  000f2	e8 00 00 00 00	 call	 ?push@CQueueS@@QAE_NPAX@Z ; CQueueS::push
  000f7	84 c0		 test	 al, al
  000f9	74 08		 je	 SHORT $LN14@PutLogQueu
  000fb	8b 4b 44	 mov	 ecx, DWORD PTR [ebx+68]
  000fe	8b 01		 mov	 eax, DWORD PTR [ecx]
  00100	ff 50 04	 call	 DWORD PTR [eax+4]
$LN14@PutLogQueu:
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 682  : }

  00103	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00106	5f		 pop	 edi
  00107	33 cd		 xor	 ecx, ebp
  00109	5b		 pop	 ebx
  0010a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010f	8b e5		 mov	 esp, ebp
  00111	5d		 pop	 ebp
  00112	c2 08 00	 ret	 8
?PutLogQueue@CLogger@@QAEXHPAD@Z ENDP			; CLogger::PutLogQueue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\include\commemmanager.h
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\include\commemmanager.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File e:\infinia-library-3.0\com\include\comlogger.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File e:\infinia-library-3.0\com\include\comlogger.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
;	COMDAT ?PutLogQueue@CLogger@@QAAXHPBDZZ
_TEXT	SEGMENT
_$S1$1 = -8716						; size = 8
_msgBuf$ = -8708					; size = 8192
_header$ = -516						; size = 512
__$ArrayPad$ = -4					; size = 4
_this$ = 8						; size = 4
_level$ = 12						; size = 4
__szFormat$ = 16					; size = 4
?PutLogQueue@CLogger@@QAAXHPBDZZ PROC			; CLogger::PutLogQueue, COMDAT

; 644  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 0c 22 00 00	 mov	 eax, 8716		; 0000220cH
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	57		 push	 edi
  00018	8b 7d 08	 mov	 edi, DWORD PTR _this$[ebp]

; 645  : 	if (!isLogFlag(IS_LOG_ENABLE)) return;

  0001b	8b 47 74	 mov	 eax, DWORD PTR [edi+116]
  0001e	c1 e8 13	 shr	 eax, 19			; 00000013H
  00021	a8 01		 test	 al, 1
  00023	0f 84 f0 00 00
	00		 je	 $LN19@PutLogQueu

; 646  : 	if (level < m_nLogLevel) return;

  00029	8b 45 0c	 mov	 eax, DWORD PTR _level$[ebp]
  0002c	3b 47 4c	 cmp	 eax, DWORD PTR [edi+76]
  0002f	0f 8c e4 00 00
	00		 jl	 $LN19@PutLogQueu

; 647  : 
; 648  : 	int nLen;
; 649  : 
; 650  : 	TCHAR	msgBuf[MAX_LOGBUF_LEN];
; 651  : 	TCHAR	header[512];
; 652  : 	va_list	ap;
; 653  : 
; 654  : 	nLen = setHeader(header, level);

  00035	53		 push	 ebx
  00036	56		 push	 esi
  00037	50		 push	 eax
  00038	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  0003e	8b cf		 mov	 ecx, edi
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ?setHeader@CLogger@@QAEHPADH@Z ; CLogger::setHeader

; 655  : 	sprintf(header + nLen, " %s ", _szFormat);

  00046	ff 75 10	 push	 DWORD PTR __szFormat$[ebp]
  00049	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _header$[ebp]
  0004f	03 c1		 add	 eax, ecx
  00051	68 00 00 00 00	 push	 OFFSET ??_C@_04KMMDIKEB@?5?$CFs?5?$AA@
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 _sprintf
  0005c	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h

; 1386 :     int const _Result = __stdio_common_vsprintf(

  0005f	8d 45 14	 lea	 eax, DWORD PTR __szFormat$[ebp+4]
  00062	50		 push	 eax
  00063	6a 00		 push	 0
  00065	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  0006b	50		 push	 eax
  0006c	8d 85 fc dd ff
	ff		 lea	 eax, DWORD PTR _msgBuf$[ebp]
  00072	68 ff 1f 00 00	 push	 8191			; 00001fffH
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0007d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007f	ff 70 04	 push	 DWORD PTR [eax+4]
  00082	83 c9 01	 or	 ecx, 1
  00085	51		 push	 ecx
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf
  0008c	8b d8		 mov	 ebx, eax
  0008e	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00091	83 c8 ff	 or	 eax, -1
  00094	85 db		 test	 ebx, ebx
  00096	0f 48 d8	 cmovs	 ebx, eax
; File e:\infinia-library-3.0\com\include\combufpool.h

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  00099	b8 01 00 00 00	 mov	 eax, 1
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 659  : 	TCHAR *pBuf = (TCHAR *)gs_pMMgr->newBuf(LEN_TO_SIZE(nLen+2));

  0009e	8d 73 02	 lea	 esi, DWORD PTR [ebx+2]
  000a1	66 0f 6e c6	 movd	 xmm0, esi
; File e:\infinia-library-3.0\com\include\combufpool.h

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  000a5	8b d6		 mov	 edx, esi
  000a7	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
; File e:\infinia-library-3.0\com\include\commemmanager.h

; 34   : 	inline char *newBuf(int nSize) { int nIdx = getIndex(nSize);  return __newBuf(nIdx, nSize); }

  000ab	56		 push	 esi
; File e:\infinia-library-3.0\com\include\combufpool.h

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  000ac	f2 0f 11 85 f4
	dd ff ff	 movsd	 QWORD PTR _$S1$1[ebp], xmm0
  000b4	8b 8d f8 dd ff
	ff		 mov	 ecx, DWORD PTR _$S1$1[ebp+4]
  000ba	c1 f9 14	 sar	 ecx, 20			; 00000014H
  000bd	81 e9 ff 03 00
	00		 sub	 ecx, 1023		; 000003ffH
  000c3	d3 e0		 shl	 eax, cl
  000c5	2b d0		 sub	 edx, eax
  000c7	23 d6		 and	 edx, esi
  000c9	f7 da		 neg	 edx
  000cb	1b d2		 sbb	 edx, edx
  000cd	f7 da		 neg	 edx
  000cf	03 d1		 add	 edx, ecx
; File e:\infinia-library-3.0\com\include\commemmanager.h

; 34   : 	inline char *newBuf(int nSize) { int nIdx = getIndex(nSize);  return __newBuf(nIdx, nSize); }

  000d1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pMMgr@@3PAVCMemManager@@A ; gs_pMMgr
  000d7	52		 push	 edx
  000d8	e8 00 00 00 00	 call	 ?__newBuf@CMemManager@@AAEPADHI@Z ; CMemManager::__newBuf
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 660  : 	_tcscpy(pBuf, msgBuf);

  000dd	8d 95 fc dd ff
	ff		 lea	 edx, DWORD PTR _msgBuf$[ebp]
  000e3	8b f0		 mov	 esi, eax
  000e5	8b ca		 mov	 ecx, edx
  000e7	2b f1		 sub	 esi, ecx
  000e9	0f 1f 80 00 00
	00 00		 npad	 7
$LL5@PutLogQueu:
  000f0	8a 0a		 mov	 cl, BYTE PTR [edx]
  000f2	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  000f5	88 4c 16 ff	 mov	 BYTE PTR [esi+edx-1], cl
  000f9	84 c9		 test	 cl, cl
  000fb	75 f3		 jne	 SHORT $LL5@PutLogQueu
; File e:\infinia-library-3.0\com\include\comlogger.h

; 207  : 	void putQueue(TCHAR *p) { if (m_sLogQueue.push(p)) m_pCondition->signal(); }

  000fd	50		 push	 eax
  000fe	8b cf		 mov	 ecx, edi
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 661  : 	pBuf[nLen] = '\n';

  00100	66 c7 04 18 0a
	00		 mov	 WORD PTR [eax+ebx], 10	; 0000000aH
; File e:\infinia-library-3.0\com\include\comlogger.h

; 207  : 	void putQueue(TCHAR *p) { if (m_sLogQueue.push(p)) m_pCondition->signal(); }

  00106	e8 00 00 00 00	 call	 ?push@CQueueS@@QAE_NPAX@Z ; CQueueS::push
  0010b	5e		 pop	 esi
  0010c	5b		 pop	 ebx
  0010d	84 c0		 test	 al, al
  0010f	74 08		 je	 SHORT $LN19@PutLogQueu
  00111	8b 4f 44	 mov	 ecx, DWORD PTR [edi+68]
  00114	8b 01		 mov	 eax, DWORD PTR [ecx]
  00116	ff 50 04	 call	 DWORD PTR [eax+4]
$LN19@PutLogQueu:
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 664  : }

  00119	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0011c	33 cd		 xor	 ecx, ebp
  0011e	5f		 pop	 edi
  0011f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00124	8b e5		 mov	 esp, ebp
  00126	5d		 pop	 ebp
  00127	c3		 ret	 0
?PutLogQueue@CLogger@@QAAXHPBDZZ ENDP			; CLogger::PutLogQueue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comlogger.cpp
;	COMDAT ?setHeader@CLogger@@QAEHPADH@Z
_TEXT	SEGMENT
_nLevel$GSCopy$1$ = -124				; size = 4
_cDateTime$ = -120					; size = 104
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pHeader$ = 8						; size = 4
_nLevel$ = 12						; size = 4
?setHeader@CLogger@@QAEHPADH@Z PROC			; CLogger::setHeader, COMDAT
; _this$ = ecx

; 414  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?setHeader@CLogger@@QAEHPADH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 70	 sub	 esp, 112		; 00000070H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b f9		 mov	 edi, ecx
  0002d	8b 45 0c	 mov	 eax, DWORD PTR _nLevel$[ebp]

; 415  : 	CDateTime	cDateTime(m_pDTE->nLastType, m_pDTE->nTZType);

  00030	8d 4d 88	 lea	 ecx, DWORD PTR _cDateTime$[ebp]
  00033	8b 5d 08	 mov	 ebx, DWORD PTR _pHeader$[ebp]
  00036	89 45 84	 mov	 DWORD PTR _nLevel$GSCopy$1$[ebp], eax
  00039	8b 47 54	 mov	 eax, DWORD PTR [edi+84]
  0003c	ff 70 08	 push	 DWORD PTR [eax+8]
  0003f	ff 70 04	 push	 DWORD PTR [eax+4]
  00042	e8 00 00 00 00	 call	 ??0CDateTime@@QAE@W4DT_TYPE@@W4TZ_TYPE@@@Z ; CDateTime::CDateTime

; 416  : 	int nLen = 0;
; 417  : 	nLen = cDateTime.setString(pHeader, m_szHeaderFormat, (DT_FORMAT)m_nDateTimeFormat);

  00047	ff 77 50	 push	 DWORD PTR [edi+80]
  0004a	8d 87 88 00 00
	00		 lea	 eax, DWORD PTR [edi+136]
  00050	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00057	50		 push	 eax
  00058	53		 push	 ebx
  00059	8d 4d 88	 lea	 ecx, DWORD PTR _cDateTime$[ebp]
  0005c	e8 00 00 00 00	 call	 ?setString@CDateTime@@QAEHPAD0W4DT_FORMAT@@@Z ; CDateTime::setString

; 418  : 	if (m_pDTE->nTZType) {

  00061	8b 4f 54	 mov	 ecx, DWORD PTR [edi+84]
  00064	8b f0		 mov	 esi, eax
  00066	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  0006a	74 17		 je	 SHORT $LN2@setHeader

; 419  : 		nLen += _stprintf(pHeader + nLen, _T("%s"), cDateTime.TimezoneString());

  0006c	8d 45 e4	 lea	 eax, DWORD PTR _cDateTime$[ebp+92]
  0006f	50		 push	 eax
  00070	8d 0c 33	 lea	 ecx, DWORD PTR [ebx+esi]
  00073	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  00078	51		 push	 ecx
  00079	e8 00 00 00 00	 call	 _sprintf
  0007e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00081	03 f0		 add	 esi, eax
$LN2@setHeader:

; 420  : 	}
; 421  : 	if (m_nLogFlag & IS_PRINT_LEVEL)

  00083	f7 47 74 00 40
	00 00		 test	 DWORD PTR [edi+116], 16384 ; 00004000H
  0008a	74 21		 je	 SHORT $LN3@setHeader

; 422  : 	{
; 423  : 		nLen += _stprintf(pHeader + nLen,_T(" %s"), gs_fmtStr[nLevel]);

  0008c	8b 45 84	 mov	 eax, DWORD PTR _nLevel$GSCopy$1$[ebp]
  0008f	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00092	8d 04 85 00 00
	00 00		 lea	 eax, DWORD PTR ?gs_fmtStr@@3QAY0M@$$CBDA[eax*4]
  00099	50		 push	 eax
  0009a	8d 04 33	 lea	 eax, DWORD PTR [ebx+esi]
  0009d	68 00 00 00 00	 push	 OFFSET ??_C@_03EEBNCBOD@?5?$CFs?$AA@
  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 _sprintf
  000a8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ab	03 f0		 add	 esi, eax
$LN3@setHeader:

; 424  : 	}
; 425  : 	return nLen;

  000ad	8d 4d 88	 lea	 ecx, DWORD PTR _cDateTime$[ebp]
  000b0	e8 00 00 00 00	 call	 ??1CDateTime@@QAE@XZ	; CDateTime::~CDateTime
  000b5	8b c6		 mov	 eax, esi

; 426  : }

  000b7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ba	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c1	59		 pop	 ecx
  000c2	5f		 pop	 edi
  000c3	5e		 pop	 esi
  000c4	5b		 pop	 ebx
  000c5	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c8	33 cd		 xor	 ecx, ebp
  000ca	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000cf	8b e5		 mov	 esp, ebp
  000d1	5d		 pop	 ebp
  000d2	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?setHeader@CLogger@@QAEHPADH@Z$0:
  00000	8d 4d 88	 lea	 ecx, DWORD PTR _cDateTime$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CDateTime@@QAE@XZ	; CDateTime::~CDateTime
__ehhandler$?setHeader@CLogger@@QAEHPADH@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a 80	 mov	 ecx, DWORD PTR [edx-128]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?setHeader@CLogger@@QAEHPADH@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?setHeader@CLogger@@QAEHPADH@Z ENDP			; CLogger::setHeader
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\comlogger.h
;	COMDAT ?isLogFlag@CLogger@@QAE_NW4E_LOG_FLAG@@@Z
_TEXT	SEGMENT
_nFlag$ = 8						; size = 4
?isLogFlag@CLogger@@QAE_NW4E_LOG_FLAG@@@Z PROC		; CLogger::isLogFlag, COMDAT
; _this$ = ecx

; 185  : 	inline bool isLogFlag(E_LOG_FLAG nFlag) { return (m_nLogFlag & nFlag)?true:false; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _nFlag$[ebp]
  00006	85 41 74	 test	 DWORD PTR [ecx+116], eax
  00009	0f 95 c0	 setne	 al
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?isLogFlag@CLogger@@QAE_NW4E_LOG_FLAG@@@Z ENDP		; CLogger::isLogFlag
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\comlogger.h
;	COMDAT ?clearLogFlag@CLogger@@QAEXW4E_LOG_FLAG@@@Z
_TEXT	SEGMENT
_nFlag$ = 8						; size = 4
?clearLogFlag@CLogger@@QAEXW4E_LOG_FLAG@@@Z PROC	; CLogger::clearLogFlag, COMDAT
; _this$ = ecx

; 184  : 	inline void clearLogFlag(E_LOG_FLAG nFlag) { m_nLogFlag &= ~nFlag; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _nFlag$[ebp]
  00006	f7 d0		 not	 eax
  00008	21 41 74	 and	 DWORD PTR [ecx+116], eax
  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?clearLogFlag@CLogger@@QAEXW4E_LOG_FLAG@@@Z ENDP	; CLogger::clearLogFlag
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\comlogger.h
;	COMDAT ?setLogFlag@CLogger@@QAEXW4E_LOG_FLAG@@@Z
_TEXT	SEGMENT
_nFlag$ = 8						; size = 4
?setLogFlag@CLogger@@QAEXW4E_LOG_FLAG@@@Z PROC		; CLogger::setLogFlag, COMDAT
; _this$ = ecx

; 183  : 	inline void setLogFlag(E_LOG_FLAG nFlag) { m_nLogFlag |= nFlag; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _nFlag$[ebp]
  00006	09 41 74	 or	 DWORD PTR [ecx+116], eax
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?setLogFlag@CLogger@@QAEXW4E_LOG_FLAG@@@Z ENDP		; CLogger::setLogFlag
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comlogger.cpp
;	COMDAT ?OpenLogger@CLogger@@QAEXXZ
_TEXT	SEGMENT
_szBuf$ = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
?OpenLogger@CLogger@@QAEXXZ PROC			; CLogger::OpenLogger, COMDAT
; _this$ = ecx

; 351  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b f1		 mov	 esi, ecx

; 352  : 	TCHAR szBuf[128];
; 353  : 	if (m_nLogFlag & LOG_FLAG_DAILY) {

  00016	8b 46 74	 mov	 eax, DWORD PTR [esi+116]
  00019	a9 00 02 00 00	 test	 eax, 512		; 00000200H
  0001e	74 26		 je	 SHORT $LN2@OpenLogger

; 354  : 		_stprintf(szBuf, _T("%s%d_%s.%s"), m_pLogDir, gs_today_time.date, m_pLogName, m_szFileExtension);

  00020	8d 46 68	 lea	 eax, DWORD PTR [esi+104]
  00023	50		 push	 eax
  00024	ff 76 64	 push	 DWORD PTR [esi+100]
  00027	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  0002d	ff 35 18 00 00
	00		 push	 DWORD PTR ?gs_today_time@@3USTTodayTime@@A+24
  00033	ff 76 60	 push	 DWORD PTR [esi+96]
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_0L@KEPNNLEH@?$CFs?$CFd_?$CFs?4?$CFs?$AA@
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 _sprintf
  00041	83 c4 18	 add	 esp, 24			; 00000018H
  00044	eb 5a		 jmp	 SHORT $LN6@OpenLogger
$LN2@OpenLogger:

; 355  : 	}
; 356  : 	else if (m_nLogFlag & LOG_FLAG_HOURLY) {

  00046	a9 00 04 00 00	 test	 eax, 1024		; 00000400H
  0004b	74 2e		 je	 SHORT $LN4@OpenLogger

; 357  : 		_stprintf(szBuf, _T("%s%d%c%s_%02d.%s"), m_pLogDir, gs_today_time.date, g_s, m_pLogName, gs_today_time.hour, m_szFileExtension);

  0004d	8d 46 68	 lea	 eax, DWORD PTR [esi+104]
  00050	50		 push	 eax
  00051	ff 35 0c 00 00
	00		 push	 DWORD PTR ?gs_today_time@@3USTTodayTime@@A+12
  00057	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  0005d	ff 76 64	 push	 DWORD PTR [esi+100]
  00060	6a 5c		 push	 92			; 0000005cH
  00062	ff 35 18 00 00
	00		 push	 DWORD PTR ?gs_today_time@@3USTTodayTime@@A+24
  00068	ff 76 60	 push	 DWORD PTR [esi+96]
  0006b	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MEMPEKDH@?$CFs?$CFd?$CFc?$CFs_?$CF02d?4?$CFs?$AA@
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 _sprintf
  00076	83 c4 20	 add	 esp, 32			; 00000020H
  00079	eb 25		 jmp	 SHORT $LN6@OpenLogger
$LN4@OpenLogger:

; 358  : 	}
; 359  : 	else if (m_nLogFlag & LOG_FLAG_FILE) {

  0007b	a9 00 08 00 00	 test	 eax, 2048		; 00000800H
  00080	74 1e		 je	 SHORT $LN6@OpenLogger

; 360  : 		_stprintf(szBuf, _T("%s%s.%s"), m_pLogDir, m_pLogName, m_szFileExtension);

  00082	8d 46 68	 lea	 eax, DWORD PTR [esi+104]
  00085	50		 push	 eax
  00086	ff 76 64	 push	 DWORD PTR [esi+100]
  00089	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  0008f	ff 76 60	 push	 DWORD PTR [esi+96]
  00092	68 00 00 00 00	 push	 OFFSET ??_C@_07GFKBPOLL@?$CFs?$CFs?4?$CFs?$AA@
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 _sprintf
  0009d	83 c4 14	 add	 esp, 20			; 00000014H
$LN6@OpenLogger:

; 361  : 	}
; 362  : 
; 363  : 	__openLogger(szBuf);

  000a0	6a 00		 push	 0
  000a2	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  000a8	8b ce		 mov	 ecx, esi
  000aa	50		 push	 eax
  000ab	e8 00 00 00 00	 call	 ?__openLogger@CLogger@@AAEXPBDH@Z ; CLogger::__openLogger

; 364  : }

  000b0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b3	33 cd		 xor	 ecx, ebp
  000b5	5e		 pop	 esi
  000b6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c3		 ret	 0
?OpenLogger@CLogger@@QAEXXZ ENDP			; CLogger::OpenLogger
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File e:\infinia-library-3.0\com\include\comtypes.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File e:\infinia-library-3.0\com\include\comlogger.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File e:\infinia-library-3.0\com\include\comtypes.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File e:\infinia-library-3.0\com\include\comtypes.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File e:\infinia-library-3.0\com\include\comlogger.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File e:\infinia-library-3.0\com\include\comlogger.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
;	COMDAT ?initConfig@CLogger@@QAE?AW4E_LOG_INIT_RES@@PAD0@Z
_TEXT	SEGMENT
_pConfig$GSCopy$1$ = -280				; size = 4
_szValue$ = -276					; size = 128
_szValue2$ = -148					; size = 128
_szValue3$ = -20					; size = 8
_szValue4$ = -12					; size = 8
__$ArrayPad$ = -4					; size = 4
_pConfig$ = 8						; size = 4
_pSection$ = 12						; size = 4
?initConfig@CLogger@@QAE?AW4E_LOG_INIT_RES@@PAD0@Z PROC	; CLogger::initConfig, COMDAT
; _this$ = ecx

; 172  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 0c	 mov	 ebx, DWORD PTR _pSection$[ebp]

; 173  : 	int nMax, nRes, nVal;
; 174  : 	TCHAR szValue[128], szValue2[128], szValue3[8], szValue4[8];
; 175  : 	E_LOG_INIT_RES eRes;
; 176  : 
; 177  : 	nRes = GetPrivateProfileString(pSection, "LOGNAME", "", szValue2, 128, pConfig);

  00017	8d 85 6c ff ff
	ff		 lea	 eax, DWORD PTR _szValue2$[ebp]
  0001d	56		 push	 esi
  0001e	8b 75 08	 mov	 esi, DWORD PTR _pConfig$[ebp]
  00021	57		 push	 edi
  00022	56		 push	 esi
  00023	68 80 00 00 00	 push	 128			; 00000080H
  00028	50		 push	 eax
  00029	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_07HFNGLEND@LOGNAME?$AA@
  00033	53		 push	 ebx
  00034	8b f9		 mov	 edi, ecx
  00036	89 b5 e8 fe ff
	ff		 mov	 DWORD PTR _pConfig$GSCopy$1$[ebp], esi
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileStringA@24

; 178  : 	if (!nRes) {

  00042	85 c0		 test	 eax, eax
  00044	75 49		 jne	 SHORT $LN4@initConfig

; 179  : 		if (&gs_cLogger == this) { eRes = LOG_INIT_NO_FILE; goto SET_DISABLE; }

  00046	81 ff 00 00 00
	00		 cmp	 edi, OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  0004c	74 59		 je	 SHORT $SET_DISABLE$30
$LN3@initConfig:
; File e:\infinia-library-3.0\com\include\comtypes.h

; 325  : 	sprintf(g_szSystemError, "ERROR! [%s:%d] %s\n", _szFunc, _nLine, pMsg);

  0004e	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FPEJDJAJ@LOGNAME?5is?5NULL?$CB?$AA@
  00053	68 b4 00 00 00	 push	 180			; 000000b4H
  00058	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@BNJIBEDO@CLogger?3?3initConfig?$AA@
  0005d	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@KEHDJCKJ@ERROR?$CB?5?$FL?$CFs?3?$CFd?$FN?5?$CFs?6?$AA@
  00062	68 00 00 00 00	 push	 OFFSET ?g_szSystemError@@3PADA ; g_szSystemError
  00067	e8 00 00 00 00	 call	 _sprintf

; 326  : 	printf(g_szSystemError);

  0006c	68 00 00 00 00	 push	 OFFSET ?g_szSystemError@@3PADA ; g_szSystemError
  00071	e8 00 00 00 00	 call	 _printf
  00076	83 c4 18	 add	 esp, 24			; 00000018H
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 180  : 		else {	comErrorPrint(_T("LOGNAME is NULL!"));	return LOG_INIT_ERROR;}

  00079	83 c8 ff	 or	 eax, -1
  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx

; 226  : }

  0007f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00082	33 cd		 xor	 ecx, ebp
  00084	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c2 08 00	 ret	 8
$LN4@initConfig:

; 181  : 	}
; 182  : 	nRes = GetPrivateProfileInt(pSection, _T("ISENABLE"), 0, pConfig);

  0008f	56		 push	 esi
  00090	6a 00		 push	 0
  00092	68 00 00 00 00	 push	 OFFSET ??_C@_08DDAPLFEB@ISENABLE?$AA@
  00097	53		 push	 ebx
  00098	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16

; 183  : 	if (!nRes) { eRes = LOG_INIT_SUCCESS; goto SET_DISABLE; }

  0009e	85 c0		 test	 eax, eax
  000a0	75 32		 jne	 SHORT $LN6@initConfig
  000a2	b8 01 00 00 00	 mov	 eax, 1
$SET_DISABLE$30:

; 220  : 
; 221  : SET_DISABLE : 
; 222  : 	if (isLogFlag(IS_LOG_ENABLE)) {

  000a7	8b 57 74	 mov	 edx, DWORD PTR [edi+116]
  000aa	8b ca		 mov	 ecx, edx
  000ac	c1 e9 13	 shr	 ecx, 19			; 00000013H
  000af	f6 c1 01	 test	 cl, 1
  000b2	0f 84 42 02 00
	00		 je	 $LN1@initConfig
; File e:\infinia-library-3.0\com\include\comlogger.h

; 184  : 	inline void clearLogFlag(E_LOG_FLAG nFlag) { m_nLogFlag &= ~nFlag; }

  000b8	81 e2 ff ff f7
	ff		 and	 edx, -524289		; fff7ffffH
  000be	89 57 74	 mov	 DWORD PTR [edi+116], edx
  000c1	5f		 pop	 edi
  000c2	5e		 pop	 esi
  000c3	5b		 pop	 ebx
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 226  : }

  000c4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c7	33 cd		 xor	 ecx, ebp
  000c9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c2 08 00	 ret	 8
$LN6@initConfig:

; 184  : 
; 185  : 	nRes = GetProfilePath(pSection, _T("LOGDIR"), _T("Log"), szValue, pConfig);

  000d4	56		 push	 esi
  000d5	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szValue$[ebp]
  000db	50		 push	 eax
  000dc	68 00 00 00 00	 push	 OFFSET ??_C@_03GGEOLGBL@Log?$AA@
  000e1	68 00 00 00 00	 push	 OFFSET ??_C@_06BGFFEFJP@LOGDIR?$AA@
  000e6	53		 push	 ebx
  000e7	e8 00 00 00 00	 call	 ?GetProfilePath@@YAHPBD00PAD0@Z ; GetProfilePath
  000ec	83 c4 14	 add	 esp, 20			; 00000014H

; 186  : 	GetPrivateProfileString(pSection, _T("EXTENSION"), g_szLogExtension, szValue3, sizeof(szValue3), pConfig);

  000ef	8d 45 ec	 lea	 eax, DWORD PTR _szValue3$[ebp]
  000f2	56		 push	 esi
  000f3	6a 08		 push	 8
  000f5	50		 push	 eax
  000f6	68 00 00 00 00	 push	 OFFSET ?g_szLogExtension@@3PADA ; g_szLogExtension
  000fb	68 00 00 00 00	 push	 OFFSET ??_C@_09NDPCHOCH@EXTENSION?$AA@
  00100	53		 push	 ebx
  00101	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileStringA@24

; 187  : 	GetPrivateProfileString(pSection, _T("KEEP_DURATION"), g_szKeepDuratrion, szValue4, sizeof(szValue4), pConfig);

  00107	56		 push	 esi
  00108	6a 08		 push	 8
  0010a	8d 45 f4	 lea	 eax, DWORD PTR _szValue4$[ebp]
  0010d	50		 push	 eax
  0010e	68 00 00 00 00	 push	 OFFSET ?g_szKeepDuratrion@@3PADA ; g_szKeepDuratrion
  00113	68 00 00 00 00	 push	 OFFSET ??_C@_0O@MIEDPAKJ@KEEP_DURATION?$AA@
  00118	53		 push	 ebx
  00119	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileStringA@24

; 188  : 	_initCom(szValue, szValue2, szValue3, szValue4);

  0011f	8d 45 f4	 lea	 eax, DWORD PTR _szValue4$[ebp]
  00122	8b cf		 mov	 ecx, edi
  00124	50		 push	 eax
  00125	8d 45 ec	 lea	 eax, DWORD PTR _szValue3$[ebp]
  00128	50		 push	 eax
  00129	8d 85 6c ff ff
	ff		 lea	 eax, DWORD PTR _szValue2$[ebp]
  0012f	50		 push	 eax
  00130	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szValue$[ebp]
  00136	50		 push	 eax
  00137	e8 00 00 00 00	 call	 ?_initCom@CLogger@@AAEXPAD000@Z ; CLogger::_initCom

; 189  : 
; 190  : 	nMax = GetPrivateProfileInt(pSection, _T("LIST_MAX"), eLDOPT_LISTMAX, pConfig);

  0013c	56		 push	 esi
  0013d	6a 14		 push	 20			; 00000014H
  0013f	68 00 00 00 00	 push	 OFFSET ??_C@_08ECKHJDBO@LIST_MAX?$AA@
  00144	53		 push	 ebx
  00145	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16

; 191  : 	if (!_setLoggerQueue(nMax)) {

  0014b	50		 push	 eax
  0014c	8b cf		 mov	 ecx, edi
  0014e	e8 00 00 00 00	 call	 ?_setLoggerQueue@CLogger@@AAE_NH@Z ; CLogger::_setLoggerQueue
  00153	84 c0		 test	 al, al
  00155	75 41		 jne	 SHORT $LN8@initConfig
; File e:\infinia-library-3.0\com\include\comtypes.h

; 325  : 	sprintf(g_szSystemError, "ERROR! [%s:%d] %s\n", _szFunc, _nLine, pMsg);

  00157	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@JBFNJKAK@_setLoggerQueue?5has?5Failed?$AA@
  0015c	68 c0 00 00 00	 push	 192			; 000000c0H
  00161	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@BNJIBEDO@CLogger?3?3initConfig?$AA@
  00166	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@KEHDJCKJ@ERROR?$CB?5?$FL?$CFs?3?$CFd?$FN?5?$CFs?6?$AA@
  0016b	68 00 00 00 00	 push	 OFFSET ?g_szSystemError@@3PADA ; g_szSystemError
  00170	e8 00 00 00 00	 call	 _sprintf

; 326  : 	printf(g_szSystemError);

  00175	68 00 00 00 00	 push	 OFFSET ?g_szSystemError@@3PADA ; g_szSystemError
  0017a	e8 00 00 00 00	 call	 _printf
  0017f	83 c4 18	 add	 esp, 24			; 00000018H
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 193  : 		return LOG_INIT_ERROR;

  00182	83 c8 ff	 or	 eax, -1
  00185	5f		 pop	 edi
  00186	5e		 pop	 esi
  00187	5b		 pop	 ebx

; 226  : }

  00188	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0018b	33 cd		 xor	 ecx, ebp
  0018d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00192	8b e5		 mov	 esp, ebp
  00194	5d		 pop	 ebp
  00195	c2 08 00	 ret	 8
$LN8@initConfig:

; 194  : 	}
; 195  : 	nRes = GetPrivateProfileInt(pSection, _T("TIMESTEMP_NO"), eLDOPT_TIMESTEMP_NO, pConfig);

  00198	56		 push	 esi
  00199	6a 00		 push	 0
  0019b	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GIODBBCL@TIMESTEMP_NO?$AA@
  001a0	53		 push	 ebx
  001a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16

; 196  : 	if (nRes < 0) {

  001a7	85 c0		 test	 eax, eax
  001a9	79 52		 jns	 SHORT $LN9@initConfig

; 197  : 		_stprintf(g_szMessage, _T("invalid value[%d]! pSection[%s]"), nRes, pSection);

  001ab	53		 push	 ebx
  001ac	50		 push	 eax
  001ad	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@KJGNIKCD@invalid?5value?$FL?$CFd?$FN?$CB?5pSection?$FL?$CFs?$FN?$AA@
  001b2	68 00 00 00 00	 push	 OFFSET ?g_szMessage@@3PADA ; g_szMessage
  001b7	e8 00 00 00 00	 call	 _sprintf
; File e:\infinia-library-3.0\com\include\comtypes.h

; 325  : 	sprintf(g_szSystemError, "ERROR! [%s:%d] %s\n", _szFunc, _nLine, pMsg);

  001bc	68 00 00 00 00	 push	 OFFSET ?g_szMessage@@3PADA ; g_szMessage
  001c1	68 c6 00 00 00	 push	 198			; 000000c6H
  001c6	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@BNJIBEDO@CLogger?3?3initConfig?$AA@
  001cb	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@KEHDJCKJ@ERROR?$CB?5?$FL?$CFs?3?$CFd?$FN?5?$CFs?6?$AA@
  001d0	68 00 00 00 00	 push	 OFFSET ?g_szSystemError@@3PADA ; g_szSystemError
  001d5	e8 00 00 00 00	 call	 _sprintf

; 326  : 	printf(g_szSystemError);

  001da	68 00 00 00 00	 push	 OFFSET ?g_szSystemError@@3PADA ; g_szSystemError
  001df	e8 00 00 00 00	 call	 _printf
  001e4	83 c4 28	 add	 esp, 40			; 00000028H
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 199  : 		return LOG_INIT_ERROR;

  001e7	83 c8 ff	 or	 eax, -1
  001ea	5f		 pop	 edi
  001eb	5e		 pop	 esi
  001ec	5b		 pop	 ebx

; 226  : }

  001ed	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001f0	33 cd		 xor	 ecx, ebp
  001f2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f7	8b e5		 mov	 esp, ebp
  001f9	5d		 pop	 ebp
  001fa	c2 08 00	 ret	 8
$LN9@initConfig:

; 200  : 	}
; 201  : 	if (!_setHeaderFormat(nRes)) {

  001fd	50		 push	 eax
  001fe	8b cf		 mov	 ecx, edi
  00200	e8 00 00 00 00	 call	 ?_setHeaderFormat@CLogger@@AAE_NH@Z ; CLogger::_setHeaderFormat
  00205	84 c0		 test	 al, al
  00207	75 2d		 jne	 SHORT $LN10@initConfig

; 202  : 		comErrorPrint(_T("_setHeaderFormat has Failed"));

  00209	68 ca 00 00 00	 push	 202			; 000000caH
  0020e	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@BNJIBEDO@CLogger?3?3initConfig?$AA@
  00213	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@KHAIMODA@_setHeaderFormat?5has?5Failed?$AA@
  00218	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPADPBDH@Z ; comGlobalErrorProc
  0021d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 203  : 		return LOG_INIT_ERROR;

  00220	83 c8 ff	 or	 eax, -1
  00223	5f		 pop	 edi
  00224	5e		 pop	 esi
  00225	5b		 pop	 ebx

; 226  : }

  00226	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00229	33 cd		 xor	 ecx, ebp
  0022b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00230	8b e5		 mov	 esp, ebp
  00232	5d		 pop	 ebp
  00233	c2 08 00	 ret	 8
$LN10@initConfig:

; 204  : 	}
; 205  : 	m_nStlNo = GetPrivateProfileInt(pSection, _T("STL_NO"), eLDOPT_STL_NO, pConfig);

  00236	56		 push	 esi
  00237	6a 00		 push	 0
  00239	68 00 00 00 00	 push	 OFFSET ??_C@_06OEDJMAPG@STL_NO?$AA@
  0023e	53		 push	 ebx
  0023f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16

; 206  : 
; 207  : 	nRes = GetPrivateProfileInt(pSection, _T("LOGTYPE"), eLDOPT_LOGTYPE, pConfig);

  00245	56		 push	 esi
  00246	6a 03		 push	 3
  00248	68 00 00 00 00	 push	 OFFSET ??_C@_07NONFHEKD@LOGTYPE?$AA@
  0024d	53		 push	 ebx
  0024e	89 47 7c	 mov	 DWORD PTR [edi+124], eax
  00251	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16

; 208  : 	m_nSizeLimit = GetPrivateProfileInt(pSection, _T("SIZE_LIMIT"), eLDOPT_SIZE_LIMIT, pConfig);

  00257	ff b5 e8 fe ff
	ff		 push	 DWORD PTR _pConfig$GSCopy$1$[ebp]
  0025d	8b f0		 mov	 esi, eax
  0025f	6a 00		 push	 0
  00261	68 00 00 00 00	 push	 OFFSET ??_C@_0L@KBIMBJLD@SIZE_LIMIT?$AA@
  00266	53		 push	 ebx
  00267	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16

; 209  : 	nVal = GetPrivateProfileInt(pSection, _T("IS_PRINT_LEVEL"), eLDOPT_IS_PRINT_LEVEL, pConfig);

  0026d	ff b5 e8 fe ff
	ff		 push	 DWORD PTR _pConfig$GSCopy$1$[ebp]
  00273	89 87 80 00 00
	00		 mov	 DWORD PTR [edi+128], eax
  00279	6a 01		 push	 1
  0027b	68 00 00 00 00	 push	 OFFSET ??_C@_0P@KBOADAAO@IS_PRINT_LEVEL?$AA@
  00280	53		 push	 ebx
  00281	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16

; 210  : 	_setLoggerBasic(nRes, nVal, m_nSizeLimit);

  00287	ff b7 80 00 00
	00		 push	 DWORD PTR [edi+128]
  0028d	8b cf		 mov	 ecx, edi
  0028f	50		 push	 eax
  00290	56		 push	 esi
  00291	e8 00 00 00 00	 call	 ?_setLoggerBasic@CLogger@@AAEXHHH@Z ; CLogger::_setLoggerBasic

; 211  : 
; 212  : 	nRes = GetPrivateProfileInt(pSection, _T("IS_PRINT"), eLDOPT_ISPRINTF, pConfig);

  00296	8b b5 e8 fe ff
	ff		 mov	 esi, DWORD PTR _pConfig$GSCopy$1$[ebp]
  0029c	56		 push	 esi
  0029d	6a 00		 push	 0
  0029f	68 00 00 00 00	 push	 OFFSET ??_C@_08GJGBIIAH@IS_PRINT?$AA@
  002a4	53		 push	 ebx
  002a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16

; 213  : 	if (nRes) m_nLogFlag |= IS_PRINT;

  002ab	85 c0		 test	 eax, eax
  002ad	74 07		 je	 SHORT $LN11@initConfig
  002af	81 4f 74 00 20
	00 00		 or	 DWORD PTR [edi+116], 8192 ; 00002000H
$LN11@initConfig:

; 214  : 	m_nLogLevel = GetPrivateProfileInt(pSection, _T("LOGLEVEL"), eLDOPT_LOGLEVEL, pConfig);

  002b6	56		 push	 esi
  002b7	6a 03		 push	 3
  002b9	68 00 00 00 00	 push	 OFFSET ??_C@_08HMDDICIG@LOGLEVEL?$AA@
  002be	53		 push	 ebx
  002bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16

; 215  : 
; 216  : 	if (isLogFlag(IS_LOG_ENABLE)) return LOG_INIT_CHANGED_SUCCESS;

  002c5	8b 4f 74	 mov	 ecx, DWORD PTR [edi+116]
  002c8	89 47 4c	 mov	 DWORD PTR [edi+76], eax
  002cb	8b c1		 mov	 eax, ecx
  002cd	c1 e8 13	 shr	 eax, 19			; 00000013H
  002d0	a8 01		 test	 al, 1
  002d2	74 18		 je	 SHORT $LN12@initConfig
  002d4	5f		 pop	 edi
  002d5	5e		 pop	 esi
  002d6	b8 02 00 00 00	 mov	 eax, 2
  002db	5b		 pop	 ebx

; 226  : }

  002dc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002df	33 cd		 xor	 ecx, ebp
  002e1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002e6	8b e5		 mov	 esp, ebp
  002e8	5d		 pop	 ebp
  002e9	c2 08 00	 ret	 8
$LN12@initConfig:
; File e:\infinia-library-3.0\com\include\comlogger.h

; 183  : 	inline void setLogFlag(E_LOG_FLAG nFlag) { m_nLogFlag |= nFlag; }

  002ec	81 c9 00 00 02
	00		 or	 ecx, 131072		; 00020000H
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 219  : 	return LOG_INIT_SUCCESS;

  002f2	b8 01 00 00 00	 mov	 eax, 1
; File e:\infinia-library-3.0\com\include\comlogger.h

; 183  : 	inline void setLogFlag(E_LOG_FLAG nFlag) { m_nLogFlag |= nFlag; }

  002f7	89 4f 74	 mov	 DWORD PTR [edi+116], ecx
$LN1@initConfig:
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 226  : }

  002fa	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002fd	5f		 pop	 edi
  002fe	5e		 pop	 esi
  002ff	33 cd		 xor	 ecx, ebp
  00301	5b		 pop	 ebx
  00302	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00307	8b e5		 mov	 esp, ebp
  00309	5d		 pop	 ebp
  0030a	c2 08 00	 ret	 8
?initConfig@CLogger@@QAE?AW4E_LOG_INIT_RES@@PAD0@Z ENDP	; CLogger::initConfig
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File e:\infinia-library-3.0\com\include\comtypes.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File e:\infinia-library-3.0\com\include\comtypes.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File e:\infinia-library-3.0\com\include\comlist.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File e:\infinia-library-3.0\com\include\comlogger.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File e:\infinia-library-3.0\com\include\comtypes.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
;	COMDAT ?initDefault@CLogger@@QAE_NPAD0HHH0@Z
_TEXT	SEGMENT
_szValue2$ = -260					; size = 128
_szValue$ = -132					; size = 128
__$ArrayPad$ = -4					; size = 4
_pDir$ = 8						; size = 4
_pName$ = 12						; size = 4
_nLogType$ = 16						; size = 4
_nLogLevel$ = 20					; size = 4
_nSizeLimit$ = 24					; size = 4
_pFileExtension$ = 28					; size = 4
?initDefault@CLogger@@QAE_NPAD0HHH0@Z PROC		; CLogger::initDefault, COMDAT
; _this$ = ecx

; 135  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _pDir$[ebp]
  00016	53		 push	 ebx
  00017	8b 5d 1c	 mov	 ebx, DWORD PTR _pFileExtension$[ebp]
  0001a	56		 push	 esi
  0001b	8b f1		 mov	 esi, ecx
  0001d	57		 push	 edi
  0001e	8b 7d 0c	 mov	 edi, DWORD PTR _pName$[ebp]

; 136  : 	TCHAR szValue[128], szValue2[128];
; 137  : 
; 138  : 	if (!pDir) {

  00021	85 c0		 test	 eax, eax
  00023	75 30		 jne	 SHORT $LN2@initDefaul
; File e:\infinia-library-3.0\com\include\comtypes.h

; 325  : 	sprintf(g_szSystemError, "ERROR! [%s:%d] %s\n", _szFunc, _nLine, pMsg);

  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0N@JBKCPMI@pDir?5is?5NULL?$AA@
  0002a	68 8b 00 00 00	 push	 139			; 0000008bH
  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@GMHDDGKB@CLogger?3?3initDefault?$AA@
  00034	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@KEHDJCKJ@ERROR?$CB?5?$FL?$CFs?3?$CFd?$FN?5?$CFs?6?$AA@
  00039	68 00 00 00 00	 push	 OFFSET ?g_szSystemError@@3PADA ; g_szSystemError
  0003e	e8 00 00 00 00	 call	 _sprintf

; 326  : 	printf(g_szSystemError);

  00043	68 00 00 00 00	 push	 OFFSET ?g_szSystemError@@3PADA ; g_szSystemError
  00048	e8 00 00 00 00	 call	 _printf
  0004d	83 c4 18	 add	 esp, 24			; 00000018H
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 140  : 		return false;

  00050	e9 4d 01 00 00	 jmp	 $LN35@initDefaul
$LN2@initDefaul:

; 141  : 	}
; 142  : 	if (pName) {

  00055	85 ff		 test	 edi, edi
  00057	74 17		 je	 SHORT $LN3@initDefaul

; 143  : 		if (pDir[0] == '~') {

  00059	80 38 7e	 cmp	 BYTE PTR [eax], 126	; 0000007eH
  0005c	75 35		 jne	 SHORT $LN4@initDefaul

; 144  : 			changeToAbsolutePath(szValue, pDir);

  0005e	50		 push	 eax
  0005f	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _szValue$[ebp]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ?changeToAbsolutePath@@YAXPADPBD@Z ; changeToAbsolutePath
  0006b	83 c4 08	 add	 esp, 8

; 145  : 			pDir = szValue;
; 146  : 		}
; 147  : 	}
; 148  : 	else {

  0006e	eb 1d		 jmp	 SHORT $LN36@initDefaul
$LN3@initDefaul:

; 149  : 		detachFullPath(pDir, szValue, szValue2);

  00070	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _szValue2$[ebp]
  00076	51		 push	 ecx
  00077	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _szValue$[ebp]
  0007d	51		 push	 ecx
  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 ?detachFullPath@@YAXPBDPAD1@Z ; detachFullPath
  00084	83 c4 0c	 add	 esp, 12			; 0000000cH

; 150  : 		pDir = szValue; pName = szValue2;

  00087	8d bd fc fe ff
	ff		 lea	 edi, DWORD PTR _szValue2$[ebp]
$LN36@initDefaul:
  0008d	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _szValue$[ebp]
$LN4@initDefaul:

; 151  : 	}
; 152  : 
; 153  : 	_initCom(pDir, pName, pFileExtension);

  00093	68 00 00 00 00	 push	 OFFSET ?g_szKeepDuratrion@@3PADA ; g_szKeepDuratrion
  00098	53		 push	 ebx
  00099	57		 push	 edi
  0009a	50		 push	 eax
  0009b	8b ce		 mov	 ecx, esi
  0009d	e8 00 00 00 00	 call	 ?_initCom@CLogger@@AAEXPAD000@Z ; CLogger::_initCom

; 154  : 
; 155  : 	if (!_setLoggerQueue(eLDOPT_LISTMAX)) {

  000a2	6a 14		 push	 20			; 00000014H
  000a4	8b ce		 mov	 ecx, esi
  000a6	e8 00 00 00 00	 call	 ?_setLoggerQueue@CLogger@@AAE_NH@Z ; CLogger::_setLoggerQueue
  000ab	84 c0		 test	 al, al
  000ad	75 30		 jne	 SHORT $LN6@initDefaul
; File e:\infinia-library-3.0\com\include\comtypes.h

; 325  : 	sprintf(g_szSystemError, "ERROR! [%s:%d] %s\n", _szFunc, _nLine, pMsg);

  000af	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@JBFNJKAK@_setLoggerQueue?5has?5Failed?$AA@
  000b4	68 9c 00 00 00	 push	 156			; 0000009cH
  000b9	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@GMHDDGKB@CLogger?3?3initDefault?$AA@
  000be	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@KEHDJCKJ@ERROR?$CB?5?$FL?$CFs?3?$CFd?$FN?5?$CFs?6?$AA@
  000c3	68 00 00 00 00	 push	 OFFSET ?g_szSystemError@@3PADA ; g_szSystemError
  000c8	e8 00 00 00 00	 call	 _sprintf

; 326  : 	printf(g_szSystemError);

  000cd	68 00 00 00 00	 push	 OFFSET ?g_szSystemError@@3PADA ; g_szSystemError
  000d2	e8 00 00 00 00	 call	 _printf
  000d7	83 c4 18	 add	 esp, 24			; 00000018H
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 157  : 		return false;

  000da	e9 c3 00 00 00	 jmp	 $LN35@initDefaul
$LN6@initDefaul:

; 38   : STLogDateTimeExp *CTimeExpManager::getDTE(int nIdx) { if (!m_pTimeExpList) return NULL;  return (STLogDateTimeExp *)m_pTimeExpList->getObj(nIdx); }

  000df	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gs_DTEManager@@3VCTimeExpManager@@A ; gs_DTEManager
  000e4	85 c0		 test	 eax, eax
  000e6	74 56		 je	 SHORT $LN33@initDefaul
  000e8	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
; File e:\infinia-library-3.0\com\include\comlist.h

; 33   : 	inline void* getObj(int i) { if (ISINCLUDE(i, m_nMax)) return m_pArray[i]; return NULL; }

  000ec	7e 50		 jle	 SHORT $LN33@initDefaul
  000ee	8b 00		 mov	 eax, DWORD PTR [eax]
  000f0	8b 38		 mov	 edi, DWORD PTR [eax]
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 338  : 	if (!pDTE) {

  000f2	85 ff		 test	 edi, edi
  000f4	74 48		 je	 SHORT $LN33@initDefaul

; 340  : 		comErrorPrint(g_szMessage);
; 341  : 		return false;
; 342  : 	}
; 343  : 	else if (m_pDTE != pDTE) {

  000f6	39 7e 54	 cmp	 DWORD PTR [esi+84], edi
  000f9	74 0b		 je	 SHORT $LN7@initDefaul

; 344  : 		setDateTimeFormat(pDTE);

  000fb	57		 push	 edi
  000fc	8b ce		 mov	 ecx, esi
  000fe	e8 00 00 00 00	 call	 ?setDateTimeFormat@CLogger@@AAEXPAUSTLogDateTimeExp@@@Z ; CLogger::setDateTimeFormat

; 345  : 		m_pDTE = pDTE;

  00103	89 7e 54	 mov	 DWORD PTR [esi+84], edi
$LN7@initDefaul:

; 158  : 	}
; 159  : 	if (!_setHeaderFormat(eLDOPT_TIMESTEMP_NO)) {
; 160  : 		comErrorPrint(_T("_setHeaderFormat has Failed"));
; 161  : 		return false;
; 162  : 	}
; 163  : 
; 164  : 	m_nStlNo = 0;
; 165  : 	m_nLogLevel = nLogLevel;
; 166  : 	_setLoggerBasic(nLogType, eLDOPT_IS_PRINT_LEVEL, nSizeLimit);

  00106	ff 75 18	 push	 DWORD PTR _nSizeLimit$[ebp]
  00109	8b 45 14	 mov	 eax, DWORD PTR _nLogLevel$[ebp]
  0010c	8b ce		 mov	 ecx, esi
  0010e	6a 01		 push	 1
  00110	ff 75 10	 push	 DWORD PTR _nLogType$[ebp]
  00113	c7 46 7c 00 00
	00 00		 mov	 DWORD PTR [esi+124], 0
  0011a	89 46 4c	 mov	 DWORD PTR [esi+76], eax
  0011d	e8 00 00 00 00	 call	 ?_setLoggerBasic@CLogger@@AAEXHHH@Z ; CLogger::_setLoggerBasic
; File e:\infinia-library-3.0\com\include\comlogger.h

; 183  : 	inline void setLogFlag(E_LOG_FLAG nFlag) { m_nLogFlag |= nFlag; }

  00122	81 4e 74 00 00
	02 00		 or	 DWORD PTR [esi+116], 131072 ; 00020000H
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 168  : 	return true;

  00129	b0 01		 mov	 al, 1
  0012b	5f		 pop	 edi
  0012c	5e		 pop	 esi
  0012d	5b		 pop	 ebx

; 169  : }

  0012e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00131	33 cd		 xor	 ecx, ebp
  00133	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00138	8b e5		 mov	 esp, ebp
  0013a	5d		 pop	 ebp
  0013b	c2 18 00	 ret	 24			; 00000018H
$LN33@initDefaul:

; 339  : 		_stprintf(g_szMessage, _T("m_pDTE is NULL! nTimeStempNo[%d]"), nTimeStempNo);

  0013e	6a 00		 push	 0
  00140	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@KMNIJCOL@m_pDTE?5is?5NULL?$CB?5nTimeStempNo?$FL?$CFd?$FN@
  00145	68 00 00 00 00	 push	 OFFSET ?g_szMessage@@3PADA ; g_szMessage
  0014a	e8 00 00 00 00	 call	 _sprintf
; File e:\infinia-library-3.0\com\include\comtypes.h

; 325  : 	sprintf(g_szSystemError, "ERROR! [%s:%d] %s\n", _szFunc, _nLine, pMsg);

  0014f	68 00 00 00 00	 push	 OFFSET ?g_szMessage@@3PADA ; g_szMessage
  00154	68 54 01 00 00	 push	 340			; 00000154H
  00159	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@CNLJKEGB@CLogger?3?3_setHeaderFormat?$AA@
  0015e	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@KEHDJCKJ@ERROR?$CB?5?$FL?$CFs?3?$CFd?$FN?5?$CFs?6?$AA@
  00163	68 00 00 00 00	 push	 OFFSET ?g_szSystemError@@3PADA ; g_szSystemError
  00168	e8 00 00 00 00	 call	 _sprintf

; 326  : 	printf(g_szSystemError);

  0016d	68 00 00 00 00	 push	 OFFSET ?g_szSystemError@@3PADA ; g_szSystemError
  00172	e8 00 00 00 00	 call	 _printf

; 325  : 	sprintf(g_szSystemError, "ERROR! [%s:%d] %s\n", _szFunc, _nLine, pMsg);

  00177	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@KHAIMODA@_setHeaderFormat?5has?5Failed?$AA@
  0017c	68 a0 00 00 00	 push	 160			; 000000a0H
  00181	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@GMHDDGKB@CLogger?3?3initDefault?$AA@
  00186	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@KEHDJCKJ@ERROR?$CB?5?$FL?$CFs?3?$CFd?$FN?5?$CFs?6?$AA@
  0018b	68 00 00 00 00	 push	 OFFSET ?g_szSystemError@@3PADA ; g_szSystemError
  00190	e8 00 00 00 00	 call	 _sprintf

; 326  : 	printf(g_szSystemError);

  00195	68 00 00 00 00	 push	 OFFSET ?g_szSystemError@@3PADA ; g_szSystemError
  0019a	e8 00 00 00 00	 call	 _printf
  0019f	83 c4 3c	 add	 esp, 60			; 0000003cH
$LN35@initDefaul:
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 169  : }

  001a2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a5	32 c0		 xor	 al, al
  001a7	5f		 pop	 edi
  001a8	5e		 pop	 esi
  001a9	33 cd		 xor	 ecx, ebp
  001ab	5b		 pop	 ebx
  001ac	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b1	8b e5		 mov	 esp, ebp
  001b3	5d		 pop	 ebp
  001b4	c2 18 00	 ret	 24			; 00000018H
?initDefault@CLogger@@QAE_NPAD0HHH0@Z ENDP		; CLogger::initDefault
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File e:\infinia-library-3.0\com\include\comlogger.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
;	COMDAT ??1CLogger@@QAE@XZ
_TEXT	SEGMENT
??1CLogger@@QAE@XZ PROC					; CLogger::~CLogger, COMDAT
; _this$ = ecx

; 118  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 119  : 	if (isLogFlag(IS_LOG_ENABLE)) {

  00003	8b 4e 74	 mov	 ecx, DWORD PTR [esi+116]
  00006	8b c1		 mov	 eax, ecx
  00008	c1 e8 13	 shr	 eax, 19			; 00000013H
  0000b	a8 01		 test	 al, 1
  0000d	74 09		 je	 SHORT $LN2@CLogger
; File e:\infinia-library-3.0\com\include\comlogger.h

; 184  : 	inline void clearLogFlag(E_LOG_FLAG nFlag) { m_nLogFlag &= ~nFlag; }

  0000f	81 e1 ff ff f7
	ff		 and	 ecx, -524289		; fff7ffffH
  00015	89 4e 74	 mov	 DWORD PTR [esi+116], ecx
$LN2@CLogger:
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 122  : 	if (m_hFile) { fclose(m_hFile); m_hFile = NULL;	}

  00018	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  0001b	85 c0		 test	 eax, eax
  0001d	74 11		 je	 SHORT $LN3@CLogger
  0001f	50		 push	 eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00026	83 c4 04	 add	 esp, 4
  00029	c7 46 58 00 00
	00 00		 mov	 DWORD PTR [esi+88], 0
$LN3@CLogger:

; 123  : 	if (m_pLogDir) {

  00030	8b 46 60	 mov	 eax, DWORD PTR [esi+96]
  00033	85 c0		 test	 eax, eax
  00035	74 12		 je	 SHORT $LN4@CLogger

; 124  : 		delete m_pLogDir; m_pLogDir = NULL;

  00037	6a 01		 push	 1
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003f	83 c4 08	 add	 esp, 8
  00042	c7 46 60 00 00
	00 00		 mov	 DWORD PTR [esi+96], 0
$LN4@CLogger:

; 125  : 	}
; 126  : 	if (m_pLogName) {

  00049	8b 46 64	 mov	 eax, DWORD PTR [esi+100]
  0004c	85 c0		 test	 eax, eax
  0004e	74 12		 je	 SHORT $LN5@CLogger

; 127  : 		delete m_pLogName; m_pLogName = NULL;

  00050	6a 01		 push	 1
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00058	83 c4 08	 add	 esp, 8
  0005b	c7 46 64 00 00
	00 00		 mov	 DWORD PTR [esi+100], 0
$LN5@CLogger:

; 128  : 	}
; 129  : 	if (m_pFName) {

  00062	8b 46 5c	 mov	 eax, DWORD PTR [esi+92]
  00065	85 c0		 test	 eax, eax
  00067	74 12		 je	 SHORT $LN6@CLogger

; 130  : 		delete m_pFName; m_pFName = NULL;

  00069	6a 01		 push	 1
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00071	83 c4 08	 add	 esp, 8
  00074	c7 46 5c 00 00
	00 00		 mov	 DWORD PTR [esi+92], 0
$LN6@CLogger:

; 131  : 	}
; 132  : }

  0007b	8b ce		 mov	 ecx, esi
  0007d	5e		 pop	 esi
  0007e	e9 00 00 00 00	 jmp	 ??1CQueueS@@QAE@XZ	; CQueueS::~CQueueS
??1CLogger@@QAE@XZ ENDP					; CLogger::~CLogger
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comlogger.cpp
;	COMDAT ??0CLogger@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CLogger@@QAE@XZ PROC					; CLogger::CLogger, COMDAT
; _this$ = ecx

; 90   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0000a	e8 00 00 00 00	 call	 ??0CQueueS@@QAE@XZ	; CQueueS::CQueueS

; 91   : 	m_hFile = NULL;
; 92   : 	m_pFName = NULL;
; 93   : 
; 94   : 	m_nLogLevel = eLDOPT_LOGLEVEL;
; 95   : 	m_nLogSize = 0;
; 96   : 	m_nLogFlag = 0;
; 97   : 	m_nStlNo = eLDOPT_STL_NO;
; 98   : 
; 99   : 	m_pLogDir = NULL;
; 100  : 	m_pLogName = NULL;
; 101  : 	strcpy(m_szFileExtension,g_szLogExtension);

  0000f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_szLogExtension@@3PADA ; g_szLogExtension
  00014	c7 46 58 00 00
	00 00		 mov	 DWORD PTR [esi+88], 0
  0001b	8d 56 68	 lea	 edx, DWORD PTR [esi+104]
  0001e	c7 46 5c 00 00
	00 00		 mov	 DWORD PTR [esi+92], 0
  00025	c7 46 4c 03 00
	00 00		 mov	 DWORD PTR [esi+76], 3
  0002c	2b d1		 sub	 edx, ecx
  0002e	c7 86 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+132], 0
  00038	c7 46 74 00 00
	00 00		 mov	 DWORD PTR [esi+116], 0
  0003f	c7 46 7c 00 00
	00 00		 mov	 DWORD PTR [esi+124], 0
  00046	c7 46 60 00 00
	00 00		 mov	 DWORD PTR [esi+96], 0
  0004d	c7 46 64 00 00
	00 00		 mov	 DWORD PTR [esi+100], 0
$LL3@CLogger:
  00054	8a 01		 mov	 al, BYTE PTR [ecx]
  00056	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00059	88 44 0a ff	 mov	 BYTE PTR [edx+ecx-1], al
  0005d	84 c0		 test	 al, al
  0005f	75 f3		 jne	 SHORT $LL3@CLogger

; 102  : 	m_nSeq = 0;

  00061	c7 46 78 00 00
	00 00		 mov	 DWORD PTR [esi+120], 0

; 103  : 	m_nSizeLimit = eLDOPT_SIZE_LIMIT;

  00068	c7 86 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+128], 0

; 104  : 	m_nLogSize = 0;

  00072	c7 86 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+132], 0

; 105  : 	m_nDateTimeFormat = 0;

  0007c	c7 46 50 00 00
	00 00		 mov	 DWORD PTR [esi+80], 0

; 106  : 	m_fpDataProc = NULL;

  00083	c7 46 40 00 00
	00 00		 mov	 DWORD PTR [esi+64], 0

; 107  : 
; 108  : 	m_szHeaderFormat[0] = 0;

  0008a	88 86 88 00 00
	00		 mov	 BYTE PTR [esi+136], al

; 109  : 	m_pObj = NULL;
; 110  : 
; 111  : 	m_nDeleteInterval = 0;
; 112  : 	m_tDeleteGoal = 0;
; 113  : }

  00090	8b c6		 mov	 eax, esi
  00092	c7 46 48 00 00
	00 00		 mov	 DWORD PTR [esi+72], 0
  00099	c7 86 d0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+208], 0
  000a3	c7 86 c8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+200], 0
  000ad	c7 86 cc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+204], 0
  000b7	5e		 pop	 esi
  000b8	8b e5		 mov	 esp, ebp
  000ba	5d		 pop	 ebp
  000bb	c3		 ret	 0
??0CLogger@@QAE@XZ ENDP					; CLogger::CLogger
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ?__autoclassinit2@CTimeExpManager@@QAEXI@Z
_TEXT	SEGMENT
_classSize$ = 8						; size = 4
?__autoclassinit2@CTimeExpManager@@QAEXI@Z PROC		; CTimeExpManager::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	ff 75 08	 push	 DWORD PTR _classSize$[ebp]
  00006	6a 00		 push	 0
  00008	51		 push	 ecx
  00009	e8 00 00 00 00	 call	 _memset
  0000e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?__autoclassinit2@CTimeExpManager@@QAEXI@Z ENDP		; CTimeExpManager::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File e:\infinia-library-3.0\com\include\comtypes.h
; File e:\infinia-library-3.0\com\include\comlist.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File e:\infinia-library-3.0\com\include\comlist.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
;	COMDAT ?getDTE@CTimeExpManager@@QAEPAUSTLogDateTimeExp@@H@Z
_TEXT	SEGMENT
_nIdx$ = 8						; size = 4
?getDTE@CTimeExpManager@@QAEPAUSTLogDateTimeExp@@H@Z PROC ; CTimeExpManager::getDTE, COMDAT
; _this$ = ecx

; 38   : STLogDateTimeExp *CTimeExpManager::getDTE(int nIdx) { if (!m_pTimeExpList) return NULL;  return (STLogDateTimeExp *)m_pTimeExpList->getObj(nIdx); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	85 c0		 test	 eax, eax
  00007	74 15		 je	 SHORT $LN5@getDTE
; File e:\infinia-library-3.0\com\include\comtypes.h

; 322  : inline bool ISINCLUDE(int i, int max) { if (0 <= i && i < max) return true; return false; }

  00009	8b 4d 08	 mov	 ecx, DWORD PTR _nIdx$[ebp]
  0000c	85 c9		 test	 ecx, ecx
  0000e	78 0e		 js	 SHORT $LN5@getDTE
  00010	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  00013	7d 09		 jge	 SHORT $LN5@getDTE
; File e:\infinia-library-3.0\com\include\comlist.h

; 33   : 	inline void* getObj(int i) { if (ISINCLUDE(i, m_nMax)) return m_pArray[i]; return NULL; }

  00015	8b 00		 mov	 eax, DWORD PTR [eax]
  00017	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 38   : STLogDateTimeExp *CTimeExpManager::getDTE(int nIdx) { if (!m_pTimeExpList) return NULL;  return (STLogDateTimeExp *)m_pTimeExpList->getObj(nIdx); }

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
$LN5@getDTE:
; File e:\infinia-library-3.0\com\include\comlist.h

; 33   : 	inline void* getObj(int i) { if (ISINCLUDE(i, m_nMax)) return m_pArray[i]; return NULL; }

  0001e	33 c0		 xor	 eax, eax
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 38   : STLogDateTimeExp *CTimeExpManager::getDTE(int nIdx) { if (!m_pTimeExpList) return NULL;  return (STLogDateTimeExp *)m_pTimeExpList->getObj(nIdx); }

  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
?getDTE@CTimeExpManager@@QAEPAUSTLogDateTimeExp@@H@Z ENDP ; CTimeExpManager::getDTE
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File e:\infinia-library-3.0\com\include\comlist.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
; File e:\infinia-library-3.0\com\include\comlist.h
; File e:\infinia-library-3.0\com\src\comlogger.cpp
;	COMDAT ?initConfig@CTimeExpManager@@QAE_NPAD@Z
_TEXT	SEGMENT
_nCount$1$ = -92					; size = 4
_this$GSCopy$1$ = -88					; size = 4
_i$1$ = -84						; size = 4
$T2 = -84						; size = 4
_szSection$ = -80					; size = 64
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pConfig$ = 8						; size = 4
?initConfig@CTimeExpManager@@QAE_NPAD@Z PROC		; CTimeExpManager::initConfig, COMDAT
; _this$ = ecx

; 41   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?initConfig@CTimeExpManager@@QAE_NPAD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d a8	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx
  0002d	8b 7d 08	 mov	 edi, DWORD PTR _pConfig$[ebp]

; 42   : 	TCHAR szSection[64];
; 43   : 	STLogDateTimeExp *pDTE;
; 44   : 	size_t nDTESize = sizeof(STLogDateTimeExp);
; 45   : 	int nCount;
; 46   : 
; 47   : 
; 48   : 	nCount = GetPrivateProfileInt(_T("DATETIME_EXPRESSION"), _T("LIST_MAX"), 0, pConfig);

  00030	57		 push	 edi
  00031	6a 00		 push	 0
  00033	68 00 00 00 00	 push	 OFFSET ??_C@_08ECKHJDBO@LIST_MAX?$AA@
  00038	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@OHGDFFFE@DATETIME_EXPRESSION?$AA@
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16

; 49   : 	int i;
; 50   : 	m_pTimeExpList = new CSList();

  00043	6a 18		 push	 24			; 00000018H
  00045	89 45 a4	 mov	 DWORD PTR _nCount$1$[ebp], eax
  00048	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0004d	83 c4 04	 add	 esp, 4
  00050	89 45 ac	 mov	 DWORD PTR $T2[ebp], eax
  00053	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0005a	85 c0		 test	 eax, eax
  0005c	74 16		 je	 SHORT $LN10@initConfig
  0005e	0f 57 c0	 xorps	 xmm0, xmm0
  00061	8b c8		 mov	 ecx, eax
  00063	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  00066	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
  0006b	e8 00 00 00 00	 call	 ??0CSList@@QAE@XZ	; CSList::CSList
  00070	8b f0		 mov	 esi, eax
  00072	eb 02		 jmp	 SHORT $LN11@initConfig
$LN10@initConfig:
  00074	33 f6		 xor	 esi, esi
$LN11@initConfig:
  00076	8b 45 a8	 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
  00079	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00080	89 30		 mov	 DWORD PTR [eax], esi

; 51   : 	if (!m_pTimeExpList) {

  00082	85 f6		 test	 esi, esi
  00084	75 1b		 jne	 SHORT $LN5@initConfig

; 52   : 		printf("new CList() is NULL!\t%s%d\n", __FUNCTION__, __LINE__);

  00086	6a 34		 push	 52			; 00000034H
  00088	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@HEFKLFAD@CTimeExpManager?3?3initConfig?$AA@
  0008d	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@BAFPIJBO@new?5CList?$CI?$CJ?5is?5NULL?$CB?7?$CFs?$CFd?6?$AA@
  00092	e8 00 00 00 00	 call	 _printf
  00097	83 c4 0c	 add	 esp, 12			; 0000000cH

; 53   : 		return false;

  0009a	32 c0		 xor	 al, al
  0009c	e9 3f 01 00 00	 jmp	 $LN1@initConfig
$LN5@initConfig:

; 55   : 	if (!m_pTimeExpList->alloc(nCount + LIST_ADD_COUNT, eAlloc_Type_alloc)) {

  000a1	8b 45 a4	 mov	 eax, DWORD PTR _nCount$1$[ebp]
; File e:\infinia-library-3.0\com\include\comlist.h

; 27   : 	inline int alloc(int nMaxCount, E_ALLOC_TYPE type = eAlloc_Type_new) { m_nObjAllocType = type;  m_nMax = __alloc(nMaxCount); return m_nMax; }

  000a4	8b ce		 mov	 ecx, esi
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 55   : 	if (!m_pTimeExpList->alloc(nCount + LIST_ADD_COUNT, eAlloc_Type_alloc)) {

  000a6	83 c0 0a	 add	 eax, 10			; 0000000aH
; File e:\infinia-library-3.0\com\include\comlist.h

; 27   : 	inline int alloc(int nMaxCount, E_ALLOC_TYPE type = eAlloc_Type_new) { m_nObjAllocType = type;  m_nMax = __alloc(nMaxCount); return m_nMax; }

  000a9	c7 46 14 03 00
	00 00		 mov	 DWORD PTR [esi+20], 3
  000b0	50		 push	 eax
  000b1	e8 00 00 00 00	 call	 ?__alloc@CSList@@AAEHH@Z ; CSList::__alloc
  000b6	89 46 10	 mov	 DWORD PTR [esi+16], eax
; File e:\infinia-library-3.0\com\src\comlogger.cpp

; 55   : 	if (!m_pTimeExpList->alloc(nCount + LIST_ADD_COUNT, eAlloc_Type_alloc)) {

  000b9	85 c0		 test	 eax, eax
  000bb	75 1b		 jne	 SHORT $LN6@initConfig

; 56   : 		printf("m_pTimeExpList->alloc has Failed!\t%s%d\n", __FUNCTION__, __LINE__);

  000bd	6a 38		 push	 56			; 00000038H
  000bf	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@HEFKLFAD@CTimeExpManager?3?3initConfig?$AA@
  000c4	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@PPNBAKOP@m_pTimeExpList?9?$DOalloc?5has?5Failed@
  000c9	e8 00 00 00 00	 call	 _printf
  000ce	83 c4 0c	 add	 esp, 12			; 0000000cH

; 57   : 		return false;

  000d1	32 c0		 xor	 al, al
  000d3	e9 08 01 00 00	 jmp	 $LN1@initConfig
$LN6@initConfig:

; 58   : 	}
; 59   : 	
; 60   : 	// Default
; 61   : 	if (!nCount) {

  000d8	8b 45 a4	 mov	 eax, DWORD PTR _nCount$1$[ebp]
  000db	85 c0		 test	 eax, eax
  000dd	75 38		 jne	 SHORT $LN7@initConfig

; 62   : 		nCount = 1;
; 63   : 		pDTE = (STLogDateTimeExp *)malloc(nDTESize);

  000df	6a 0c		 push	 12			; 0000000cH
  000e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  000e7	83 c4 04	 add	 esp, 4

; 64   : 		pDTE->bTimeDelimeter = 1;
; 65   : 		pDTE->cDateDelimeter = '/';

  000ea	66 c7 40 01 2f
	01		 mov	 WORD PTR [eax+1], 303	; 0000012fH

; 66   : 		pDTE->bBracketEnclosed = 1;
; 67   : 		pDTE->nLastType = DT_MILLISEC;
; 68   : 		pDTE->nYearLen = 4;
; 69   : 		pDTE->nTZType = TZ_NONE;
; 70   : 		m_pTimeExpList->push_back(pDTE);

  000f0	6a 00		 push	 0
  000f2	c6 00 01	 mov	 BYTE PTR [eax], 1
  000f5	c7 40 04 02 00
	00 00		 mov	 DWORD PTR [eax+4], 2
  000fc	c6 40 03 04	 mov	 BYTE PTR [eax+3], 4
  00100	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  00107	50		 push	 eax
  00108	8b 45 a8	 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
  0010b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0010d	e8 00 00 00 00	 call	 ?push_back@CSList@@QAE_NPAXPAH@Z ; CSList::push_back

; 71   : 	}
; 72   : 	else {

  00112	e9 c7 00 00 00	 jmp	 $LN3@initConfig
$LN7@initConfig:

; 73   : 		for (i = 0; i < nCount; i++) {

  00117	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _i$1$[ebp], 0
  0011e	85 c0		 test	 eax, eax
  00120	0f 8e b8 00 00
	00		 jle	 $LN3@initConfig
$LL4@initConfig:

; 74   : 			pDTE = (STLogDateTimeExp *)malloc(nDTESize);

  00126	6a 0c		 push	 12			; 0000000cH
  00128	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc

; 75   : 			_stprintf(szSection, _T("DATETIME_EXPRESSION_%d"), i);

  0012e	ff 75 ac	 push	 DWORD PTR _i$1$[ebp]
  00131	8b f0		 mov	 esi, eax
  00133	8d 45 b0	 lea	 eax, DWORD PTR _szSection$[ebp]
  00136	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@NELLCKCE@DATETIME_EXPRESSION_?$CFd?$AA@
  0013b	50		 push	 eax
  0013c	e8 00 00 00 00	 call	 _sprintf
  00141	83 c4 10	 add	 esp, 16			; 00000010H

; 76   : 			pDTE->bTimeDelimeter = GetPrivateProfileInt(szSection, _T("IS_TIME_DELIMETER"), 1, pConfig);

  00144	8d 45 b0	 lea	 eax, DWORD PTR _szSection$[ebp]
  00147	57		 push	 edi
  00148	6a 01		 push	 1
  0014a	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OCOKOBEC@IS_TIME_DELIMETER?$AA@
  0014f	50		 push	 eax
  00150	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16

; 77   : 			pDTE->cDateDelimeter = (char)GetPrivateProfileInt(szSection, _T("DATE_DELIMETER"), '/', pConfig);

  00156	57		 push	 edi
  00157	6a 2f		 push	 47			; 0000002fH
  00159	88 46 02	 mov	 BYTE PTR [esi+2], al
  0015c	8d 45 b0	 lea	 eax, DWORD PTR _szSection$[ebp]
  0015f	68 00 00 00 00	 push	 OFFSET ??_C@_0P@LDLGAHN@DATE_DELIMETER?$AA@
  00164	50		 push	 eax
  00165	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16

; 78   : 			pDTE->bBracketEnclosed = GetPrivateProfileInt(szSection, _T("IS_BRACKET_ENCLOSED"), 1, pConfig);

  0016b	57		 push	 edi
  0016c	6a 01		 push	 1
  0016e	88 46 01	 mov	 BYTE PTR [esi+1], al
  00171	8d 45 b0	 lea	 eax, DWORD PTR _szSection$[ebp]
  00174	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@BMLAJOJB@IS_BRACKET_ENCLOSED?$AA@
  00179	50		 push	 eax
  0017a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16

; 79   : 			pDTE->nLastType = (DT_TYPE)GetPrivateProfileInt(szSection, _T("LAST_TYPE"), DT_MILLISEC, pConfig);

  00180	57		 push	 edi
  00181	6a 02		 push	 2
  00183	88 06		 mov	 BYTE PTR [esi], al
  00185	8d 45 b0	 lea	 eax, DWORD PTR _szSection$[ebp]
  00188	68 00 00 00 00	 push	 OFFSET ??_C@_09DKNFFIJD@LAST_TYPE?$AA@
  0018d	50		 push	 eax
  0018e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16

; 80   : 			pDTE->nYearLen = GetPrivateProfileInt(szSection, _T("YEAR_LEN"), 4, pConfig);

  00194	57		 push	 edi
  00195	6a 04		 push	 4
  00197	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0019a	8d 45 b0	 lea	 eax, DWORD PTR _szSection$[ebp]
  0019d	68 00 00 00 00	 push	 OFFSET ??_C@_08HGGKJFPL@YEAR_LEN?$AA@
  001a2	50		 push	 eax
  001a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16

; 81   : 			pDTE->nTZType = (TZ_TYPE)GetPrivateProfileInt(szSection, _T("TZ_TYPE"), TZ_NONE, pConfig);

  001a9	57		 push	 edi
  001aa	6a 00		 push	 0
  001ac	88 46 03	 mov	 BYTE PTR [esi+3], al
  001af	8d 45 b0	 lea	 eax, DWORD PTR _szSection$[ebp]
  001b2	68 00 00 00 00	 push	 OFFSET ??_C@_07KLOIGNKC@TZ_TYPE?$AA@
  001b7	50		 push	 eax
  001b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  001be	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 82   : 			m_pTimeExpList->push_back(pDTE);

  001c1	8b 45 a8	 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
  001c4	6a 00		 push	 0
  001c6	56		 push	 esi
  001c7	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c9	e8 00 00 00 00	 call	 ?push_back@CSList@@QAE_NPAXPAH@Z ; CSList::push_back
  001ce	8b 45 ac	 mov	 eax, DWORD PTR _i$1$[ebp]
  001d1	40		 inc	 eax
  001d2	89 45 ac	 mov	 DWORD PTR _i$1$[ebp], eax
  001d5	3b 45 a4	 cmp	 eax, DWORD PTR _nCount$1$[ebp]
  001d8	0f 8c 48 ff ff
	ff		 jl	 $LL4@initConfig
$LN3@initConfig:

; 83   : 		}
; 84   : 	}
; 85   : 	return true;

  001de	b0 01		 mov	 al, 1
$LN1@initConfig:

; 86   : }

  001e0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001e3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001ea	59		 pop	 ecx
  001eb	5f		 pop	 edi
  001ec	5e		 pop	 esi
  001ed	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001f0	33 cd		 xor	 ecx, ebp
  001f2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f7	8b e5		 mov	 esp, ebp
  001f9	5d		 pop	 ebp
  001fa	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?initConfig@CTimeExpManager@@QAE_NPAD@Z$0:
  00000	6a 18		 push	 24			; 00000018H
  00002	8b 45 ac	 mov	 eax, DWORD PTR $T2[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
__ehhandler$?initConfig@CTimeExpManager@@QAE_NPAD@Z:
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a a4	 mov	 ecx, DWORD PTR [edx-92]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?initConfig@CTimeExpManager@@QAE_NPAD@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?initConfig@CTimeExpManager@@QAE_NPAD@Z ENDP		; CTimeExpManager::initConfig
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comlogger.cpp
;	COMDAT ??1CTimeExpManager@@QAE@XZ
_TEXT	SEGMENT
??1CTimeExpManager@@QAE@XZ PROC				; CTimeExpManager::~CTimeExpManager, COMDAT
; _this$ = ecx

; 34   : {

  00000	56		 push	 esi

; 35   : 	if (m_pTimeExpList) delete m_pTimeExpList; // 내부 malloc 까지 전부 destroy

  00001	8b 31		 mov	 esi, DWORD PTR [ecx]
  00003	85 f6		 test	 esi, esi
  00005	74 12		 je	 SHORT $LN7@CTimeExpMa
  00007	8b ce		 mov	 ecx, esi
  00009	e8 00 00 00 00	 call	 ??1CSList@@QAE@XZ	; CSList::~CSList
  0000e	6a 18		 push	 24			; 00000018H
  00010	56		 push	 esi
  00011	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00016	83 c4 08	 add	 esp, 8
$LN7@CTimeExpMa:
  00019	5e		 pop	 esi

; 36   : }

  0001a	c3		 ret	 0
??1CTimeExpManager@@QAE@XZ ENDP				; CTimeExpManager::~CTimeExpManager
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comlogger.cpp
;	COMDAT ??0CTimeExpManager@@QAE@XZ
_TEXT	SEGMENT
??0CTimeExpManager@@QAE@XZ PROC				; CTimeExpManager::CTimeExpManager, COMDAT
; _this$ = ecx

; 31   : 	m_pTimeExpList = NULL;

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 32   : }

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0CTimeExpManager@@QAE@XZ ENDP				; CTimeExpManager::CTimeExpManager
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCSList@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCSList@@QAEPAXI@Z PROC				; CSList::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CSList@@QAE@XZ	; CSList::~CSList
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 18		 push	 24			; 00000018H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_GCSList@@QAEPAXI@Z ENDP				; CSList::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ?__autoclassinit2@CSList@@QAEXI@Z
_TEXT	SEGMENT
_classSize$ = 8						; size = 4
?__autoclassinit2@CSList@@QAEXI@Z PROC			; CSList::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	ff 75 08	 push	 DWORD PTR _classSize$[ebp]
  00006	6a 00		 push	 0
  00008	51		 push	 ecx
  00009	e8 00 00 00 00	 call	 _memset
  0000e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?__autoclassinit2@CSList@@QAEXI@Z ENDP			; CSList::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\comlist.h
; File e:\infinia-library-3.0\com\include\comtypes.h
; File e:\infinia-library-3.0\com\include\comlist.h
;	COMDAT ?getObj@CSList@@QAEPAXH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?getObj@CSList@@QAEPAXH@Z PROC				; CSList::getObj, COMDAT
; _this$ = ecx

; 33   : 	inline void* getObj(int i) { if (ISINCLUDE(i, m_nMax)) return m_pArray[i]; return NULL; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File e:\infinia-library-3.0\com\include\comtypes.h

; 322  : inline bool ISINCLUDE(int i, int max) { if (0 <= i && i < max) return true; return false; }

  00003	8b 55 08	 mov	 edx, DWORD PTR _i$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	78 0e		 js	 SHORT $LN2@getObj
  0000a	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  0000d	7d 09		 jge	 SHORT $LN2@getObj
; File e:\infinia-library-3.0\com\include\comlist.h

; 33   : 	inline void* getObj(int i) { if (ISINCLUDE(i, m_nMax)) return m_pArray[i]; return NULL; }

  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00011	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN2@getObj:
  00018	33 c0		 xor	 eax, eax
  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?getObj@CSList@@QAEPAXH@Z ENDP				; CSList::getObj
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\comlist.h
;	COMDAT ?alloc@CSList@@QAEHHW4E_ALLOC_TYPE@@@Z
_TEXT	SEGMENT
_nMaxCount$ = 8						; size = 4
_type$ = 12						; size = 4
?alloc@CSList@@QAEHHW4E_ALLOC_TYPE@@@Z PROC		; CSList::alloc, COMDAT
; _this$ = ecx

; 27   : 	inline int alloc(int nMaxCount, E_ALLOC_TYPE type = eAlloc_Type_new) { m_nObjAllocType = type;  m_nMax = __alloc(nMaxCount); return m_nMax; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR _type$[ebp]
  00006	56		 push	 esi
  00007	ff 75 08	 push	 DWORD PTR _nMaxCount$[ebp]
  0000a	8b f1		 mov	 esi, ecx
  0000c	89 46 14	 mov	 DWORD PTR [esi+20], eax
  0000f	e8 00 00 00 00	 call	 ?__alloc@CSList@@AAEHH@Z ; CSList::__alloc
  00014	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
?alloc@CSList@@QAEHHW4E_ALLOC_TYPE@@@Z ENDP		; CSList::alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\commemmanager.h
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\include\commemmanager.h
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\include\commemmanager.h
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\include\commemmanager.h
;	COMDAT ?newBuf@CMemManager@@QAEPADH@Z
_TEXT	SEGMENT
_$S1$1 = -8						; size = 8
_nSize$ = 8						; size = 4
?newBuf@CMemManager@@QAEPADH@Z PROC			; CMemManager::newBuf, COMDAT
; _this$ = ecx

; 34   : 	inline char *newBuf(int nSize) { int nIdx = getIndex(nSize);  return __newBuf(nIdx, nSize); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
; File e:\infinia-library-3.0\com\include\combufpool.h

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  00006	8b 55 08	 mov	 edx, DWORD PTR _nSize$[ebp]
  00009	b8 01 00 00 00	 mov	 eax, 1
  0000e	56		 push	 esi
  0000f	57		 push	 edi
; File e:\infinia-library-3.0\com\include\commemmanager.h

; 34   : 	inline char *newBuf(int nSize) { int nIdx = getIndex(nSize);  return __newBuf(nIdx, nSize); }

  00010	8b f9		 mov	 edi, ecx
  00012	66 0f 6e c2	 movd	 xmm0, edx
; File e:\infinia-library-3.0\com\include\combufpool.h

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  00016	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
; File e:\infinia-library-3.0\com\include\commemmanager.h

; 34   : 	inline char *newBuf(int nSize) { int nIdx = getIndex(nSize);  return __newBuf(nIdx, nSize); }

  0001a	52		 push	 edx
; File e:\infinia-library-3.0\com\include\combufpool.h

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  0001b	f2 0f 11 45 f8	 movsd	 QWORD PTR _$S1$1[ebp], xmm0
  00020	8b 75 fc	 mov	 esi, DWORD PTR _$S1$1[ebp+4]
  00023	c1 fe 14	 sar	 esi, 20			; 00000014H
  00026	81 ee ff 03 00
	00		 sub	 esi, 1023		; 000003ffH
  0002c	8b ce		 mov	 ecx, esi
  0002e	d3 e0		 shl	 eax, cl
  00030	8b ca		 mov	 ecx, edx
  00032	2b c8		 sub	 ecx, eax
  00034	23 ca		 and	 ecx, edx
  00036	f7 d9		 neg	 ecx
  00038	1b c9		 sbb	 ecx, ecx
  0003a	f7 d9		 neg	 ecx
  0003c	03 ce		 add	 ecx, esi
; File e:\infinia-library-3.0\com\include\commemmanager.h

; 34   : 	inline char *newBuf(int nSize) { int nIdx = getIndex(nSize);  return __newBuf(nIdx, nSize); }

  0003e	51		 push	 ecx
  0003f	8b cf		 mov	 ecx, edi
  00041	e8 00 00 00 00	 call	 ?__newBuf@CMemManager@@AAEPADHI@Z ; CMemManager::__newBuf
  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4
?newBuf@CMemManager@@QAEPADH@Z ENDP			; CMemManager::newBuf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\combufpool.h
;	COMDAT ?getIndex@@YAHH@Z
_TEXT	SEGMENT
_$S1$ = -8						; size = 8
_s$ = 8							; size = 4
?getIndex@@YAHH@Z PROC					; getIndex, COMDAT

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	8b 75 08	 mov	 esi, DWORD PTR _s$[ebp]
  0000a	ba 01 00 00 00	 mov	 edx, 1
  0000f	8b c6		 mov	 eax, esi
  00011	66 0f 6e c6	 movd	 xmm0, esi
  00015	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00019	f2 0f 11 45 f8	 movsd	 QWORD PTR _$S1$[ebp], xmm0
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _$S1$[ebp+4]
  00021	c1 f9 14	 sar	 ecx, 20			; 00000014H
  00024	81 e9 ff 03 00
	00		 sub	 ecx, 1023		; 000003ffH
  0002a	d3 e2		 shl	 edx, cl
  0002c	2b c2		 sub	 eax, edx
  0002e	23 c6		 and	 eax, esi
  00030	f7 d8		 neg	 eax
  00032	5e		 pop	 esi
  00033	1b c0		 sbb	 eax, eax
  00035	f7 d8		 neg	 eax
  00037	03 c1		 add	 eax, ecx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
?getIndex@@YAHH@Z ENDP					; getIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\comdatetime.h
;	COMDAT ?TimezoneString@CDateTime@@QAEPBDXZ
_TEXT	SEGMENT
?TimezoneString@CDateTime@@QAEPBDXZ PROC		; CDateTime::TimezoneString, COMDAT
; _this$ = ecx

; 224  : 	inline const TCHAR *TimezoneString() { return m_szTimezone; }

  00000	8d 41 5c	 lea	 eax, DWORD PTR [ecx+92]
  00003	c3		 ret	 0
?TimezoneString@CDateTime@@QAEPBDXZ ENDP		; CDateTime::TimezoneString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\comqueue.h
;	COMDAT ?capacity@CQueueS@@QAEHXZ
_TEXT	SEGMENT
?capacity@CQueueS@@QAEHXZ PROC				; CQueueS::capacity, COMDAT
; _this$ = ecx

; 43   :     inline int  capacity()   { return m_nMax; }

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	c3		 ret	 0
?capacity@CQueueS@@QAEHXZ ENDP				; CQueueS::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\comtypes.h
;	COMDAT ?comGlobalErrorProc@@YAXPADPBDH@Z
_TEXT	SEGMENT
_pMsg$ = 8						; size = 4
__szFunc$ = 12						; size = 4
__nLine$ = 16						; size = 4
?comGlobalErrorProc@@YAXPADPBDH@Z PROC			; comGlobalErrorProc, COMDAT

; 324  : inline void comGlobalErrorProc(char *pMsg, const char *_szFunc, const int _nLine) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 325  : 	sprintf(g_szSystemError, "ERROR! [%s:%d] %s\n", _szFunc, _nLine, pMsg);

  00003	ff 75 08	 push	 DWORD PTR _pMsg$[ebp]
  00006	ff 75 10	 push	 DWORD PTR __nLine$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __szFunc$[ebp]
  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@KEHDJCKJ@ERROR?$CB?5?$FL?$CFs?3?$CFd?$FN?5?$CFs?6?$AA@
  00011	68 00 00 00 00	 push	 OFFSET ?g_szSystemError@@3PADA ; g_szSystemError
  00016	e8 00 00 00 00	 call	 _sprintf

; 326  : 	printf(g_szSystemError);

  0001b	68 00 00 00 00	 push	 OFFSET ?g_szSystemError@@3PADA ; g_szSystemError
  00020	e8 00 00 00 00	 call	 _printf
  00025	83 c4 18	 add	 esp, 24			; 00000018H

; 327  : }

  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?comGlobalErrorProc@@YAXPADPBDH@Z ENDP			; comGlobalErrorProc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\comtypes.h
;	COMDAT ?ISINCLUDE@@YA_NHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
_max$ = 12						; size = 4
?ISINCLUDE@@YA_NHH@Z PROC				; ISINCLUDE, COMDAT

; 322  : inline bool ISINCLUDE(int i, int max) { if (0 <= i && i < max) return true; return false; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 09		 js	 SHORT $LN2@ISINCLUDE
  0000a	3b 45 0c	 cmp	 eax, DWORD PTR _max$[ebp]
  0000d	7d 04		 jge	 SHORT $LN2@ISINCLUDE
  0000f	b0 01		 mov	 al, 1
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
$LN2@ISINCLUDE:
  00013	32 c0		 xor	 al, al
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?ISINCLUDE@@YA_NHH@Z ENDP				; ISINCLUDE
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h
;	COMDAT _time
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_time	PROC						; COMDAT

; 534  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 536  :         }

  00003	5d		 pop	 ebp

; 535  :             return _time64(_Time);

  00004	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp___time64
_time	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00006	8d 4d 10	 lea	 ecx, DWORD PTR __Format$[ebp+4]
  00009	51		 push	 ecx
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000f	6a ff		 push	 -1
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	83 c9 01	 or	 ecx, 1
  0001f	51		 push	 ecx
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00026	83 c9 ff	 or	 ecx, -1
  00029	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002c	85 c0		 test	 eax, eax
  0002e	0f 48 c1	 cmovs	 eax, ecx

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);
; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);
; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);
; 1787 :     return _Result;
; 1788 : }

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00003	ff 75 14	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 10	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 1459 :     #pragma warning(pop)
; 1460 : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vsnprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
_vsnprintf PROC						; COMDAT

; 1435 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1436 :     int const _Result = __stdio_common_vsprintf(

  00003	ff 75 14	 push	 DWORD PTR __ArgList$[ebp]
  00006	6a 00		 push	 0
  00008	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000b	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 02	 or	 ecx, 2
  0001e	51		 push	 ecx
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf

; 1437 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1438 :         _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1439 : 
; 1440 :     return _Result < 0 ? -1 : _Result;

  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1441 : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
_vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsnprintf PROC					; COMDAT

; 1405 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00003	ff 75 14	 push	 DWORD PTR __ArgList$[ebp]
  00006	6a 00		 push	 0
  00008	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000b	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1406 :     #pragma warning(push)
; 1407 :     #pragma warning(disable: 4996) // Deprecation
; 1408 :     return _vsnprintf_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1409 :     #pragma warning(pop)
; 1410 : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
__vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00003	ff 75 18	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 14	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	83 c9 01	 or	 ecx, 1
  0001f	51		 push	 ecx
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00026	83 c9 ff	 or	 ecx, -1
  00029	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002c	85 c0		 test	 eax, eax
  0002e	0f 48 c1	 cmovs	 eax, ecx

; 1391 : }

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 950  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 951  :     int _Result;
; 952  :     va_list _ArgList;
; 953  :     __crt_va_start(_ArgList, _Format);
; 954  :     _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Format$[ebp]
  00007	6a 01		 push	 1
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  0000f	83 c4 04	 add	 esp, 4

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00012	8d 4d 0c	 lea	 ecx, DWORD PTR __Format$[ebp+4]
  00015	51		 push	 ecx
  00016	6a 00		 push	 0
  00018	56		 push	 esi
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0001f	ff 70 04	 push	 DWORD PTR [eax+4]
  00022	ff 30		 push	 DWORD PTR [eax]
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vfprintf
  0002a	83 c4 18	 add	 esp, 24			; 00000018H
  0002d	5e		 pop	 esi

; 955  :     __crt_va_end(_ArgList);
; 956  :     return _Result;
; 957  : }

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 831  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00006	8d 4d 10	 lea	 ecx, DWORD PTR __Format$[ebp+4]
  00009	51		 push	 ecx
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00015	ff 70 04	 push	 DWORD PTR [eax+4]
  00018	ff 30		 push	 DWORD PTR [eax]
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vfprintf
  00020	83 c4 18	 add	 esp, 24			; 00000018H

; 832  :     int _Result;
; 833  :     va_list _ArgList;
; 834  :     __crt_va_start(_ArgList, _Format);
; 835  :     _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);
; 836  :     __crt_va_end(_ArgList);
; 837  :     return _Result;
; 838  : }

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 638  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00003	ff 75 14	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 10	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 08	 push	 DWORD PTR __Stream$[ebp]
  0000f	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00014	ff 70 04	 push	 DWORD PTR [eax+4]
  00017	ff 30		 push	 DWORD PTR [eax]
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vfprintf
  0001f	83 c4 18	 add	 esp, 24			; 00000018H

; 640  : }

  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
;	COMDAT __tcscmp
_TEXT	SEGMENT
__s1$ = 8						; size = 4
__s2$ = 12						; size = 4
__tcscmp PROC						; COMDAT

; 1669 : _Check_return_ __inline int _tcscmp(_In_ _CPC _s1,_In_ _CPC _s2) {return _mbscmp((_CPUC)_s1,(_CPUC)_s2);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp___mbscmp
__tcscmp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
;	COMDAT __tcsrchr
_TEXT	SEGMENT
__s1$ = 8						; size = 4
__c$ = 12						; size = 4
__tcsrchr PROC						; COMDAT

; 1569 : _Check_return_ __inline _CRPC _tcsrchr(_In_ _CPC _s1,_In_ _UI _c) {return (_CRPC)_mbsrchr((_CPUC)_s1,_c);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp___mbsrchr
__tcsrchr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
;	COMDAT __tcsncpy
_TEXT	SEGMENT
__Dst$ = 8						; size = 4
__Source$ = 12						; size = 4
__Count$ = 16						; size = 4
__tcsncpy PROC						; COMDAT

; 1542 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1546 : #pragma warning(pop)
; 1547 : }

  00003	5d		 pop	 ebp

; 1543 : #pragma warning(push)
; 1544 : #pragma warning(disable:4996)
; 1545 :     return (char *)_mbsnbcpy((unsigned char *)_Dst,(const unsigned char *)_Source,_Count);

  00004	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp___mbsnbcpy
__tcsncpy ENDP
_TEXT	ENDS
END
