; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	E:\InfiniA-Library-3.0\com\src\comFileUtil.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	___local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	_printf
PUBLIC	_sprintf
PUBLIC	?delBuf@CMemManager@@QAEXPADH@Z			; CMemManager::delBuf
PUBLIC	?filter_stringCompare@@YA_NPADPAX1@Z		; filter_stringCompare
PUBLIC	?filter_dateTimeCompare@@YA_NPADPAX1@Z		; filter_dateTimeCompare
PUBLIC	?IsExistDirectory@CFileUtil@@SA_NPAD@Z		; CFileUtil::IsExistDirectory
PUBLIC	?GetFileList@CFileUtil@@SA_NPAUSTFileList@@PAUSTFilterData@@@Z ; CFileUtil::GetFileList
PUBLIC	?delDirectory@CFileUtil@@SAHPAUSTDelInfo@@PAUSTFilterData@@@Z ; CFileUtil::delDirectory
PUBLIC	?MakeDirectory@CFileUtil@@SA_NPBD@Z		; CFileUtil::MakeDirectory
PUBLIC	?FileCopy@CFileUtil@@SA_NPBD0@Z			; CFileUtil::FileCopy
PUBLIC	?IsAbsolutePath@CFileUtil@@SA_NPBD@Z		; CFileUtil::IsAbsolutePath
PUBLIC	?setDirectory@CFileUtil@@SA_NPADH@Z		; CFileUtil::setDirectory
PUBLIC	?changeDirName@CFileUtil@@SA_NPAD0@Z		; CFileUtil::changeDirName
PUBLIC	?read@CFileUtil@@SAHPAD0H@Z			; CFileUtil::read
PUBLIC	?readNalloc@CFileUtil@@SAHPADPAPADPAH@Z		; CFileUtil::readNalloc
PUBLIC	?getNextLine@CFileUtil@@SAHPAUSTStrInfo@@@Z	; CFileUtil::getNextLine
PUBLIC	?getFieldList@CFileUtil@@SA_NPADDPAVCStringList@@@Z ; CFileUtil::getFieldList
PUBLIC	?fileToFieldRecord@CFileUtil@@SA_NPADPAV?$CTList@VCStringList@@@@D@Z ; CFileUtil::fileToFieldRecord
PUBLIC	?add@CFileUtil@@SA_NPAD0@Z			; CFileUtil::add
PUBLIC	?getReFileName@CFileUtil@@SA_NPADPBD1@Z		; CFileUtil::getReFileName
PUBLIC	?renameFile@CFileUtil@@SA_NPBD0@Z		; CFileUtil::renameFile
PUBLIC	?getFileSize@CFileUtil@@SAHPAD@Z		; CFileUtil::getFileSize
PUBLIC	?tryopen@CFileUtil@@SAPAU_iobuf@@HPADPBDPAH@Z	; CFileUtil::tryopen
PUBLIC	?modify@CFileUtil@@SA_NPADH0@Z			; CFileUtil::modify
PUBLIC	?getFileSize2@CFileUtil@@SAHPADHPAHH@Z		; CFileUtil::getFileSize2
PUBLIC	?readLoop@CFileUtil@@SAHPADHHPAUSTFileMem@@H@Z	; CFileUtil::readLoop
PUBLIC	?nextReadLoop@CFileUtil@@SAHPADHHPAUSTFileMem@@HH@Z ; CFileUtil::nextReadLoop
PUBLIC	?nextRead@CFileUtil@@SAHPAD0HH@Z		; CFileUtil::nextRead
PUBLIC	?modify@CFileUtil@@SA_NPADHPAUSTFileMem@@@Z	; CFileUtil::modify
PUBLIC	?add@CFileUtil@@SA_NPADHPAUSTFileMem@@@Z	; CFileUtil::add
PUBLIC	?ehstrstr@CFileUtil@@SAPADPBD0@Z		; CFileUtil::ehstrstr
PUBLIC	?appendFileList@CFileUtil@@CA_NPAV?$CTList@UfileInfo@@@@PBDD@Z ; CFileUtil::appendFileList
PUBLIC	?CheckDirName@@YAXPAD@Z				; CheckDirName
PUBLIC	??0?$CTList@UfileInfo@@@@QAE@XZ			; CTList<fileInfo>::CTList<fileInfo>
PUBLIC	?alloc@?$CTList@UfileInfo@@@@QAEHHW4E_ALLOC_TYPE@@@Z ; CTList<fileInfo>::alloc
PUBLIC	?push_back@?$CTList@UfileInfo@@@@QAE_NPAUfileInfo@@PAH@Z ; CTList<fileInfo>::push_back
PUBLIC	?__alloc@?$CTList@UfileInfo@@@@AAEHH@Z		; CTList<fileInfo>::__alloc
PUBLIC	?push_back@?$CTList@VCStringList@@@@QAE_NPAVCStringList@@PAH@Z ; CTList<CStringList>::push_back
PUBLIC	?getNext@?$CTList@VCStringList@@@@QAEPAVCStringList@@PAH@Z ; CTList<CStringList>::getNext
PUBLIC	?__alloc@?$CTList@VCStringList@@@@AAEHH@Z	; CTList<CStringList>::__alloc
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_05DFBJLIFO@?$CFs?$CK?4?$CK?$AA@		; `string'
PUBLIC	??_C@_01LFCBOECM@?4?$AA@			; `string'
PUBLIC	??_C@_02DJGKEECL@?4?4?$AA@			; `string'
PUBLIC	??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@		; `string'
PUBLIC	??_C@_06HCFNFKLM@?$CFs?$CFs?$CFc?$AA@		; `string'
PUBLIC	??_C@_0CA@CEPONNIG@FAILED?5_tremove?$FL?$CFs?$FN?5nResult?$FL?$CFd?$FN?$AA@ ; `string'
PUBLIC	??_C@_0BI@LGHDAFAC@CFileUtil?3?3delDirectory?$AA@ ; `string'
PUBLIC	??_C@_0CB@MCDNEDGF@SUCCESS?5_tremove?$FL?$CFs?$FN?5nResult?$FL?$CFd?$FN@ ; `string'
PUBLIC	??_C@_0BC@OKJOCLIE@SUCCESS?5rmdir?$FL?$CFs?$FN?$AA@ ; `string'
PUBLIC	??_C@_0BB@FMJCPMNG@FAILED?5rmdir?$FL?$CFs?$FN?$AA@ ; `string'
PUBLIC	??_C@_0BF@BIJEHKFJ@fname?$FL?$CFs?$FN?5nCount?$FL?$CFd?$FN?$AA@ ; `string'
PUBLIC	??_C@_0BF@EKILNHNC@?5fname?$FL?$CFd?$FN?5ftype?$FL?$CFd?$FN?$AA@ ; `string'
PUBLIC	??_C@_0BK@LBJCMIIM@CFileUtil?3?3appendFileList?$AA@ ; `string'
PUBLIC	??_C@_02CEGDFPFP@?4?2?$AA@			; `string'
PUBLIC	??_C@_0BL@NPNPEALE@com_mkdir?5has?5Failed?$CB?5?$FL?$CFs?$FN?$AA@ ; `string'
PUBLIC	??_C@_0BJ@KGBJCJNH@CFileUtil?3?3MakeDirectory?$AA@ ; `string'
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	??_C@_03BFHAFKOB@wb?$CL?$AA@			; `string'
PUBLIC	??_C@_0CE@HGILDMCF@CDFSFile?3?3read?5pFile?5open?5FAIL?5?$FL@ ; `string'
PUBLIC	??_C@_09GBGMKMEP@new?5pList?$AA@		; `string'
PUBLIC	??_C@_0BN@FPEGNMGD@CFileUtil?3?3fileToFieldRecord?$AA@ ; `string'
PUBLIC	??_C@_0M@HJCAEDLM@alloc?5pList?$AA@		; `string'
PUBLIC	??_C@_0O@BICGIAHP@add?5pLineList?$AA@		; `string'
PUBLIC	??_C@_0CO@KJLDNOFB@CFileUtil?3?3readNalloc?5malloc?5err@ ; `string'
PUBLIC	??_C@_0BB@PMEFOBEN@fread?5errno?$FL?$CFd?$FN?6?$AA@ ; `string'
PUBLIC	??_C@_0DJ@NKNKPPFB@CFileUtil?3?3getNextLine?5gs_pMMgr?9@ ; `string'
PUBLIC	??_C@_02DPNLHKJD@a?$CL?$AA@			; `string'
PUBLIC	??_C@_0CD@EKCIMLP@CDFSFile?3?3add?5pFile?5open?5FAIL?5?$FL?$CF@ ; `string'
PUBLIC	??_C@_0BI@GLMOIJMA@FILEMOVE?5error?5code?$FL?$CFd?$FN?$AA@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_0CD@CJLBFMFH@CFileUtil?3?3tryopen?5pFile?5open?5FA@ ; `string'
PUBLIC	??_C@_01NOFIACDB@w?$AA@				; `string'
PUBLIC	??_C@_0CH@NODJAAOJ@CFileUtil?3?3modify?5pFile?5open?5FAI@ ; `string'
PUBLIC	??_C@_0CI@DIMAMHM@CDFSFile?3?3readLoop?5pFile?5open?5FA@ ; `string'
PUBLIC	??_C@_0CM@MJNEIDFC@CDFSFile?3?3nextReadLoop?5pFile?5ope@ ; `string'
PUBLIC	??_C@_0CI@OMHCJKIB@CDFSFile?3?3nextRead?5pFile?5open?5FA@ ; `string'
PUBLIC	??_C@_0CG@JGICPKLC@CDFSFile?3?3modify?5pFile?5open?5FAIL@ ; `string'
PUBLIC	??_C@_0CE@IKFEAMNF@CDFSFile?3?3add2?5pFile?5open?5FAIL?5?$FL@ ; `string'
PUBLIC	??_C@_0BF@ENADEEIE@pList?5calloc?5is?5NULL?$AA@	; `string'
PUBLIC	__real@4020000000000000
PUBLIC	__real@40b0000000000000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fflush:PROC
EXTRN	__imp__fopen:PROC
EXTRN	__imp__fread:PROC
EXTRN	__imp__fseek:PROC
EXTRN	__imp__ftell:PROC
EXTRN	__imp__fwrite:PROC
EXTRN	__imp__remove:PROC
EXTRN	__imp__rename:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	__imp___errno:PROC
EXTRN	__imp__strchr:PROC
EXTRN	__imp__calloc:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp___mbschr:PROC
EXTRN	__imp___mbscmp:PROC
EXTRN	__imp___mbsnbcpy:PROC
EXTRN	__imp___mbsrchr:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__FindClose@4:PROC
EXTRN	__imp__CreateDirectoryA@8:PROC
EXTRN	__imp__RemoveDirectoryA@4:PROC
EXTRN	__imp__GetFileAttributesA@4:PROC
EXTRN	__imp__FindFirstFileA@8:PROC
EXTRN	__imp__FindNextFileA@8:PROC
EXTRN	__imp__MoveFileA@8:PROC
EXTRN	??2@YAPAXIABUnothrow_t@std@@@Z:PROC		; operator new
EXTRN	??3@YAXPAXABUnothrow_t@std@@@Z:PROC		; operator delete
EXTRN	??0CFileTime@@QAE@XZ:PROC			; CFileTime::CFileTime
EXTRN	??1CFileTime@@QAE@XZ:PROC			; CFileTime::~CFileTime
EXTRN	?setFileTime@CFileTime@@QAEHPAU_FILETIME@@@Z:PROC ; CFileTime::setFileTime
EXTRN	?isCompare@CFileTime@@QAE_NPAV1@W4E_OPERATOR@@@Z:PROC ; CFileTime::isCompare
EXTRN	?delBufByIndex@CMemManager@@QAEXPADH@Z:PROC	; CMemManager::delBufByIndex
EXTRN	?__newBuf@CMemManager@@AAEPADHI@Z:PROC		; CMemManager::__newBuf
EXTRN	?PutLogQueue@CLogger@@QAAXHPBDZZ:PROC		; CLogger::PutLogQueue
EXTRN	?__debugLog@CLogger@@QAAXHPBDH0ZZ:PROC		; CLogger::__debugLog
EXTRN	?compare@CmString@@QAEHPBD@Z:PROC		; CmString::compare
EXTRN	??0CStringList@@QAE@XZ:PROC			; CStringList::CStringList
EXTRN	??1CStringList@@QAE@XZ:PROC			; CStringList::~CStringList
EXTRN	?__alloc@CStringList@@AAEHH@Z:PROC		; CStringList::__alloc
EXTRN	?__add@CStringList@@AAEPAVCmString@@PADH@Z:PROC	; CStringList::__add
EXTRN	?newIdx@CStringList@@AAEHXZ:PROC		; CStringList::newIdx
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__chkstk:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	?nothrow@std@@3Unothrow_t@1@B:BYTE		; std::nothrow
EXTRN	?g_szMessage@@3PADA:BYTE			; g_szMessage
EXTRN	?gs_pMMgr@@3PAVCMemManager@@A:DWORD		; gs_pMMgr
EXTRN	?gs_cLogger@@3VCLogger@@A:BYTE			; gs_cLogger
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT __real@40b0000000000000
CONST	SEGMENT
__real@40b0000000000000 DQ 040b0000000000000r	; 4096
CONST	ENDS
;	COMDAT __real@4020000000000000
CONST	SEGMENT
__real@4020000000000000 DQ 04020000000000000r	; 8
CONST	ENDS
;	COMDAT ??_C@_0BF@ENADEEIE@pList?5calloc?5is?5NULL?$AA@
CONST	SEGMENT
??_C@_0BF@ENADEEIE@pList?5calloc?5is?5NULL?$AA@ DB 'pList calloc is NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@IKFEAMNF@CDFSFile?3?3add2?5pFile?5open?5FAIL?5?$FL@
CONST	SEGMENT
??_C@_0CE@IKFEAMNF@CDFSFile?3?3add2?5pFile?5open?5FAIL?5?$FL@ DB 'CDFSFil'
	DB	'e::add2 pFile open FAIL [%s]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@JGICPKLC@CDFSFile?3?3modify?5pFile?5open?5FAIL@
CONST	SEGMENT
??_C@_0CG@JGICPKLC@CDFSFile?3?3modify?5pFile?5open?5FAIL@ DB 'CDFSFile::m'
	DB	'odify pFile open FAIL [%s]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@OMHCJKIB@CDFSFile?3?3nextRead?5pFile?5open?5FA@
CONST	SEGMENT
??_C@_0CI@OMHCJKIB@CDFSFile?3?3nextRead?5pFile?5open?5FA@ DB 'CDFSFile::n'
	DB	'extRead pFile open FAIL [%s]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@MJNEIDFC@CDFSFile?3?3nextReadLoop?5pFile?5ope@
CONST	SEGMENT
??_C@_0CM@MJNEIDFC@CDFSFile?3?3nextReadLoop?5pFile?5ope@ DB 'CDFSFile::ne'
	DB	'xtReadLoop pFile open FAIL [%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@DIMAMHM@CDFSFile?3?3readLoop?5pFile?5open?5FA@
CONST	SEGMENT
??_C@_0CI@DIMAMHM@CDFSFile?3?3readLoop?5pFile?5open?5FA@ DB 'CDFSFile::re'
	DB	'adLoop pFile open FAIL [%s]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@NODJAAOJ@CFileUtil?3?3modify?5pFile?5open?5FAI@
CONST	SEGMENT
??_C@_0CH@NODJAAOJ@CFileUtil?3?3modify?5pFile?5open?5FAI@ DB 'CFileUtil::'
	DB	'modify pFile open FAIL [%s]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w?$AA@
CONST	SEGMENT
??_C@_01NOFIACDB@w?$AA@ DB 'w', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@CJLBFMFH@CFileUtil?3?3tryopen?5pFile?5open?5FA@
CONST	SEGMENT
??_C@_0CD@CJLBFMFH@CFileUtil?3?3tryopen?5pFile?5open?5FA@ DB 'CFileUtil::'
	DB	'tryopen pFile open FAIL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@GLMOIJMA@FILEMOVE?5error?5code?$FL?$CFd?$FN?$AA@
CONST	SEGMENT
??_C@_0BI@GLMOIJMA@FILEMOVE?5error?5code?$FL?$CFd?$FN?$AA@ DB 'FILEMOVE e'
	DB	'rror code[%d]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@EKCIMLP@CDFSFile?3?3add?5pFile?5open?5FAIL?5?$FL?$CF@
CONST	SEGMENT
??_C@_0CD@EKCIMLP@CDFSFile?3?3add?5pFile?5open?5FAIL?5?$FL?$CF@ DB 'CDFSF'
	DB	'ile::add pFile open FAIL [%s]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPNLHKJD@a?$CL?$AA@
CONST	SEGMENT
??_C@_02DPNLHKJD@a?$CL?$AA@ DB 'a+', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@NKNKPPFB@CFileUtil?3?3getNextLine?5gs_pMMgr?9@
CONST	SEGMENT
??_C@_0DJ@NKNKPPFB@CFileUtil?3?3getNextLine?5gs_pMMgr?9@ DB 'CFileUtil::g'
	DB	'etNextLine gs_pMMgr->newBuf error! size[%ld]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PMEFOBEN@fread?5errno?$FL?$CFd?$FN?6?$AA@
CONST	SEGMENT
??_C@_0BB@PMEFOBEN@fread?5errno?$FL?$CFd?$FN?6?$AA@ DB 'fread errno[%d]', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@KJLDNOFB@CFileUtil?3?3readNalloc?5malloc?5err@
CONST	SEGMENT
??_C@_0CO@KJLDNOFB@CFileUtil?3?3readNalloc?5malloc?5err@ DB 'CFileUtil::r'
	DB	'eadNalloc malloc error! size[%ld]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BICGIAHP@add?5pLineList?$AA@
CONST	SEGMENT
??_C@_0O@BICGIAHP@add?5pLineList?$AA@ DB 'add pLineList', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HJCAEDLM@alloc?5pList?$AA@
CONST	SEGMENT
??_C@_0M@HJCAEDLM@alloc?5pList?$AA@ DB 'alloc pList', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@FPEGNMGD@CFileUtil?3?3fileToFieldRecord?$AA@
CONST	SEGMENT
??_C@_0BN@FPEGNMGD@CFileUtil?3?3fileToFieldRecord?$AA@ DB 'CFileUtil::fil'
	DB	'eToFieldRecord', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09GBGMKMEP@new?5pList?$AA@
CONST	SEGMENT
??_C@_09GBGMKMEP@new?5pList?$AA@ DB 'new pList', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@HGILDMCF@CDFSFile?3?3read?5pFile?5open?5FAIL?5?$FL@
CONST	SEGMENT
??_C@_0CE@HGILDMCF@CDFSFile?3?3read?5pFile?5open?5FAIL?5?$FL@ DB 'CDFSFil'
	DB	'e::read pFile open FAIL [%s]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03BFHAFKOB@wb?$CL?$AA@
CONST	SEGMENT
??_C@_03BFHAFKOB@wb?$CL?$AA@ DB 'wb+', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KGBJCJNH@CFileUtil?3?3MakeDirectory?$AA@
CONST	SEGMENT
??_C@_0BJ@KGBJCJNH@CFileUtil?3?3MakeDirectory?$AA@ DB 'CFileUtil::MakeDir'
	DB	'ectory', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@NPNPEALE@com_mkdir?5has?5Failed?$CB?5?$FL?$CFs?$FN?$AA@
CONST	SEGMENT
??_C@_0BL@NPNPEALE@com_mkdir?5has?5Failed?$CB?5?$FL?$CFs?$FN?$AA@ DB 'com'
	DB	'_mkdir has Failed! [%s]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02CEGDFPFP@?4?2?$AA@
CONST	SEGMENT
??_C@_02CEGDFPFP@?4?2?$AA@ DB '.\', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@LBJCMIIM@CFileUtil?3?3appendFileList?$AA@
CONST	SEGMENT
??_C@_0BK@LBJCMIIM@CFileUtil?3?3appendFileList?$AA@ DB 'CFileUtil::append'
	DB	'FileList', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EKILNHNC@?5fname?$FL?$CFd?$FN?5ftype?$FL?$CFd?$FN?$AA@
CONST	SEGMENT
??_C@_0BF@EKILNHNC@?5fname?$FL?$CFd?$FN?5ftype?$FL?$CFd?$FN?$AA@ DB ' fna'
	DB	'me[%d] ftype[%d]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BIJEHKFJ@fname?$FL?$CFs?$FN?5nCount?$FL?$CFd?$FN?$AA@
CONST	SEGMENT
??_C@_0BF@BIJEHKFJ@fname?$FL?$CFs?$FN?5nCount?$FL?$CFd?$FN?$AA@ DB 'fname'
	DB	'[%s] nCount[%d]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FMJCPMNG@FAILED?5rmdir?$FL?$CFs?$FN?$AA@
CONST	SEGMENT
??_C@_0BB@FMJCPMNG@FAILED?5rmdir?$FL?$CFs?$FN?$AA@ DB 'FAILED rmdir[%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OKJOCLIE@SUCCESS?5rmdir?$FL?$CFs?$FN?$AA@
CONST	SEGMENT
??_C@_0BC@OKJOCLIE@SUCCESS?5rmdir?$FL?$CFs?$FN?$AA@ DB 'SUCCESS rmdir[%s]'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MCDNEDGF@SUCCESS?5_tremove?$FL?$CFs?$FN?5nResult?$FL?$CFd?$FN@
CONST	SEGMENT
??_C@_0CB@MCDNEDGF@SUCCESS?5_tremove?$FL?$CFs?$FN?5nResult?$FL?$CFd?$FN@ DB 'S'
	DB	'UCCESS _tremove[%s] nResult[%d]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LGHDAFAC@CFileUtil?3?3delDirectory?$AA@
CONST	SEGMENT
??_C@_0BI@LGHDAFAC@CFileUtil?3?3delDirectory?$AA@ DB 'CFileUtil::delDirec'
	DB	'tory', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@CEPONNIG@FAILED?5_tremove?$FL?$CFs?$FN?5nResult?$FL?$CFd?$FN?$AA@
CONST	SEGMENT
??_C@_0CA@CEPONNIG@FAILED?5_tremove?$FL?$CFs?$FN?5nResult?$FL?$CFd?$FN?$AA@ DB 'F'
	DB	'AILED _tremove[%s] nResult[%d]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06HCFNFKLM@?$CFs?$CFs?$CFc?$AA@
CONST	SEGMENT
??_C@_06HCFNFKLM@?$CFs?$CFs?$CFc?$AA@ DB '%s%s%c', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
CONST	SEGMENT
??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@ DB '%s%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DJGKEECL@?4?4?$AA@
CONST	SEGMENT
??_C@_02DJGKEECL@?4?4?$AA@ DB '..', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4?$AA@
CONST	SEGMENT
??_C@_01LFCBOECM@?4?$AA@ DB '.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05DFBJLIFO@?$CFs?$CK?4?$CK?$AA@
CONST	SEGMENT
??_C@_05DFBJLIFO@?$CFs?$CK?4?$CK?$AA@ DB '%s*.*', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?fileToFieldRecord@CFileUtil@@SA_NPADPAV?$CTList@VCStringList@@@@D@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?fileToFieldRecord@CFileUtil@@SA_NPADPAV?$CTList@VCStringList@@@@D@Z$7
__ehfuncinfo$?fileToFieldRecord@CFileUtil@@SA_NPADPAV?$CTList@VCStringList@@@@D@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?fileToFieldRecord@CFileUtil@@SA_NPADPAV?$CTList@VCStringList@@@@D@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?delDirectory@CFileUtil@@SAHPAUSTDelInfo@@PAUSTFilterData@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?delDirectory@CFileUtil@@SAHPAUSTDelInfo@@PAUSTFilterData@@@Z$0
__ehfuncinfo$?delDirectory@CFileUtil@@SAHPAUSTDelInfo@@PAUSTFilterData@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?delDirectory@CFileUtil@@SAHPAUSTDelInfo@@PAUSTFilterData@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?filter_stringCompare@@YA_NPADPAX1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?filter_stringCompare@@YA_NPADPAX1@Z$0
__ehfuncinfo$?filter_stringCompare@@YA_NPADPAX1@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?filter_stringCompare@@YA_NPADPAX1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?__alloc@?$CTList@VCStringList@@@@AAEHH@Z
_TEXT	SEGMENT
_nMaxCount$ = 8						; size = 4
?__alloc@?$CTList@VCStringList@@@@AAEHH@Z PROC		; CTList<CStringList>::__alloc, COMDAT
; _this$ = ecx

; 402  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 403  : 	T** pList = (T**)calloc(nMaxCount, sizeof(T*));

  00005	6a 04		 push	 4
  00007	ff 75 08	 push	 DWORD PTR _nMaxCount$[ebp]
  0000a	8b f1		 mov	 esi, ecx
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  00012	8b f8		 mov	 edi, eax
  00014	83 c4 08	 add	 esp, 8

; 404  : 	if (!pList) {

  00017	85 ff		 test	 edi, edi
  00019	75 1a		 jne	 SHORT $LN2@alloc

; 405  : 		_stprintf(g_szMessage, "pList calloc is NULL");

  0001b	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@ENADEEIE@pList?5calloc?5is?5NULL?$AA@
  00020	68 00 00 00 00	 push	 OFFSET ?g_szMessage@@3PADA ; g_szMessage
  00025	e8 00 00 00 00	 call	 _sprintf
  0002a	83 c4 08	 add	 esp, 8

; 406  : 		return 0;

  0002d	33 c0		 xor	 eax, eax
  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi

; 415  : }

  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
$LN2@alloc:

; 407  : 	}
; 408  : 	//_stprintf(g_szMessage, _T("CTList::__alloc list m_nMaxCount[%d]"), nMaxCount);
; 409  : 	if (m_pArray) {

  00035	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00037	85 c9		 test	 ecx, ecx
  00039	74 19		 je	 SHORT $LN3@alloc

; 410  : 		memcpy(pList, m_pArray, m_nMax * sizeof(T*));

  0003b	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0003e	c1 e0 02	 shl	 eax, 2
  00041	50		 push	 eax
  00042	51		 push	 ecx
  00043	57		 push	 edi
  00044	e8 00 00 00 00	 call	 _memcpy

; 411  : 		free(m_pArray);

  00049	ff 36		 push	 DWORD PTR [esi]
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00051	83 c4 10	 add	 esp, 16			; 00000010H
$LN3@alloc:

; 412  : 	}
; 413  : 	m_pArray = pList;
; 414  : 	return nMaxCount;

  00054	8b 45 08	 mov	 eax, DWORD PTR _nMaxCount$[ebp]
  00057	89 3e		 mov	 DWORD PTR [esi], edi
  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi

; 415  : }

  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
?__alloc@?$CTList@VCStringList@@@@AAEHH@Z ENDP		; CTList<CStringList>::__alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?getNext@?$CTList@VCStringList@@@@QAEPAVCStringList@@PAH@Z
_TEXT	SEGMENT
_pIdx$ = 8						; size = 4
?getNext@?$CTList@VCStringList@@@@QAEPAVCStringList@@PAH@Z PROC ; CTList<CStringList>::getNext, COMDAT
; _this$ = ecx

; 334  : 	inline T* getNext(int *pIdx) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 335  : 		for (*pIdx; *pIdx < m_nMax; (*pIdx)++) {

  00004	8b 75 08	 mov	 esi, DWORD PTR _pIdx$[ebp]
  00007	8b d1		 mov	 edx, ecx
  00009	8b 06		 mov	 eax, DWORD PTR [esi]
  0000b	3b 42 10	 cmp	 eax, DWORD PTR [edx+16]
  0000e	7d 14		 jge	 SHORT $LN3@getNext
$LL4@getNext:

; 336  : 			if (m_pArray[*pIdx]) { return m_pArray[*pIdx]; }

  00010	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00012	8b 02		 mov	 eax, DWORD PTR [edx]
  00014	83 3c 88 00	 cmp	 DWORD PTR [eax+ecx*4], 0
  00018	75 11		 jne	 SHORT $LN8@getNext

; 335  : 		for (*pIdx; *pIdx < m_nMax; (*pIdx)++) {

  0001a	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0001d	89 06		 mov	 DWORD PTR [esi], eax
  0001f	3b 42 10	 cmp	 eax, DWORD PTR [edx+16]
  00022	7c ec		 jl	 SHORT $LL4@getNext
$LN3@getNext:

; 337  : 		}
; 338  : 		return NULL;

  00024	33 c0		 xor	 eax, eax
  00026	5e		 pop	 esi

; 339  : 	}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN8@getNext:

; 336  : 			if (m_pArray[*pIdx]) { return m_pArray[*pIdx]; }

  0002b	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  0002e	5e		 pop	 esi

; 339  : 	}

  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?getNext@?$CTList@VCStringList@@@@QAEPAVCStringList@@PAH@Z ENDP ; CTList<CStringList>::getNext
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?push_back@?$CTList@VCStringList@@@@QAE_NPAVCStringList@@PAH@Z
_TEXT	SEGMENT
_Obj$ = 8						; size = 4
_pIdx$ = 12						; size = 4
?push_back@?$CTList@VCStringList@@@@QAE_NPAVCStringList@@PAH@Z PROC ; CTList<CStringList>::push_back, COMDAT
; _this$ = ecx

; 472  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	57		 push	 edi

; 473  : 	int nIdx, i;
; 474  : 
; 475  : 	if (m_nUse >= m_nMax) {

  00008	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0000b	39 4e 04	 cmp	 DWORD PTR [esi+4], ecx
  0000e	7c 38		 jl	 SHORT $LN5@push_back

; 476  : 		if (!__alloc(m_nMax + TLIST_ADD_SIZE)) return false;

  00010	8d 41 40	 lea	 eax, DWORD PTR [ecx+64]
  00013	8b ce		 mov	 ecx, esi
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ?__alloc@?$CTList@VCStringList@@@@AAEHH@Z ; CTList<CStringList>::__alloc
  0001b	85 c0		 test	 eax, eax
  0001d	74 56		 je	 SHORT $LN3@push_back

; 477  : 		nIdx = m_nMax;

  0001f	8b 56 10	 mov	 edx, DWORD PTR [esi+16]

; 478  : 		m_nMax += TLIST_ADD_SIZE;

  00022	8d 42 40	 lea	 eax, DWORD PTR [edx+64]
  00025	89 46 10	 mov	 DWORD PTR [esi+16], eax
$ADD_SUCCESS$21:

; 495  : 
; 496  : ADD_SUCCESS:
; 497  : 	m_nUse++;
; 498  : 	m_pArray[nIdx] = Obj;

  00028	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0002a	ff 46 04	 inc	 DWORD PTR [esi+4]
  0002d	8b 45 08	 mov	 eax, DWORD PTR _Obj$[ebp]
  00030	89 04 91	 mov	 DWORD PTR [ecx+edx*4], eax

; 499  : 	m_nLast++;

  00033	ff 46 08	 inc	 DWORD PTR [esi+8]

; 500  : 	//_stprintf(g_szMessage, _T("CMemList::add i[%d] m_nLast[%d] m_nCurCount[%d]"), nIdx, m_nLast, m_nUse);
; 501  : 	if (pIdx) *pIdx = nIdx;

  00036	8b 45 0c	 mov	 eax, DWORD PTR _pIdx$[ebp]
  00039	85 c0		 test	 eax, eax
  0003b	74 02		 je	 SHORT $LN13@push_back
  0003d	89 10		 mov	 DWORD PTR [eax], edx
$LN13@push_back:
  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi

; 502  : 	return true;

  00041	b0 01		 mov	 al, 1
  00043	5b		 pop	 ebx

; 503  : }

  00044	5d		 pop	 ebp
  00045	c2 08 00	 ret	 8
$LN5@push_back:

; 479  : 		goto ADD_SUCCESS;
; 480  : 	}
; 481  : 
; 482  : 	if (!m_pArray[m_nLast]) { nIdx = m_nLast;  goto ADD_SUCCESS; }

  00048	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0004b	8b 1e		 mov	 ebx, DWORD PTR [esi]
  0004d	83 3c 93 00	 cmp	 DWORD PTR [ebx+edx*4], 0
  00051	74 d5		 je	 SHORT $ADD_SUCCESS$21

; 483  : 
; 484  : 	nIdx = m_nLast;
; 485  : 	for (i = 0; i < m_nMax; i++)

  00053	33 c0		 xor	 eax, eax
  00055	8b fa		 mov	 edi, edx
  00057	85 c9		 test	 ecx, ecx
  00059	7e 1a		 jle	 SHORT $LN3@push_back
  0005b	0f 1f 44 00 00	 npad	 5
$LL4@push_back:
  00060	33 d2		 xor	 edx, edx
  00062	3b f9		 cmp	 edi, ecx
  00064	0f 4c d7	 cmovl	 edx, edi

; 486  : 	{
; 487  : 		if (nIdx >= m_nMax) nIdx = 0;
; 488  : 		if (!m_pArray[nIdx]) {

  00067	83 3c 93 00	 cmp	 DWORD PTR [ebx+edx*4], 0
  0006b	74 bb		 je	 SHORT $ADD_SUCCESS$21

; 489  : 			goto ADD_SUCCESS;
; 490  : 		}
; 491  : 		nIdx++;

  0006d	40		 inc	 eax
  0006e	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
  00071	3b c1		 cmp	 eax, ecx
  00073	7c eb		 jl	 SHORT $LL4@push_back
$LN3@push_back:
  00075	5f		 pop	 edi
  00076	5e		 pop	 esi

; 492  : 	}
; 493  : 	//_stprintf(m_szMessage, _T("add FAIL! m_nLast[%d] m_nCurCount[%d] m_nMax[%d]"), m_nLast, m_nUse, m_nMax);
; 494  : 	return false;

  00077	32 c0		 xor	 al, al
  00079	5b		 pop	 ebx

; 503  : }

  0007a	5d		 pop	 ebp
  0007b	c2 08 00	 ret	 8
?push_back@?$CTList@VCStringList@@@@QAE_NPAVCStringList@@PAH@Z ENDP ; CTList<CStringList>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ?__autoclassinit2@?$CTList@UfileInfo@@@@QAEXI@Z
_TEXT	SEGMENT
_classSize$ = 8						; size = 4
?__autoclassinit2@?$CTList@UfileInfo@@@@QAEXI@Z PROC	; CTList<fileInfo>::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	ff 75 08	 push	 DWORD PTR _classSize$[ebp]
  00006	6a 00		 push	 0
  00008	51		 push	 ecx
  00009	e8 00 00 00 00	 call	 _memset
  0000e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?__autoclassinit2@?$CTList@UfileInfo@@@@QAEXI@Z ENDP	; CTList<fileInfo>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?__alloc@?$CTList@UfileInfo@@@@AAEHH@Z
_TEXT	SEGMENT
_nMaxCount$ = 8						; size = 4
?__alloc@?$CTList@UfileInfo@@@@AAEHH@Z PROC		; CTList<fileInfo>::__alloc, COMDAT
; _this$ = ecx

; 402  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 403  : 	T** pList = (T**)calloc(nMaxCount, sizeof(T*));

  00005	6a 04		 push	 4
  00007	ff 75 08	 push	 DWORD PTR _nMaxCount$[ebp]
  0000a	8b f1		 mov	 esi, ecx
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  00012	8b f8		 mov	 edi, eax
  00014	83 c4 08	 add	 esp, 8

; 404  : 	if (!pList) {

  00017	85 ff		 test	 edi, edi
  00019	75 1a		 jne	 SHORT $LN2@alloc

; 405  : 		_stprintf(g_szMessage, "pList calloc is NULL");

  0001b	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@ENADEEIE@pList?5calloc?5is?5NULL?$AA@
  00020	68 00 00 00 00	 push	 OFFSET ?g_szMessage@@3PADA ; g_szMessage
  00025	e8 00 00 00 00	 call	 _sprintf
  0002a	83 c4 08	 add	 esp, 8

; 406  : 		return 0;

  0002d	33 c0		 xor	 eax, eax
  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi

; 415  : }

  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
$LN2@alloc:

; 407  : 	}
; 408  : 	//_stprintf(g_szMessage, _T("CTList::__alloc list m_nMaxCount[%d]"), nMaxCount);
; 409  : 	if (m_pArray) {

  00035	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00037	85 c9		 test	 ecx, ecx
  00039	74 19		 je	 SHORT $LN3@alloc

; 410  : 		memcpy(pList, m_pArray, m_nMax * sizeof(T*));

  0003b	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0003e	c1 e0 02	 shl	 eax, 2
  00041	50		 push	 eax
  00042	51		 push	 ecx
  00043	57		 push	 edi
  00044	e8 00 00 00 00	 call	 _memcpy

; 411  : 		free(m_pArray);

  00049	ff 36		 push	 DWORD PTR [esi]
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00051	83 c4 10	 add	 esp, 16			; 00000010H
$LN3@alloc:

; 412  : 	}
; 413  : 	m_pArray = pList;
; 414  : 	return nMaxCount;

  00054	8b 45 08	 mov	 eax, DWORD PTR _nMaxCount$[ebp]
  00057	89 3e		 mov	 DWORD PTR [esi], edi
  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi

; 415  : }

  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
?__alloc@?$CTList@UfileInfo@@@@AAEHH@Z ENDP		; CTList<fileInfo>::__alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?size@?$CTList@UfileInfo@@@@QAEHXZ
_TEXT	SEGMENT
?size@?$CTList@UfileInfo@@@@QAEHXZ PROC			; CTList<fileInfo>::size, COMDAT
; _this$ = ecx

; 347  : 	inline int  size() { return m_nUse; }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c3		 ret	 0
?size@?$CTList@UfileInfo@@@@QAEHXZ ENDP			; CTList<fileInfo>::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?push_back@?$CTList@UfileInfo@@@@QAE_NPAUfileInfo@@PAH@Z
_TEXT	SEGMENT
_Obj$ = 8						; size = 4
_pIdx$ = 12						; size = 4
?push_back@?$CTList@UfileInfo@@@@QAE_NPAUfileInfo@@PAH@Z PROC ; CTList<fileInfo>::push_back, COMDAT
; _this$ = ecx

; 472  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	57		 push	 edi

; 473  : 	int nIdx, i;
; 474  : 
; 475  : 	if (m_nUse >= m_nMax) {

  00008	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0000b	39 4e 04	 cmp	 DWORD PTR [esi+4], ecx
  0000e	7c 38		 jl	 SHORT $LN5@push_back

; 476  : 		if (!__alloc(m_nMax + TLIST_ADD_SIZE)) return false;

  00010	8d 41 40	 lea	 eax, DWORD PTR [ecx+64]
  00013	8b ce		 mov	 ecx, esi
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ?__alloc@?$CTList@UfileInfo@@@@AAEHH@Z ; CTList<fileInfo>::__alloc
  0001b	85 c0		 test	 eax, eax
  0001d	74 56		 je	 SHORT $LN3@push_back

; 477  : 		nIdx = m_nMax;

  0001f	8b 56 10	 mov	 edx, DWORD PTR [esi+16]

; 478  : 		m_nMax += TLIST_ADD_SIZE;

  00022	8d 42 40	 lea	 eax, DWORD PTR [edx+64]
  00025	89 46 10	 mov	 DWORD PTR [esi+16], eax
$ADD_SUCCESS$21:

; 495  : 
; 496  : ADD_SUCCESS:
; 497  : 	m_nUse++;
; 498  : 	m_pArray[nIdx] = Obj;

  00028	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0002a	ff 46 04	 inc	 DWORD PTR [esi+4]
  0002d	8b 45 08	 mov	 eax, DWORD PTR _Obj$[ebp]
  00030	89 04 91	 mov	 DWORD PTR [ecx+edx*4], eax

; 499  : 	m_nLast++;

  00033	ff 46 08	 inc	 DWORD PTR [esi+8]

; 500  : 	//_stprintf(g_szMessage, _T("CMemList::add i[%d] m_nLast[%d] m_nCurCount[%d]"), nIdx, m_nLast, m_nUse);
; 501  : 	if (pIdx) *pIdx = nIdx;

  00036	8b 45 0c	 mov	 eax, DWORD PTR _pIdx$[ebp]
  00039	85 c0		 test	 eax, eax
  0003b	74 02		 je	 SHORT $LN13@push_back
  0003d	89 10		 mov	 DWORD PTR [eax], edx
$LN13@push_back:
  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi

; 502  : 	return true;

  00041	b0 01		 mov	 al, 1
  00043	5b		 pop	 ebx

; 503  : }

  00044	5d		 pop	 ebp
  00045	c2 08 00	 ret	 8
$LN5@push_back:

; 479  : 		goto ADD_SUCCESS;
; 480  : 	}
; 481  : 
; 482  : 	if (!m_pArray[m_nLast]) { nIdx = m_nLast;  goto ADD_SUCCESS; }

  00048	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0004b	8b 1e		 mov	 ebx, DWORD PTR [esi]
  0004d	83 3c 93 00	 cmp	 DWORD PTR [ebx+edx*4], 0
  00051	74 d5		 je	 SHORT $ADD_SUCCESS$21

; 483  : 
; 484  : 	nIdx = m_nLast;
; 485  : 	for (i = 0; i < m_nMax; i++)

  00053	33 c0		 xor	 eax, eax
  00055	8b fa		 mov	 edi, edx
  00057	85 c9		 test	 ecx, ecx
  00059	7e 1a		 jle	 SHORT $LN3@push_back
  0005b	0f 1f 44 00 00	 npad	 5
$LL4@push_back:
  00060	33 d2		 xor	 edx, edx
  00062	3b f9		 cmp	 edi, ecx
  00064	0f 4c d7	 cmovl	 edx, edi

; 486  : 	{
; 487  : 		if (nIdx >= m_nMax) nIdx = 0;
; 488  : 		if (!m_pArray[nIdx]) {

  00067	83 3c 93 00	 cmp	 DWORD PTR [ebx+edx*4], 0
  0006b	74 bb		 je	 SHORT $ADD_SUCCESS$21

; 489  : 			goto ADD_SUCCESS;
; 490  : 		}
; 491  : 		nIdx++;

  0006d	40		 inc	 eax
  0006e	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
  00071	3b c1		 cmp	 eax, ecx
  00073	7c eb		 jl	 SHORT $LL4@push_back
$LN3@push_back:
  00075	5f		 pop	 edi
  00076	5e		 pop	 esi

; 492  : 	}
; 493  : 	//_stprintf(m_szMessage, _T("add FAIL! m_nLast[%d] m_nCurCount[%d] m_nMax[%d]"), m_nLast, m_nUse, m_nMax);
; 494  : 	return false;

  00077	32 c0		 xor	 al, al
  00079	5b		 pop	 ebx

; 503  : }

  0007a	5d		 pop	 ebp
  0007b	c2 08 00	 ret	 8
?push_back@?$CTList@UfileInfo@@@@QAE_NPAUfileInfo@@PAH@Z ENDP ; CTList<fileInfo>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?alloc@?$CTList@UfileInfo@@@@QAEHHW4E_ALLOC_TYPE@@@Z
_TEXT	SEGMENT
_nMaxCount$ = 8						; size = 4
_type$ = 12						; size = 4
?alloc@?$CTList@UfileInfo@@@@QAEHHW4E_ALLOC_TYPE@@@Z PROC ; CTList<fileInfo>::alloc, COMDAT
; _this$ = ecx

; 326  : 	int alloc(int nMaxCount, E_ALLOC_TYPE type = eAlloc_Type_new) { m_nObjAllocType = type;  m_nMax = __alloc(nMaxCount); return m_nMax; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR _type$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 403  : 	T** pList = (T**)calloc(nMaxCount, sizeof(T*));

  00009	8b 7d 08	 mov	 edi, DWORD PTR _nMaxCount$[ebp]

; 326  : 	int alloc(int nMaxCount, E_ALLOC_TYPE type = eAlloc_Type_new) { m_nObjAllocType = type;  m_nMax = __alloc(nMaxCount); return m_nMax; }

  0000c	8b f1		 mov	 esi, ecx

; 403  : 	T** pList = (T**)calloc(nMaxCount, sizeof(T*));

  0000e	6a 04		 push	 4
  00010	57		 push	 edi

; 326  : 	int alloc(int nMaxCount, E_ALLOC_TYPE type = eAlloc_Type_new) { m_nObjAllocType = type;  m_nMax = __alloc(nMaxCount); return m_nMax; }

  00011	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 403  : 	T** pList = (T**)calloc(nMaxCount, sizeof(T*));

  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  0001a	8b d8		 mov	 ebx, eax
  0001c	83 c4 08	 add	 esp, 8

; 404  : 	if (!pList) {

  0001f	85 db		 test	 ebx, ebx
  00021	75 1e		 jne	 SHORT $LN4@alloc

; 405  : 		_stprintf(g_szMessage, "pList calloc is NULL");

  00023	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@ENADEEIE@pList?5calloc?5is?5NULL?$AA@
  00028	68 00 00 00 00	 push	 OFFSET ?g_szMessage@@3PADA ; g_szMessage
  0002d	e8 00 00 00 00	 call	 _sprintf
  00032	83 c4 08	 add	 esp, 8

; 326  : 	int alloc(int nMaxCount, E_ALLOC_TYPE type = eAlloc_Type_new) { m_nObjAllocType = type;  m_nMax = __alloc(nMaxCount); return m_nMax; }

  00035	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  00038	33 c0		 xor	 eax, eax
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	5d		 pop	 ebp
  0003e	c2 08 00	 ret	 8
$LN4@alloc:

; 409  : 	if (m_pArray) {

  00041	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00043	85 c9		 test	 ecx, ecx
  00045	74 19		 je	 SHORT $LN5@alloc

; 410  : 		memcpy(pList, m_pArray, m_nMax * sizeof(T*));

  00047	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0004a	c1 e0 02	 shl	 eax, 2
  0004d	50		 push	 eax
  0004e	51		 push	 ecx
  0004f	53		 push	 ebx
  00050	e8 00 00 00 00	 call	 _memcpy

; 411  : 		free(m_pArray);

  00055	ff 36		 push	 DWORD PTR [esi]
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0005d	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@alloc:

; 326  : 	int alloc(int nMaxCount, E_ALLOC_TYPE type = eAlloc_Type_new) { m_nObjAllocType = type;  m_nMax = __alloc(nMaxCount); return m_nMax; }

  00060	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00063	8b c7		 mov	 eax, edi
  00065	5f		 pop	 edi

; 413  : 	m_pArray = pList;

  00066	89 1e		 mov	 DWORD PTR [esi], ebx
  00068	5e		 pop	 esi
  00069	5b		 pop	 ebx

; 326  : 	int alloc(int nMaxCount, E_ALLOC_TYPE type = eAlloc_Type_new) { m_nObjAllocType = type;  m_nMax = __alloc(nMaxCount); return m_nMax; }

  0006a	5d		 pop	 ebp
  0006b	c2 08 00	 ret	 8
?alloc@?$CTList@UfileInfo@@@@QAEHHW4E_ALLOC_TYPE@@@Z ENDP ; CTList<fileInfo>::alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ??0?$CTList@UfileInfo@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CTList@UfileInfo@@@@QAE@XZ PROC			; CTList<fileInfo>::CTList<fileInfo>, COMDAT
; _this$ = ecx

; 366  : 	m_pArray = NULL;

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 367  : 	m_nUse = 0;
; 368  : 	m_nLast = 0;
; 369  : 	m_nDelIdx = 0;
; 370  : 	m_nMax = 0;
; 371  : 	m_nObjAllocType = eAlloc_Type_none;
; 372  : }

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  0001d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00024	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  0002b	c3		 ret	 0
??0?$CTList@UfileInfo@@@@QAE@XZ ENDP			; CTList<fileInfo>::CTList<fileInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
;	COMDAT ?CheckDirName@@YAXPAD@Z
_TEXT	SEGMENT
_dirName$ = 8						; size = 4
?CheckDirName@@YAXPAD@Z PROC				; CheckDirName, COMDAT

; 61   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 62   : #ifndef WIN32
; 63   : 	TCHAR	fromChar = '\\';
; 64   : 	TCHAR	toChar = '/';
; 65   : #else
; 66   : 	TCHAR	fromChar = '/';
; 67   : 	TCHAR	toChar = '\\';
; 68   : #endif
; 69   : 
; 70   : 	while (dirName && *dirName)

  00003	8b 45 08	 mov	 eax, DWORD PTR _dirName$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 19		 je	 SHORT $LN3@CheckDirNa
  0000a	66 0f 1f 44 00
	00		 npad	 6
$LL2@CheckDirNa:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	84 c9		 test	 cl, cl
  00014	74 0d		 je	 SHORT $LN3@CheckDirNa

; 71   : 	{
; 72   : 		if (*dirName == fromChar)

  00016	80 f9 2f	 cmp	 cl, 47			; 0000002fH
  00019	75 03		 jne	 SHORT $LN4@CheckDirNa

; 73   : 			*dirName = toChar;

  0001b	c6 00 5c	 mov	 BYTE PTR [eax], 92	; 0000005cH
$LN4@CheckDirNa:

; 74   : 		dirName++;

  0001e	83 c0 01	 add	 eax, 1

; 62   : #ifndef WIN32
; 63   : 	TCHAR	fromChar = '\\';
; 64   : 	TCHAR	toChar = '/';
; 65   : #else
; 66   : 	TCHAR	fromChar = '/';
; 67   : 	TCHAR	toChar = '\\';
; 68   : #endif
; 69   : 
; 70   : 	while (dirName && *dirName)

  00021	75 ed		 jne	 SHORT $LL2@CheckDirNa
$LN3@CheckDirNa:

; 75   : 	}
; 76   : }

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
?CheckDirName@@YAXPAD@Z ENDP				; CheckDirName
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File e:\infinia-library-3.0\com\include\comtlist.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\include\commemmanager.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File e:\infinia-library-3.0\com\include\commemmanager.h
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\include\commemmanager.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
;	COMDAT ?appendFileList@CFileUtil@@CA_NPAV?$CTList@UfileInfo@@@@PBDD@Z
_TEXT	SEGMENT
_$S1$1 = -8						; size = 8
_$S1$2 = -8						; size = 8
tv255 = 8						; size = 4
$T3 = 8							; size = 4
_flist$ = 8						; size = 4
_fname$ = 12						; size = 4
_ftype$ = 16						; size = 1
?appendFileList@CFileUtil@@CA_NPAV?$CTList@UfileInfo@@@@PBDD@Z PROC ; CFileUtil::appendFileList, COMDAT

; 272  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 273  : 	if (!flist) {

  00007	8b 75 08	 mov	 esi, DWORD PTR _flist$[ebp]
  0000a	85 f6		 test	 esi, esi
  0000c	75 65		 jne	 SHORT $LN4@appendFile

; 274  : 		flist = new CTList<fileInfo>();

  0000e	6a 18		 push	 24			; 00000018H
  00010	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00015	8b f0		 mov	 esi, eax
  00017	83 c4 04	 add	 esp, 4
  0001a	89 75 08	 mov	 DWORD PTR $T3[ebp], esi
  0001d	85 f6		 test	 esi, esi
  0001f	74 36		 je	 SHORT $LN8@appendFile
  00021	0f 57 c0	 xorps	 xmm0, xmm0
  00024	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
  00027	66 0f d6 46 10	 movq	 QWORD PTR [esi+16], xmm0
; File e:\infinia-library-3.0\com\include\comtlist.h

; 366  : 	m_pArray = NULL;

  0002c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 367  : 	m_nUse = 0;

  00032	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 368  : 	m_nLast = 0;

  00039	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 369  : 	m_nDelIdx = 0;

  00040	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0

; 370  : 	m_nMax = 0;

  00047	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 371  : 	m_nObjAllocType = eAlloc_Type_none;

  0004e	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 274  : 		flist = new CTList<fileInfo>();

  00055	eb 02		 jmp	 SHORT $LN9@appendFile
$LN8@appendFile:
  00057	33 f6		 xor	 esi, esi
$LN9@appendFile:

; 275  : 		if (!flist) return false;

  00059	85 f6		 test	 esi, esi
  0005b	75 07		 jne	 SHORT $LN3@appendFile
$LN33@appendFile:
  0005d	32 c0		 xor	 al, al
  0005f	5e		 pop	 esi

; 294  : 	}
; 295  : }

  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
$LN3@appendFile:

; 276  : 		if (!flist->alloc(UNIT_FILE_LIST, eAlloc_Type_BufPool)) return false;

  00064	6a 04		 push	 4
  00066	6a 40		 push	 64			; 00000040H
  00068	8b ce		 mov	 ecx, esi
  0006a	e8 00 00 00 00	 call	 ?alloc@?$CTList@UfileInfo@@@@QAEHHW4E_ALLOC_TYPE@@@Z ; CTList<fileInfo>::alloc
  0006f	85 c0		 test	 eax, eax
  00071	74 ea		 je	 SHORT $LN33@appendFile
$LN4@appendFile:
; File e:\infinia-library-3.0\com\include\combufpool.h

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  00073	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4020000000000000
  0007b	b8 01 00 00 00	 mov	 eax, 1
  00080	f2 0f 11 45 f8	 movsd	 QWORD PTR _$S1$2[ebp], xmm0
  00085	ba f8 ff ff ff	 mov	 edx, -8			; fffffff8H
  0008a	8b 4d fc	 mov	 ecx, DWORD PTR _$S1$2[ebp+4]
  0008d	c1 f9 14	 sar	 ecx, 20			; 00000014H
  00090	81 e9 ff 03 00
	00		 sub	 ecx, 1023		; 000003ffH
  00096	d3 e0		 shl	 eax, cl
  00098	2b d0		 sub	 edx, eax
  0009a	53		 push	 ebx
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 280  : 	FileInfo *pInfo = (FileInfo *)gs_pMMgr->newBuf(nLen, &nIdx);

  0009b	c1 ea 03	 shr	 edx, 3
  0009e	57		 push	 edi
  0009f	83 e2 01	 and	 edx, 1
; File e:\infinia-library-3.0\com\include\combufpool.h

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  000a2	03 d1		 add	 edx, ecx
; File e:\infinia-library-3.0\com\include\commemmanager.h

; 35   : 	inline char *newBuf(int nSize, int *pIndex) { *pIndex = getIndex(nSize);  return __newBuf(*pIndex, nSize); }

  000a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pMMgr@@3PAVCMemManager@@A ; gs_pMMgr
  000aa	6a 08		 push	 8
  000ac	52		 push	 edx
  000ad	e8 00 00 00 00	 call	 ?__newBuf@CMemManager@@AAEPADHI@Z ; CMemManager::__newBuf
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 282  : 	pInfo->fname = gs_pMMgr->newBuf((int)_tcslen(fname) + 1);

  000b2	8b 5d 0c	 mov	 ebx, DWORD PTR _fname$[ebp]
  000b5	8b f8		 mov	 edi, eax
  000b7	8b d3		 mov	 edx, ebx
  000b9	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]
  000bc	0f 1f 40 00	 npad	 4
$LL30@appendFile:
  000c0	8a 02		 mov	 al, BYTE PTR [edx]
  000c2	42		 inc	 edx
  000c3	84 c0		 test	 al, al
  000c5	75 f9		 jne	 SHORT $LL30@appendFile
  000c7	2b d1		 sub	 edx, ecx
; File e:\infinia-library-3.0\com\include\combufpool.h

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  000c9	b8 01 00 00 00	 mov	 eax, 1
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 282  : 	pInfo->fname = gs_pMMgr->newBuf((int)_tcslen(fname) + 1);

  000ce	42		 inc	 edx
; File e:\infinia-library-3.0\com\include\commemmanager.h

; 34   : 	inline char *newBuf(int nSize) { int nIdx = getIndex(nSize);  return __newBuf(nIdx, nSize); }

  000cf	52		 push	 edx
  000d0	66 0f 6e c2	 movd	 xmm0, edx
; File e:\infinia-library-3.0\com\include\combufpool.h

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  000d4	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  000d8	f2 0f 11 45 f8	 movsd	 QWORD PTR _$S1$1[ebp], xmm0
  000dd	8b 4d fc	 mov	 ecx, DWORD PTR _$S1$1[ebp+4]
  000e0	c1 f9 14	 sar	 ecx, 20			; 00000014H
  000e3	81 e9 ff 03 00
	00		 sub	 ecx, 1023		; 000003ffH
  000e9	d3 e0		 shl	 eax, cl
  000eb	89 45 08	 mov	 DWORD PTR tv255[ebp], eax
  000ee	8b c2		 mov	 eax, edx
  000f0	2b 45 08	 sub	 eax, DWORD PTR tv255[ebp]
  000f3	23 c2		 and	 eax, edx
  000f5	f7 d8		 neg	 eax
  000f7	1b c0		 sbb	 eax, eax
  000f9	f7 d8		 neg	 eax
  000fb	03 c1		 add	 eax, ecx
; File e:\infinia-library-3.0\com\include\commemmanager.h

; 34   : 	inline char *newBuf(int nSize) { int nIdx = getIndex(nSize);  return __newBuf(nIdx, nSize); }

  000fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pMMgr@@3PAVCMemManager@@A ; gs_pMMgr
  00103	50		 push	 eax
  00104	e8 00 00 00 00	 call	 ?__newBuf@CMemManager@@AAEPADHI@Z ; CMemManager::__newBuf
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 282  : 	pInfo->fname = gs_pMMgr->newBuf((int)_tcslen(fname) + 1);

  00109	89 07		 mov	 DWORD PTR [edi], eax

; 283  : 	_tcscpy(pInfo->fname, fname);

  0010b	8b d3		 mov	 edx, ebx
  0010d	0f 1f 00	 npad	 3
$LL10@appendFile:
  00110	8a 0a		 mov	 cl, BYTE PTR [edx]
  00112	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00115	88 08		 mov	 BYTE PTR [eax], cl
  00117	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  0011a	84 c9		 test	 cl, cl
  0011c	75 f2		 jne	 SHORT $LL10@appendFile

; 284  : 	pInfo->stat = ftype;

  0011e	8a 5d 10	 mov	 bl, BYTE PTR _ftype$[ebp]

; 285  : 
; 286  : 	// add
; 287  : 	if (flist->push_back(pInfo)) {

  00121	8b ce		 mov	 ecx, esi
  00123	6a 00		 push	 0
  00125	57		 push	 edi
  00126	88 5f 04	 mov	 BYTE PTR [edi+4], bl
  00129	e8 00 00 00 00	 call	 ?push_back@?$CTList@UfileInfo@@@@QAE_NPAUfileInfo@@PAH@Z ; CTList<fileInfo>::push_back
  0012e	84 c0		 test	 al, al
  00130	74 22		 je	 SHORT $LN5@appendFile

; 288  : 		gs_cLogger.PutLogQueue(LEVEL_TRACE, _T("fname[%s] nCount[%d]"), pInfo->fname, flist->size());

  00132	ff 76 04	 push	 DWORD PTR [esi+4]
  00135	ff 37		 push	 DWORD PTR [edi]
  00137	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@BIJEHKFJ@fname?$FL?$CFs?$FN?5nCount?$FL?$CFd?$FN?$AA@
  0013c	6a 02		 push	 2
  0013e	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  00143	e8 00 00 00 00	 call	 ?PutLogQueue@CLogger@@QAAXHPBDZZ ; CLogger::PutLogQueue
  00148	83 c4 14	 add	 esp, 20			; 00000014H

; 289  : 		return true;

  0014b	b0 01		 mov	 al, 1
  0014d	5f		 pop	 edi
  0014e	5b		 pop	 ebx
  0014f	5e		 pop	 esi

; 294  : 	}
; 295  : }

  00150	8b e5		 mov	 esp, ebp
  00152	5d		 pop	 ebp
  00153	c3		 ret	 0
$LN5@appendFile:

; 290  : 	}
; 291  : 	else {
; 292  : 		gs_cLogger.DebugLog(LEVEL_ERROR, _T(" fname[%d] ftype[%d]"), fname, ftype);

  00154	0f be c3	 movsx	 eax, bl
  00157	50		 push	 eax
  00158	ff 75 0c	 push	 DWORD PTR _fname$[ebp]
  0015b	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@EKILNHNC@?5fname?$FL?$CFd?$FN?5ftype?$FL?$CFd?$FN?$AA@
  00160	68 24 01 00 00	 push	 292			; 00000124H
  00165	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@LBJCMIIM@CFileUtil?3?3appendFileList?$AA@
  0016a	6a 05		 push	 5
  0016c	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  00171	e8 00 00 00 00	 call	 ?__debugLog@CLogger@@QAAXHPBDH0ZZ ; CLogger::__debugLog
  00176	83 c4 1c	 add	 esp, 28			; 0000001cH

; 293  : 		return false;

  00179	32 c0		 xor	 al, al
  0017b	5f		 pop	 edi
  0017c	5b		 pop	 ebx
  0017d	5e		 pop	 esi

; 294  : 	}
; 295  : }

  0017e	8b e5		 mov	 esp, ebp
  00180	5d		 pop	 ebp
  00181	c3		 ret	 0
?appendFileList@CFileUtil@@CA_NPAV?$CTList@UfileInfo@@@@PBDD@Z ENDP ; CFileUtil::appendFileList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
;	COMDAT ?ehstrstr@CFileUtil@@SAPADPBD0@Z
_TEXT	SEGMENT
_pTarget$ = 8						; size = 4
_psubstr$ = 12						; size = 4
?ehstrstr@CFileUtil@@SAPADPBD0@Z PROC			; CFileUtil::ehstrstr, COMDAT

; 840  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 841  : 	char *pPos = (char *)pTarget;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _pTarget$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 842  : 	int nIdx=0, nLen= (int)strlen(psubstr);

  00009	8b 7d 0c	 mov	 edi, DWORD PTR _psubstr$[ebp]
  0000c	8b f7		 mov	 esi, edi
  0000e	8d 56 01	 lea	 edx, DWORD PTR [esi+1]
$LL20@ehstrstr:
  00011	8a 06		 mov	 al, BYTE PTR [esi]
  00013	46		 inc	 esi
  00014	84 c0		 test	 al, al
  00016	75 f9		 jne	 SHORT $LL20@ehstrstr
  00018	2b f2		 sub	 esi, edx

; 843  : 	while (*pPos) {

  0001a	8a 11		 mov	 dl, BYTE PTR [ecx]
  0001c	84 d2		 test	 dl, dl
  0001e	74 22		 je	 SHORT $LN19@ehstrstr
  00020	8a 1f		 mov	 bl, BYTE PTR [edi]
$LL2@ehstrstr:

; 844  : 		while (*pPos == psubstr[nIdx++]) {

  00022	33 c0		 xor	 eax, eax
  00024	3a d3		 cmp	 dl, bl
  00026	75 12		 jne	 SHORT $LN13@ehstrstr
$LL4@ehstrstr:
  00028	40		 inc	 eax

; 845  : 			if (nIdx >= nLen) return pPos;

  00029	3b c6		 cmp	 eax, esi
  0002b	7d 1c		 jge	 SHORT $LN11@ehstrstr

; 846  : 			pPos++; if (!*pPos) return NULL;			

  0002d	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  00030	41		 inc	 ecx
  00031	84 d2		 test	 dl, dl
  00033	74 0d		 je	 SHORT $LN19@ehstrstr

; 844  : 		while (*pPos == psubstr[nIdx++]) {

  00035	3a 14 38	 cmp	 dl, BYTE PTR [eax+edi]
  00038	74 ee		 je	 SHORT $LL4@ehstrstr
$LN13@ehstrstr:

; 843  : 	while (*pPos) {

  0003a	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]

; 847  : 		}
; 848  : 		nIdx = 0;
; 849  : 		pPos++;

  0003d	41		 inc	 ecx
  0003e	84 d2		 test	 dl, dl
  00040	75 e0		 jne	 SHORT $LL2@ehstrstr
$LN19@ehstrstr:
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi

; 850  : 	}
; 851  : 	return NULL;

  00044	33 c0		 xor	 eax, eax
  00046	5b		 pop	 ebx

; 852  : }

  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
$LN11@ehstrstr:
  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi

; 845  : 			if (nIdx >= nLen) return pPos;

  0004b	8b c1		 mov	 eax, ecx
  0004d	5b		 pop	 ebx

; 852  : }

  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
?ehstrstr@CFileUtil@@SAPADPBD0@Z ENDP			; CFileUtil::ehstrstr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
;	COMDAT ?add@CFileUtil@@SA_NPADHPAUSTFileMem@@@Z
_TEXT	SEGMENT
_pFilePath$ = 8						; size = 4
_nLoopCnt$ = 12						; size = 4
_pBuf$ = 16						; size = 4
?add@CFileUtil@@SA_NPADHPAUSTFileMem@@@Z PROC		; CFileUtil::add, COMDAT

; 813  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 814  : 	int i;
; 815  : 	FILE *pFile = _tfopen(pFilePath, _T("a+"));

  00004	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__fopen
  0000a	56		 push	 esi
  0000b	8b 75 08	 mov	 esi, DWORD PTR _pFilePath$[ebp]
  0000e	57		 push	 edi
  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_02DPNLHKJD@a?$CL?$AA@
  00014	56		 push	 esi
  00015	ff d3		 call	 ebx
  00017	8b f8		 mov	 edi, eax
  00019	83 c4 08	 add	 esp, 8

; 816  : 
; 817  : 	if (!pFile) {

  0001c	85 ff		 test	 edi, edi
  0001e	75 33		 jne	 SHORT $LN6@add

; 818  : 
; 819  : 		CFileUtil::MakeDirectory(pFilePath);

  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ?MakeDirectory@CFileUtil@@SA_NPBD@Z ; CFileUtil::MakeDirectory

; 820  : 		pFile = _tfopen(pFilePath, _T("a+"));

  00026	68 00 00 00 00	 push	 OFFSET ??_C@_02DPNLHKJD@a?$CL?$AA@
  0002b	56		 push	 esi
  0002c	ff d3		 call	 ebx
  0002e	8b f8		 mov	 edi, eax
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH

; 821  : 
; 822  : 		if (!pFile) {

  00033	85 ff		 test	 edi, edi
  00035	75 1c		 jne	 SHORT $LN6@add

; 823  : 			gs_cLogger.PutLogQueue(LEVEL_ERROR, _T("CDFSFile::add2 pFile open FAIL [%s]"), pFilePath);

  00037	56		 push	 esi
  00038	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@IKFEAMNF@CDFSFile?3?3add2?5pFile?5open?5FAIL?5?$FL@
  0003d	6a 05		 push	 5
  0003f	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  00044	e8 00 00 00 00	 call	 ?PutLogQueue@CLogger@@QAAXHPBDZZ ; CLogger::PutLogQueue
  00049	83 c4 10	 add	 esp, 16			; 00000010H

; 824  : 			return false;

  0004c	32 c0		 xor	 al, al
  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx

; 835  : 
; 836  : }

  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
$LN6@add:

; 825  : 		}
; 826  : 	}
; 827  : 
; 828  : 	for (i = 0; i < nLoopCnt; i++) {

  00053	33 f6		 xor	 esi, esi
  00055	39 75 0c	 cmp	 DWORD PTR _nLoopCnt$[ebp], esi
  00058	7e 33		 jle	 SHORT $LN3@add
  0005a	66 0f 1f 44 00
	00		 npad	 6
$LL4@add:

; 829  : 		fwrite(pBuf[i].pBlock, g_nChSize, _tcslen(pBuf[i].pBlock), pFile);

  00060	8b 45 10	 mov	 eax, DWORD PTR _pBuf$[ebp]
  00063	8b 14 f0	 mov	 edx, DWORD PTR [eax+esi*8]
  00066	8b c2		 mov	 eax, edx
  00068	8d 58 01	 lea	 ebx, DWORD PTR [eax+1]
  0006b	0f 1f 44 00 00	 npad	 5
$LL12@add:
  00070	8a 08		 mov	 cl, BYTE PTR [eax]
  00072	40		 inc	 eax
  00073	84 c9		 test	 cl, cl
  00075	75 f9		 jne	 SHORT $LL12@add
  00077	57		 push	 edi
  00078	2b c3		 sub	 eax, ebx
  0007a	50		 push	 eax
  0007b	6a 01		 push	 1
  0007d	52		 push	 edx
  0007e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  00084	46		 inc	 esi
  00085	83 c4 10	 add	 esp, 16			; 00000010H
  00088	3b 75 0c	 cmp	 esi, DWORD PTR _nLoopCnt$[ebp]
  0008b	7c d3		 jl	 SHORT $LL4@add
$LN3@add:

; 830  : 		//_ftprintf(pBackup, pBuf[i]);
; 831  : 	}
; 832  : 	fflush(pFile);

  0008d	57		 push	 edi
  0008e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fflush

; 833  : 	fclose(pFile);

  00094	57		 push	 edi
  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  0009b	83 c4 08	 add	 esp, 8

; 834  : 	return true;

  0009e	b0 01		 mov	 al, 1
  000a0	5f		 pop	 edi
  000a1	5e		 pop	 esi
  000a2	5b		 pop	 ebx

; 835  : 
; 836  : }

  000a3	5d		 pop	 ebp
  000a4	c3		 ret	 0
?add@CFileUtil@@SA_NPADHPAUSTFileMem@@@Z ENDP		; CFileUtil::add
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
;	COMDAT ?modify@CFileUtil@@SA_NPADHPAUSTFileMem@@@Z
_TEXT	SEGMENT
_pFilePath$ = 8						; size = 4
_nLoopCnt$ = 12						; size = 4
_pBuf$ = 16						; size = 4
?modify@CFileUtil@@SA_NPADHPAUSTFileMem@@@Z PROC	; CFileUtil::modify, COMDAT

; 789  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 790  : 	int i;
; 791  : 	FILE *pFile = _tfopen(pFilePath, _T("w"));

  00004	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__fopen
  0000a	56		 push	 esi
  0000b	8b 75 08	 mov	 esi, DWORD PTR _pFilePath$[ebp]
  0000e	57		 push	 edi
  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w?$AA@
  00014	56		 push	 esi
  00015	ff d3		 call	 ebx
  00017	8b f8		 mov	 edi, eax
  00019	83 c4 08	 add	 esp, 8

; 792  : 
; 793  : 	if (!pFile) {

  0001c	85 ff		 test	 edi, edi
  0001e	75 33		 jne	 SHORT $LN6@modify

; 794  : 
; 795  : 		CFileUtil::MakeDirectory(pFilePath);

  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ?MakeDirectory@CFileUtil@@SA_NPBD@Z ; CFileUtil::MakeDirectory

; 796  : 		pFile = _tfopen(pFilePath, _T("w"));

  00026	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w?$AA@
  0002b	56		 push	 esi
  0002c	ff d3		 call	 ebx
  0002e	8b f8		 mov	 edi, eax
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH

; 797  : 
; 798  : 		if (!pFile) {

  00033	85 ff		 test	 edi, edi
  00035	75 1c		 jne	 SHORT $LN6@modify

; 799  : 			gs_cLogger.PutLogQueue(LEVEL_ERROR, _T("CDFSFile::modify pFile open FAIL [%s]"), pFilePath);

  00037	56		 push	 esi
  00038	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@JGICPKLC@CDFSFile?3?3modify?5pFile?5open?5FAIL@
  0003d	6a 05		 push	 5
  0003f	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  00044	e8 00 00 00 00	 call	 ?PutLogQueue@CLogger@@QAAXHPBDZZ ; CLogger::PutLogQueue
  00049	83 c4 10	 add	 esp, 16			; 00000010H

; 800  : 			return false;

  0004c	32 c0		 xor	 al, al
  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx

; 811  : }

  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
$LN6@modify:

; 801  : 		}
; 802  : 	}
; 803  : 
; 804  : 	for (i = 0; i < nLoopCnt; i++) {

  00053	33 f6		 xor	 esi, esi
  00055	39 75 0c	 cmp	 DWORD PTR _nLoopCnt$[ebp], esi
  00058	7e 33		 jle	 SHORT $LN3@modify
  0005a	66 0f 1f 44 00
	00		 npad	 6
$LL4@modify:

; 805  : 		fwrite(pBuf[i].pBlock, g_nChSize, _tcslen(pBuf[i].pBlock), pFile);

  00060	8b 45 10	 mov	 eax, DWORD PTR _pBuf$[ebp]
  00063	8b 14 f0	 mov	 edx, DWORD PTR [eax+esi*8]
  00066	8b c2		 mov	 eax, edx
  00068	8d 58 01	 lea	 ebx, DWORD PTR [eax+1]
  0006b	0f 1f 44 00 00	 npad	 5
$LL12@modify:
  00070	8a 08		 mov	 cl, BYTE PTR [eax]
  00072	40		 inc	 eax
  00073	84 c9		 test	 cl, cl
  00075	75 f9		 jne	 SHORT $LL12@modify
  00077	57		 push	 edi
  00078	2b c3		 sub	 eax, ebx
  0007a	50		 push	 eax
  0007b	6a 01		 push	 1
  0007d	52		 push	 edx
  0007e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  00084	46		 inc	 esi
  00085	83 c4 10	 add	 esp, 16			; 00000010H
  00088	3b 75 0c	 cmp	 esi, DWORD PTR _nLoopCnt$[ebp]
  0008b	7c d3		 jl	 SHORT $LL4@modify
$LN3@modify:

; 806  : 		//_ftprintf(pBackup, pBuf[i]);
; 807  : 	}
; 808  : 	fflush(pFile);

  0008d	57		 push	 edi
  0008e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fflush

; 809  : 	fclose(pFile);

  00094	57		 push	 edi
  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  0009b	83 c4 08	 add	 esp, 8

; 810  : 	return true;

  0009e	b0 01		 mov	 al, 1
  000a0	5f		 pop	 edi
  000a1	5e		 pop	 esi
  000a2	5b		 pop	 ebx

; 811  : }

  000a3	5d		 pop	 ebp
  000a4	c3		 ret	 0
?modify@CFileUtil@@SA_NPADHPAUSTFileMem@@@Z ENDP	; CFileUtil::modify
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
;	COMDAT ?nextRead@CFileUtil@@SAHPAD0HH@Z
_TEXT	SEGMENT
_pFilePath$ = 8						; size = 4
_pBuf$ = 12						; size = 4
_nMaxBuf$ = 16						; size = 4
_nPos$ = 20						; size = 4
?nextRead@CFileUtil@@SAHPAD0HH@Z PROC			; CFileUtil::nextRead, COMDAT

; 772  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 773  : 	FILE *pFile = _tfopen(pFilePath, _T("rb"));

  00005	8b 75 08	 mov	 esi, DWORD PTR _pFilePath$[ebp]
  00008	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb?$AA@
  0000d	56		 push	 esi
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00014	8b d8		 mov	 ebx, eax
  00016	83 c4 08	 add	 esp, 8

; 774  : 	if (!pFile) {

  00019	85 db		 test	 ebx, ebx
  0001b	75 1b		 jne	 SHORT $LN2@nextRead

; 775  : 		gs_cLogger.PutLogQueue(LEVEL_ERROR, _T("CDFSFile::nextRead pFile open FAIL [%s]"), pFilePath);

  0001d	56		 push	 esi
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@OMHCJKIB@CDFSFile?3?3nextRead?5pFile?5open?5FA@
  00023	6a 05		 push	 5
  00025	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  0002a	e8 00 00 00 00	 call	 ?PutLogQueue@CLogger@@QAAXHPBDZZ ; CLogger::PutLogQueue
  0002f	83 c4 10	 add	 esp, 16			; 00000010H

; 776  : 		return 0;

  00032	33 c0		 xor	 eax, eax
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx

; 785  : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
$LN2@nextRead:
  00038	57		 push	 edi

; 777  : 	}
; 778  : 
; 779  : 	fseek(pFile, nPos*g_nChSize, SEEK_SET);

  00039	6a 00		 push	 0
  0003b	ff 75 14	 push	 DWORD PTR _nPos$[ebp]
  0003e	53		 push	 ebx
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek

; 780  : 
; 781  : 	int nSize = (int)fread(pBuf, g_nChSize, nMaxBuf, pFile);

  00045	8b 75 0c	 mov	 esi, DWORD PTR _pBuf$[ebp]
  00048	53		 push	 ebx
  00049	ff 75 10	 push	 DWORD PTR _nMaxBuf$[ebp]
  0004c	6a 01		 push	 1
  0004e	56		 push	 esi
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  00055	8b f8		 mov	 edi, eax

; 782  : 	pBuf[nSize] = 0;
; 783  : 	fclose(pFile);

  00057	53		 push	 ebx
  00058	c6 04 37 00	 mov	 BYTE PTR [edi+esi], 0
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00062	83 c4 20	 add	 esp, 32			; 00000020H

; 784  : 	return nSize;

  00065	8b c7		 mov	 eax, edi
  00067	5f		 pop	 edi
  00068	5e		 pop	 esi
  00069	5b		 pop	 ebx

; 785  : }

  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
?nextRead@CFileUtil@@SAHPAD0HH@Z ENDP			; CFileUtil::nextRead
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
;	COMDAT ?nextReadLoop@CFileUtil@@SAHPADHHPAUSTFileMem@@HH@Z
_TEXT	SEGMENT
tv238 = -4						; size = 4
_pFilePath$ = 8						; size = 4
_nLoopCnt$ = 12						; size = 4
_nMaxBuf$ = 16						; size = 4
_pMem$ = 20						; size = 4
_nPos$ = 24						; size = 4
_ntotSize$ = 28						; size = 4
?nextReadLoop@CFileUtil@@SAHPADHHPAUSTFileMem@@HH@Z PROC ; CFileUtil::nextReadLoop, COMDAT

; 733  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 734  : 	int i;
; 735  : 	int nTot = 0;

  00006	33 db		 xor	 ebx, ebx

; 736  : 	int nEndSize;
; 737  : 	int nReadSize;
; 738  : 
; 739  : 	FILE *pFile;
; 740  : 	for (i = 0; i < 3; i++) {

  00008	33 f6		 xor	 esi, esi
  0000a	57		 push	 edi
  0000b	0f 1f 44 00 00	 npad	 5
$LL4@nextReadLo:

; 741  : 		pFile = _tfopen(pFilePath, _T("rb"));

  00010	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb?$AA@
  00015	ff 75 08	 push	 DWORD PTR _pFilePath$[ebp]
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  0001e	8b f8		 mov	 edi, eax
  00020	83 c4 08	 add	 esp, 8

; 742  : 		if (pFile) break;

  00023	85 ff		 test	 edi, edi
  00025	75 26		 jne	 SHORT $LN9@nextReadLo

; 736  : 	int nEndSize;
; 737  : 	int nReadSize;
; 738  : 
; 739  : 	FILE *pFile;
; 740  : 	for (i = 0; i < 3; i++) {

  00027	46		 inc	 esi
  00028	83 fe 03	 cmp	 esi, 3
  0002b	7c e3		 jl	 SHORT $LL4@nextReadLo

; 743  : 		//  
; 744  : 	}
; 745  : 	if (!pFile) {
; 746  : 		gs_cLogger.PutLogQueue(LEVEL_ERROR, _T("CDFSFile::nextReadLoop pFile open FAIL [%s]"), pFilePath);

  0002d	ff 75 08	 push	 DWORD PTR _pFilePath$[ebp]
  00030	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@MJNEIDFC@CDFSFile?3?3nextReadLoop?5pFile?5ope@
  00035	6a 05		 push	 5
  00037	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  0003c	e8 00 00 00 00	 call	 ?PutLogQueue@CLogger@@QAAXHPBDZZ ; CLogger::PutLogQueue
  00041	83 c4 10	 add	 esp, 16			; 00000010H

; 747  : 		return 0;

  00044	33 c0		 xor	 eax, eax
  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx

; 768  : }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
$LN9@nextReadLo:

; 748  : 	}
; 749  : 
; 750  : 	fseek(pFile, nPos*g_nChSize, SEEK_SET);

  0004d	6a 00		 push	 0
  0004f	ff 75 18	 push	 DWORD PTR _nPos$[ebp]
  00052	57		 push	 edi
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek

; 751  : 
; 752  : 	for (i = 0; i < nLoopCnt; i++) {

  00059	8b 45 0c	 mov	 eax, DWORD PTR _nLoopCnt$[ebp]
  0005c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005f	33 f6		 xor	 esi, esi
  00061	85 c0		 test	 eax, eax
  00063	7e 46		 jle	 SHORT $LN6@nextReadLo
  00065	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp__fread
  0006b	48		 dec	 eax
  0006c	89 45 fc	 mov	 DWORD PTR tv238[ebp], eax
  0006f	90		 npad	 1
$LL7@nextReadLo:

; 755  : 			nReadSize = (int)fread(pMem[i].pBlock, g_nChSize, nEndSize, pFile);

  00070	57		 push	 edi
  00071	3b f0		 cmp	 esi, eax
  00073	75 07		 jne	 SHORT $LN10@nextReadLo

; 753  : 		if (i == nLoopCnt - 1) {
; 754  : 			nEndSize = ntotSize - nTot;

  00075	8b 45 1c	 mov	 eax, DWORD PTR _ntotSize$[ebp]
  00078	2b c3		 sub	 eax, ebx

; 756  : 			nTot += nReadSize;
; 757  : 			pMem[i].pBlock[nReadSize] = 0;
; 758  : 		}
; 759  : 		else {

  0007a	eb 04		 jmp	 SHORT $LN23@nextReadLo
$LN10@nextReadLo:

; 760  : 			nReadSize = (int)fread(pMem[i].pBlock, g_nChSize, nMaxBuf - 1, pFile);

  0007c	8b 45 10	 mov	 eax, DWORD PTR _nMaxBuf$[ebp]
  0007f	48		 dec	 eax
$LN23@nextReadLo:
  00080	50		 push	 eax
  00081	8b 45 14	 mov	 eax, DWORD PTR _pMem$[ebp]
  00084	6a 01		 push	 1
  00086	ff 34 f0	 push	 DWORD PTR [eax+esi*8]
  00089	ff d1		 call	 ecx
  0008b	8b c8		 mov	 ecx, eax
  0008d	83 c4 10	 add	 esp, 16			; 00000010H

; 761  : 			nTot += nReadSize;
; 762  : 			pMem[i].pBlock[nReadSize] = 0;

  00090	8b 45 14	 mov	 eax, DWORD PTR _pMem$[ebp]
  00093	03 d9		 add	 ebx, ecx
  00095	8b 04 f0	 mov	 eax, DWORD PTR [eax+esi*8]
  00098	46		 inc	 esi
  00099	c6 04 01 00	 mov	 BYTE PTR [ecx+eax], 0
  0009d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp__fread
  000a3	8b 45 fc	 mov	 eax, DWORD PTR tv238[ebp]
  000a6	3b 75 0c	 cmp	 esi, DWORD PTR _nLoopCnt$[ebp]
  000a9	7c c5		 jl	 SHORT $LL7@nextReadLo
$LN6@nextReadLo:

; 763  : 		}
; 764  : 	}
; 765  : 	fclose(pFile);

  000ab	57		 push	 edi
  000ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  000b2	83 c4 04	 add	 esp, 4

; 766  : 
; 767  : 	return nTot;

  000b5	8b c3		 mov	 eax, ebx
  000b7	5f		 pop	 edi
  000b8	5e		 pop	 esi
  000b9	5b		 pop	 ebx

; 768  : }

  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c3		 ret	 0
?nextReadLoop@CFileUtil@@SAHPADHHPAUSTFileMem@@HH@Z ENDP ; CFileUtil::nextReadLoop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
;	COMDAT ?readLoop@CFileUtil@@SAHPADHHPAUSTFileMem@@H@Z
_TEXT	SEGMENT
tv237 = -4						; size = 4
_pFilePath$ = 8						; size = 4
_nLoopCnt$ = 12						; size = 4
_nMaxBuf$ = 16						; size = 4
_pMem$ = 20						; size = 4
_ntotSize$ = 24						; size = 4
?readLoop@CFileUtil@@SAHPADHHPAUSTFileMem@@H@Z PROC	; CFileUtil::readLoop, COMDAT

; 703  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 704  : 	int i;
; 705  : 	int nTot = 0, nEndSize;
; 706  : 	int nReadSize;
; 707  : 
; 708  : 	FILE *pFile;
; 709  : 	pFile = _tfopen(pFilePath, _T("rb"));

  00006	8b 75 08	 mov	 esi, DWORD PTR _pFilePath$[ebp]
  00009	57		 push	 edi
  0000a	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb?$AA@
  0000f	56		 push	 esi
  00010	33 ff		 xor	 edi, edi
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00018	8b d8		 mov	 ebx, eax
  0001a	83 c4 08	 add	 esp, 8

; 710  : 	if (!pFile) {

  0001d	85 db		 test	 ebx, ebx
  0001f	75 1e		 jne	 SHORT $LN5@readLoop

; 711  : 		gs_cLogger.PutLogQueue(LEVEL_ERROR, _T("CDFSFile::readLoop pFile open FAIL [%s]"), pFilePath);

  00021	56		 push	 esi
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@DIMAMHM@CDFSFile?3?3readLoop?5pFile?5open?5FA@
  00027	6a 05		 push	 5
  00029	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  0002e	e8 00 00 00 00	 call	 ?PutLogQueue@CLogger@@QAAXHPBDZZ ; CLogger::PutLogQueue
  00033	83 c4 10	 add	 esp, 16			; 00000010H

; 712  : 		return 0;

  00036	33 c0		 xor	 eax, eax
  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx

; 730  : }

  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
$LN5@readLoop:

; 713  : 	}
; 714  : 
; 715  : 	for (i = 0; i < nLoopCnt; i++) {

  0003f	8b 45 0c	 mov	 eax, DWORD PTR _nLoopCnt$[ebp]
  00042	33 f6		 xor	 esi, esi
  00044	85 c0		 test	 eax, eax
  00046	7e 45		 jle	 SHORT $LN3@readLoop
  00048	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp__fread
  0004e	48		 dec	 eax
  0004f	89 45 fc	 mov	 DWORD PTR tv237[ebp], eax
$LL4@readLoop:

; 718  : 			nReadSize = (int)fread(pMem[i].pBlock, g_nChSize, nEndSize, pFile);

  00052	53		 push	 ebx
  00053	3b f0		 cmp	 esi, eax
  00055	75 07		 jne	 SHORT $LN6@readLoop

; 716  : 		if (i == nLoopCnt - 1) {
; 717  : 			nEndSize = ntotSize - nTot;

  00057	8b 45 18	 mov	 eax, DWORD PTR _ntotSize$[ebp]
  0005a	2b c7		 sub	 eax, edi

; 719  : 			nTot += nReadSize;
; 720  : 			pMem[i].pBlock[nReadSize] = 0;
; 721  : 		}
; 722  : 		else {

  0005c	eb 04		 jmp	 SHORT $LN13@readLoop
$LN6@readLoop:

; 723  : 			nReadSize = (int)fread(pMem[i].pBlock, g_nChSize, nMaxBuf - 1, pFile);

  0005e	8b 45 10	 mov	 eax, DWORD PTR _nMaxBuf$[ebp]
  00061	48		 dec	 eax
$LN13@readLoop:
  00062	50		 push	 eax
  00063	8b 45 14	 mov	 eax, DWORD PTR _pMem$[ebp]
  00066	6a 01		 push	 1
  00068	ff 34 f0	 push	 DWORD PTR [eax+esi*8]
  0006b	ff d1		 call	 ecx
  0006d	8b c8		 mov	 ecx, eax
  0006f	83 c4 10	 add	 esp, 16			; 00000010H

; 724  : 			nTot += nReadSize;
; 725  : 			pMem[i].pBlock[nReadSize] = 0;

  00072	8b 45 14	 mov	 eax, DWORD PTR _pMem$[ebp]
  00075	03 f9		 add	 edi, ecx
  00077	8b 04 f0	 mov	 eax, DWORD PTR [eax+esi*8]
  0007a	46		 inc	 esi
  0007b	c6 04 01 00	 mov	 BYTE PTR [ecx+eax], 0
  0007f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp__fread
  00085	8b 45 fc	 mov	 eax, DWORD PTR tv237[ebp]
  00088	3b 75 0c	 cmp	 esi, DWORD PTR _nLoopCnt$[ebp]
  0008b	7c c5		 jl	 SHORT $LL4@readLoop
$LN3@readLoop:

; 726  : 		}
; 727  : 	}
; 728  : 	fclose(pFile);

  0008d	53		 push	 ebx
  0008e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00094	83 c4 04	 add	 esp, 4

; 729  : 	return nTot;

  00097	8b c7		 mov	 eax, edi
  00099	5f		 pop	 edi
  0009a	5e		 pop	 esi
  0009b	5b		 pop	 ebx

; 730  : }

  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
?readLoop@CFileUtil@@SAHPADHHPAUSTFileMem@@H@Z ENDP	; CFileUtil::readLoop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
;	COMDAT ?getFileSize2@CFileUtil@@SAHPADHPAHH@Z
_TEXT	SEGMENT
_pFilePath$ = 8						; size = 4
_nMaxBuf$ = 12						; size = 4
_pLoopLen$ = 16						; size = 4
_nPos$ = 20						; size = 4
?getFileSize2@CFileUtil@@SAHPADHPAHH@Z PROC		; CFileUtil::getFileSize2, COMDAT

; 676  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 677  : 	int i = 0;
; 678  : 	int nTotSize;
; 679  : 	FILE *pFile;
; 680  : 
; 681  : 	pFile = _tfopen(pFilePath, _T("r"));

  00004	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  00009	ff 75 08	 push	 DWORD PTR _pFilePath$[ebp]
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00012	8b f0		 mov	 esi, eax
  00014	83 c4 08	 add	 esp, 8

; 682  : 	if (!pFile) {

  00017	85 f6		 test	 esi, esi
  00019	75 03		 jne	 SHORT $LN2@getFileSiz
  0001b	5e		 pop	 esi

; 699  : }

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
$LN2@getFileSiz:
  0001e	57		 push	 edi

; 683  : 		return 0;
; 684  : 	}
; 685  : 
; 686  : 	fseek(pFile, 0, SEEK_END);

  0001f	6a 02		 push	 2
  00021	6a 00		 push	 0
  00023	56		 push	 esi
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek

; 687  : 	nTotSize = ftell(pFile);

  0002a	56		 push	 esi
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ftell

; 688  : 	fclose(pFile);

  00031	56		 push	 esi
  00032	8b f8		 mov	 edi, eax
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose

; 689  : 
; 690  : 	//if(!nMaxBuf) return nTotSize; 
; 691  : 
; 692  : 	nTotSize = nTotSize / g_nChSize - nPos;

  0003a	2b 7d 14	 sub	 edi, DWORD PTR _nPos$[ebp]
  0003d	83 c4 14	 add	 esp, 20			; 00000014H

; 693  : 
; 694  : 	*pLoopLen = (int)(nTotSize / nMaxBuf);

  00040	8b c7		 mov	 eax, edi
  00042	99		 cdq
  00043	f7 7d 0c	 idiv	 DWORD PTR _nMaxBuf$[ebp]
  00046	8b 55 10	 mov	 edx, DWORD PTR _pLoopLen$[ebp]

; 695  : 	if (*pLoopLen * nMaxBuf < nTotSize) {

  00049	8b c8		 mov	 ecx, eax
  0004b	0f af 4d 0c	 imul	 ecx, DWORD PTR _nMaxBuf$[ebp]
  0004f	89 02		 mov	 DWORD PTR [edx], eax
  00051	3b cf		 cmp	 ecx, edi
  00053	7d 03		 jge	 SHORT $LN3@getFileSiz

; 696  : 		*pLoopLen += 1;

  00055	40		 inc	 eax
  00056	89 02		 mov	 DWORD PTR [edx], eax
$LN3@getFileSiz:

; 697  : 	}
; 698  : 	return nTotSize;

  00058	8b c7		 mov	 eax, edi
  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi

; 699  : }

  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
?getFileSize2@CFileUtil@@SAHPADHPAHH@Z ENDP		; CFileUtil::getFileSize2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
;	COMDAT ?modify@CFileUtil@@SA_NPADH0@Z
_TEXT	SEGMENT
_pFilePath$ = 8						; size = 4
_nSize$ = 12						; size = 4
_pBuf$ = 16						; size = 4
?modify@CFileUtil@@SA_NPADH0@Z PROC			; CFileUtil::modify, COMDAT

; 653  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 654  : 	FILE *pFile = _tfopen(pFilePath, _T("w"));

  00005	8b 7d 08	 mov	 edi, DWORD PTR _pFilePath$[ebp]
  00008	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w?$AA@
  0000d	57		 push	 edi
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00014	8b f0		 mov	 esi, eax
  00016	83 c4 08	 add	 esp, 8

; 655  : 
; 656  : 	if (!pFile) {

  00019	85 f6		 test	 esi, esi
  0001b	75 36		 jne	 SHORT $LN3@modify

; 657  : 
; 658  : 		CFileUtil::MakeDirectory(pFilePath);

  0001d	57		 push	 edi
  0001e	e8 00 00 00 00	 call	 ?MakeDirectory@CFileUtil@@SA_NPBD@Z ; CFileUtil::MakeDirectory

; 659  : 		pFile = _tfopen(pFilePath, _T("w"));

  00023	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w?$AA@
  00028	57		 push	 edi
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  0002f	8b f0		 mov	 esi, eax
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 660  : 
; 661  : 		if (!pFile) {

  00034	85 f6		 test	 esi, esi
  00036	75 1b		 jne	 SHORT $LN3@modify

; 662  : 			gs_cLogger.PutLogQueue(LEVEL_ERROR, _T("CFileUtil::modify pFile open FAIL [%s]"), pFilePath);

  00038	57		 push	 edi
  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@NODJAAOJ@CFileUtil?3?3modify?5pFile?5open?5FAI@
  0003e	6a 05		 push	 5
  00040	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  00045	e8 00 00 00 00	 call	 ?PutLogQueue@CLogger@@QAAXHPBDZZ ; CLogger::PutLogQueue
  0004a	83 c4 10	 add	 esp, 16			; 00000010H

; 663  : 			return false;

  0004d	32 c0		 xor	 al, al
  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi

; 671  : }

  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
$LN3@modify:

; 664  : 		}
; 665  : 	}
; 666  : 
; 667  : 	fwrite(pBuf, g_nChSize, nSize, pFile);

  00053	56		 push	 esi
  00054	ff 75 0c	 push	 DWORD PTR _nSize$[ebp]
  00057	6a 01		 push	 1
  00059	ff 75 10	 push	 DWORD PTR _pBuf$[ebp]
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite

; 668  : 	fflush(pFile);

  00062	56		 push	 esi
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fflush

; 669  : 	fclose(pFile);

  00069	56		 push	 esi
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00070	83 c4 18	 add	 esp, 24			; 00000018H

; 670  : 	return true;

  00073	b0 01		 mov	 al, 1
  00075	5f		 pop	 edi
  00076	5e		 pop	 esi

; 671  : }

  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
?modify@CFileUtil@@SA_NPADH0@Z ENDP			; CFileUtil::modify
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
;	COMDAT ?tryopen@CFileUtil@@SAPAU_iobuf@@HPADPBDPAH@Z
_TEXT	SEGMENT
_tryCnt$ = 8						; size = 4
_pFilePath$ = 12					; size = 4
_pMode$ = 16						; size = 4
_pSize$ = 20						; size = 4
?tryopen@CFileUtil@@SAPAU_iobuf@@HPADPBDPAH@Z PROC	; CFileUtil::tryopen, COMDAT

; 637  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 638  : 	int i, res;
; 639  : 	FILE *pFile;
; 640  : 	for (i = 0; i < tryCnt; i++) {

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _tryCnt$[ebp]
  00007	56		 push	 esi
  00008	33 f6		 xor	 esi, esi
  0000a	57		 push	 edi
  0000b	85 db		 test	 ebx, ebx
  0000d	7e 1b		 jle	 SHORT $LN3@tryopen
  0000f	90		 npad	 1
$LL4@tryopen:

; 641  : 		pFile = _tfopen(pFilePath, pMode);

  00010	ff 75 10	 push	 DWORD PTR _pMode$[ebp]
  00013	ff 75 0c	 push	 DWORD PTR _pFilePath$[ebp]
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  0001c	8b f8		 mov	 edi, eax
  0001e	83 c4 08	 add	 esp, 8

; 642  : 		if (pFile) {

  00021	85 ff		 test	 edi, edi
  00023	75 20		 jne	 SHORT $LN8@tryopen

; 638  : 	int i, res;
; 639  : 	FILE *pFile;
; 640  : 	for (i = 0; i < tryCnt; i++) {

  00025	46		 inc	 esi
  00026	3b f3		 cmp	 esi, ebx
  00028	7c e6		 jl	 SHORT $LL4@tryopen
$LN3@tryopen:

; 646  : 		}
; 647  : 		//  
; 648  : 	}
; 649  : 	gs_cLogger.PutLogQueue(LEVEL_ERROR, _T("CFileUtil::tryopen pFile open FAIL"));

  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@CJLBFMFH@CFileUtil?3?3tryopen?5pFile?5open?5FA@
  0002f	6a 05		 push	 5
  00031	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  00036	e8 00 00 00 00	 call	 ?PutLogQueue@CLogger@@QAAXHPBDZZ ; CLogger::PutLogQueue
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 650  : 	return NULL;

  0003e	33 c0		 xor	 eax, eax
  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx

; 651  : }

  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
$LN8@tryopen:

; 643  : 			res = fseek(pFile, 0, SEEK_END);

  00045	6a 02		 push	 2
  00047	6a 00		 push	 0
  00049	57		 push	 edi
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek

; 644  : 			*pSize = ftell(pFile);

  00050	57		 push	 edi
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ftell
  00057	8b 4d 14	 mov	 ecx, DWORD PTR _pSize$[ebp]
  0005a	83 c4 10	 add	 esp, 16			; 00000010H
  0005d	89 01		 mov	 DWORD PTR [ecx], eax

; 645  : 			return pFile;

  0005f	8b c7		 mov	 eax, edi
  00061	5f		 pop	 edi
  00062	5e		 pop	 esi
  00063	5b		 pop	 ebx

; 651  : }

  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
?tryopen@CFileUtil@@SAPAU_iobuf@@HPADPBDPAH@Z ENDP	; CFileUtil::tryopen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
;	COMDAT ?getFileSize@CFileUtil@@SAHPAD@Z
_TEXT	SEGMENT
_pFilePath$ = 8						; size = 4
?getFileSize@CFileUtil@@SAHPAD@Z PROC			; CFileUtil::getFileSize, COMDAT

; 621  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 622  : 	int nTotSize;
; 623  : 	FILE *pFile;
; 624  : 
; 625  : 	pFile = _tfopen(pFilePath, _T("r"));

  00004	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  00009	ff 75 08	 push	 DWORD PTR _pFilePath$[ebp]
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00012	8b f8		 mov	 edi, eax
  00014	83 c4 08	 add	 esp, 8

; 626  : 	if (!pFile) {

  00017	85 ff		 test	 edi, edi
  00019	75 03		 jne	 SHORT $LN2@getFileSiz
  0001b	5f		 pop	 edi

; 635  : }

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
$LN2@getFileSiz:
  0001e	56		 push	 esi

; 627  : 		return 0;
; 628  : 	}
; 629  : 
; 630  : 	fseek(pFile, 0, SEEK_END);

  0001f	6a 02		 push	 2
  00021	6a 00		 push	 0
  00023	57		 push	 edi
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek

; 631  : 	nTotSize = ftell(pFile);

  0002a	57		 push	 edi
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ftell

; 632  : 	fclose(pFile);

  00031	57		 push	 edi
  00032	8b f0		 mov	 esi, eax
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  0003a	83 c4 14	 add	 esp, 20			; 00000014H

; 633  : 
; 634  : 	return nTotSize;

  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	5f		 pop	 edi

; 635  : }

  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
?getFileSize@CFileUtil@@SAHPAD@Z ENDP			; CFileUtil::getFileSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File e:\infinia-library-3.0\com\include\comfiletypes.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
;	COMDAT ?renameFile@CFileUtil@@SA_NPBD0@Z
_TEXT	SEGMENT
_pOldFileName$ = 8					; size = 4
_pNewFileName$ = 12					; size = 4
?renameFile@CFileUtil@@SA_NPBD0@Z PROC			; CFileUtil::renameFile, COMDAT

; 591  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File e:\infinia-library-3.0\com\include\comfiletypes.h

; 79   : inline bool com_isFile(const TCHAR *file) { int res = GetFileAttributes(file); if (res == INVALID_FILE_ATTRIBUTES || res == FILE_ATTRIBUTE_DIRECTORY)return false; return true; }

  00003	ff 75 08	 push	 DWORD PTR _pOldFileName$[ebp]
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileAttributesA@4
  0000c	83 f8 ff	 cmp	 eax, -1
  0000f	74 34		 je	 SHORT $LN3@renameFile
  00011	83 f8 10	 cmp	 eax, 16			; 00000010H
  00014	74 2f		 je	 SHORT $LN3@renameFile
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 604  : 		int nRes = FILEMOVE(pOldFileName, pNewFileName);

  00016	ff 75 0c	 push	 DWORD PTR _pNewFileName$[ebp]
  00019	ff 75 08	 push	 DWORD PTR _pOldFileName$[ebp]
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MoveFileA@8

; 605  : #ifdef WIN32
; 606  : 		if(!nRes)

  00022	85 c0		 test	 eax, eax
  00024	75 1f		 jne	 SHORT $LN3@renameFile

; 607  : #else
; 608  : 		if (nRes)
; 609  : #endif
; 610  : 
; 611  : 		{
; 612  : 			DWORD error = GetLastError();

  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 613  : 			gs_cLogger.PutLogQueue(LEVEL_ERROR, _T("FILEMOVE error code[%d]"), error);

  0002c	50		 push	 eax
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@GLMOIJMA@FILEMOVE?5error?5code?$FL?$CFd?$FN?$AA@
  00032	6a 05		 push	 5
  00034	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  00039	e8 00 00 00 00	 call	 ?PutLogQueue@CLogger@@QAAXHPBDZZ ; CLogger::PutLogQueue
  0003e	83 c4 10	 add	 esp, 16			; 00000010H

; 614  : 			return false;

  00041	32 c0		 xor	 al, al

; 618  : }

  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
$LN3@renameFile:

; 615  : 		}
; 616  : 	}
; 617  : 	return true;

  00045	b0 01		 mov	 al, 1

; 618  : }

  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?renameFile@CFileUtil@@SA_NPBD0@Z ENDP			; CFileUtil::renameFile
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
;	COMDAT ?getReFileName@CFileUtil@@SA_NPADPBD1@Z
_TEXT	SEGMENT
_pTarget$ = 8						; size = 4
_pOriPath$ = 12						; size = 4
_pChangeStr$ = 16					; size = 4
?getReFileName@CFileUtil@@SA_NPADPBD1@Z PROC		; CFileUtil::getReFileName, COMDAT

; 583  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h

; 1569 : _Check_return_ __inline _CRPC _tcsrchr(_In_ _CPC _s1,_In_ _UI _c) {return (_CRPC)_mbsrchr((_CPUC)_s1,_c);}

  00004	8b 75 0c	 mov	 esi, DWORD PTR _pOriPath$[ebp]
  00007	57		 push	 edi
  00008	6a 2e		 push	 46			; 0000002eH
  0000a	56		 push	 esi
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mbsrchr
  00011	8b f8		 mov	 edi, eax
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 585  : 	size_t nLen = pPos - pOriPath;

  00013	2b fe		 sub	 edi, esi
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h

; 1545 :     return (char *)_mbsnbcpy((unsigned char *)_Dst,(const unsigned char *)_Source,_Count);

  00015	57		 push	 edi
  00016	56		 push	 esi
  00017	8b 75 08	 mov	 esi, DWORD PTR _pTarget$[ebp]
  0001a	56		 push	 esi
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mbsnbcpy
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 587  : 	_tcscpy(&pTarget[nLen], pChangeStr);

  00021	8b 4d 10	 mov	 ecx, DWORD PTR _pChangeStr$[ebp]
  00024	8d 14 37	 lea	 edx, DWORD PTR [edi+esi]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h

; 1545 :     return (char *)_mbsnbcpy((unsigned char *)_Dst,(const unsigned char *)_Source,_Count);

  00027	83 c4 14	 add	 esp, 20			; 00000014H
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 587  : 	_tcscpy(&pTarget[nLen], pChangeStr);

  0002a	2b d1		 sub	 edx, ecx
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	66 90		 npad	 2
$LL3@getReFileN:
  00030	8a 01		 mov	 al, BYTE PTR [ecx]
  00032	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00035	88 44 0a ff	 mov	 BYTE PTR [edx+ecx-1], al
  00039	84 c0		 test	 al, al
  0003b	75 f3		 jne	 SHORT $LL3@getReFileN

; 588  : 	return true;

  0003d	b0 01		 mov	 al, 1

; 589  : }

  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?getReFileName@CFileUtil@@SA_NPADPBD1@Z ENDP		; CFileUtil::getReFileName
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
;	COMDAT ?add@CFileUtil@@SA_NPAD0@Z
_TEXT	SEGMENT
_pFilePath$ = 8						; size = 4
_pBuf$ = 12						; size = 4
?add@CFileUtil@@SA_NPAD0@Z PROC				; CFileUtil::add, COMDAT

; 564  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 565  : 	// File copy
; 566  : 	FILE * pFile;
; 567  : 	pFile = _tfopen(pFilePath, _T("a+"));

  00005	8b 75 08	 mov	 esi, DWORD PTR _pFilePath$[ebp]
  00008	68 00 00 00 00	 push	 OFFSET ??_C@_02DPNLHKJD@a?$CL?$AA@
  0000d	56		 push	 esi
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00014	8b d8		 mov	 ebx, eax
  00016	83 c4 08	 add	 esp, 8

; 568  : 	if (!pFile) {

  00019	85 db		 test	 ebx, ebx
  0001b	75 34		 jne	 SHORT $LN2@add

; 569  : 		CFileUtil::MakeDirectory(pFilePath);

  0001d	56		 push	 esi
  0001e	e8 00 00 00 00	 call	 ?MakeDirectory@CFileUtil@@SA_NPBD@Z ; CFileUtil::MakeDirectory

; 570  : 		pFile = _tfopen(pFilePath, _T("a+"));

  00023	68 00 00 00 00	 push	 OFFSET ??_C@_02DPNLHKJD@a?$CL?$AA@
  00028	56		 push	 esi
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 571  : 		if (!pFile) {

  00032	85 c0		 test	 eax, eax
  00034	75 15		 jne	 SHORT $LN3@add

; 572  : 			gs_cLogger.PutLogQueue(LEVEL_ERROR, _T("CDFSFile::add pFile open FAIL [%s]"), pFilePath);

  00036	56		 push	 esi
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@EKCIMLP@CDFSFile?3?3add?5pFile?5open?5FAIL?5?$FL?$CF@
  0003c	6a 05		 push	 5
  0003e	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  00043	e8 00 00 00 00	 call	 ?PutLogQueue@CLogger@@QAAXHPBDZZ ; CLogger::PutLogQueue
  00048	83 c4 10	 add	 esp, 16			; 00000010H
$LN3@add:

; 573  : 			return false;

  0004b	5e		 pop	 esi
  0004c	32 c0		 xor	 al, al
  0004e	5b		 pop	 ebx

; 581  : }

  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
$LN2@add:

; 574  : 		}
; 575  : 		return false;
; 576  : 	}
; 577  : 	fwrite(pBuf, sizeof(TCHAR), _tcslen(pBuf), pFile);

  00051	8b 55 0c	 mov	 edx, DWORD PTR _pBuf$[ebp]
  00054	8b ca		 mov	 ecx, edx
  00056	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
  00059	0f 1f 80 00 00
	00 00		 npad	 7
$LL5@add:
  00060	8a 01		 mov	 al, BYTE PTR [ecx]
  00062	41		 inc	 ecx
  00063	84 c0		 test	 al, al
  00065	75 f9		 jne	 SHORT $LL5@add
  00067	53		 push	 ebx
  00068	2b ce		 sub	 ecx, esi
  0006a	51		 push	 ecx
  0006b	6a 01		 push	 1
  0006d	52		 push	 edx
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite

; 578  : 	fflush(pFile);

  00074	53		 push	 ebx
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fflush

; 579  : 	fclose(pFile);

  0007b	53		 push	 ebx
  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00082	83 c4 18	 add	 esp, 24			; 00000018H

; 580  : 	return true;

  00085	b0 01		 mov	 al, 1
  00087	5e		 pop	 esi
  00088	5b		 pop	 ebx

; 581  : }

  00089	5d		 pop	 ebp
  0008a	c3		 ret	 0
?add@CFileUtil@@SA_NPAD0@Z ENDP				; CFileUtil::add
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\include\commemmanager.h
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\include\commemmanager.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File e:\infinia-library-3.0\com\include\comtlist.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File e:\infinia-library-3.0\com\include\commstring.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File e:\infinia-library-3.0\com\include\comtlist.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File e:\infinia-library-3.0\com\include\comtlist.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\include\commemmanager.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\include\commemmanager.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File e:\infinia-library-3.0\com\include\comtlist.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File e:\infinia-library-3.0\com\include\comtlist.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File e:\infinia-library-3.0\com\include\comtlist.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File e:\infinia-library-3.0\com\include\comtlist.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File e:\infinia-library-3.0\com\include\comtlist.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
;	COMDAT ?fileToFieldRecord@CFileUtil@@SA_NPADPAV?$CTList@VCStringList@@@@D@Z
_TEXT	SEGMENT
_stInfo$ = -44						; size = 12
_$S1$2 = -32						; size = 8
_$S1$3 = -32						; size = 8
_$S1$4 = -32						; size = 8
$T5 = -28						; size = 4
_nMaxCount$1$ = -24					; size = 4
_idx$6 = -24						; size = 4
_fileSize$ = -24					; size = 4
_pFileBuf$ = -20					; size = 4
_fileSize$1$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pFilePath$ = 8						; size = 4
_pLineList$ = 12					; size = 4
_ch$ = 16						; size = 1
?fileToFieldRecord@CFileUtil@@SA_NPADPAV?$CTList@VCStringList@@@@D@Z PROC ; CFileUtil::fileToFieldRecord, COMDAT

; 399  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?fileToFieldRecord@CFileUtil@@SA_NPADPAV?$CTList@VCStringList@@@@D@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 400  : 	// FILE READ
; 401  : 	TCHAR *pFileBuf = NULL;
; 402  : 	int fileSize = 0;
; 403  : 	CStringList *pList;
; 404  : 	bool bres;
; 405  : 	STStrInfo stInfo;
; 406  : 
; 407  : 	memset(&stInfo, 0, sizeof(STStrInfo));
; 408  : 	fileSize = readNalloc(pFilePath, &pFileBuf, &fileSize);

  00028	8d 45 e8	 lea	 eax, DWORD PTR _fileSize$[ebp]
  0002b	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _pFileBuf$[ebp], 0
  00032	50		 push	 eax
  00033	8d 45 ec	 lea	 eax, DWORD PTR _pFileBuf$[ebp]
  00036	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _fileSize$[ebp], 0
  0003d	50		 push	 eax
  0003e	ff 75 08	 push	 DWORD PTR _pFilePath$[ebp]
  00041	0f 57 c0	 xorps	 xmm0, xmm0
  00044	33 f6		 xor	 esi, esi
  00046	66 0f d6 45 d4	 movq	 QWORD PTR _stInfo$[ebp], xmm0
  0004b	e8 00 00 00 00	 call	 ?readNalloc@CFileUtil@@SAHPADPAPADPAH@Z ; CFileUtil::readNalloc
  00050	8b c8		 mov	 ecx, eax
  00052	83 c4 0c	 add	 esp, 12			; 0000000cH
  00055	89 4d f0	 mov	 DWORD PTR _fileSize$1$[ebp], ecx

; 409  : 
; 410  : 	if (!fileSize) {

  00058	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  0005b	85 c9		 test	 ecx, ecx
  0005d	75 07		 jne	 SHORT $LN6@fileToFiel

; 411  : 		bres = false;

  0005f	32 db		 xor	 bl, bl

; 412  : 		goto END_PROC;

  00061	e9 65 01 00 00	 jmp	 $LN100@fileToFiel
$LN6@fileToFiel:
; File e:\infinia-library-3.0\com\include\combufpool.h

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  00066	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@40b0000000000000
  0006e	ba 00 f0 ff ff	 mov	 edx, -4096		; fffff000H
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 416  : 	stInfo.pSource = pFileBuf;

  00073	8b 4d ec	 mov	 ecx, DWORD PTR _pFileBuf$[ebp]
  00076	be 00 10 00 00	 mov	 esi, 4096		; 00001000H
  0007b	89 4d d4	 mov	 DWORD PTR _stInfo$[ebp], ecx
; File e:\infinia-library-3.0\com\include\combufpool.h

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  0007e	f2 0f 11 45 e0	 movsd	 QWORD PTR _$S1$4[ebp], xmm0
  00083	8b 4d e4	 mov	 ecx, DWORD PTR _$S1$4[ebp+4]
  00086	c1 f9 14	 sar	 ecx, 20			; 00000014H
  00089	81 e9 ff 03 00
	00		 sub	 ecx, 1023		; 000003ffH
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 415  : 	stInfo.aBufSize = 4096;

  0008f	89 75 dc	 mov	 DWORD PTR _stInfo$[ebp+8], esi
; File e:\infinia-library-3.0\com\include\combufpool.h

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  00092	d3 e0		 shl	 eax, cl
  00094	2b d0		 sub	 edx, eax
; File e:\infinia-library-3.0\com\include\commemmanager.h

; 34   : 	inline char *newBuf(int nSize) { int nIdx = getIndex(nSize);  return __newBuf(nIdx, nSize); }

  00096	c1 ea 0c	 shr	 edx, 12			; 0000000cH
  00099	83 e2 01	 and	 edx, 1
; File e:\infinia-library-3.0\com\include\combufpool.h

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  0009c	03 d1		 add	 edx, ecx
; File e:\infinia-library-3.0\com\include\commemmanager.h

; 34   : 	inline char *newBuf(int nSize) { int nIdx = getIndex(nSize);  return __newBuf(nIdx, nSize); }

  0009e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pMMgr@@3PAVCMemManager@@A ; gs_pMMgr
  000a4	56		 push	 esi
  000a5	52		 push	 edx
  000a6	e8 00 00 00 00	 call	 ?__newBuf@CMemManager@@AAEPADHI@Z ; CMemManager::__newBuf
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 417  : 	stInfo.pTarget = gs_pMMgr->newBuf(4096);

  000ab	8b f8		 mov	 edi, eax
  000ad	89 7d d8	 mov	 DWORD PTR _stInfo$[ebp+4], edi

; 418  : 	if (!stInfo.pTarget) {

  000b0	85 ff		 test	 edi, edi
  000b2	75 0d		 jne	 SHORT $LN70@fileToFiel

; 419  : 		bres = false;
; 420  : 		goto END_PROC;

  000b4	8b 4d f0	 mov	 ecx, DWORD PTR _fileSize$1$[ebp]
  000b7	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  000ba	32 db		 xor	 bl, bl
  000bc	e9 0d 01 00 00	 jmp	 $END_PROC$103
$LN70@fileToFiel:

; 423  : 	while(getNextLine(&stInfo))

  000c1	8d 45 d4	 lea	 eax, DWORD PTR _stInfo$[ebp]
  000c4	50		 push	 eax
  000c5	e8 00 00 00 00	 call	 ?getNextLine@CFileUtil@@SAHPAUSTStrInfo@@@Z ; CFileUtil::getNextLine
  000ca	83 c4 04	 add	 esp, 4
  000cd	85 c0		 test	 eax, eax
  000cf	0f 84 e9 00 00
	00		 je	 $LN3@fileToFiel
; File e:\infinia-library-3.0\com\include\comtlist.h

; 487  : 		if (nIdx >= m_nMax) nIdx = 0;

  000d5	8b 7d 0c	 mov	 edi, DWORD PTR _pLineList$[ebp]
  000d8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL2@fileToFiel:
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 425  : 		pList = new (std::nothrow) CStringList();

  000e0	68 00 00 00 00	 push	 OFFSET ?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  000e5	6a 14		 push	 20			; 00000014H
  000e7	e8 00 00 00 00	 call	 ??2@YAPAXIABUnothrow_t@std@@@Z ; operator new
  000ec	83 c4 08	 add	 esp, 8
  000ef	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax
  000f2	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000f9	85 c0		 test	 eax, eax
  000fb	74 0b		 je	 SHORT $LN23@fileToFiel
  000fd	8b c8		 mov	 ecx, eax
  000ff	e8 00 00 00 00	 call	 ??0CStringList@@QAE@XZ	; CStringList::CStringList
  00104	8b d8		 mov	 ebx, eax
  00106	eb 02		 jmp	 SHORT $LN24@fileToFiel
$LN23@fileToFiel:
  00108	33 db		 xor	 ebx, ebx
$LN24@fileToFiel:
  0010a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 426  : 		if (!pList) { gs_cLogger.DebugLog(LEVEL_ERROR, _T("new pList")); goto ERROR_PROC; }

  00111	85 db		 test	 ebx, ebx
  00113	0f 84 b8 01 00
	00		 je	 $LN75@fileToFiel
; File e:\infinia-library-3.0\com\include\commstring.h

; 85   : 	int alloc(int nMaxCount) { m_nListCnt = __alloc(nMaxCount); return m_nListCnt; }

  00119	6a 0a		 push	 10			; 0000000aH
  0011b	8b cb		 mov	 ecx, ebx
  0011d	e8 00 00 00 00	 call	 ?__alloc@CStringList@@AAEHH@Z ; CStringList::__alloc
  00122	89 03		 mov	 DWORD PTR [ebx], eax
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 427  : 		if (!pList->alloc(10)) { gs_cLogger.DebugLog(LEVEL_ERROR, _T("alloc pList")); goto ERROR_PROC; }

  00124	85 c0		 test	 eax, eax
  00126	0f 84 99 01 00
	00		 je	 $LN76@fileToFiel

; 428  : 		if (!getFieldList(stInfo.pTarget, ch, pList)) {

  0012c	53		 push	 ebx
  0012d	ff 75 10	 push	 DWORD PTR _ch$[ebp]
  00130	ff 75 d8	 push	 DWORD PTR _stInfo$[ebp+4]
  00133	e8 00 00 00 00	 call	 ?getFieldList@CFileUtil@@SA_NPADDPAVCStringList@@@Z ; CFileUtil::getFieldList
  00138	83 c4 0c	 add	 esp, 12			; 0000000cH
  0013b	84 c0		 test	 al, al
  0013d	0f 84 ac 01 00
	00		 je	 $ERROR_PROC$104
; File e:\infinia-library-3.0\com\include\comtlist.h

; 475  : 	if (m_nUse >= m_nMax) {

  00143	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00146	39 47 04	 cmp	 DWORD PTR [edi+4], eax
  00149	0f 8c 16 01 00
	00		 jl	 $LN38@fileToFiel

; 476  : 		if (!__alloc(m_nMax + TLIST_ADD_SIZE)) return false;

  0014f	83 c0 40	 add	 eax, 64			; 00000040H

; 403  : 	T** pList = (T**)calloc(nMaxCount, sizeof(T*));

  00152	6a 04		 push	 4
  00154	50		 push	 eax

; 476  : 		if (!__alloc(m_nMax + TLIST_ADD_SIZE)) return false;

  00155	89 45 e8	 mov	 DWORD PTR _nMaxCount$1$[ebp], eax

; 403  : 	T** pList = (T**)calloc(nMaxCount, sizeof(T*));

  00158	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  0015e	8b f0		 mov	 esi, eax
  00160	83 c4 08	 add	 esp, 8

; 404  : 	if (!pList) {

  00163	85 f6		 test	 esi, esi
  00165	0f 84 3c 01 00
	00		 je	 $LN93@fileToFiel

; 406  : 		return 0;
; 407  : 	}
; 408  : 	//_stprintf(g_szMessage, _T("CTList::__alloc list m_nMaxCount[%d]"), nMaxCount);
; 409  : 	if (m_pArray) {

  0016b	8b 07		 mov	 eax, DWORD PTR [edi]
  0016d	85 c0		 test	 eax, eax
  0016f	74 19		 je	 SHORT $LN50@fileToFiel

; 410  : 		memcpy(pList, m_pArray, m_nMax * sizeof(T*));

  00171	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00174	c1 e1 02	 shl	 ecx, 2
  00177	51		 push	 ecx
  00178	50		 push	 eax
  00179	56		 push	 esi
  0017a	e8 00 00 00 00	 call	 _memcpy

; 411  : 		free(m_pArray);

  0017f	ff 37		 push	 DWORD PTR [edi]
  00181	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00187	83 c4 10	 add	 esp, 16			; 00000010H
$LN50@fileToFiel:

; 476  : 		if (!__alloc(m_nMax + TLIST_ADD_SIZE)) return false;

  0018a	83 7d e8 00	 cmp	 DWORD PTR _nMaxCount$1$[ebp], 0

; 413  : 	m_pArray = pList;

  0018e	89 37		 mov	 DWORD PTR [edi], esi

; 476  : 		if (!__alloc(m_nMax + TLIST_ADD_SIZE)) return false;

  00190	0f 84 23 01 00
	00		 je	 $LN78@fileToFiel

; 477  : 		nIdx = m_nMax;

  00196	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]

; 478  : 		m_nMax += TLIST_ADD_SIZE;

  00199	8d 41 40	 lea	 eax, DWORD PTR [ecx+64]
  0019c	89 47 10	 mov	 DWORD PTR [edi+16], eax
$ADD_SUCCESS$105:

; 492  : 	}
; 493  : 	//_stprintf(m_szMessage, _T("add FAIL! m_nLast[%d] m_nCurCount[%d] m_nMax[%d]"), m_nLast, m_nUse, m_nMax);
; 494  : 	return false;
; 495  : 
; 496  : ADD_SUCCESS:
; 497  : 	m_nUse++;
; 498  : 	m_pArray[nIdx] = Obj;

  0019f	8b 07		 mov	 eax, DWORD PTR [edi]
  001a1	ff 47 04	 inc	 DWORD PTR [edi+4]
  001a4	89 1c 88	 mov	 DWORD PTR [eax+ecx*4], ebx
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 423  : 	while(getNextLine(&stInfo))

  001a7	8d 45 d4	 lea	 eax, DWORD PTR _stInfo$[ebp]
; File e:\infinia-library-3.0\com\include\comtlist.h

; 499  : 	m_nLast++;

  001aa	ff 47 08	 inc	 DWORD PTR [edi+8]
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 423  : 	while(getNextLine(&stInfo))

  001ad	50		 push	 eax
  001ae	e8 00 00 00 00	 call	 ?getNextLine@CFileUtil@@SAHPAUSTStrInfo@@@Z ; CFileUtil::getNextLine
  001b3	83 c4 04	 add	 esp, 4
  001b6	85 c0		 test	 eax, eax
  001b8	0f 85 22 ff ff
	ff		 jne	 $LL2@fileToFiel
$LN3@fileToFiel:

; 432  : 	}
; 433  : 	bres = true;

  001be	b3 01		 mov	 bl, 1
$LN102@fileToFiel:
  001c0	8b 4d f0	 mov	 ecx, DWORD PTR _fileSize$1$[ebp]
  001c3	b8 01 00 00 00	 mov	 eax, 1
  001c8	8b 75 dc	 mov	 esi, DWORD PTR _stInfo$[ebp+8]
$LN100@fileToFiel:
  001cb	8b 7d d8	 mov	 edi, DWORD PTR _stInfo$[ebp+4]
$END_PROC$103:

; 446  : END_PROC:
; 447  : 	if (pFileBuf) gs_pMMgr->delBuf(pFileBuf, fileSize);

  001ce	83 7d ec 00	 cmp	 DWORD PTR _pFileBuf$[ebp], 0
  001d2	74 3c		 je	 SHORT $LN20@fileToFiel
  001d4	66 0f 6e c1	 movd	 xmm0, ecx
; File e:\infinia-library-3.0\com\include\combufpool.h

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  001d8	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  001dc	f2 0f 11 45 e0	 movsd	 QWORD PTR _$S1$3[ebp], xmm0
  001e1	8b 55 e4	 mov	 edx, DWORD PTR _$S1$3[ebp+4]
  001e4	c1 fa 14	 sar	 edx, 20			; 00000014H
  001e7	81 ea ff 03 00
	00		 sub	 edx, 1023		; 000003ffH
  001ed	8b ca		 mov	 ecx, edx
  001ef	d3 e0		 shl	 eax, cl
  001f1	8b 4d f0	 mov	 ecx, DWORD PTR _fileSize$1$[ebp]
  001f4	2b c8		 sub	 ecx, eax
  001f6	23 4d f0	 and	 ecx, DWORD PTR _fileSize$1$[ebp]
  001f9	f7 d9		 neg	 ecx
  001fb	1b c9		 sbb	 ecx, ecx
  001fd	f7 d9		 neg	 ecx
  001ff	03 ca		 add	 ecx, edx
; File e:\infinia-library-3.0\com\include\commemmanager.h

; 38   : 	inline void delBuf(char *pBuf, int nSize) { int nIdx = getIndex(nSize); delBufByIndex(pBuf, nIdx); }

  00201	51		 push	 ecx
  00202	ff 75 ec	 push	 DWORD PTR _pFileBuf$[ebp]
  00205	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pMMgr@@3PAVCMemManager@@A ; gs_pMMgr
  0020b	e8 00 00 00 00	 call	 ?delBufByIndex@CMemManager@@QAEXPADH@Z ; CMemManager::delBufByIndex
$LN20@fileToFiel:
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 448  : 	if(stInfo.pTarget) gs_pMMgr->delBuf(stInfo.pTarget, stInfo.aBufSize);

  00210	85 ff		 test	 edi, edi
  00212	74 3d		 je	 SHORT $LN97@fileToFiel
  00214	66 0f 6e c6	 movd	 xmm0, esi
; File e:\infinia-library-3.0\com\include\combufpool.h

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  00218	b8 01 00 00 00	 mov	 eax, 1
  0021d	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00221	f2 0f 11 45 e0	 movsd	 QWORD PTR _$S1$2[ebp], xmm0
  00226	8b 55 e4	 mov	 edx, DWORD PTR _$S1$2[ebp+4]
  00229	c1 fa 14	 sar	 edx, 20			; 00000014H
  0022c	81 ea ff 03 00
	00		 sub	 edx, 1023		; 000003ffH
  00232	8b ca		 mov	 ecx, edx
  00234	d3 e0		 shl	 eax, cl
  00236	8b ce		 mov	 ecx, esi
  00238	2b c8		 sub	 ecx, eax
  0023a	23 ce		 and	 ecx, esi
  0023c	f7 d9		 neg	 ecx
  0023e	1b c9		 sbb	 ecx, ecx
  00240	f7 d9		 neg	 ecx
  00242	03 ca		 add	 ecx, edx
; File e:\infinia-library-3.0\com\include\commemmanager.h

; 38   : 	inline void delBuf(char *pBuf, int nSize) { int nIdx = getIndex(nSize); delBufByIndex(pBuf, nIdx); }

  00244	51		 push	 ecx
  00245	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pMMgr@@3PAVCMemManager@@A ; gs_pMMgr
  0024b	57		 push	 edi
  0024c	e8 00 00 00 00	 call	 ?delBufByIndex@CMemManager@@QAEXPADH@Z ; CMemManager::delBufByIndex
$LN97@fileToFiel:
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 449  : 	return bres;

  00251	8a c3		 mov	 al, bl

; 450  : }

  00253	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00256	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0025d	59		 pop	 ecx
  0025e	5f		 pop	 edi
  0025f	5e		 pop	 esi
  00260	5b		 pop	 ebx
  00261	8b e5		 mov	 esp, ebp
  00263	5d		 pop	 ebp
  00264	c3		 ret	 0
$LN38@fileToFiel:
; File e:\infinia-library-3.0\com\include\comtlist.h

; 482  : 	if (!m_pArray[m_nLast]) { nIdx = m_nLast;  goto ADD_SUCCESS; }

  00265	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00268	8b 17		 mov	 edx, DWORD PTR [edi]
  0026a	83 3c 8a 00	 cmp	 DWORD PTR [edx+ecx*4], 0
  0026e	0f 84 2b ff ff
	ff		 je	 $ADD_SUCCESS$105

; 483  : 
; 484  : 	nIdx = m_nLast;
; 485  : 	for (i = 0; i < m_nMax; i++)

  00274	33 d2		 xor	 edx, edx
  00276	8b f1		 mov	 esi, ecx
  00278	85 c0		 test	 eax, eax
  0027a	7e 3d		 jle	 SHORT $LN78@fileToFiel
  0027c	0f 1f 40 00	 npad	 4
$LL37@fileToFiel:
  00280	33 c9		 xor	 ecx, ecx
  00282	3b f0		 cmp	 esi, eax
  00284	0f 4c ce	 cmovl	 ecx, esi

; 488  : 		if (!m_pArray[nIdx]) {

  00287	8b 37		 mov	 esi, DWORD PTR [edi]
  00289	83 3c 8e 00	 cmp	 DWORD PTR [esi+ecx*4], 0
  0028d	0f 84 0c ff ff
	ff		 je	 $ADD_SUCCESS$105

; 489  : 			goto ADD_SUCCESS;
; 490  : 		}
; 491  : 		nIdx++;

  00293	42		 inc	 edx
  00294	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
  00297	3b d0		 cmp	 edx, eax
  00299	7c e5		 jl	 SHORT $LL37@fileToFiel
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 431  : 		if (!pLineList->push_back(pList)) { gs_cLogger.DebugLog(LEVEL_ERROR, _T("add pLineList")); goto ERROR_PROC; }

  0029b	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BICGIAHP@add?5pLineList?$AA@
  002a0	68 af 01 00 00	 push	 431			; 000001afH
  002a5	eb 34		 jmp	 SHORT $LN101@fileToFiel
$LN93@fileToFiel:
; File e:\infinia-library-3.0\com\include\comtlist.h

; 405  : 		_stprintf(g_szMessage, "pList calloc is NULL");

  002a7	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@ENADEEIE@pList?5calloc?5is?5NULL?$AA@
  002ac	68 00 00 00 00	 push	 OFFSET ?g_szMessage@@3PADA ; g_szMessage
  002b1	e8 00 00 00 00	 call	 _sprintf
  002b6	83 c4 08	 add	 esp, 8
$LN78@fileToFiel:
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 431  : 		if (!pLineList->push_back(pList)) { gs_cLogger.DebugLog(LEVEL_ERROR, _T("add pLineList")); goto ERROR_PROC; }

  002b9	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BICGIAHP@add?5pLineList?$AA@
  002be	68 af 01 00 00	 push	 431			; 000001afH
  002c3	eb 16		 jmp	 SHORT $LN101@fileToFiel
$LN76@fileToFiel:

; 427  : 		if (!pList->alloc(10)) { gs_cLogger.DebugLog(LEVEL_ERROR, _T("alloc pList")); goto ERROR_PROC; }

  002c5	68 00 00 00 00	 push	 OFFSET ??_C@_0M@HJCAEDLM@alloc?5pList?$AA@
  002ca	68 ab 01 00 00	 push	 427			; 000001abH
  002cf	eb 0a		 jmp	 SHORT $LN101@fileToFiel
$LN75@fileToFiel:

; 426  : 		if (!pList) { gs_cLogger.DebugLog(LEVEL_ERROR, _T("new pList")); goto ERROR_PROC; }

  002d1	68 00 00 00 00	 push	 OFFSET ??_C@_09GBGMKMEP@new?5pList?$AA@
  002d6	68 aa 01 00 00	 push	 426			; 000001aaH
$LN101@fileToFiel:
  002db	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@FPEGNMGD@CFileUtil?3?3fileToFieldRecord?$AA@
  002e0	6a 05		 push	 5
  002e2	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  002e7	e8 00 00 00 00	 call	 ?__debugLog@CLogger@@QAAXHPBDH0ZZ ; CLogger::__debugLog
  002ec	83 c4 14	 add	 esp, 20			; 00000014H
$ERROR_PROC$104:

; 434  : 	goto END_PROC;
; 435  : ERROR_PROC:
; 436  : 	if (pLineList) {

  002ef	85 ff		 test	 edi, edi
  002f1	74 58		 je	 SHORT $LN98@fileToFiel

; 437  : 		int idx = 0;
; 438  : 		pList = pLineList->getNext(&idx);

  002f3	8d 45 e8	 lea	 eax, DWORD PTR _idx$6[ebp]
  002f6	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _idx$6[ebp], 0
  002fd	50		 push	 eax
  002fe	8b cf		 mov	 ecx, edi
  00300	e8 00 00 00 00	 call	 ?getNext@?$CTList@VCStringList@@@@QAEPAVCStringList@@PAH@Z ; CTList<CStringList>::getNext
  00305	8b d8		 mov	 ebx, eax

; 439  : 		while (pList) {

  00307	85 db		 test	 ebx, ebx
  00309	74 40		 je	 SHORT $LN98@fileToFiel
  0030b	8b 75 e8	 mov	 esi, DWORD PTR _idx$6[ebp]
  0030e	66 90		 npad	 2
$LL4@fileToFiel:
  00310	8b cb		 mov	 ecx, ebx
  00312	e8 00 00 00 00	 call	 ??1CStringList@@QAE@XZ	; CStringList::~CStringList
  00317	6a 14		 push	 20			; 00000014H
  00319	53		 push	 ebx
  0031a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File e:\infinia-library-3.0\com\include\comtlist.h

; 335  : 		for (*pIdx; *pIdx < m_nMax; (*pIdx)++) {

  0031f	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 441  : 			idx++;

  00322	46		 inc	 esi
  00323	83 c4 08	 add	 esp, 8
; File e:\infinia-library-3.0\com\include\comtlist.h

; 335  : 		for (*pIdx; *pIdx < m_nMax; (*pIdx)++) {

  00326	3b f1		 cmp	 esi, ecx
  00328	7d 21		 jge	 SHORT $LN98@fileToFiel

; 336  : 			if (m_pArray[*pIdx]) { return m_pArray[*pIdx]; }

  0032a	8b 1f		 mov	 ebx, DWORD PTR [edi]
  0032c	8d 04 b3	 lea	 eax, DWORD PTR [ebx+esi*4]
  0032f	90		 npad	 1
$LL59@fileToFiel:
  00330	83 38 00	 cmp	 DWORD PTR [eax], 0
  00333	75 0f		 jne	 SHORT $LN79@fileToFiel

; 335  : 		for (*pIdx; *pIdx < m_nMax; (*pIdx)++) {

  00335	46		 inc	 esi
  00336	83 c0 04	 add	 eax, 4
  00339	3b f1		 cmp	 esi, ecx
  0033b	7c f3		 jl	 SHORT $LL59@fileToFiel
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 445  : 	bres = false;

  0033d	32 db		 xor	 bl, bl
  0033f	e9 7c fe ff ff	 jmp	 $LN102@fileToFiel
$LN79@fileToFiel:
; File e:\infinia-library-3.0\com\include\comtlist.h

; 336  : 			if (m_pArray[*pIdx]) { return m_pArray[*pIdx]; }

  00344	8b 1c b3	 mov	 ebx, DWORD PTR [ebx+esi*4]
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 439  : 		while (pList) {

  00347	85 db		 test	 ebx, ebx
  00349	75 c5		 jne	 SHORT $LL4@fileToFiel
$LN98@fileToFiel:

; 445  : 	bres = false;

  0034b	32 db		 xor	 bl, bl
  0034d	e9 6e fe ff ff	 jmp	 $LN102@fileToFiel
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?fileToFieldRecord@CFileUtil@@SA_NPADPAV?$CTList@VCStringList@@@@D@Z$7:
  00000	68 00 00 00 00	 push	 OFFSET ?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00005	8b 45 e4	 mov	 eax, DWORD PTR $T5[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ??3@YAXPAXABUnothrow_t@std@@@Z ; operator delete
  0000e	83 c4 08	 add	 esp, 8
  00011	c3		 ret	 0
__ehhandler$?fileToFieldRecord@CFileUtil@@SA_NPADPAV?$CTList@VCStringList@@@@D@Z:
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?fileToFieldRecord@CFileUtil@@SA_NPADPAV?$CTList@VCStringList@@@@D@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?fileToFieldRecord@CFileUtil@@SA_NPADPAV?$CTList@VCStringList@@@@D@Z ENDP ; CFileUtil::fileToFieldRecord
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File e:\infinia-library-3.0\com\include\commstring.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File e:\infinia-library-3.0\com\include\commstring.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\string.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\string.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\string.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\string.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\string.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\string.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File e:\infinia-library-3.0\com\include\commstring.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
;	COMDAT ?getFieldList@CFileUtil@@SA_NPADDPAVCStringList@@@Z
_TEXT	SEGMENT
tv229 = -528						; size = 4
_pList$GSCopy$1$ = -524					; size = 4
_bEnd$1$ = -517						; size = 1
_word$ = -516						; size = 512
__$ArrayPad$ = -4					; size = 4
_pRecord$ = 8						; size = 4
_cSeparator$ = 12					; size = 1
_pList$ = 16						; size = 4
?getFieldList@CFileUtil@@SA_NPADDPAVCStringList@@@Z PROC ; CFileUtil::getFieldList, COMDAT

; 453  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 10 02 00
	00		 sub	 esp, 528		; 00000210H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8a 45 0c	 mov	 al, BYTE PTR _cSeparator$[ebp]

; 454  : 	int nLen; 
; 455  : 	TCHAR *pNext, word[512];
; 456  : 	bool bEnd=false;

  00016	c6 85 fb fd ff
	ff 00		 mov	 BYTE PTR _bEnd$1$[ebp], 0
  0001d	53		 push	 ebx
  0001e	8b 5d 10	 mov	 ebx, DWORD PTR _pList$[ebp]
  00021	89 9d f4 fd ff
	ff		 mov	 DWORD PTR _pList$GSCopy$1$[ebp], ebx
  00027	56		 push	 esi
  00028	8b 75 08	 mov	 esi, DWORD PTR _pRecord$[ebp]

; 457  : 
; 458  : 	if (!cSeparator) {

  0002b	84 c0		 test	 al, al
  0002d	75 4f		 jne	 SHORT $LN32@getFieldLi
; File e:\infinia-library-3.0\com\include\commstring.h

; 87   : 	CmString * CStringList::push_back(TCHAR* pString) {if (!m_pList[m_nLast]) return __add(pString, m_nLast);return __add(pString, newIdx());}

  0002f	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00032	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00035	83 3c 88 00	 cmp	 DWORD PTR [eax+ecx*4], 0
  00039	75 1e		 jne	 SHORT $LN19@getFieldLi
  0003b	51		 push	 ecx
  0003c	56		 push	 esi
  0003d	8b cb		 mov	 ecx, ebx
  0003f	e8 00 00 00 00	 call	 ?__add@CStringList@@AAEPAVCmString@@PADH@Z ; CStringList::__add
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 459  : 		if (pList->push_back(pRecord)) {

  00044	85 c0		 test	 eax, eax
  00046	5e		 pop	 esi
  00047	0f 95 c0	 setne	 al
  0004a	5b		 pop	 ebx

; 482  : 	}
; 483  : 	return true;
; 484  : }

  0004b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004e	33 cd		 xor	 ecx, ebp
  00050	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN19@getFieldLi:
; File e:\infinia-library-3.0\com\include\commstring.h

; 87   : 	CmString * CStringList::push_back(TCHAR* pString) {if (!m_pList[m_nLast]) return __add(pString, m_nLast);return __add(pString, newIdx());}

  00059	8b cb		 mov	 ecx, ebx
  0005b	e8 00 00 00 00	 call	 ?newIdx@CStringList@@AAEHXZ ; CStringList::newIdx
  00060	50		 push	 eax
  00061	56		 push	 esi
  00062	8b cb		 mov	 ecx, ebx
  00064	e8 00 00 00 00	 call	 ?__add@CStringList@@AAEPAVCmString@@PADH@Z ; CStringList::__add
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 459  : 		if (pList->push_back(pRecord)) {

  00069	85 c0		 test	 eax, eax
  0006b	5e		 pop	 esi
  0006c	0f 95 c0	 setne	 al
  0006f	5b		 pop	 ebx

; 482  : 	}
; 483  : 	return true;
; 484  : }

  00070	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00073	33 cd		 xor	 ecx, ebp
  00075	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
$LN32@getFieldLi:

; 460  : 			return true;
; 461  : 		}
; 462  : 		return false;
; 463  : 	}
; 464  : 
; 465  : 	while (*pRecord)

  0007e	80 3e 00	 cmp	 BYTE PTR [esi], 0
  00081	57		 push	 edi
  00082	0f 84 d0 00 00
	00		 je	 $LN3@getFieldLi
  00088	0f be c8	 movsx	 ecx, al
  0008b	89 8d f0 fd ff
	ff		 mov	 DWORD PTR tv229[ebp], ecx
$LN51@getFieldLi:
  00091	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__strchr
$LL4@getFieldLi:

; 466  : 	{
; 467  : 		while (*pRecord == CH_SPC || *pRecord == CH_TAB) pRecord++;

  00097	8a 06		 mov	 al, BYTE PTR [esi]
  00099	3c 20		 cmp	 al, 32			; 00000020H
  0009b	74 04		 je	 SHORT $LN8@getFieldLi
  0009d	3c 09		 cmp	 al, 9
  0009f	75 03		 jne	 SHORT $LN5@getFieldLi
$LN8@getFieldLi:
  000a1	46		 inc	 esi
  000a2	eb f3		 jmp	 SHORT $LL4@getFieldLi
$LN5@getFieldLi:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\string.h

; 519  :         return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));

  000a4	51		 push	 ecx
  000a5	56		 push	 esi
  000a6	ff d3		 call	 ebx
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 468  : 		pNext = strchr(pRecord, cSeparator);

  000a8	8b f8		 mov	 edi, eax
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\string.h

; 519  :         return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));

  000aa	83 c4 08	 add	 esp, 8
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 469  : 		if (!pNext) {

  000ad	85 ff		 test	 edi, edi
  000af	75 22		 jne	 SHORT $LN9@getFieldLi
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\string.h

; 519  :         return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));

  000b1	50		 push	 eax
  000b2	56		 push	 esi
  000b3	ff d3		 call	 ebx
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 470  : 			if (!pNext) pNext = strchr(pRecord, 0);

  000b5	8b f8		 mov	 edi, eax
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\string.h

; 519  :         return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));

  000b7	83 c4 08	 add	 esp, 8
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 471  : 			if (!pNext) pNext = strchr(pRecord, g_rc);

  000ba	85 ff		 test	 edi, edi
  000bc	75 0e		 jne	 SHORT $LN42@getFieldLi
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\string.h

; 519  :         return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));

  000be	6a 0a		 push	 10			; 0000000aH
  000c0	56		 push	 esi
  000c1	ff d3		 call	 ebx
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 471  : 			if (!pNext) pNext = strchr(pRecord, g_rc);

  000c3	8b f8		 mov	 edi, eax
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\string.h

; 519  :         return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));

  000c5	83 c4 08	 add	 esp, 8
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 472  : 			if (!pNext) return false;

  000c8	85 ff		 test	 edi, edi
  000ca	74 79		 je	 SHORT $LN36@getFieldLi
$LN42@getFieldLi:

; 473  : 			bEnd = true;

  000cc	c6 85 fb fd ff
	ff 01		 mov	 BYTE PTR _bEnd$1$[ebp], 1
$LN9@getFieldLi:

; 475  : 		nLen = (int)(pNext - pRecord);

  000d3	8b df		 mov	 ebx, edi
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h

; 1545 :     return (char *)_mbsnbcpy((unsigned char *)_Dst,(const unsigned char *)_Source,_Count);

  000d5	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _word$[ebp]
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 475  : 		nLen = (int)(pNext - pRecord);

  000db	2b de		 sub	 ebx, esi
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h

; 1545 :     return (char *)_mbsnbcpy((unsigned char *)_Dst,(const unsigned char *)_Source,_Count);

  000dd	53		 push	 ebx
  000de	56		 push	 esi
  000df	50		 push	 eax
  000e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mbsnbcpy
  000e6	83 c4 0c	 add	 esp, 12			; 0000000cH
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 476  : 		_tcsncpy(word, pRecord, nLen); word[nLen] = 0;

  000e9	81 fb 00 02 00
	00		 cmp	 ebx, 512		; 00000200H
  000ef	73 7a		 jae	 SHORT $LN52@getFieldLi
  000f1	c6 84 1d fc fd
	ff ff 00	 mov	 BYTE PTR _word$[ebp+ebx], 0
; File e:\infinia-library-3.0\com\include\commstring.h

; 87   : 	CmString * CStringList::push_back(TCHAR* pString) {if (!m_pList[m_nLast]) return __add(pString, m_nLast);return __add(pString, newIdx());}

  000f9	8b 9d f4 fd ff
	ff		 mov	 ebx, DWORD PTR _pList$GSCopy$1$[ebp]
  000ff	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00102	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00105	83 3c 88 00	 cmp	 DWORD PTR [eax+ecx*4], 0
  00109	75 03		 jne	 SHORT $LN30@getFieldLi
  0010b	51		 push	 ecx
  0010c	eb 08		 jmp	 SHORT $LN50@getFieldLi
$LN30@getFieldLi:
  0010e	8b cb		 mov	 ecx, ebx
  00110	e8 00 00 00 00	 call	 ?newIdx@CStringList@@AAEHXZ ; CStringList::newIdx
  00115	50		 push	 eax
$LN50@getFieldLi:
  00116	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _word$[ebp]
  0011c	8b cb		 mov	 ecx, ebx
  0011e	50		 push	 eax
  0011f	e8 00 00 00 00	 call	 ?__add@CStringList@@AAEPAVCmString@@PADH@Z ; CStringList::__add
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 477  : 		if (!pList->push_back(word)) {

  00124	85 c0		 test	 eax, eax
  00126	74 1d		 je	 SHORT $LN36@getFieldLi

; 479  : 		}
; 480  : 		if (bEnd) return true;

  00128	80 bd fb fd ff
	ff 00		 cmp	 BYTE PTR _bEnd$1$[ebp], 0
  0012f	75 27		 jne	 SHORT $LN3@getFieldLi

; 481  : 		pRecord = pNext + 1;

  00131	80 7f 01 00	 cmp	 BYTE PTR [edi+1], 0
  00135	8d 77 01	 lea	 esi, DWORD PTR [edi+1]
  00138	74 1e		 je	 SHORT $LN3@getFieldLi

; 466  : 	{
; 467  : 		while (*pRecord == CH_SPC || *pRecord == CH_TAB) pRecord++;

  0013a	8b 8d f0 fd ff
	ff		 mov	 ecx, DWORD PTR tv229[ebp]
  00140	e9 4c ff ff ff	 jmp	 $LN51@getFieldLi
$LN36@getFieldLi:
  00145	5f		 pop	 edi
  00146	5e		 pop	 esi

; 478  : 			return false;

  00147	32 c0		 xor	 al, al
  00149	5b		 pop	 ebx

; 482  : 	}
; 483  : 	return true;
; 484  : }

  0014a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0014d	33 cd		 xor	 ecx, ebp
  0014f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00154	8b e5		 mov	 esp, ebp
  00156	5d		 pop	 ebp
  00157	c3		 ret	 0
$LN3@getFieldLi:
  00158	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0015b	b0 01		 mov	 al, 1
  0015d	5f		 pop	 edi
  0015e	5e		 pop	 esi
  0015f	33 cd		 xor	 ecx, ebp
  00161	5b		 pop	 ebx
  00162	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00167	8b e5		 mov	 esp, ebp
  00169	5d		 pop	 ebp
  0016a	c3		 ret	 0
$LN52@getFieldLi:

; 476  : 		_tcsncpy(word, pRecord, nLen); word[nLen] = 0;

  0016b	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN53@getFieldLi:
$LN48@getFieldLi:
  00170	cc		 int	 3
?getFieldList@CFileUtil@@SA_NPADDPAVCStringList@@@Z ENDP ; CFileUtil::getFieldList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\include\commemmanager.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\include\commemmanager.h
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\include\commemmanager.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
;	COMDAT ?getNextLine@CFileUtil@@SAHPAUSTStrInfo@@@Z
_TEXT	SEGMENT
_$S1$1 = -8						; size = 8
_$S1$2 = -8						; size = 8
tv287 = -4						; size = 4
_pInfo$ = 8						; size = 4
_bEnd$1$ = 11						; size = 1
?getNextLine@CFileUtil@@SAHPAUSTStrInfo@@@Z PROC	; CFileUtil::getNextLine, COMDAT

; 526  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 527  : 	int nSize = 0, nBufSize;  //g_nChSize
; 528  : 	TCHAR *pNextLine = _tcschr(pInfo->pSource, g_rc);

  00007	8b 75 08	 mov	 esi, DWORD PTR _pInfo$[ebp]
  0000a	57		 push	 edi
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h

; 1497 : __inline _CRPC _tcschr(_In_ _CPC _s1,_In_ _UI _c) {return (_CRPC)_mbschr((_CPUC)_s1,_c);}

  0000b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp___mbschr
  00011	6a 0a		 push	 10			; 0000000aH
  00013	ff 36		 push	 DWORD PTR [esi]
  00015	ff d7		 call	 edi
  00017	83 c4 08	 add	 esp, 8
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 529  : 	bool bEnd = false;

  0001a	c6 45 0b 00	 mov	 BYTE PTR _bEnd$1$[ebp], 0

; 530  : 
; 531  : 	if (pNextLine) {

  0001e	85 c0		 test	 eax, eax
  00020	74 07		 je	 SHORT $LN2@getNextLin

; 532  : 		nSize = (int)(pNextLine - pInfo->pSource) + 1;

  00022	8b f8		 mov	 edi, eax
  00024	2b 3e		 sub	 edi, DWORD PTR [esi]
  00026	47		 inc	 edi

; 533  : 	}
; 534  : 	else {

  00027	eb 1b		 jmp	 SHORT $LN3@getNextLin
$LN2@getNextLin:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h

; 1497 : __inline _CRPC _tcschr(_In_ _CPC _s1,_In_ _UI _c) {return (_CRPC)_mbschr((_CPUC)_s1,_c);}

  00029	6a 00		 push	 0
  0002b	ff 36		 push	 DWORD PTR [esi]
  0002d	ff d7		 call	 edi
  0002f	83 c4 08	 add	 esp, 8
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 536  : 		if(!pNextLine) return 0;

  00032	85 c0		 test	 eax, eax
  00034	75 06		 jne	 SHORT $LN4@getNextLin
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi

; 561  : }

  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
$LN4@getNextLin:

; 537  : 		nSize = (int)(pNextLine - pInfo->pSource);

  0003c	8b f8		 mov	 edi, eax

; 538  : 		bEnd = true;

  0003e	c6 45 0b 01	 mov	 BYTE PTR _bEnd$1$[ebp], 1
  00042	2b 3e		 sub	 edi, DWORD PTR [esi]
$LN3@getNextLin:

; 539  : 	}
; 540  : 
; 541  : 	*pNextLine = 0;

  00044	53		 push	 ebx
  00045	c6 00 00	 mov	 BYTE PTR [eax], 0

; 542  : 	nBufSize = nSize * g_nChSize;
; 543  : 	if (pInfo->aBufSize < nBufSize) {

  00048	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  0004b	3b df		 cmp	 ebx, edi
  0004d	0f 8d b3 00 00
	00		 jge	 $LN5@getNextLin

; 544  : 		if (pInfo->aBufSize) {

  00053	b8 01 00 00 00	 mov	 eax, 1
  00058	85 db		 test	 ebx, ebx
  0005a	74 3f		 je	 SHORT $LN6@getNextLin
  0005c	66 0f 6e c3	 movd	 xmm0, ebx
; File e:\infinia-library-3.0\com\include\combufpool.h

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  00060	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00064	f2 0f 11 45 f8	 movsd	 QWORD PTR _$S1$2[ebp], xmm0
  00069	8b 55 fc	 mov	 edx, DWORD PTR _$S1$2[ebp+4]
  0006c	c1 fa 14	 sar	 edx, 20			; 00000014H
  0006f	81 ea ff 03 00
	00		 sub	 edx, 1023		; 000003ffH
  00075	8b ca		 mov	 ecx, edx
  00077	d3 e0		 shl	 eax, cl
  00079	8b cb		 mov	 ecx, ebx
  0007b	2b c8		 sub	 ecx, eax
  0007d	23 cb		 and	 ecx, ebx
  0007f	f7 d9		 neg	 ecx
  00081	1b c9		 sbb	 ecx, ecx
  00083	f7 d9		 neg	 ecx
  00085	03 ca		 add	 ecx, edx
; File e:\infinia-library-3.0\com\include\commemmanager.h

; 38   : 	inline void delBuf(char *pBuf, int nSize) { int nIdx = getIndex(nSize); delBufByIndex(pBuf, nIdx); }

  00087	51		 push	 ecx
  00088	ff 76 04	 push	 DWORD PTR [esi+4]
  0008b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pMMgr@@3PAVCMemManager@@A ; gs_pMMgr
  00091	e8 00 00 00 00	 call	 ?delBufByIndex@CMemManager@@QAEXPADH@Z ; CMemManager::delBufByIndex
  00096	b8 01 00 00 00	 mov	 eax, 1
$LN6@getNextLin:
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 547  : 		nBufSize += 1024; // Allocating enough space

  0009b	8d 9f 00 04 00
	00		 lea	 ebx, DWORD PTR [edi+1024]
  000a1	66 0f 6e c3	 movd	 xmm0, ebx
; File e:\infinia-library-3.0\com\include\combufpool.h

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  000a5	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
; File e:\infinia-library-3.0\com\include\commemmanager.h

; 34   : 	inline char *newBuf(int nSize) { int nIdx = getIndex(nSize);  return __newBuf(nIdx, nSize); }

  000a9	53		 push	 ebx
; File e:\infinia-library-3.0\com\include\combufpool.h

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  000aa	f2 0f 11 45 f8	 movsd	 QWORD PTR _$S1$1[ebp], xmm0
  000af	8b 4d fc	 mov	 ecx, DWORD PTR _$S1$1[ebp+4]
  000b2	c1 f9 14	 sar	 ecx, 20			; 00000014H
  000b5	81 e9 ff 03 00
	00		 sub	 ecx, 1023		; 000003ffH
  000bb	d3 e0		 shl	 eax, cl
  000bd	89 45 fc	 mov	 DWORD PTR tv287[ebp], eax
  000c0	8b c3		 mov	 eax, ebx
  000c2	2b 45 fc	 sub	 eax, DWORD PTR tv287[ebp]
  000c5	23 c3		 and	 eax, ebx
  000c7	f7 d8		 neg	 eax
  000c9	1b c0		 sbb	 eax, eax
  000cb	f7 d8		 neg	 eax
  000cd	03 c1		 add	 eax, ecx
; File e:\infinia-library-3.0\com\include\commemmanager.h

; 34   : 	inline char *newBuf(int nSize) { int nIdx = getIndex(nSize);  return __newBuf(nIdx, nSize); }

  000cf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pMMgr@@3PAVCMemManager@@A ; gs_pMMgr
  000d5	50		 push	 eax
  000d6	e8 00 00 00 00	 call	 ?__newBuf@CMemManager@@AAEPADHI@Z ; CMemManager::__newBuf
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 548  : 		pInfo->pTarget = gs_pMMgr->newBuf(nBufSize);

  000db	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 549  : 		if (!pInfo->pTarget) {

  000de	85 c0		 test	 eax, eax
  000e0	75 21		 jne	 SHORT $LN7@getNextLin

; 550  : 			pInfo->aBufSize = 0;
; 551  : 			gs_cLogger.PutLogQueue(LEVEL_ERROR, _T("CFileUtil::getNextLine gs_pMMgr->newBuf error! size[%ld]"), nBufSize);

  000e2	53		 push	 ebx
  000e3	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@NKNKPPFB@CFileUtil?3?3getNextLine?5gs_pMMgr?9@
  000e8	6a 05		 push	 5
  000ea	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  000ef	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000f2	e8 00 00 00 00	 call	 ?PutLogQueue@CLogger@@QAAXHPBDZZ ; CLogger::PutLogQueue
  000f7	83 c4 10	 add	 esp, 16			; 00000010H
$LN31@getNextLin:

; 552  : 			return 0;

  000fa	5b		 pop	 ebx
  000fb	5f		 pop	 edi
  000fc	33 c0		 xor	 eax, eax
  000fe	5e		 pop	 esi

; 561  : }

  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c3		 ret	 0
$LN7@getNextLin:

; 553  : 		}
; 554  : 		pInfo->aBufSize = nBufSize;

  00103	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
$LN5@getNextLin:

; 555  : 	}
; 556  : 
; 557  : 	_tcscpy(pInfo->pTarget, pInfo->pSource);

  00106	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00108	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0010b	0f 1f 44 00 00	 npad	 5
$LL10@getNextLin:
  00110	8a 01		 mov	 al, BYTE PTR [ecx]
  00112	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00115	88 02		 mov	 BYTE PTR [edx], al
  00117	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  0011a	84 c0		 test	 al, al
  0011c	75 f2		 jne	 SHORT $LL10@getNextLin

; 558  : 	if (bEnd) return 0;

  0011e	38 45 0b	 cmp	 BYTE PTR _bEnd$1$[ebp], al
  00121	75 d7		 jne	 SHORT $LN31@getNextLin

; 559  : 	pInfo->pSource += nSize;

  00123	01 3e		 add	 DWORD PTR [esi], edi

; 560  : 	return nSize;

  00125	8b c7		 mov	 eax, edi
  00127	5b		 pop	 ebx
  00128	5f		 pop	 edi
  00129	5e		 pop	 esi

; 561  : }

  0012a	8b e5		 mov	 esp, ebp
  0012c	5d		 pop	 ebp
  0012d	c3		 ret	 0
?getNextLine@CFileUtil@@SAHPAUSTStrInfo@@@Z ENDP	; CFileUtil::getNextLine
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\include\commemmanager.h
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\include\commemmanager.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
;	COMDAT ?readNalloc@CFileUtil@@SAHPADPAPADPAH@Z
_TEXT	SEGMENT
_$S1$1 = -16						; size = 8
_nSize$1$ = -8						; size = 4
_nBufSize$1$ = -4					; size = 4
_pFilePath$ = 8						; size = 4
_pBuf$ = 12						; size = 4
_aBufSize$ = 16						; size = 4
?readNalloc@CFileUtil@@SAHPADPAPADPAH@Z PROC		; CFileUtil::readNalloc, COMDAT

; 487  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 488  : 	FILE *pFile = _tfopen(pFilePath, _T("rb"));

  00008	8b 75 08	 mov	 esi, DWORD PTR _pFilePath$[ebp]
  0000b	57		 push	 edi
  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb?$AA@
  00011	56		 push	 esi
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00018	8b d8		 mov	 ebx, eax
  0001a	83 c4 08	 add	 esp, 8

; 489  : 	int nSize = 0, nRead, nPos=0, nBufSize;

  0001d	33 ff		 xor	 edi, edi

; 490  : 
; 491  : 	if (!pFile) {

  0001f	85 db		 test	 ebx, ebx
  00021	75 1e		 jne	 SHORT $LN4@readNalloc

; 492  : 		gs_cLogger.PutLogQueue(LEVEL_ERROR, _T("CDFSFile::read pFile open FAIL [%s]"), pFilePath);

  00023	56		 push	 esi
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@HGILDMCF@CDFSFile?3?3read?5pFile?5open?5FAIL?5?$FL@
$LN19@readNalloc:
  00029	6a 05		 push	 5
  0002b	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  00030	e8 00 00 00 00	 call	 ?PutLogQueue@CLogger@@QAAXHPBDZZ ; CLogger::PutLogQueue
  00035	83 c4 10	 add	 esp, 16			; 00000010H

; 493  : 		return 0;

  00038	33 c0		 xor	 eax, eax
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx

; 523  : }

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
$LN4@readNalloc:

; 494  : 	}
; 495  : 	fseek(pFile, 0, SEEK_END);

  00041	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__fseek
  00047	6a 02		 push	 2
  00049	6a 00		 push	 0
  0004b	53		 push	 ebx
  0004c	ff d6		 call	 esi

; 496  : 	nSize = ftell(pFile);

  0004e	53		 push	 ebx
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ftell

; 497  : 	fseek(pFile, 0, SEEK_SET);

  00055	6a 00		 push	 0
  00057	6a 00		 push	 0
  00059	53		 push	 ebx
  0005a	89 45 f8	 mov	 DWORD PTR _nSize$1$[ebp], eax
  0005d	ff d6		 call	 esi

; 498  : 
; 499  : 	nBufSize = nSize + 1;

  0005f	8b 45 f8	 mov	 eax, DWORD PTR _nSize$1$[ebp]
  00062	83 c4 1c	 add	 esp, 28			; 0000001cH

; 500  : 	if (*aBufSize < nBufSize) {

  00065	8b 4d 10	 mov	 ecx, DWORD PTR _aBufSize$[ebp]
  00068	8b 75 0c	 mov	 esi, DWORD PTR _pBuf$[ebp]
  0006b	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0006e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00070	89 55 fc	 mov	 DWORD PTR _nBufSize$1$[ebp], edx
  00073	3b ca		 cmp	 ecx, edx
  00075	7d 6d		 jge	 SHORT $LN14@readNalloc

; 501  : 		if (*aBufSize) {

  00077	85 c9		 test	 ecx, ecx
  00079	74 11		 je	 SHORT $LN6@readNalloc

; 502  : 			gs_pMMgr->delBuf(*pBuf, *aBufSize);

  0007b	51		 push	 ecx
  0007c	ff 36		 push	 DWORD PTR [esi]
  0007e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pMMgr@@3PAVCMemManager@@A ; gs_pMMgr
  00084	e8 00 00 00 00	 call	 ?delBuf@CMemManager@@QAEXPADH@Z ; CMemManager::delBuf
  00089	8b 55 fc	 mov	 edx, DWORD PTR _nBufSize$1$[ebp]
$LN6@readNalloc:
  0008c	66 0f 6e c2	 movd	 xmm0, edx
; File e:\infinia-library-3.0\com\include\combufpool.h

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  00090	b8 01 00 00 00	 mov	 eax, 1
  00095	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
; File e:\infinia-library-3.0\com\include\commemmanager.h

; 34   : 	inline char *newBuf(int nSize) { int nIdx = getIndex(nSize);  return __newBuf(nIdx, nSize); }

  00099	52		 push	 edx
; File e:\infinia-library-3.0\com\include\combufpool.h

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  0009a	f2 0f 11 45 f0	 movsd	 QWORD PTR _$S1$1[ebp], xmm0
  0009f	8b 4d f4	 mov	 ecx, DWORD PTR _$S1$1[ebp+4]
  000a2	c1 f9 14	 sar	 ecx, 20			; 00000014H
  000a5	81 e9 ff 03 00
	00		 sub	 ecx, 1023		; 000003ffH
  000ab	d3 e0		 shl	 eax, cl
  000ad	2b d0		 sub	 edx, eax
  000af	23 55 fc	 and	 edx, DWORD PTR _nBufSize$1$[ebp]
  000b2	f7 da		 neg	 edx
  000b4	1b d2		 sbb	 edx, edx
  000b6	f7 da		 neg	 edx
  000b8	03 d1		 add	 edx, ecx
; File e:\infinia-library-3.0\com\include\commemmanager.h

; 34   : 	inline char *newBuf(int nSize) { int nIdx = getIndex(nSize);  return __newBuf(nIdx, nSize); }

  000ba	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pMMgr@@3PAVCMemManager@@A ; gs_pMMgr
  000c0	52		 push	 edx
  000c1	e8 00 00 00 00	 call	 ?__newBuf@CMemManager@@AAEPADHI@Z ; CMemManager::__newBuf
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 504  : 		*pBuf = gs_pMMgr->newBuf(nBufSize);

  000c6	89 06		 mov	 DWORD PTR [esi], eax

; 505  : 		if (!*pBuf) {

  000c8	85 c0		 test	 eax, eax
  000ca	75 0d		 jne	 SHORT $LN7@readNalloc

; 506  : 			gs_cLogger.PutLogQueue(LEVEL_ERROR, _T("CFileUtil::readNalloc malloc error! size[%ld]"), nBufSize);

  000cc	ff 75 fc	 push	 DWORD PTR _nBufSize$1$[ebp]
  000cf	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@KJLDNOFB@CFileUtil?3?3readNalloc?5malloc?5err@

; 507  : 			return 0;

  000d4	e9 50 ff ff ff	 jmp	 $LN19@readNalloc
$LN7@readNalloc:

; 508  : 		}
; 509  : 		*aBufSize = nBufSize;

  000d9	8b 4d 10	 mov	 ecx, DWORD PTR _aBufSize$[ebp]
  000dc	8b 45 fc	 mov	 eax, DWORD PTR _nBufSize$1$[ebp]
  000df	89 01		 mov	 DWORD PTR [ecx], eax
  000e1	8b 45 f8	 mov	 eax, DWORD PTR _nSize$1$[ebp]
$LN14@readNalloc:

; 510  : 	}
; 511  : 
; 512  : 	while ((nRead = (int)fread(*pBuf + nPos, 1, nSize - nPos, pFile)) > 0)

  000e4	53		 push	 ebx
  000e5	50		 push	 eax
  000e6	6a 01		 push	 1
  000e8	ff 36		 push	 DWORD PTR [esi]
  000ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  000f0	83 c4 10	 add	 esp, 16			; 00000010H
  000f3	85 c0		 test	 eax, eax
  000f5	7e 21		 jle	 SHORT $LN18@readNalloc
$LL2@readNalloc:

; 513  : 	{
; 514  : 		nPos += nRead;

  000f7	03 f8		 add	 edi, eax
  000f9	8b 45 f8	 mov	 eax, DWORD PTR _nSize$1$[ebp]
  000fc	2b c7		 sub	 eax, edi
  000fe	53		 push	 ebx
  000ff	50		 push	 eax
  00100	8b 06		 mov	 eax, DWORD PTR [esi]
  00102	03 c7		 add	 eax, edi
  00104	6a 01		 push	 1
  00106	50		 push	 eax
  00107	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  0010d	83 c4 10	 add	 esp, 16			; 00000010H
  00110	85 c0		 test	 eax, eax
  00112	7f e3		 jg	 SHORT $LL2@readNalloc

; 515  : 	}
; 516  : 
; 517  : 	if (!nPos) {

  00114	85 ff		 test	 edi, edi
  00116	75 15		 jne	 SHORT $LN8@readNalloc
$LN18@readNalloc:

; 518  : 		printf("fread errno[%d]\n", errno);

  00118	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  0011e	ff 30		 push	 DWORD PTR [eax]
  00120	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@PMEFOBEN@fread?5errno?$FL?$CFd?$FN?6?$AA@
  00125	e8 00 00 00 00	 call	 _printf
  0012a	83 c4 08	 add	 esp, 8
$LN8@readNalloc:

; 519  : 	}
; 520  : 	(*pBuf)[nPos] = 0;

  0012d	8b 06		 mov	 eax, DWORD PTR [esi]

; 521  : 	fclose(pFile);

  0012f	53		 push	 ebx
  00130	c6 04 07 00	 mov	 BYTE PTR [edi+eax], 0
  00134	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose

; 522  : 	return nSize;

  0013a	8b 45 f8	 mov	 eax, DWORD PTR _nSize$1$[ebp]
  0013d	83 c4 04	 add	 esp, 4
  00140	5f		 pop	 edi
  00141	5e		 pop	 esi
  00142	5b		 pop	 ebx

; 523  : }

  00143	8b e5		 mov	 esp, ebp
  00145	5d		 pop	 ebp
  00146	c3		 ret	 0
?readNalloc@CFileUtil@@SAHPADPAPADPAH@Z ENDP		; CFileUtil::readNalloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
;	COMDAT ?read@CFileUtil@@SAHPAD0H@Z
_TEXT	SEGMENT
_pFilePath$ = 8						; size = 4
_pBuf$ = 12						; size = 4
_nFileSize$ = 16					; size = 4
?read@CFileUtil@@SAHPAD0H@Z PROC			; CFileUtil::read, COMDAT

; 384  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 385  : 	FILE *pFile = _tfopen(pFilePath, _T("rb"));

  00005	8b 75 08	 mov	 esi, DWORD PTR _pFilePath$[ebp]
  00008	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb?$AA@
  0000d	56		 push	 esi
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00014	8b d8		 mov	 ebx, eax
  00016	83 c4 08	 add	 esp, 8

; 386  : 	int nSize = 0;
; 387  : 
; 388  : 	if (!pFile) {

  00019	85 db		 test	 ebx, ebx
  0001b	75 1b		 jne	 SHORT $LN2@read

; 389  : 		gs_cLogger.PutLogQueue(LEVEL_ERROR, _T("CDFSFile::read pFile open FAIL [%s]"), pFilePath);

  0001d	56		 push	 esi
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@HGILDMCF@CDFSFile?3?3read?5pFile?5open?5FAIL?5?$FL@
  00023	6a 05		 push	 5
  00025	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  0002a	e8 00 00 00 00	 call	 ?PutLogQueue@CLogger@@QAAXHPBDZZ ; CLogger::PutLogQueue
  0002f	83 c4 10	 add	 esp, 16			; 00000010H

; 390  : 		return 0;

  00032	33 c0		 xor	 eax, eax
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx

; 396  : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
$LN2@read:

; 391  : 	}
; 392  : 	nSize = (int)fread(pBuf, g_nChSize, nFileSize, pFile);

  00038	8b 75 0c	 mov	 esi, DWORD PTR _pBuf$[ebp]
  0003b	57		 push	 edi
  0003c	53		 push	 ebx
  0003d	ff 75 10	 push	 DWORD PTR _nFileSize$[ebp]
  00040	6a 01		 push	 1
  00042	56		 push	 esi
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  00049	8b f8		 mov	 edi, eax

; 393  : 	pBuf[nSize] = 0;
; 394  : 	fclose(pFile);

  0004b	53		 push	 ebx
  0004c	c6 04 37 00	 mov	 BYTE PTR [edi+esi], 0
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00056	83 c4 14	 add	 esp, 20			; 00000014H

; 395  : 	return nSize;

  00059	8b c7		 mov	 eax, edi
  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx

; 396  : }

  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?read@CFileUtil@@SAHPAD0H@Z ENDP			; CFileUtil::read
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
;	COMDAT ?changeDirName@CFileUtil@@SA_NPAD0@Z
_TEXT	SEGMENT
_pOriDir$ = 8						; size = 4
_pNewDir$ = 12						; size = 4
?changeDirName@CFileUtil@@SA_NPAD0@Z PROC		; CFileUtil::changeDirName, COMDAT

; 374  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 375  : 	MakeDirectory(pNewDir);

  00003	ff 75 0c	 push	 DWORD PTR _pNewDir$[ebp]
  00006	e8 00 00 00 00	 call	 ?MakeDirectory@CFileUtil@@SA_NPBD@Z ; CFileUtil::MakeDirectory

; 376  : 	if ( _trename(pOriDir, pNewDir) != 0 ) {

  0000b	ff 75 0c	 push	 DWORD PTR _pNewDir$[ebp]
  0000e	ff 75 08	 push	 DWORD PTR _pOriDir$[ebp]
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__rename
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001a	85 c0		 test	 eax, eax
  0001c	0f 94 c0	 sete	 al

; 377  : 		return false;
; 378  : 	}
; 379  : 	return true;
; 380  : }

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?changeDirName@CFileUtil@@SA_NPAD0@Z ENDP		; CFileUtil::changeDirName
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
;	COMDAT ?setDirectory@CFileUtil@@SA_NPADH@Z
_TEXT	SEGMENT
_pDir$ = 8						; size = 4
_upCount$ = 12						; size = 4
?setDirectory@CFileUtil@@SA_NPADH@Z PROC		; CFileUtil::setDirectory, COMDAT

; 251  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 252  : 	if (!pDir) {

  00004	8b 7d 08	 mov	 edi, DWORD PTR _pDir$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	75 05		 jne	 SHORT $LN5@setDirecto

; 253  : 		return false;

  0000b	32 c0		 xor	 al, al
  0000d	5f		 pop	 edi

; 269  : }

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
$LN5@setDirecto:
  00010	53		 push	 ebx

; 254  : 	}
; 255  : 	size_t	nLen = (int)_tcslen(pDir);
; 256  : 	char *pRear = pDir;
; 257  : 
; 258  : 	int i;
; 259  : 	for (i = 0; i < upCount; i++) {

  00011	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp___mbsrchr
  00017	56		 push	 esi
  00018	8b 75 0c	 mov	 esi, DWORD PTR _upCount$[ebp]
  0001b	85 f6		 test	 esi, esi
  0001d	7e 11		 jle	 SHORT $LN3@setDirecto
  0001f	90		 npad	 1
$LL4@setDirecto:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h

; 1569 : _Check_return_ __inline _CRPC _tcsrchr(_In_ _CPC _s1,_In_ _UI _c) {return (_CRPC)_mbsrchr((_CPUC)_s1,_c);}

  00020	6a 5c		 push	 92			; 0000005cH
  00022	57		 push	 edi
  00023	ff d3		 call	 ebx
  00025	83 c4 08	 add	 esp, 8
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 261  : 		*pRear = 0;

  00028	c6 00 00	 mov	 BYTE PTR [eax], 0
  0002b	83 ee 01	 sub	 esi, 1
  0002e	75 f0		 jne	 SHORT $LL4@setDirecto
$LN3@setDirecto:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h

; 1569 : _Check_return_ __inline _CRPC _tcsrchr(_In_ _CPC _s1,_In_ _UI _c) {return (_CRPC)_mbsrchr((_CPUC)_s1,_c);}

  00030	6a 5c		 push	 92			; 0000005cH
  00032	57		 push	 edi
  00033	ff d3		 call	 ebx
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 265  : 	nLen = pRear - pDir + 1;

  00035	be 01 00 00 00	 mov	 esi, 1
  0003a	2b f7		 sub	 esi, edi
  0003c	03 f0		 add	 esi, eax
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h

; 1545 :     return (char *)_mbsnbcpy((unsigned char *)_Dst,(const unsigned char *)_Source,_Count);

  0003e	56		 push	 esi
  0003f	57		 push	 edi
  00040	57		 push	 edi
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mbsnbcpy
  00047	83 c4 14	 add	 esp, 20			; 00000014H
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 267  : 	_tcsncpy(pDir, pDir, nLen); pDir[nLen] = 0;

  0004a	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0

; 268  : 	return true;

  0004e	b0 01		 mov	 al, 1
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	5f		 pop	 edi

; 269  : }

  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
?setDirectory@CFileUtil@@SA_NPADH@Z ENDP		; CFileUtil::setDirectory
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
;	COMDAT ?IsAbsolutePath@CFileUtil@@SA_NPBD@Z
_TEXT	SEGMENT
_pPath$ = 8						; size = 4
?IsAbsolutePath@CFileUtil@@SA_NPBD@Z PROC		; CFileUtil::IsAbsolutePath, COMDAT

; 329  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 330  : 	if (!pPath)

  00003	8b 45 08	 mov	 eax, DWORD PTR _pPath$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN2@IsAbsolute
$LN7@IsAbsolute:

; 331  : 		return false;

  0000a	32 c0		 xor	 al, al

; 335  : 	else
; 336  : 		return false;
; 337  : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
$LN2@IsAbsolute:

; 332  : 
; 333  : 	if (pPath[1] == ':' || pPath[0] == '\\' || pPath[0] == '/')

  0000e	80 78 01 3a	 cmp	 BYTE PTR [eax+1], 58	; 0000003aH
  00012	74 0a		 je	 SHORT $LN5@IsAbsolute
  00014	8a 00		 mov	 al, BYTE PTR [eax]
  00016	3c 5c		 cmp	 al, 92			; 0000005cH
  00018	74 04		 je	 SHORT $LN5@IsAbsolute
  0001a	3c 2f		 cmp	 al, 47			; 0000002fH
  0001c	75 ec		 jne	 SHORT $LN7@IsAbsolute
$LN5@IsAbsolute:

; 334  : 		return true;

  0001e	b0 01		 mov	 al, 1

; 335  : 	else
; 336  : 		return false;
; 337  : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?IsAbsolutePath@CFileUtil@@SA_NPBD@Z ENDP		; CFileUtil::IsAbsolutePath
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
;	COMDAT ?FileCopy@CFileUtil@@SA_NPBD0@Z
_TEXT	SEGMENT
_szBuf$ = -8196						; size = 8192
__$ArrayPad$ = -4					; size = 4
_szSrc$ = 8						; size = 4
_szDest$ = 12						; size = 4
?FileCopy@CFileUtil@@SA_NPBD0@Z PROC			; CFileUtil::FileCopy, COMDAT

; 341  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 04 20 00 00	 mov	 eax, 8196		; 00002004H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	8b 45 08	 mov	 eax, DWORD PTR _szSrc$[ebp]
  0001a	53		 push	 ebx
  0001b	8b 5d 0c	 mov	 ebx, DWORD PTR _szDest$[ebp]
  0001e	56		 push	 esi

; 342  : 
; 343  : 	TCHAR	szBuf[8192];
; 344  : 	size_t	nLen;
; 345  : 	FILE *inFp=NULL, *outFp=NULL;
; 346  : 
; 347  : 	inFp = _tfopen(szSrc, _T("rb"));

  0001f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__fopen
  00025	57		 push	 edi
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb?$AA@
  0002b	50		 push	 eax
  0002c	ff d6		 call	 esi
  0002e	8b f8		 mov	 edi, eax
  00030	83 c4 08	 add	 esp, 8

; 348  : 	if(!inFp) {

  00033	85 ff		 test	 edi, edi
  00035	74 1b		 je	 SHORT $LN14@FileCopy

; 349  : 		return false;
; 350  : 	}
; 351  : 
; 352  : 	outFp = _tfopen(szDest, _T("wb+"));

  00037	68 00 00 00 00	 push	 OFFSET ??_C@_03BFHAFKOB@wb?$CL?$AA@
  0003c	53		 push	 ebx
  0003d	ff d6		 call	 esi
  0003f	83 c4 08	 add	 esp, 8
  00042	8b d8		 mov	 ebx, eax

; 353  : 	if(!outFp) {
; 354  : 		fclose(inFp);

  00044	57		 push	 edi
  00045	85 db		 test	 ebx, ebx
  00047	75 1c		 jne	 SHORT $LN5@FileCopy
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  0004f	83 c4 04	 add	 esp, 4
$LN14@FileCopy:

; 355  : 		return false;

  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	32 c0		 xor	 al, al
  00056	5b		 pop	 ebx

; 370  : 	return true;
; 371  : }

  00057	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005a	33 cd		 xor	 ecx, ebp
  0005c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
$LN5@FileCopy:

; 356  : 	}
; 357  : 
; 358  : 	nLen = fread(szBuf, g_nChSize, sizeof(szBuf), inFp);

  00065	68 00 20 00 00	 push	 8192			; 00002000H
  0006a	8d 85 fc df ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  00070	6a 01		 push	 1
  00072	50		 push	 eax
  00073	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  00079	8b f0		 mov	 esi, eax
  0007b	83 c4 10	 add	 esp, 16			; 00000010H

; 359  : 	while (0 < nLen) 

  0007e	85 f6		 test	 esi, esi
  00080	74 3a		 je	 SHORT $LN13@FileCopy
$LL2@FileCopy:

; 360  :     {
; 361  : 		fwrite(szBuf, g_nChSize, nLen, outFp);

  00082	53		 push	 ebx
  00083	56		 push	 esi
  00084	8d 85 fc df ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  0008a	6a 01		 push	 1
  0008c	50		 push	 eax
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  00093	83 c4 10	 add	 esp, 16			; 00000010H

; 362  : 		if (nLen < sizeof(szBuf))

  00096	81 fe 00 20 00
	00		 cmp	 esi, 8192		; 00002000H
  0009c	72 1e		 jb	 SHORT $LN13@FileCopy

; 363  : 			break;
; 364  : 
; 365  :         nLen = fread(szBuf, g_nChSize, sizeof(szBuf), inFp);

  0009e	57		 push	 edi
  0009f	68 00 20 00 00	 push	 8192			; 00002000H
  000a4	8d 85 fc df ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  000aa	6a 01		 push	 1
  000ac	50		 push	 eax
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  000b3	8b f0		 mov	 esi, eax
  000b5	83 c4 10	 add	 esp, 16			; 00000010H
  000b8	85 f6		 test	 esi, esi
  000ba	75 c6		 jne	 SHORT $LL2@FileCopy
$LN13@FileCopy:

; 366  : 	}
; 367  : 
; 368  : 	fclose(inFp);

  000bc	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__fclose
  000c2	57		 push	 edi
  000c3	ff d6		 call	 esi

; 369  : 	fclose(outFp);

  000c5	53		 push	 ebx
  000c6	ff d6		 call	 esi

; 370  : 	return true;
; 371  : }

  000c8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000cb	83 c4 08	 add	 esp, 8
  000ce	33 cd		 xor	 ecx, ebp
  000d0	b0 01		 mov	 al, 1
  000d2	5f		 pop	 edi
  000d3	5e		 pop	 esi
  000d4	5b		 pop	 ebx
  000d5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c3		 ret	 0
?FileCopy@CFileUtil@@SA_NPBD0@Z ENDP			; CFileUtil::FileCopy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File e:\infinia-library-3.0\com\include\comfiletypes.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
;	COMDAT ?MakeDirectory@CFileUtil@@SA_NPBD@Z
_TEXT	SEGMENT
_szTmp$ = -272						; size = 10
_tmpBuf$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_dirName$ = 8						; size = 4
?MakeDirectory@CFileUtil@@SA_NPBD@Z PROC		; CFileUtil::MakeDirectory, COMDAT

; 298  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 10 01 00
	00		 sub	 esp, 272		; 00000110H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _dirName$[ebp]

; 299  : 	TCHAR	tmpBuf[MAX_PATH_LEN];
; 300  : 	TCHAR	*ptr, *dptr = (TCHAR *)dirName;

  00017	8b d3		 mov	 edx, ebx

; 301  : 	int	len;	
; 302  : 	CheckDirName((TCHAR*)dirName);

  00019	8b c3		 mov	 eax, ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi

; 70   : 	while (dirName && *dirName)

  0001d	85 db		 test	 ebx, ebx
  0001f	74 13		 je	 SHORT $LN47@MakeDirect
$LL14@MakeDirect:
  00021	8a 08		 mov	 cl, BYTE PTR [eax]
  00023	84 c9		 test	 cl, cl
  00025	74 0d		 je	 SHORT $LN47@MakeDirect

; 71   : 	{
; 72   : 		if (*dirName == fromChar)

  00027	80 f9 2f	 cmp	 cl, 47			; 0000002fH
  0002a	75 03		 jne	 SHORT $LN16@MakeDirect

; 73   : 			*dirName = toChar;

  0002c	c6 00 5c	 mov	 BYTE PTR [eax], 92	; 0000005cH
$LN16@MakeDirect:

; 74   : 		dirName++;

  0002f	83 c0 01	 add	 eax, 1

; 70   : 	while (dirName && *dirName)

  00032	75 ed		 jne	 SHORT $LL14@MakeDirect
$LN47@MakeDirect:

; 303  : #ifndef WIN32
; 304  : 	TCHAR szTmp[2][5] = {_T("./"), _T("../")};
; 305  : #else
; 306  : 	TCHAR szTmp[2][5] = {_T(".\\"), _T("..\\")};

  00034	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_02CEGDFPFP@?4?2?$AA@
  0003a	66 89 85 f0 fe
	ff ff		 mov	 WORD PTR _szTmp$[ebp], ax
  00041	a0 02 00 00 00	 mov	 al, BYTE PTR ??_C@_02CEGDFPFP@?4?2?$AA@+2
  00046	88 85 f2 fe ff
	ff		 mov	 BYTE PTR _szTmp$[ebp+2], al
  0004c	33 c0		 xor	 eax, eax
  0004e	66 89 85 f3 fe
	ff ff		 mov	 WORD PTR _szTmp$[ebp+3], ax
  00055	c7 85 f5 fe ff
	ff 2e 2e 5c 00	 mov	 DWORD PTR _szTmp$[ebp+5], 6041134 ; 005c2e2eH
  0005f	88 85 f9 fe ff
	ff		 mov	 BYTE PTR _szTmp$[ebp+9], al

; 308  : 	while (dptr && (ptr = _tcschr(dptr, g_s)))

  00065	85 db		 test	 ebx, ebx
  00067	0f 84 e1 00 00
	00		 je	 $LN3@MakeDirect
  0006d	0f 1f 00	 npad	 3
$LL2@MakeDirect:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h

; 1497 : __inline _CRPC _tcschr(_In_ _CPC _s1,_In_ _UI _c) {return (_CRPC)_mbschr((_CPUC)_s1,_c);}

  00070	6a 5c		 push	 92			; 0000005cH
  00072	52		 push	 edx
  00073	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mbschr
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 308  : 	while (dptr && (ptr = _tcschr(dptr, g_s)))

  00079	8b f8		 mov	 edi, eax
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h

; 1497 : __inline _CRPC _tcschr(_In_ _CPC _s1,_In_ _UI _c) {return (_CRPC)_mbschr((_CPUC)_s1,_c);}

  0007b	83 c4 08	 add	 esp, 8
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 308  : 	while (dptr && (ptr = _tcschr(dptr, g_s)))

  0007e	85 ff		 test	 edi, edi
  00080	0f 84 c8 00 00
	00		 je	 $LN3@MakeDirect

; 310  : 		len = (int)(ptr - dirName) + 1;

  00086	8b f7		 mov	 esi, edi
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h

; 1545 :     return (char *)_mbsnbcpy((unsigned char *)_Dst,(const unsigned char *)_Source,_Count);

  00088	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _tmpBuf$[ebp]
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 310  : 		len = (int)(ptr - dirName) + 1;

  0008e	2b f3		 sub	 esi, ebx
  00090	46		 inc	 esi
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h

; 1545 :     return (char *)_mbsnbcpy((unsigned char *)_Dst,(const unsigned char *)_Source,_Count);

  00091	56		 push	 esi
  00092	53		 push	 ebx
  00093	50		 push	 eax
  00094	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mbsnbcpy
  0009a	83 c4 0c	 add	 esp, 12			; 0000000cH
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 312  : 		tmpBuf[len] = 0;

  0009d	81 fe 00 01 00
	00		 cmp	 esi, 256		; 00000100H
  000a3	0f 83 f0 00 00
	00		 jae	 $LN49@MakeDirect
  000a9	c6 84 35 fc fe
	ff ff 00	 mov	 BYTE PTR _tmpBuf$[ebp+esi], 0

; 313  : 
; 314  : 		if (strcmp(tmpBuf, szTmp[0]) && strcmp(tmpBuf, szTmp[1])) {

  000b1	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _szTmp$[ebp]
  000b7	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _tmpBuf$[ebp]
  000bd	0f 1f 00	 npad	 3
$LL39@MakeDirect:
  000c0	8a 10		 mov	 dl, BYTE PTR [eax]
  000c2	3a 11		 cmp	 dl, BYTE PTR [ecx]
  000c4	75 1a		 jne	 SHORT $LN40@MakeDirect
  000c6	84 d2		 test	 dl, dl
  000c8	74 12		 je	 SHORT $LN41@MakeDirect
  000ca	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  000cd	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  000d0	75 0e		 jne	 SHORT $LN40@MakeDirect
  000d2	83 c0 02	 add	 eax, 2
  000d5	83 c1 02	 add	 ecx, 2
  000d8	84 d2		 test	 dl, dl
  000da	75 e4		 jne	 SHORT $LL39@MakeDirect
$LN41@MakeDirect:
  000dc	33 c0		 xor	 eax, eax
  000de	eb 05		 jmp	 SHORT $LN42@MakeDirect
$LN40@MakeDirect:
  000e0	1b c0		 sbb	 eax, eax
  000e2	83 c8 01	 or	 eax, 1
$LN42@MakeDirect:
  000e5	85 c0		 test	 eax, eax
  000e7	74 78		 je	 SHORT $MDIR_ERROR$51
  000e9	8d 8d f5 fe ff
	ff		 lea	 ecx, DWORD PTR _szTmp$[ebp+5]
  000ef	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _tmpBuf$[ebp]
$LL43@MakeDirect:
  000f5	8a 10		 mov	 dl, BYTE PTR [eax]
  000f7	3a 11		 cmp	 dl, BYTE PTR [ecx]
  000f9	75 1a		 jne	 SHORT $LN44@MakeDirect
  000fb	84 d2		 test	 dl, dl
  000fd	74 12		 je	 SHORT $LN45@MakeDirect
  000ff	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00102	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00105	75 0e		 jne	 SHORT $LN44@MakeDirect
  00107	83 c0 02	 add	 eax, 2
  0010a	83 c1 02	 add	 ecx, 2
  0010d	84 d2		 test	 dl, dl
  0010f	75 e4		 jne	 SHORT $LL43@MakeDirect
$LN45@MakeDirect:
  00111	33 c0		 xor	 eax, eax
  00113	eb 05		 jmp	 SHORT $LN46@MakeDirect
$LN44@MakeDirect:
  00115	1b c0		 sbb	 eax, eax
  00117	83 c8 01	 or	 eax, 1
$LN46@MakeDirect:
  0011a	85 c0		 test	 eax, eax
  0011c	74 43		 je	 SHORT $MDIR_ERROR$51
; File e:\infinia-library-3.0\com\include\comfiletypes.h

; 78   : inline bool com_isInvalid(const TCHAR *fath) { if (GetFileAttributes(fath) == INVALID_FILE_ATTRIBUTES)return true; return false; }

  0011e	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _tmpBuf$[ebp]
  00124	50		 push	 eax
  00125	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileAttributesA@4
  0012b	83 f8 ff	 cmp	 eax, -1
  0012e	75 13		 jne	 SHORT $LN7@MakeDirect

; 75   : inline bool com_mkdir(const TCHAR *path)	{int res = CreateDirectory(path, NULL); return (res)?true:false; }

  00130	6a 00		 push	 0
  00132	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _tmpBuf$[ebp]
  00138	50		 push	 eax
  00139	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDirectoryA@8
  0013f	85 c0		 test	 eax, eax
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 316  : 				if (!com_mkdir(tmpBuf)) goto MDIR_ERROR;

  00141	74 1e		 je	 SHORT $MDIR_ERROR$51
$LN7@MakeDirect:

; 317  : 			}
; 318  : 		}
; 319  : 		else goto MDIR_ERROR;
; 320  : 		dptr = ptr + 1;

  00143	8d 57 01	 lea	 edx, DWORD PTR [edi+1]
  00146	85 d2		 test	 edx, edx
  00148	0f 85 22 ff ff
	ff		 jne	 $LL2@MakeDirect
$LN3@MakeDirect:
  0014e	5f		 pop	 edi
  0014f	5e		 pop	 esi

; 321  : 	}
; 322  : 	return true;

  00150	b0 01		 mov	 al, 1
  00152	5b		 pop	 ebx

; 325  : 	return false;
; 326  : }

  00153	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00156	33 cd		 xor	 ecx, ebp
  00158	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015d	8b e5		 mov	 esp, ebp
  0015f	5d		 pop	 ebp
  00160	c3		 ret	 0
$MDIR_ERROR$51:

; 323  : MDIR_ERROR:
; 324  : 	gs_cLogger.DebugLog(LEVEL_ERROR, "com_mkdir has Failed! [%s]", tmpBuf);

  00161	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _tmpBuf$[ebp]
  00167	50		 push	 eax
  00168	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@NPNPEALE@com_mkdir?5has?5Failed?$CB?5?$FL?$CFs?$FN?$AA@
  0016d	68 44 01 00 00	 push	 324			; 00000144H
  00172	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@KGBJCJNH@CFileUtil?3?3MakeDirectory?$AA@
  00177	6a 05		 push	 5
  00179	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  0017e	e8 00 00 00 00	 call	 ?__debugLog@CLogger@@QAAXHPBDH0ZZ ; CLogger::__debugLog

; 325  : 	return false;
; 326  : }

  00183	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00186	83 c4 18	 add	 esp, 24			; 00000018H
  00189	33 cd		 xor	 ecx, ebp
  0018b	32 c0		 xor	 al, al
  0018d	5f		 pop	 edi
  0018e	5e		 pop	 esi
  0018f	5b		 pop	 ebx
  00190	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00195	8b e5		 mov	 esp, ebp
  00197	5d		 pop	 ebp
  00198	c3		 ret	 0
$LN49@MakeDirect:

; 312  : 		tmpBuf[len] = 0;

  00199	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN50@MakeDirect:
$LN48@MakeDirect:
  0019e	cc		 int	 3
?MakeDirectory@CFileUtil@@SA_NPBD@Z ENDP		; CFileUtil::MakeDirectory
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File e:\infinia-library-3.0\com\include\comfiletypes.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File e:\infinia-library-3.0\com\include\comfiletypes.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File e:\infinia-library-3.0\com\include\comfiletypes.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File e:\infinia-library-3.0\com\include\comfiletypes.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
;	COMDAT ?delDirectory@CFileUtil@@SAHPAUSTDelInfo@@PAUSTFilterData@@@Z
_TEXT	SEGMENT
_dir$1$ = -880						; size = 4
tv332 = -876						; size = 4
$T2 = -872						; size = 4
_stSubDir$ = -868					; size = 12
_file$ = -856						; size = 320
_cFTime$ = -536						; size = 8
_filePath$ = -528					; size = 256
_szSubDir$ = -272					; size = 128
_szDir$ = -144						; size = 128
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pData$ = 8						; size = 4
_filter$ = 12						; size = 4
?delDirectory@CFileUtil@@SAHPAUSTDelInfo@@PAUSTFilterData@@@Z PROC ; CFileUtil::delDirectory, COMDAT

; 149  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?delDirectory@CFileUtil@@SAHPAUSTDelInfo@@PAUSTFilterData@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 64 03 00
	00		 sub	 esp, 868		; 00000364H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b 75 08	 mov	 esi, DWORD PTR _pData$[ebp]

; 150  : 	JPDIR dir;
; 151  : 	JFILEDATA  file;
; 152  : 	TCHAR	*fname = NULL, filePath[256], szDir[128], szSubDir[128];
; 153  : 	int nCount = 0, nResult;
; 154  : 	bool bDirectory = false;
; 155  : 	CFileTime cFTime;

  00031	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR _cFTime$[ebp]
  00037	8b 5d 0c	 mov	 ebx, DWORD PTR _filter$[ebp]
  0003a	32 c0		 xor	 al, al
  0003c	c7 85 98 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  00046	89 85 94 fc ff
	ff		 mov	 DWORD PTR tv332[ebp], eax
  0004c	e8 00 00 00 00	 call	 ??0CFileTime@@QAE@XZ	; CFileTime::CFileTime

; 156  : 	STDelInfo stSubDir;
; 157  : 	void *pRes = NULL;
; 158  : 	CStringList *filterList = NULL;
; 159  : 
; 160  : #ifndef WIN32
; 161  : 	struct  stat st;
; 162  : #endif
; 163  : 
; 164  : 	if (!pData->root) {

  00051	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00053	33 ff		 xor	 edi, edi
  00055	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0005c	85 c9		 test	 ecx, ecx
  0005e	0f 84 73 02 00
	00		 je	 $LN34@delDirecto

; 165  : 		// TODO LOG
; 166  : 		return 0;
; 167  : 	}
; 168  : 	_tcscpy(szDir, pData->root);

  00064	8d 95 70 ff ff
	ff		 lea	 edx, DWORD PTR _szDir$[ebp]
  0006a	2b d1		 sub	 edx, ecx
  0006c	0f 1f 40 00	 npad	 4
$LL29@delDirecto:
  00070	8a 01		 mov	 al, BYTE PTR [ecx]
  00072	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00075	88 44 0a ff	 mov	 BYTE PTR [edx+ecx-1], al
  00079	84 c0		 test	 al, al
  0007b	75 f3		 jne	 SHORT $LL29@delDirecto
; File e:\infinia-library-3.0\com\include\comfiletypes.h

; 80   : inline bool com_isDirectory(TCHAR *dir) { int res = GetFileAttributes(dir); if (res == FILE_ATTRIBUTE_DIRECTORY)return true; return false; }

  0007d	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _szDir$[ebp]
  00083	50		 push	 eax
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileAttributesA@4
  0008a	83 f8 10	 cmp	 eax, 16			; 00000010H
  0008d	0f 85 44 02 00
	00		 jne	 $LN34@delDirecto
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 89   : 		_stprintf(dirName, _T("%s*.*"), dirName);

  00093	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _szDir$[ebp]
  00099	50		 push	 eax
  0009a	68 00 00 00 00	 push	 OFFSET ??_C@_05DFBJLIFO@?$CFs?$CK?4?$CK?$AA@
  0009f	50		 push	 eax
  000a0	e8 00 00 00 00	 call	 _sprintf
  000a5	83 c4 0c	 add	 esp, 12			; 0000000cH
; File e:\infinia-library-3.0\com\include\comfiletypes.h

; 81   : inline JPDIR com_findFirstFile(const TCHAR *pDirName, LPJFILEDATA pFileData) { return FindFirstFile(pDirName, pFileData); }

  000a8	8d 85 a8 fc ff
	ff		 lea	 eax, DWORD PTR _file$[ebp]
  000ae	50		 push	 eax
  000af	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _szDir$[ebp]
  000b5	50		 push	 eax
  000b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindFirstFileA@8
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 173  : 	dir = com_findFirstFile(szDir, &file);

  000bc	89 85 90 fc ff
	ff		 mov	 DWORD PTR _dir$1$[ebp], eax

; 174  : 	if (0 >= dir) return 0;

  000c2	85 c0		 test	 eax, eax
  000c4	0f 84 0d 02 00
	00		 je	 $LN34@delDirecto
; File e:\infinia-library-3.0\com\include\comfiletypes.h

; 82   : inline bool com_nextFile(JPDIR dir, LPJFILEDATA pFileData) { return (FindNextFile(dir, pFileData))?true:false; }

  000ca	8d 8d a8 fc ff
	ff		 lea	 ecx, DWORD PTR _file$[ebp]
  000d0	51		 push	 ecx
  000d1	50		 push	 eax
  000d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindNextFileA@8
  000d8	85 c0		 test	 eax, eax
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 175  : 	while (com_nextFile(dir, &file))

  000da	0f 84 97 01 00
	00		 je	 $LN3@delDirecto
$LL2@delDirecto:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h

; 1669 : _Check_return_ __inline int _tcscmp(_In_ _CPC _s1,_In_ _CPC _s2) {return _mbscmp((_CPUC)_s1,(_CPUC)_s2);}

  000e0	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR _file$[ebp+44]
  000e6	68 00 00 00 00	 push	 OFFSET ??_C@_01LFCBOECM@?4?$AA@
  000eb	50		 push	 eax
  000ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mbscmp
  000f2	83 c4 08	 add	 esp, 8
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 179  : 			|| _tcscmp(fname, _T("..")) == 0)

  000f5	85 c0		 test	 eax, eax
  000f7	0f 84 5f 01 00
	00		 je	 $LN21@delDirecto
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h

; 1669 : _Check_return_ __inline int _tcscmp(_In_ _CPC _s1,_In_ _CPC _s2) {return _mbscmp((_CPUC)_s1,(_CPUC)_s2);}

  000fd	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR _file$[ebp+44]
  00103	68 00 00 00 00	 push	 OFFSET ??_C@_02DJGKEECL@?4?4?$AA@
  00108	50		 push	 eax
  00109	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mbscmp
  0010f	83 c4 08	 add	 esp, 8
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 179  : 			|| _tcscmp(fname, _T("..")) == 0)

  00112	85 c0		 test	 eax, eax
  00114	0f 84 42 01 00
	00		 je	 $LN21@delDirecto

; 180  : 			continue;
; 181  : 
; 182  : 		_stprintf(filePath, _T("%s%s"), pData->root, fname);

  0011a	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR _file$[ebp+44]
  00120	50		 push	 eax
  00121	ff 36		 push	 DWORD PTR [esi]
  00123	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR _filePath$[ebp]
  00129	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  0012e	50		 push	 eax
  0012f	e8 00 00 00 00	 call	 _sprintf
  00134	83 c4 10	 add	 esp, 16			; 00000010H

; 183  : #ifndef WIN32 // -- only unix
; 184  : 		stat(filePath, &st);
; 185  : 		if (com_ISDIR(&st)) bDirectory = true;
; 186  : 		if (filter) {
; 187  : 			if (filter->pFunc == filter_dateTimeCompare) { cFTime.setFileTime(st.st_mtime); pRes = &cFTime; }
; 188  : 			else if (filter->pFunc == filter_stringCompare) { pRes = filterList; }
; 189  : 		}
; 190  : #else
; 191  : 		cFTime.setFileTime(&file.ftLastWriteTime);

  00137	8d 85 bc fc ff
	ff		 lea	 eax, DWORD PTR _file$[ebp+20]
  0013d	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR _cFTime$[ebp]
  00143	50		 push	 eax
  00144	e8 00 00 00 00	 call	 ?setFileTime@CFileTime@@QAEHPAU_FILETIME@@@Z ; CFileTime::setFileTime

; 192  : 		// windows
; 193  : 		if (com_ISDIR(&file)) bDirectory = true;

  00149	8b 85 a8 fc ff
	ff		 mov	 eax, DWORD PTR _file$[ebp]
  0014f	8b 8d 94 fc ff
	ff		 mov	 ecx, DWORD PTR tv332[ebp]
  00155	c1 e8 04	 shr	 eax, 4
  00158	a8 01		 test	 al, 1
  0015a	0f b6 c9	 movzx	 ecx, cl
  0015d	b8 01 00 00 00	 mov	 eax, 1
  00162	0f 45 c8	 cmovne	 ecx, eax
  00165	89 8d 94 fc ff
	ff		 mov	 DWORD PTR tv332[ebp], ecx

; 194  : 		if (filter) {

  0016b	85 db		 test	 ebx, ebx
  0016d	74 1b		 je	 SHORT $LN13@delDirecto

; 195  : 			if (filter->pFunc == filter_dateTimeCompare) { 

  0016f	8b 03		 mov	 eax, DWORD PTR [ebx]
  00171	3d 00 00 00 00	 cmp	 eax, OFFSET ?filter_dateTimeCompare@@YA_NPADPAX1@Z ; filter_dateTimeCompare
  00176	75 08		 jne	 SHORT $LN11@delDirecto

; 196  : 				//cFTime.setFileTime(filePath); 
; 197  : 				pRes = &cFTime; 

  00178	8d bd e8 fd ff
	ff		 lea	 edi, DWORD PTR _cFTime$[ebp]
  0017e	eb 0a		 jmp	 SHORT $LN13@delDirecto
$LN11@delDirecto:

; 198  : 			}
; 199  : 			else if (filter->pFunc == filter_stringCompare) { pRes = filterList; }

  00180	33 d2		 xor	 edx, edx
  00182	3d 00 00 00 00	 cmp	 eax, OFFSET ?filter_stringCompare@@YA_NPADPAX1@Z ; filter_stringCompare
  00187	0f 44 fa	 cmove	 edi, edx
$LN13@delDirecto:

; 200  : 		}
; 201  : #endif
; 202  : 
; 203  : 		if (bDirectory) {

  0018a	84 c9		 test	 cl, cl
  0018c	74 61		 je	 SHORT $LN14@delDirecto

; 204  : 			if (pData->nFlag & DIR_RECURSIVE) {

  0018e	f6 46 04 01	 test	 BYTE PTR [esi+4], 1
  00192	0f 84 c4 00 00
	00		 je	 $LN21@delDirecto

; 205  : 				_stprintf(szSubDir, _T("%s%s%c"), pData->root, fname, g_s);

  00198	6a 5c		 push	 92			; 0000005cH
  0019a	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR _file$[ebp+44]
  001a0	50		 push	 eax
  001a1	ff 36		 push	 DWORD PTR [esi]
  001a3	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _szSubDir$[ebp]
  001a9	68 00 00 00 00	 push	 OFFSET ??_C@_06HCFNFKLM@?$CFs?$CFs?$CFc?$AA@
  001ae	50		 push	 eax
  001af	e8 00 00 00 00	 call	 _sprintf

; 206  : 				memcpy(&stSubDir, pData, sizeof(STDelInfo));

  001b4	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  001b7	f3 0f 7e 06	 movq	 xmm0, QWORD PTR [esi]
  001bb	89 85 a4 fc ff
	ff		 mov	 DWORD PTR _stSubDir$[ebp+8], eax

; 207  : 				stSubDir.root = szSubDir;

  001c1	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _szSubDir$[ebp]
  001c7	66 0f d6 85 9c
	fc ff ff	 movq	 QWORD PTR _stSubDir$[ebp], xmm0
  001cf	89 85 9c fc ff
	ff		 mov	 DWORD PTR _stSubDir$[ebp], eax

; 208  : 				delDirectory(&stSubDir, filter);

  001d5	8d 85 9c fc ff
	ff		 lea	 eax, DWORD PTR _stSubDir$[ebp]
  001db	53		 push	 ebx
  001dc	50		 push	 eax
  001dd	e8 00 00 00 00	 call	 ?delDirectory@CFileUtil@@SAHPAUSTDelInfo@@PAUSTFilterData@@@Z ; CFileUtil::delDirectory
  001e2	83 c4 1c	 add	 esp, 28			; 0000001cH

; 209  : 				bDirectory = false;

  001e5	32 c0		 xor	 al, al
  001e7	89 85 94 fc ff
	ff		 mov	 DWORD PTR tv332[ebp], eax

; 210  : 			}
; 211  : 		}
; 212  : 		else {

  001ed	eb 6d		 jmp	 SHORT $LN21@delDirecto
$LN14@delDirecto:

; 213  : 			if (filter) {

  001ef	85 db		 test	 ebx, ebx
  001f1	74 16		 je	 SHORT $LN17@delDirecto

; 214  : 				if (filter->pFunc(fname, filter->pData, pRes)) nResult = 1;

  001f3	57		 push	 edi
  001f4	ff 73 04	 push	 DWORD PTR [ebx+4]
  001f7	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR _file$[ebp+44]
  001fd	50		 push	 eax
  001fe	8b 03		 mov	 eax, DWORD PTR [ebx]
  00200	ff d0		 call	 eax
  00202	83 c4 0c	 add	 esp, 12			; 0000000cH
  00205	84 c0		 test	 al, al
  00207	74 53		 je	 SHORT $LN21@delDirecto
$LN17@delDirecto:

; 215  : 				else nResult = 0;
; 216  : 			}
; 217  : 			else nResult = 1;
; 218  : 
; 219  : 
; 220  : 			if (nResult) {
; 221  : 				nResult = _tremove(filePath);

  00209	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR _filePath$[ebp]
  0020f	50		 push	 eax
  00210	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__remove
  00216	83 c4 04	 add	 esp, 4

; 222  : 				if (nResult < 0) {

  00219	85 c0		 test	 eax, eax

; 223  : 					// TODO ERROR LOG
; 224  : 					gs_cLogger.DebugLog(LEVEL_WARN, _T("FAILED _tremove[%s] nResult[%d]"), filePath, nResult);

  0021b	50		 push	 eax
  0021c	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR _filePath$[ebp]
  00222	50		 push	 eax
  00223	79 13		 jns	 SHORT $LN22@delDirecto
  00225	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@CEPONNIG@FAILED?5_tremove?$FL?$CFs?$FN?5nResult?$FL?$CFd?$FN?$AA@
  0022a	68 e0 00 00 00	 push	 224			; 000000e0H
  0022f	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@LGHDAFAC@CFileUtil?3?3delDirectory?$AA@
  00234	6a 04		 push	 4

; 225  : 				}
; 226  : 				else {

  00236	eb 11		 jmp	 SHORT $LN68@delDirecto
$LN22@delDirecto:

; 227  : 					gs_cLogger.DebugLog(LEVEL_INFO, _T("SUCCESS _tremove[%s] nResult[%d]"), filePath, nResult);

  00238	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@MCDNEDGF@SUCCESS?5_tremove?$FL?$CFs?$FN?5nResult?$FL?$CFd?$FN@
  0023d	68 e3 00 00 00	 push	 227			; 000000e3H
  00242	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@LGHDAFAC@CFileUtil?3?3delDirectory?$AA@
  00247	6a 03		 push	 3
$LN68@delDirecto:
  00249	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  0024e	e8 00 00 00 00	 call	 ?__debugLog@CLogger@@QAAXHPBDH0ZZ ; CLogger::__debugLog
  00253	83 c4 1c	 add	 esp, 28			; 0000001cH

; 228  : 				}
; 229  : 				// TODO TRACE LOG
; 230  : 				nCount++;

  00256	ff 85 98 fc ff
	ff		 inc	 DWORD PTR $T2[ebp]
$LN21@delDirecto:
; File e:\infinia-library-3.0\com\include\comfiletypes.h

; 82   : inline bool com_nextFile(JPDIR dir, LPJFILEDATA pFileData) { return (FindNextFile(dir, pFileData))?true:false; }

  0025c	8d 85 a8 fc ff
	ff		 lea	 eax, DWORD PTR _file$[ebp]
  00262	50		 push	 eax
  00263	ff b5 90 fc ff
	ff		 push	 DWORD PTR _dir$1$[ebp]
  00269	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindNextFileA@8
  0026f	85 c0		 test	 eax, eax
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 175  : 	while (com_nextFile(dir, &file))

  00271	0f 85 69 fe ff
	ff		 jne	 $LL2@delDirecto
$LN3@delDirecto:

; 231  : 			}
; 232  : 		}
; 233  : 	}
; 234  : 	com_dirclose(dir);

  00277	ff b5 90 fc ff
	ff		 push	 DWORD PTR _dir$1$[ebp]
  0027d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindClose@4

; 235  : 	if (filterList) delete filterList;
; 236  : 	if (pData->nFlag & DEL_DIRECTORY) {

  00283	f6 46 04 02	 test	 BYTE PTR [esi+4], 2
  00287	74 54		 je	 SHORT $LN35@delDirecto

; 237  : 		if (com_rmdir(pData->root)) {

  00289	ff 36		 push	 DWORD PTR [esi]
  0028b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RemoveDirectoryA@4

; 238  : 			gs_cLogger.DebugLog(LEVEL_INFO, _T("SUCCESS rmdir[%s]"), pData->root);

  00291	ff 36		 push	 DWORD PTR [esi]
  00293	85 c0		 test	 eax, eax
  00295	74 20		 je	 SHORT $LN26@delDirecto
  00297	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OKJOCLIE@SUCCESS?5rmdir?$FL?$CFs?$FN?$AA@
  0029c	68 ee 00 00 00	 push	 238			; 000000eeH
  002a1	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@LGHDAFAC@CFileUtil?3?3delDirectory?$AA@
  002a6	6a 03		 push	 3
  002a8	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  002ad	e8 00 00 00 00	 call	 ?__debugLog@CLogger@@QAAXHPBDH0ZZ ; CLogger::__debugLog
  002b2	83 c4 18	 add	 esp, 24			; 00000018H

; 239  : 		}
; 240  : 		else {

  002b5	eb 26		 jmp	 SHORT $LN35@delDirecto
$LN26@delDirecto:

; 241  : 			gs_cLogger.DebugLog(LEVEL_WARN, _T("FAILED rmdir[%s]"), pData->root);

  002b7	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FMJCPMNG@FAILED?5rmdir?$FL?$CFs?$FN?$AA@
  002bc	68 f1 00 00 00	 push	 241			; 000000f1H
  002c1	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@LGHDAFAC@CFileUtil?3?3delDirectory?$AA@
  002c6	6a 04		 push	 4
  002c8	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  002cd	e8 00 00 00 00	 call	 ?__debugLog@CLogger@@QAAXHPBDH0ZZ ; CLogger::__debugLog
  002d2	83 c4 18	 add	 esp, 24			; 00000018H

; 242  : 		}
; 243  : 	}
; 244  : 	return nCount;

  002d5	eb 06		 jmp	 SHORT $LN35@delDirecto
$LN34@delDirecto:
  002d7	89 bd 98 fc ff
	ff		 mov	 DWORD PTR $T2[ebp], edi
$LN35@delDirecto:
  002dd	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR _cFTime$[ebp]
  002e3	e8 00 00 00 00	 call	 ??1CFileTime@@QAE@XZ	; CFileTime::~CFileTime
  002e8	8b 85 98 fc ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]

; 245  : }

  002ee	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  002f1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002f8	59		 pop	 ecx
  002f9	5f		 pop	 edi
  002fa	5e		 pop	 esi
  002fb	5b		 pop	 ebx
  002fc	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002ff	33 cd		 xor	 ecx, ebp
  00301	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00306	8b e5		 mov	 esp, ebp
  00308	5d		 pop	 ebp
  00309	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?delDirectory@CFileUtil@@SAHPAUSTDelInfo@@PAUSTFilterData@@@Z$0:
  00000	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR _cFTime$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CFileTime@@QAE@XZ	; CFileTime::~CFileTime
__ehhandler$?delDirectory@CFileUtil@@SAHPAUSTDelInfo@@PAUSTFilterData@@@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a 8c fc ff
	ff		 mov	 ecx, DWORD PTR [edx-884]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?delDirectory@CFileUtil@@SAHPAUSTDelInfo@@PAUSTFilterData@@@Z
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?delDirectory@CFileUtil@@SAHPAUSTDelInfo@@PAUSTFilterData@@@Z ENDP ; CFileUtil::delDirectory
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File e:\infinia-library-3.0\com\include\comfiletypes.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File e:\infinia-library-3.0\com\include\comfiletypes.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File e:\infinia-library-3.0\com\include\comfiletypes.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
;	COMDAT ?GetFileList@CFileUtil@@SA_NPAUSTFileList@@PAUSTFilterData@@@Z
_TEXT	SEGMENT
_pResult$GSCopy$1$ = -456				; size = 4
_file$ = -452						; size = 320
_dirName$ = -132					; size = 128
__$ArrayPad$ = -4					; size = 4
_pResult$ = 8						; size = 4
_pFilter$ = 12						; size = 4
?GetFileList@CFileUtil@@SA_NPAUSTFileList@@PAUSTFilterData@@@Z PROC ; CFileUtil::GetFileList, COMDAT

; 96   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 01 00
	00		 sub	 esp, 456		; 000001c8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _pResult$[ebp]
  00016	89 85 38 fe ff
	ff		 mov	 DWORD PTR _pResult$GSCopy$1$[ebp], eax
  0001c	56		 push	 esi
  0001d	8b 75 0c	 mov	 esi, DWORD PTR _pFilter$[ebp]

; 97   : 	JPDIR dir;
; 98   : 	JFILEDATA  file;
; 99   : 
; 100  : 	CStringList *filterList = NULL;
; 101  : 	TCHAR	*fname= NULL;
; 102  : 	CTList<fileInfo> *fList = NULL;
; 103  : 	int nCount = 0;
; 104  : 	TCHAR dirName[128];
; 105  : 
; 106  : 	if (!pResult) return false;

  00020	85 c0		 test	 eax, eax
  00022	75 11		 jne	 SHORT $LN5@GetFileLis
$LN53@GetFileLis:
  00024	32 c0		 xor	 al, al
  00026	5e		 pop	 esi

; 143  : 	delete filterList;
; 144  : 	return true;
; 145  : }

  00027	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0002a	33 cd		 xor	 ecx, ebp
  0002c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
$LN5@GetFileLis:

; 107  : 	_tcscpy(dirName, pResult->root);

  00035	8b 08		 mov	 ecx, DWORD PTR [eax]
  00037	8d 95 7c ff ff
	ff		 lea	 edx, DWORD PTR _dirName$[ebp]
  0003d	2b d1		 sub	 edx, ecx
  0003f	90		 npad	 1
$LL16@GetFileLis:
  00040	8a 01		 mov	 al, BYTE PTR [ecx]
  00042	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00045	88 44 0a ff	 mov	 BYTE PTR [edx+ecx-1], al
  00049	84 c0		 test	 al, al
  0004b	75 f3		 jne	 SHORT $LL16@GetFileLis
; File e:\infinia-library-3.0\com\include\comfiletypes.h

; 80   : inline bool com_isDirectory(TCHAR *dir) { int res = GetFileAttributes(dir); if (res == FILE_ATTRIBUTE_DIRECTORY)return true; return false; }

  0004d	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _dirName$[ebp]
  00053	50		 push	 eax
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileAttributesA@4
  0005a	83 f8 10	 cmp	 eax, 16			; 00000010H
  0005d	75 c5		 jne	 SHORT $LN53@GetFileLis
  0005f	53		 push	 ebx
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 89   : 		_stprintf(dirName, _T("%s*.*"), dirName);

  00060	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _dirName$[ebp]
  00066	50		 push	 eax
  00067	68 00 00 00 00	 push	 OFFSET ??_C@_05DFBJLIFO@?$CFs?$CK?4?$CK?$AA@
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 _sprintf
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH
; File e:\infinia-library-3.0\com\include\comfiletypes.h

; 81   : inline JPDIR com_findFirstFile(const TCHAR *pDirName, LPJFILEDATA pFileData) { return FindFirstFile(pDirName, pFileData); }

  00075	8d 85 3c fe ff
	ff		 lea	 eax, DWORD PTR _file$[ebp]
  0007b	50		 push	 eax
  0007c	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _dirName$[ebp]
  00082	50		 push	 eax
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindFirstFileA@8
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 115  : 	dir = com_findFirstFile(dirName, &file);

  00089	8b d8		 mov	 ebx, eax

; 116  : 	if (0 >= dir) return false;

  0008b	85 db		 test	 ebx, ebx
  0008d	75 12		 jne	 SHORT $LN57@GetFileLis
  0008f	5b		 pop	 ebx
  00090	32 c0		 xor	 al, al
  00092	5e		 pop	 esi

; 143  : 	delete filterList;
; 144  : 	return true;
; 145  : }

  00093	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00096	33 cd		 xor	 ecx, ebp
  00098	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c3		 ret	 0
$LN57@GetFileLis:
  000a1	57		 push	 edi

; 116  : 	if (0 >= dir) return false;

  000a2	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp___mbscmp
  000a8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL4@GetFileLis:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h

; 1669 : _Check_return_ __inline int _tcscmp(_In_ _CPC _s1,_In_ _CPC _s2) {return _mbscmp((_CPUC)_s1,(_CPUC)_s2);}

  000b0	8d 85 68 fe ff
	ff		 lea	 eax, DWORD PTR _file$[ebp+44]
  000b6	68 00 00 00 00	 push	 OFFSET ??_C@_01LFCBOECM@?4?$AA@
  000bb	50		 push	 eax
  000bc	ff d7		 call	 edi
  000be	83 c4 08	 add	 esp, 8
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 122  : 			|| _tcscmp(fname, _T("..")) == 0)

  000c1	85 c0		 test	 eax, eax
  000c3	74 5a		 je	 SHORT $LN2@GetFileLis
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h

; 1669 : _Check_return_ __inline int _tcscmp(_In_ _CPC _s1,_In_ _CPC _s2) {return _mbscmp((_CPUC)_s1,(_CPUC)_s2);}

  000c5	8d 85 68 fe ff
	ff		 lea	 eax, DWORD PTR _file$[ebp+44]
  000cb	68 00 00 00 00	 push	 OFFSET ??_C@_02DJGKEECL@?4?4?$AA@
  000d0	50		 push	 eax
  000d1	ff d7		 call	 edi
  000d3	83 c4 08	 add	 esp, 8
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 122  : 			|| _tcscmp(fname, _T("..")) == 0)

  000d6	85 c0		 test	 eax, eax
  000d8	74 45		 je	 SHORT $LN2@GetFileLis

; 123  : 			continue;
; 124  : 
; 125  : #ifndef WIN32 // -- only unix
; 126  : 		_stprintf(filePath, _T("%s%s"), szDir, fname);
; 127  : 		stat(filePath, &st);
; 128  : 		if(com_ISDIR(&st)) { appendFileList(fList, fname, 'D');}
; 129  : 		else if(com_ISREG(&st)) {
; 130  : #else		
; 131  : 		if(com_ISDIR(&file)) { appendFileList(fList, fname, 'D'); }

  000da	8b 85 3c fe ff
	ff		 mov	 eax, DWORD PTR _file$[ebp]
  000e0	c1 e8 04	 shr	 eax, 4
  000e3	a8 01		 test	 al, 1
  000e5	74 04		 je	 SHORT $LN10@GetFileLis
  000e7	6a 44		 push	 68			; 00000044H

; 132  : 		else if(com_ISREG(&file)) {

  000e9	eb 23		 jmp	 SHORT $LN59@GetFileLis
$LN10@GetFileLis:
  000eb	f6 d0		 not	 al
  000ed	a8 01		 test	 al, 1
  000ef	74 2e		 je	 SHORT $LN2@GetFileLis

; 133  : #endif
; 134  : 			if (pFilter) {

  000f1	85 f6		 test	 esi, esi
  000f3	74 17		 je	 SHORT $LN14@GetFileLis

; 135  : 				if (!pFilter->pFunc(fname, pFilter->pData, filterList)) continue;

  000f5	6a 00		 push	 0
  000f7	ff 76 04	 push	 DWORD PTR [esi+4]
  000fa	8d 85 68 fe ff
	ff		 lea	 eax, DWORD PTR _file$[ebp+44]
  00100	50		 push	 eax
  00101	8b 06		 mov	 eax, DWORD PTR [esi]
  00103	ff d0		 call	 eax
  00105	83 c4 0c	 add	 esp, 12			; 0000000cH
  00108	84 c0		 test	 al, al
  0010a	74 13		 je	 SHORT $LN2@GetFileLis
$LN14@GetFileLis:

; 136  : 			}
; 137  : 			appendFileList(fList, fname, 'F');

  0010c	6a 46		 push	 70			; 00000046H
$LN59@GetFileLis:
  0010e	8d 85 68 fe ff
	ff		 lea	 eax, DWORD PTR _file$[ebp+44]
  00114	50		 push	 eax
  00115	6a 00		 push	 0
  00117	e8 00 00 00 00	 call	 ?appendFileList@CFileUtil@@CA_NPAV?$CTList@UfileInfo@@@@PBDD@Z ; CFileUtil::appendFileList
  0011c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@GetFileLis:
; File e:\infinia-library-3.0\com\include\comfiletypes.h

; 82   : inline bool com_nextFile(JPDIR dir, LPJFILEDATA pFileData) { return (FindNextFile(dir, pFileData))?true:false; }

  0011f	8d 85 3c fe ff
	ff		 lea	 eax, DWORD PTR _file$[ebp]
  00125	50		 push	 eax
  00126	53		 push	 ebx
  00127	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindNextFileA@8
  0012d	85 c0		 test	 eax, eax
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 139  : 	} while (com_nextFile(dir, &file));

  0012f	0f 85 7b ff ff
	ff		 jne	 $LL4@GetFileLis

; 140  : 
; 141  : 	com_dirclose(dir);

  00135	53		 push	 ebx
  00136	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindClose@4

; 142  : 	pResult->pList = fList;

  0013c	8b 85 38 fe ff
	ff		 mov	 eax, DWORD PTR _pResult$GSCopy$1$[ebp]

; 143  : 	delete filterList;
; 144  : 	return true;
; 145  : }

  00142	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00145	5f		 pop	 edi
  00146	5b		 pop	 ebx
  00147	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0014e	33 cd		 xor	 ecx, ebp
  00150	b0 01		 mov	 al, 1
  00152	5e		 pop	 esi
  00153	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00158	8b e5		 mov	 esp, ebp
  0015a	5d		 pop	 ebp
  0015b	c3		 ret	 0
?GetFileList@CFileUtil@@SA_NPAUSTFileList@@PAUSTFilterData@@@Z ENDP ; CFileUtil::GetFileList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File e:\infinia-library-3.0\com\include\comfiletypes.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File e:\infinia-library-3.0\com\include\comfiletypes.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
;	COMDAT ?IsExistDirectory@CFileUtil@@SA_NPAD@Z
_TEXT	SEGMENT
_dirName$ = 8						; size = 4
?IsExistDirectory@CFileUtil@@SA_NPAD@Z PROC		; CFileUtil::IsExistDirectory, COMDAT

; 79   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
; File e:\infinia-library-3.0\com\include\comfiletypes.h

; 80   : inline bool com_isDirectory(TCHAR *dir) { int res = GetFileAttributes(dir); if (res == FILE_ATTRIBUTE_DIRECTORY)return true; return false; }

  00005	8b 75 08	 mov	 esi, DWORD PTR _dirName$[ebp]
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 80   : 	bool bRes = false;

  00008	32 db		 xor	 bl, bl
; File e:\infinia-library-3.0\com\include\comfiletypes.h

; 80   : inline bool com_isDirectory(TCHAR *dir) { int res = GetFileAttributes(dir); if (res == FILE_ATTRIBUTE_DIRECTORY)return true; return false; }

  0000a	56		 push	 esi
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileAttributesA@4
  00011	83 f8 10	 cmp	 eax, 16			; 00000010H
  00014	75 11		 jne	 SHORT $LN8@IsExistDir
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 89   : 		_stprintf(dirName, _T("%s*.*"), dirName);

  00016	56		 push	 esi
  00017	68 00 00 00 00	 push	 OFFSET ??_C@_05DFBJLIFO@?$CFs?$CK?4?$CK?$AA@
  0001c	56		 push	 esi
  0001d	b3 01		 mov	 bl, 1
  0001f	e8 00 00 00 00	 call	 _sprintf
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@IsExistDir:

; 90   : 	}
; 91   : #endif
; 92   : 	return bRes;

  00027	5e		 pop	 esi
  00028	8a c3		 mov	 al, bl
  0002a	5b		 pop	 ebx

; 93   : }

  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
?IsExistDirectory@CFileUtil@@SA_NPAD@Z ENDP		; CFileUtil::IsExistDirectory
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
;	COMDAT ?filter_dateTimeCompare@@YA_NPADPAX1@Z
_TEXT	SEGMENT
_pFile$ = 8						; size = 4
_pData$ = 12						; size = 4
_pRes$ = 16						; size = 4
?filter_dateTimeCompare@@YA_NPADPAX1@Z PROC		; filter_dateTimeCompare, COMDAT

; 50   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 51   : 	CFileTime *pComperand = (CFileTime *)pData;
; 52   : 	CFileTime *pComFileTime = (CFileTime *)pRes;
; 53   : 	if (pComFileTime->isCompare(pComperand, eOperator_LE)) // LE : less or Equal

  00003	8b 4d 10	 mov	 ecx, DWORD PTR _pRes$[ebp]
  00006	6a 06		 push	 6
  00008	ff 75 0c	 push	 DWORD PTR _pData$[ebp]
  0000b	e8 00 00 00 00	 call	 ?isCompare@CFileTime@@QAE_NPAV1@W4E_OPERATOR@@@Z ; CFileTime::isCompare
  00010	84 c0		 test	 al, al
  00012	0f 95 c0	 setne	 al

; 54   : 	{
; 55   : 		return true;
; 56   : 	}
; 57   : 	return false;
; 58   : }

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?filter_dateTimeCompare@@YA_NPADPAX1@Z ENDP		; filter_dateTimeCompare
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File e:\infinia-library-3.0\com\include\commstring.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File e:\infinia-library-3.0\com\include\commstring.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File e:\infinia-library-3.0\com\include\commstring.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File e:\infinia-library-3.0\com\include\commstring.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File e:\infinia-library-3.0\com\include\commstring.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File e:\infinia-library-3.0\com\include\commstring.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
; File e:\infinia-library-3.0\com\include\commstring.h
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
;	COMDAT ?filter_stringCompare@@YA_NPADPAX1@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_pFile$ = 8						; size = 4
$T2 = 12						; size = 4
_pData$ = 12						; size = 4
_pRes$ = 16						; size = 4
?filter_stringCompare@@YA_NPADPAX1@Z PROC		; filter_stringCompare, COMDAT

; 27   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?filter_stringCompare@@YA_NPADPAX1@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 28   : 	if (!pData) return true;

  00024	8b 75 0c	 mov	 esi, DWORD PTR _pData$[ebp]
  00027	85 f6		 test	 esi, esi
  00029	75 13		 jne	 SHORT $LN4@filter_str
$LN38@filter_str:
  0002b	b0 01		 mov	 al, 1

; 47   : }

  0002d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00030	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00037	59		 pop	 ecx
  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
$LN4@filter_str:

; 29   : 	CStringList *filterList = NULL;
; 30   : 	if (!pRes) {

  0003e	8b 7d 10	 mov	 edi, DWORD PTR _pRes$[ebp]
  00041	85 ff		 test	 edi, edi
  00043	75 48		 jne	 SHORT $LN6@filter_str

; 32   : 		filterList = new CStringList();

  00045	6a 14		 push	 20			; 00000014H
  00047	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0004c	83 c4 04	 add	 esp, 4
  0004f	89 45 0c	 mov	 DWORD PTR $T2[ebp], eax
  00052	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi
  00055	85 c0		 test	 eax, eax
  00057	74 14		 je	 SHORT $LN9@filter_str
  00059	0f 57 c0	 xorps	 xmm0, xmm0
  0005c	8b c8		 mov	 ecx, eax
  0005e	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  00061	89 78 10	 mov	 DWORD PTR [eax+16], edi
  00064	e8 00 00 00 00	 call	 ??0CStringList@@QAE@XZ	; CStringList::CStringList
  00069	8b f8		 mov	 edi, eax
  0006b	eb 02		 jmp	 SHORT $LN10@filter_str
$LN9@filter_str:
  0006d	33 ff		 xor	 edi, edi
$LN10@filter_str:
; File e:\infinia-library-3.0\com\include\commstring.h

; 85   : 	int alloc(int nMaxCount) { m_nListCnt = __alloc(nMaxCount); return m_nListCnt; }

  0006f	6a 04		 push	 4
  00071	8b cf		 mov	 ecx, edi
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 32   : 		filterList = new CStringList();

  00073	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File e:\infinia-library-3.0\com\include\commstring.h

; 85   : 	int alloc(int nMaxCount) { m_nListCnt = __alloc(nMaxCount); return m_nListCnt; }

  0007a	e8 00 00 00 00	 call	 ?__alloc@CStringList@@AAEHH@Z ; CStringList::__alloc
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 34   : 		CFileUtil::getFieldList((char *)pFilter, CH_DELIMITER, filterList);

  0007f	57		 push	 edi
  00080	6a 3b		 push	 59			; 0000003bH
  00082	56		 push	 esi
; File e:\infinia-library-3.0\com\include\commstring.h

; 85   : 	int alloc(int nMaxCount) { m_nListCnt = __alloc(nMaxCount); return m_nListCnt; }

  00083	89 07		 mov	 DWORD PTR [edi], eax
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 34   : 		CFileUtil::getFieldList((char *)pFilter, CH_DELIMITER, filterList);

  00085	e8 00 00 00 00	 call	 ?getFieldList@CFileUtil@@SA_NPADDPAVCStringList@@@Z ; CFileUtil::getFieldList
  0008a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@filter_str:
; File e:\infinia-library-3.0\com\include\commstring.h

; 106  : 		for (*i; *i < m_nListCnt; (*i)++) {

  0008d	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 39   : 	int i = 0;

  0008f	33 f6		 xor	 esi, esi
; File e:\infinia-library-3.0\com\include\commstring.h

; 106  : 		for (*i; *i < m_nListCnt; (*i)++) {

  00091	85 c9		 test	 ecx, ecx
  00093	7e 18		 jle	 SHORT $LN21@filter_str

; 107  : 			if (m_pList[*i]) { return m_pList[*i]; }

  00095	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  00098	8b c2		 mov	 eax, edx
  0009a	66 0f 1f 44 00
	00		 npad	 6
$LL22@filter_str:
  000a0	83 38 00	 cmp	 DWORD PTR [eax], 0
  000a3	75 52		 jne	 SHORT $LN36@filter_str

; 106  : 		for (*i; *i < m_nListCnt; (*i)++) {

  000a5	46		 inc	 esi
  000a6	83 c0 04	 add	 eax, 4
  000a9	3b f1		 cmp	 esi, ecx
  000ab	7c f3		 jl	 SHORT $LL22@filter_str
$LN21@filter_str:

; 108  : 		}
; 109  : 		return NULL;

  000ad	33 c0		 xor	 eax, eax
$LN19@filter_str:
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 41   : 	while (filter)

  000af	85 c0		 test	 eax, eax
  000b1	74 31		 je	 SHORT $LN3@filter_str
$LL2@filter_str:

; 42   : 	{
; 43   : 		if (filter->compare(pFile)) return true;

  000b3	ff 75 08	 push	 DWORD PTR _pFile$[ebp]
  000b6	8b c8		 mov	 ecx, eax
  000b8	e8 00 00 00 00	 call	 ?compare@CmString@@QAEHPBD@Z ; CmString::compare
  000bd	85 c0		 test	 eax, eax
  000bf	0f 85 66 ff ff
	ff		 jne	 $LN38@filter_str
; File e:\infinia-library-3.0\com\include\commstring.h

; 106  : 		for (*i; *i < m_nListCnt; (*i)++) {

  000c5	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000c7	3b f1		 cmp	 esi, ecx
  000c9	7d 13		 jge	 SHORT $LN29@filter_str

; 107  : 			if (m_pList[*i]) { return m_pList[*i]; }

  000cb	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  000ce	8d 04 b2	 lea	 eax, DWORD PTR [edx+esi*4]
$LL30@filter_str:
  000d1	83 38 00	 cmp	 DWORD PTR [eax], 0
  000d4	75 26		 jne	 SHORT $LN37@filter_str

; 106  : 		for (*i; *i < m_nListCnt; (*i)++) {

  000d6	46		 inc	 esi
  000d7	83 c0 04	 add	 eax, 4
  000da	3b f1		 cmp	 esi, ecx
  000dc	7c f3		 jl	 SHORT $LL30@filter_str
$LN29@filter_str:

; 108  : 		}
; 109  : 		return NULL;

  000de	33 c0		 xor	 eax, eax
$LN27@filter_str:
; File e:\infinia-library-3.0\com\src\comfileutil.cpp

; 41   : 	while (filter)

  000e0	85 c0		 test	 eax, eax
  000e2	75 cf		 jne	 SHORT $LL2@filter_str
$LN3@filter_str:

; 44   : 		filter = filterList->getNext(&i);
; 45   : 	}
; 46   : 	return false;

  000e4	32 c0		 xor	 al, al

; 47   : }

  000e6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000e9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000f0	59		 pop	 ecx
  000f1	5f		 pop	 edi
  000f2	5e		 pop	 esi
  000f3	8b e5		 mov	 esp, ebp
  000f5	5d		 pop	 ebp
  000f6	c3		 ret	 0
$LN36@filter_str:
; File e:\infinia-library-3.0\com\include\commstring.h

; 107  : 			if (m_pList[*i]) { return m_pList[*i]; }

  000f7	8b 04 b2	 mov	 eax, DWORD PTR [edx+esi*4]
  000fa	eb b3		 jmp	 SHORT $LN19@filter_str
$LN37@filter_str:
  000fc	8b 04 b2	 mov	 eax, DWORD PTR [edx+esi*4]
  000ff	eb df		 jmp	 SHORT $LN27@filter_str
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?filter_stringCompare@@YA_NPADPAX1@Z$0:
  00000	6a 14		 push	 20			; 00000014H
  00002	8b 45 0c	 mov	 eax, DWORD PTR $T2[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
__ehhandler$?filter_stringCompare@@YA_NPADPAX1@Z:
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?filter_stringCompare@@YA_NPADPAX1@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?filter_stringCompare@@YA_NPADPAX1@Z ENDP		; filter_stringCompare
; Function compile flags: /Ogtp
;	COMDAT ??_GCStringList@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCStringList@@QAEPAXI@Z PROC				; CStringList::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CStringList@@QAE@XZ	; CStringList::~CStringList
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 14		 push	 20			; 00000014H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_GCStringList@@QAEPAXI@Z ENDP				; CStringList::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ?__autoclassinit2@CStringList@@QAEXI@Z
_TEXT	SEGMENT
_classSize$ = 8						; size = 4
?__autoclassinit2@CStringList@@QAEXI@Z PROC		; CStringList::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	ff 75 08	 push	 DWORD PTR _classSize$[ebp]
  00006	6a 00		 push	 0
  00008	51		 push	 ecx
  00009	e8 00 00 00 00	 call	 _memset
  0000e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?__autoclassinit2@CStringList@@QAEXI@Z ENDP		; CStringList::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\commstring.h
;	COMDAT ?__getNext@CStringList@@AAEPAVCmString@@PAH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?__getNext@CStringList@@AAEPAVCmString@@PAH@Z PROC	; CStringList::__getNext, COMDAT
; _this$ = ecx

; 105  : 	inline CmString *__getNext(int *i) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 106  : 		for (*i; *i < m_nListCnt; (*i)++) {

  00004	8b 75 08	 mov	 esi, DWORD PTR _i$[ebp]
  00007	8b d1		 mov	 edx, ecx
  00009	8b 06		 mov	 eax, DWORD PTR [esi]
  0000b	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000d	7d 15		 jge	 SHORT $LN3@getNext
  0000f	90		 npad	 1
$LL4@getNext:

; 107  : 			if (m_pList[*i]) { return m_pList[*i]; }

  00010	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00012	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00015	83 3c 88 00	 cmp	 DWORD PTR [eax+ecx*4], 0
  00019	75 10		 jne	 SHORT $LN8@getNext

; 106  : 		for (*i; *i < m_nListCnt; (*i)++) {

  0001b	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0001e	89 06		 mov	 DWORD PTR [esi], eax
  00020	3b 02		 cmp	 eax, DWORD PTR [edx]
  00022	7c ec		 jl	 SHORT $LL4@getNext
$LN3@getNext:

; 108  : 		}
; 109  : 		return NULL;

  00024	33 c0		 xor	 eax, eax
  00026	5e		 pop	 esi

; 110  : 	}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN8@getNext:

; 107  : 			if (m_pList[*i]) { return m_pList[*i]; }

  0002b	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  0002e	5e		 pop	 esi

; 110  : 	}

  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?__getNext@CStringList@@AAEPAVCmString@@PAH@Z ENDP	; CStringList::__getNext
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\commstring.h
;	COMDAT ?getNext@CStringList@@QAEPAVCmString@@PAH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?getNext@CStringList@@QAEPAVCmString@@PAH@Z PROC	; CStringList::getNext, COMDAT
; _this$ = ecx

; 90   : 	inline CmString *getNext(int *i) { return __getNext(i);	}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 106  : 		for (*i; *i < m_nListCnt; (*i)++) {

  00004	8b 75 08	 mov	 esi, DWORD PTR _i$[ebp]

; 90   : 	inline CmString *getNext(int *i) { return __getNext(i);	}

  00007	8b d1		 mov	 edx, ecx

; 106  : 		for (*i; *i < m_nListCnt; (*i)++) {

  00009	8b 06		 mov	 eax, DWORD PTR [esi]
  0000b	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000d	7d 15		 jge	 SHORT $LN5@getNext
  0000f	90		 npad	 1
$LL6@getNext:

; 107  : 			if (m_pList[*i]) { return m_pList[*i]; }

  00010	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00012	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00015	83 3c 88 00	 cmp	 DWORD PTR [eax+ecx*4], 0
  00019	75 10		 jne	 SHORT $LN10@getNext

; 91   : 	inline TCHAR *getNext_str(int *i) { CmString *p = __getNext(i); if (p) return p->str(); return NULL; }
; 92   : 	inline CmString *getString(int i) { return m_pList[i]; }
; 93   : 	inline TCHAR *get_str(int i) { CmString *p = m_pList[i]; if (p) return p->str(); return NULL;}
; 94   : 	inline int GETUSECNT() { return m_nUseCnt;	}
; 95   : 	inline int GETMAXCNT() { return m_nListCnt; }
; 96   : 	inline int GETLASTCNT() { return m_nLast; }
; 97   : private:
; 98   : 	int m_nListCnt;
; 99   : 	int m_nUseCnt;
; 100  : 	int	m_nLast;
; 101  : 	int	m_nDelIdx;
; 102  : 	CmString **m_pList;
; 103  : 	int __alloc(int nMaxCount);
; 104  : 	inline void _DEL(int i) { if (m_pList[i]) { delete m_pList[i];  m_pList[i] = 0; m_nDelIdx = i; m_nUseCnt--;	} }
; 105  : 	inline CmString *__getNext(int *i) {
; 106  : 		for (*i; *i < m_nListCnt; (*i)++) {

  0001b	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0001e	89 06		 mov	 DWORD PTR [esi], eax
  00020	3b 02		 cmp	 eax, DWORD PTR [edx]
  00022	7c ec		 jl	 SHORT $LL6@getNext
$LN5@getNext:

; 90   : 	inline CmString *getNext(int *i) { return __getNext(i);	}

  00024	33 c0		 xor	 eax, eax
  00026	5e		 pop	 esi
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN10@getNext:
  0002b	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?getNext@CStringList@@QAEPAVCmString@@PAH@Z ENDP	; CStringList::getNext
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\commstring.h
;	COMDAT ?push_back@CStringList@@QAEPAVCmString@@PAD@Z
_TEXT	SEGMENT
_pString$ = 8						; size = 4
?push_back@CStringList@@QAEPAVCmString@@PAD@Z PROC	; CStringList::push_back, COMDAT
; _this$ = ecx

; 87   : 	CmString * CStringList::push_back(TCHAR* pString) {if (!m_pList[m_nLast]) return __add(pString, m_nLast);return __add(pString, newIdx());}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00009	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000c	83 3c 88 00	 cmp	 DWORD PTR [eax+ecx*4], 0
  00010	75 10		 jne	 SHORT $LN2@push_back
  00012	51		 push	 ecx
  00013	ff 75 08	 push	 DWORD PTR _pString$[ebp]
  00016	8b ce		 mov	 ecx, esi
  00018	e8 00 00 00 00	 call	 ?__add@CStringList@@AAEPAVCmString@@PADH@Z ; CStringList::__add
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
$LN2@push_back:
  00022	8b ce		 mov	 ecx, esi
  00024	e8 00 00 00 00	 call	 ?newIdx@CStringList@@AAEHXZ ; CStringList::newIdx
  00029	50		 push	 eax
  0002a	ff 75 08	 push	 DWORD PTR _pString$[ebp]
  0002d	8b ce		 mov	 ecx, esi
  0002f	e8 00 00 00 00	 call	 ?__add@CStringList@@AAEPAVCmString@@PADH@Z ; CStringList::__add
  00034	5e		 pop	 esi
  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
?push_back@CStringList@@QAEPAVCmString@@PAD@Z ENDP	; CStringList::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\commstring.h
;	COMDAT ?alloc@CStringList@@QAEHH@Z
_TEXT	SEGMENT
_nMaxCount$ = 8						; size = 4
?alloc@CStringList@@QAEHH@Z PROC			; CStringList::alloc, COMDAT
; _this$ = ecx

; 85   : 	int alloc(int nMaxCount) { m_nListCnt = __alloc(nMaxCount); return m_nListCnt; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	ff 75 08	 push	 DWORD PTR _nMaxCount$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	e8 00 00 00 00	 call	 ?__alloc@CStringList@@AAEHH@Z ; CStringList::__alloc
  0000e	89 06		 mov	 DWORD PTR [esi], eax
  00010	5e		 pop	 esi
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?alloc@CStringList@@QAEHH@Z ENDP			; CStringList::alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\commemmanager.h
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\include\commemmanager.h
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\include\commemmanager.h
;	COMDAT ?delBuf@CMemManager@@QAEXPADH@Z
_TEXT	SEGMENT
_$S1$1 = -8						; size = 8
_pBuf$ = 8						; size = 4
_nSize$ = 12						; size = 4
?delBuf@CMemManager@@QAEXPADH@Z PROC			; CMemManager::delBuf, COMDAT
; _this$ = ecx

; 38   : 	inline void delBuf(char *pBuf, int nSize) { int nIdx = getIndex(nSize); delBufByIndex(pBuf, nIdx); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
; File e:\infinia-library-3.0\com\include\combufpool.h

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  00006	8b 55 0c	 mov	 edx, DWORD PTR _nSize$[ebp]
  00009	b8 01 00 00 00	 mov	 eax, 1
  0000e	56		 push	 esi
  0000f	57		 push	 edi
; File e:\infinia-library-3.0\com\include\commemmanager.h

; 38   : 	inline void delBuf(char *pBuf, int nSize) { int nIdx = getIndex(nSize); delBufByIndex(pBuf, nIdx); }

  00010	8b f9		 mov	 edi, ecx
  00012	66 0f 6e c2	 movd	 xmm0, edx
; File e:\infinia-library-3.0\com\include\combufpool.h

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  00016	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0001a	f2 0f 11 45 f8	 movsd	 QWORD PTR _$S1$1[ebp], xmm0
  0001f	8b 75 fc	 mov	 esi, DWORD PTR _$S1$1[ebp+4]
  00022	c1 fe 14	 sar	 esi, 20			; 00000014H
  00025	81 ee ff 03 00
	00		 sub	 esi, 1023		; 000003ffH
  0002b	8b ce		 mov	 ecx, esi
  0002d	d3 e0		 shl	 eax, cl
  0002f	8b ca		 mov	 ecx, edx
  00031	2b c8		 sub	 ecx, eax
  00033	23 ca		 and	 ecx, edx
  00035	f7 d9		 neg	 ecx
  00037	1b c9		 sbb	 ecx, ecx
  00039	f7 d9		 neg	 ecx
  0003b	03 ce		 add	 ecx, esi
; File e:\infinia-library-3.0\com\include\commemmanager.h

; 38   : 	inline void delBuf(char *pBuf, int nSize) { int nIdx = getIndex(nSize); delBufByIndex(pBuf, nIdx); }

  0003d	51		 push	 ecx
  0003e	ff 75 08	 push	 DWORD PTR _pBuf$[ebp]
  00041	8b cf		 mov	 ecx, edi
  00043	e8 00 00 00 00	 call	 ?delBufByIndex@CMemManager@@QAEXPADH@Z ; CMemManager::delBufByIndex
  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 08 00	 ret	 8
?delBuf@CMemManager@@QAEXPADH@Z ENDP			; CMemManager::delBuf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\commemmanager.h
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\include\commemmanager.h
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\include\commemmanager.h
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\include\commemmanager.h
;	COMDAT ?newBuf@CMemManager@@QAEPADHPAH@Z
_TEXT	SEGMENT
_$S1$1 = -8						; size = 8
_nSize$ = 8						; size = 4
_pIndex$ = 12						; size = 4
?newBuf@CMemManager@@QAEPADHPAH@Z PROC			; CMemManager::newBuf, COMDAT
; _this$ = ecx

; 35   : 	inline char *newBuf(int nSize, int *pIndex) { *pIndex = getIndex(nSize);  return __newBuf(*pIndex, nSize); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
; File e:\infinia-library-3.0\com\include\combufpool.h

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  00007	8b 75 08	 mov	 esi, DWORD PTR _nSize$[ebp]
  0000a	b8 01 00 00 00	 mov	 eax, 1
  0000f	57		 push	 edi
; File e:\infinia-library-3.0\com\include\commemmanager.h

; 35   : 	inline char *newBuf(int nSize, int *pIndex) { *pIndex = getIndex(nSize);  return __newBuf(*pIndex, nSize); }

  00010	8b f9		 mov	 edi, ecx
  00012	56		 push	 esi
  00013	66 0f 6e c6	 movd	 xmm0, esi
; File e:\infinia-library-3.0\com\include\combufpool.h

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  00017	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0001b	f2 0f 11 45 f8	 movsd	 QWORD PTR _$S1$1[ebp], xmm0
  00020	8b 55 fc	 mov	 edx, DWORD PTR _$S1$1[ebp+4]
  00023	c1 fa 14	 sar	 edx, 20			; 00000014H
  00026	81 ea ff 03 00
	00		 sub	 edx, 1023		; 000003ffH
  0002c	8b ca		 mov	 ecx, edx
  0002e	d3 e0		 shl	 eax, cl
  00030	8b ce		 mov	 ecx, esi
  00032	2b c8		 sub	 ecx, eax
; File e:\infinia-library-3.0\com\include\commemmanager.h

; 35   : 	inline char *newBuf(int nSize, int *pIndex) { *pIndex = getIndex(nSize);  return __newBuf(*pIndex, nSize); }

  00034	8b 45 0c	 mov	 eax, DWORD PTR _pIndex$[ebp]
; File e:\infinia-library-3.0\com\include\combufpool.h

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  00037	23 ce		 and	 ecx, esi
  00039	f7 d9		 neg	 ecx
  0003b	1b c9		 sbb	 ecx, ecx
  0003d	f7 d9		 neg	 ecx
  0003f	03 ca		 add	 ecx, edx
; File e:\infinia-library-3.0\com\include\commemmanager.h

; 35   : 	inline char *newBuf(int nSize, int *pIndex) { *pIndex = getIndex(nSize);  return __newBuf(*pIndex, nSize); }

  00041	89 08		 mov	 DWORD PTR [eax], ecx
  00043	51		 push	 ecx
  00044	8b cf		 mov	 ecx, edi
  00046	e8 00 00 00 00	 call	 ?__newBuf@CMemManager@@AAEPADHI@Z ; CMemManager::__newBuf
  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c2 08 00	 ret	 8
?newBuf@CMemManager@@QAEPADHPAH@Z ENDP			; CMemManager::newBuf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\commemmanager.h
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\include\commemmanager.h
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\include\commemmanager.h
; File e:\infinia-library-3.0\com\include\combufpool.h
; File e:\infinia-library-3.0\com\include\commemmanager.h
;	COMDAT ?newBuf@CMemManager@@QAEPADH@Z
_TEXT	SEGMENT
_$S1$1 = -8						; size = 8
_nSize$ = 8						; size = 4
?newBuf@CMemManager@@QAEPADH@Z PROC			; CMemManager::newBuf, COMDAT
; _this$ = ecx

; 34   : 	inline char *newBuf(int nSize) { int nIdx = getIndex(nSize);  return __newBuf(nIdx, nSize); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
; File e:\infinia-library-3.0\com\include\combufpool.h

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  00006	8b 55 08	 mov	 edx, DWORD PTR _nSize$[ebp]
  00009	b8 01 00 00 00	 mov	 eax, 1
  0000e	56		 push	 esi
  0000f	57		 push	 edi
; File e:\infinia-library-3.0\com\include\commemmanager.h

; 34   : 	inline char *newBuf(int nSize) { int nIdx = getIndex(nSize);  return __newBuf(nIdx, nSize); }

  00010	8b f9		 mov	 edi, ecx
  00012	66 0f 6e c2	 movd	 xmm0, edx
; File e:\infinia-library-3.0\com\include\combufpool.h

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  00016	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
; File e:\infinia-library-3.0\com\include\commemmanager.h

; 34   : 	inline char *newBuf(int nSize) { int nIdx = getIndex(nSize);  return __newBuf(nIdx, nSize); }

  0001a	52		 push	 edx
; File e:\infinia-library-3.0\com\include\combufpool.h

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  0001b	f2 0f 11 45 f8	 movsd	 QWORD PTR _$S1$1[ebp], xmm0
  00020	8b 75 fc	 mov	 esi, DWORD PTR _$S1$1[ebp+4]
  00023	c1 fe 14	 sar	 esi, 20			; 00000014H
  00026	81 ee ff 03 00
	00		 sub	 esi, 1023		; 000003ffH
  0002c	8b ce		 mov	 ecx, esi
  0002e	d3 e0		 shl	 eax, cl
  00030	8b ca		 mov	 ecx, edx
  00032	2b c8		 sub	 ecx, eax
  00034	23 ca		 and	 ecx, edx
  00036	f7 d9		 neg	 ecx
  00038	1b c9		 sbb	 ecx, ecx
  0003a	f7 d9		 neg	 ecx
  0003c	03 ce		 add	 ecx, esi
; File e:\infinia-library-3.0\com\include\commemmanager.h

; 34   : 	inline char *newBuf(int nSize) { int nIdx = getIndex(nSize);  return __newBuf(nIdx, nSize); }

  0003e	51		 push	 ecx
  0003f	8b cf		 mov	 ecx, edi
  00041	e8 00 00 00 00	 call	 ?__newBuf@CMemManager@@AAEPADHI@Z ; CMemManager::__newBuf
  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4
?newBuf@CMemManager@@QAEPADH@Z ENDP			; CMemManager::newBuf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\combufpool.h
;	COMDAT ?getIndex@@YAHH@Z
_TEXT	SEGMENT
_$S1$ = -8						; size = 8
_s$ = 8							; size = 4
?getIndex@@YAHH@Z PROC					; getIndex, COMDAT

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	8b 75 08	 mov	 esi, DWORD PTR _s$[ebp]
  0000a	ba 01 00 00 00	 mov	 edx, 1
  0000f	8b c6		 mov	 eax, esi
  00011	66 0f 6e c6	 movd	 xmm0, esi
  00015	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00019	f2 0f 11 45 f8	 movsd	 QWORD PTR _$S1$[ebp], xmm0
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _$S1$[ebp+4]
  00021	c1 f9 14	 sar	 ecx, 20			; 00000014H
  00024	81 e9 ff 03 00
	00		 sub	 ecx, 1023		; 000003ffH
  0002a	d3 e2		 shl	 edx, cl
  0002c	2b c2		 sub	 eax, edx
  0002e	23 c6		 and	 eax, esi
  00030	f7 d8		 neg	 eax
  00032	5e		 pop	 esi
  00033	1b c0		 sbb	 eax, eax
  00035	f7 d8		 neg	 eax
  00037	03 c1		 add	 eax, ecx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
?getIndex@@YAHH@Z ENDP					; getIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\comfiletypes.h
;	COMDAT ?jISDIR@@YA_NPAU_WIN32_FIND_DATAA@@@Z
_TEXT	SEGMENT
_pFD$ = 8						; size = 4
?jISDIR@@YA_NPAU_WIN32_FIND_DATAA@@@Z PROC		; jISDIR, COMDAT

; 86   : inline bool jISDIR(LPJFILEDATA pFD)		{return (pFD->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)?true:false;} //directory?

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _pFD$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	c1 e8 04	 shr	 eax, 4
  0000b	24 01		 and	 al, 1
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?jISDIR@@YA_NPAU_WIN32_FIND_DATAA@@@Z ENDP		; jISDIR
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\comfiletypes.h
;	COMDAT ?jISREG@@YA_NPAU_WIN32_FIND_DATAA@@@Z
_TEXT	SEGMENT
_pFD$ = 8						; size = 4
?jISREG@@YA_NPAU_WIN32_FIND_DATAA@@@Z PROC		; jISREG, COMDAT

; 85   : inline bool jISREG(LPJFILEDATA pFD)		{return (pFD->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)? false : true;} //regular file?

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _pFD$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	c1 e8 04	 shr	 eax, 4
  0000b	f6 d0		 not	 al
  0000d	24 01		 and	 al, 1
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?jISREG@@YA_NPAU_WIN32_FIND_DATAA@@@Z ENDP		; jISREG
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\comfiletypes.h
;	COMDAT ?com_getFileName@@YAXPAPADPAU_WIN32_FIND_DATAA@@@Z
_TEXT	SEGMENT
_pFileName$ = 8						; size = 4
_pFileData$ = 12					; size = 4
?com_getFileName@@YAXPAPADPAU_WIN32_FIND_DATAA@@@Z PROC	; com_getFileName, COMDAT

; 83   : inline void com_getFileName(TCHAR **pFileName, LPJFILEDATA pFileData) { *pFileName = pFileData->cFileName;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _pFileName$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _pFileData$[ebp]
  00009	83 c1 2c	 add	 ecx, 44			; 0000002cH
  0000c	89 08		 mov	 DWORD PTR [eax], ecx
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?com_getFileName@@YAXPAPADPAU_WIN32_FIND_DATAA@@@Z ENDP	; com_getFileName
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\comfiletypes.h
;	COMDAT ?com_nextFile@@YA_NPAXPAU_WIN32_FIND_DATAA@@@Z
_TEXT	SEGMENT
_dir$ = 8						; size = 4
_pFileData$ = 12					; size = 4
?com_nextFile@@YA_NPAXPAU_WIN32_FIND_DATAA@@@Z PROC	; com_nextFile, COMDAT

; 82   : inline bool com_nextFile(JPDIR dir, LPJFILEDATA pFileData) { return (FindNextFile(dir, pFileData))?true:false; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	ff 75 0c	 push	 DWORD PTR _pFileData$[ebp]
  00006	ff 75 08	 push	 DWORD PTR _dir$[ebp]
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindNextFileA@8
  0000f	85 c0		 test	 eax, eax
  00011	0f 95 c0	 setne	 al
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?com_nextFile@@YA_NPAXPAU_WIN32_FIND_DATAA@@@Z ENDP	; com_nextFile
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\comfiletypes.h
;	COMDAT ?com_findFirstFile@@YAPAXPBDPAU_WIN32_FIND_DATAA@@@Z
_TEXT	SEGMENT
_pDirName$ = 8						; size = 4
_pFileData$ = 12					; size = 4
?com_findFirstFile@@YAPAXPBDPAU_WIN32_FIND_DATAA@@@Z PROC ; com_findFirstFile, COMDAT

; 81   : inline JPDIR com_findFirstFile(const TCHAR *pDirName, LPJFILEDATA pFileData) { return FindFirstFile(pDirName, pFileData); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	ff 75 0c	 push	 DWORD PTR _pFileData$[ebp]
  00006	ff 75 08	 push	 DWORD PTR _pDirName$[ebp]
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindFirstFileA@8
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?com_findFirstFile@@YAPAXPBDPAU_WIN32_FIND_DATAA@@@Z ENDP ; com_findFirstFile
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\comfiletypes.h
;	COMDAT ?com_isDirectory@@YA_NPAD@Z
_TEXT	SEGMENT
_dir$ = 8						; size = 4
?com_isDirectory@@YA_NPAD@Z PROC			; com_isDirectory, COMDAT

; 80   : inline bool com_isDirectory(TCHAR *dir) { int res = GetFileAttributes(dir); if (res == FILE_ATTRIBUTE_DIRECTORY)return true; return false; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	ff 75 08	 push	 DWORD PTR _dir$[ebp]
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileAttributesA@4
  0000c	83 f8 10	 cmp	 eax, 16			; 00000010H
  0000f	0f 94 c0	 sete	 al
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?com_isDirectory@@YA_NPAD@Z ENDP			; com_isDirectory
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\comfiletypes.h
;	COMDAT ?com_isFile@@YA_NPBD@Z
_TEXT	SEGMENT
_file$ = 8						; size = 4
?com_isFile@@YA_NPBD@Z PROC				; com_isFile, COMDAT

; 79   : inline bool com_isFile(const TCHAR *file) { int res = GetFileAttributes(file); if (res == INVALID_FILE_ATTRIBUTES || res == FILE_ATTRIBUTE_DIRECTORY)return false; return true; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	ff 75 08	 push	 DWORD PTR _file$[ebp]
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileAttributesA@4
  0000c	83 f8 ff	 cmp	 eax, -1
  0000f	74 09		 je	 SHORT $LN3@com_isFile
  00011	83 f8 10	 cmp	 eax, 16			; 00000010H
  00014	74 04		 je	 SHORT $LN3@com_isFile
  00016	b0 01		 mov	 al, 1
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
$LN3@com_isFile:
  0001a	32 c0		 xor	 al, al
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?com_isFile@@YA_NPBD@Z ENDP				; com_isFile
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\comfiletypes.h
;	COMDAT ?com_isInvalid@@YA_NPBD@Z
_TEXT	SEGMENT
_fath$ = 8						; size = 4
?com_isInvalid@@YA_NPBD@Z PROC				; com_isInvalid, COMDAT

; 78   : inline bool com_isInvalid(const TCHAR *fath) { if (GetFileAttributes(fath) == INVALID_FILE_ATTRIBUTES)return true; return false; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	ff 75 08	 push	 DWORD PTR _fath$[ebp]
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileAttributesA@4
  0000c	83 f8 ff	 cmp	 eax, -1
  0000f	0f 94 c0	 sete	 al
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?com_isInvalid@@YA_NPBD@Z ENDP				; com_isInvalid
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\infinia-library-3.0\com\include\comfiletypes.h
;	COMDAT ?com_mkdir@@YA_NPBD@Z
_TEXT	SEGMENT
_path$ = 8						; size = 4
?com_mkdir@@YA_NPBD@Z PROC				; com_mkdir, COMDAT

; 75   : inline bool com_mkdir(const TCHAR *path)	{int res = CreateDirectory(path, NULL); return (res)?true:false; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a 00		 push	 0
  00005	ff 75 08	 push	 DWORD PTR _path$[ebp]
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDirectoryA@8
  0000e	85 c0		 test	 eax, eax
  00010	0f 95 c0	 setne	 al
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?com_mkdir@@YA_NPBD@Z ENDP				; com_mkdir
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
;	COMDAT ?_tcsrchr@@YAPADPADI@Z
_TEXT	SEGMENT
__S$ = 8						; size = 4
__C$ = 12						; size = 4
?_tcsrchr@@YAPADPADI@Z PROC				; _tcsrchr, COMDAT

; 2027 :         {return ((char *)_tcsrchr((const char *)_S, _C)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp

; 1569 : _Check_return_ __inline _CRPC _tcsrchr(_In_ _CPC _s1,_In_ _UI _c) {return (_CRPC)_mbsrchr((_CPUC)_s1,_c);}

  00004	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp___mbsrchr
?_tcsrchr@@YAPADPADI@Z ENDP				; _tcsrchr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
;	COMDAT ?_tcschr@@YAPADPADI@Z
_TEXT	SEGMENT
__S$ = 8						; size = 4
__C$ = 12						; size = 4
?_tcschr@@YAPADPADI@Z PROC				; _tcschr, COMDAT

; 2023 :         {return ((char *)_tcschr((const char *)_S, _C)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp

; 1497 : __inline _CRPC _tcschr(_In_ _CPC _s1,_In_ _UI _c) {return (_CRPC)_mbschr((_CPUC)_s1,_c);}

  00004	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp___mbschr
?_tcschr@@YAPADPADI@Z ENDP				; _tcschr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
;	COMDAT __tcscmp
_TEXT	SEGMENT
__s1$ = 8						; size = 4
__s2$ = 12						; size = 4
__tcscmp PROC						; COMDAT

; 1669 : _Check_return_ __inline int _tcscmp(_In_ _CPC _s1,_In_ _CPC _s2) {return _mbscmp((_CPUC)_s1,(_CPUC)_s2);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp___mbscmp
__tcscmp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
;	COMDAT __tcsrchr
_TEXT	SEGMENT
__s1$ = 8						; size = 4
__c$ = 12						; size = 4
__tcsrchr PROC						; COMDAT

; 1569 : _Check_return_ __inline _CRPC _tcsrchr(_In_ _CPC _s1,_In_ _UI _c) {return (_CRPC)_mbsrchr((_CPUC)_s1,_c);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp___mbsrchr
__tcsrchr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
;	COMDAT __tcsncpy
_TEXT	SEGMENT
__Dst$ = 8						; size = 4
__Source$ = 12						; size = 4
__Count$ = 16						; size = 4
__tcsncpy PROC						; COMDAT

; 1542 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1546 : #pragma warning(pop)
; 1547 : }

  00003	5d		 pop	 ebp

; 1543 : #pragma warning(push)
; 1544 : #pragma warning(disable:4996)
; 1545 :     return (char *)_mbsnbcpy((unsigned char *)_Dst,(const unsigned char *)_Source,_Count);

  00004	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp___mbsnbcpy
__tcsncpy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
;	COMDAT __tcschr
_TEXT	SEGMENT
__s1$ = 8						; size = 4
__c$ = 12						; size = 4
__tcschr PROC						; COMDAT

; 1497 : __inline _CRPC _tcschr(_In_ _CPC _s1,_In_ _UI _c) {return (_CRPC)_mbschr((_CPUC)_s1,_c);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp___mbschr
__tcschr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\string.h
;	COMDAT ?strchr@@YAPADQADH@Z
_TEXT	SEGMENT
__String$ = 8						; size = 4
__Ch$ = 12						; size = 4
?strchr@@YAPADQADH@Z PROC				; strchr, COMDAT

; 518  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 520  :     }

  00003	5d		 pop	 ebp

; 519  :         return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));

  00004	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp__strchr
?strchr@@YAPADQADH@Z ENDP				; strchr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00006	8d 4d 10	 lea	 ecx, DWORD PTR __Format$[ebp+4]
  00009	51		 push	 ecx
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000f	6a ff		 push	 -1
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	83 c9 01	 or	 ecx, 1
  0001f	51		 push	 ecx
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00026	83 c9 ff	 or	 ecx, -1
  00029	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002c	85 c0		 test	 eax, eax
  0002e	0f 48 c1	 cmovs	 eax, ecx

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);
; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);
; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);
; 1787 :     return _Result;
; 1788 : }

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00003	ff 75 14	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 10	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 1459 :     #pragma warning(pop)
; 1460 : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00003	ff 75 18	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 14	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	83 c9 01	 or	 ecx, 1
  0001f	51		 push	 ecx
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00026	83 c9 ff	 or	 ecx, -1
  00029	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002c	85 c0		 test	 eax, eax
  0002e	0f 48 c1	 cmovs	 eax, ecx

; 1391 : }

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 950  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 951  :     int _Result;
; 952  :     va_list _ArgList;
; 953  :     __crt_va_start(_ArgList, _Format);
; 954  :     _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Format$[ebp]
  00007	6a 01		 push	 1
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  0000f	83 c4 04	 add	 esp, 4

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00012	8d 4d 0c	 lea	 ecx, DWORD PTR __Format$[ebp+4]
  00015	51		 push	 ecx
  00016	6a 00		 push	 0
  00018	56		 push	 esi
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0001f	ff 70 04	 push	 DWORD PTR [eax+4]
  00022	ff 30		 push	 DWORD PTR [eax]
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vfprintf
  0002a	83 c4 18	 add	 esp, 24			; 00000018H
  0002d	5e		 pop	 esi

; 955  :     __crt_va_end(_ArgList);
; 956  :     return _Result;
; 957  : }

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 638  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00003	ff 75 14	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 10	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 08	 push	 DWORD PTR __Stream$[ebp]
  0000f	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00014	ff 70 04	 push	 DWORD PTR [eax+4]
  00017	ff 30		 push	 DWORD PTR [eax]
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vfprintf
  0001f	83 c4 18	 add	 esp, 24			; 00000018H

; 640  : }

  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
