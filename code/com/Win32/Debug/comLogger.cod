; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	E:\InfiniA-Library-3.0\com\src\comLogger.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?g_szKeepDuratrion@@3PADA			; g_szKeepDuratrion
PUBLIC	?g_szLogExtension@@3PADA			; g_szLogExtension
_DATA	SEGMENT
?g_szKeepDuratrion@@3PADA DB '15D', 00H			; g_szKeepDuratrion
	ORG $+4
?g_szLogExtension@@3PADA DB 'log', 00H			; g_szLogExtension
	ORG $+4
_DATA	ENDS
CONST	SEGMENT
$SG86447 DB	'LIST_MAX', 00H
$SG86519 DB	00H
$SG86983 DB	00H
	ORG $+1
$SG86448 DB	'DATETIME_EXPRESSION', 00H
$SG86451 DB	'CTimeExpManager::initConfig', 00H
$SG86452 DB	'new CList() is NULL!', 09H, '%s%d', 0aH, 00H
	ORG $+1
$SG86454 DB	'CTimeExpManager::initConfig', 00H
$SG86455 DB	'm_pTimeExpList->alloc has Failed!', 09H, '%s%d', 0aH, 00H
$SG86458 DB	'DATETIME_EXPRESSION_%d', 00H
	ORG $+1
$SG86459 DB	'IS_TIME_DELIMETER', 00H
	ORG $+2
$SG86460 DB	'DATE_DELIMETER', 00H
	ORG $+1
$SG86461 DB	'IS_BRACKET_ENCLOSED', 00H
$SG86462 DB	'LAST_TYPE', 00H
	ORG $+2
$SG86463 DB	'YEAR_LEN', 00H
	ORG $+3
$SG86464 DB	'TZ_TYPE', 00H
$SG86494 DB	'CLogger::initDefault', 00H
	ORG $+3
$SG86495 DB	'pDir is NULL', 00H
	ORG $+3
$SG86500 DB	'CLogger::initDefault', 00H
	ORG $+3
$SG86501 DB	'_setLoggerQueue has Failed', 00H
	ORG $+1
$SG86503 DB	'CLogger::initDefault', 00H
	ORG $+3
$SG86504 DB	'_setHeaderFormat has Failed', 00H
$SG86525 DB	'CLogger::initConfig', 00H
?gs_fmtStr@@3QAY0M@$$CBDA DB 00H			; gs_fmtStr
	ORG $+11
	DB	'[DEBUG] ', 00H
	ORG $+3
	DB	'[TRACE] ', 00H
	ORG $+3
	DB	'[INFO] ', 00H
	ORG $+4
	DB	'[WARNING] ', 00H
	ORG $+1
	DB	'[ERROR] ', 00H
	ORG $+3
	DB	'[FATAL] ', 00H
	ORG $+3
	DB	'[ALARM] ', 00H
	ORG $+3
$SG86520 DB	'LOGNAME', 00H
$SG86526 DB	'LOGNAME is NULL!', 00H
	ORG $+3
$SG86527 DB	'ISENABLE', 00H
	ORG $+3
$SG86530 DB	'Log', 00H
$SG86531 DB	'LOGDIR', 00H
	ORG $+1
$SG86532 DB	'EXTENSION', 00H
	ORG $+2
$SG86533 DB	'KEEP_DURATION', 00H
	ORG $+2
$SG86534 DB	'LIST_MAX', 00H
	ORG $+3
$SG86536 DB	'CLogger::initConfig', 00H
$SG86537 DB	'_setLoggerQueue has Failed', 00H
	ORG $+1
$SG86538 DB	'TIMESTEMP_NO', 00H
	ORG $+3
$SG86540 DB	'invalid value[%d]! pSection[%s]', 00H
$SG86541 DB	'CLogger::initConfig', 00H
$SG86543 DB	'CLogger::initConfig', 00H
$SG86544 DB	'_setHeaderFormat has Failed', 00H
$SG86545 DB	'STL_NO', 00H
	ORG $+1
$SG86546 DB	'LOGTYPE', 00H
$SG86547 DB	'SIZE_LIMIT', 00H
	ORG $+1
$SG86548 DB	'IS_PRINT_LEVEL', 00H
	ORG $+1
$SG86549 DB	'IS_PRINT', 00H
	ORG $+3
$SG86551 DB	'LOGLEVEL', 00H
	ORG $+3
$SG86562 DB	'Logger is not Initialized!', 00H
	ORG $+1
$SG86565 DB	'TYPE_DAILY', 00H
	ORG $+1
$SG86568 DB	'TYPE_HOURLY', 00H
$SG86570 DB	'TYPE_FILE', 00H
	ORG $+2
$SG86571 DB	'================================================', 0aH, 00H
	ORG $+2
$SG86572 DB	'Logger Path[%s] Prefix[%s] Extension[%s]', 0aH, 00H
	ORG $+2
$SG86573 DB	'Logger SizeLimit[%d] LogLevel[%d] LogType[%s]', 0aH, 00H
	ORG $+1
$SG86574 DB	'KeepDuration : %02d days %02d:%02d:%02d', 00H
$SG86575 DB	'Logger KeepDuration[%s]', 0aH, 00H
	ORG $+3
$SG86576 DB	'================================================', 0aH, 00H
	ORG $+2
$SG86610 DB	'm_sLogQueue.alloc(20, eAlloc_Type_BufPool) has Failed', 00H
	ORG $+2
$SG86611 DB	'CLogger::_setLoggerQueue', 00H
	ORG $+3
$SG86614 DB	'm_sLogQueue.realloc(%d,true) has Failed', 00H
$SG86615 DB	'CLogger::_setLoggerQueue', 00H
	ORG $+3
$SG86638 DB	'm_pDTE is NULL! nTimeStempNo[%d]', 00H
	ORG $+3
$SG86639 DB	'CLogger::_setHeaderFormat', 00H
	ORG $+2
$SG86647 DB	'%s%d_%s.%s', 00H
	ORG $+1
$SG86650 DB	'%s%d%c%s_%02d.%s', 00H
	ORG $+3
$SG86652 DB	'%s%s.%s', 00H
$SG86667 DB	'%04d', 00H
	ORG $+3
$SG86674 DB	'%s', 00H
	ORG $+1
$SG86680 DB	'%c', 00H
	ORG $+1
$SG86681 DB	'%02d', 00H
	ORG $+3
$SG86683 DB	'%c', 00H
	ORG $+1
$SG86684 DB	'%02d ', 00H
	ORG $+2
$SG86687 DB	'%02d:%02d:%02d', 00H
	ORG $+1
$SG86688 DB	'%02d%02d%02d', 00H
	ORG $+3
$SG86690 DB	'.%03d', 00H
	ORG $+2
$SG86692 DB	'.%06d', 00H
	ORG $+2
$SG86694 DB	'.%09d', 00H
	ORG $+2
$SG86705 DB	'%s', 00H
	ORG $+1
$SG86707 DB	' %s', 00H
$SG86719 DB	'%s.%d', 00H
	ORG $+2
$SG86723 DB	'a+', 00H
	ORG $+1
$SG86725 DB	'Can''t create log file [%s]', 0aH, 00H
$SG86787 DB	' %s ', 00H
	ORG $+3
$SG86808 DB	' nSIdx[%d] Send [%d] PKIdx[%d] ', 00H
$SG86809 DB	' nSIdx[%d] Recv [%d] PKIdx[%d] ', 00H
$SG86810 DB	' nSIdx[%d] send Queue [%d] PKIdx[%d] ', 00H
	ORG $+2
$SG86811 DB	' nSIdx[%d] recv Queue [%d] PKIdx[%d] ', 00H
	ORG $+2
$SG86812 DB	' Undefind nkind[%d] [%d] PKIdx[%d] ', 00H
$SG86815 DB	'%02x ', 00H
	ORG $+2
$SG86841 DB	' %s, %d, %s ', 00H
	ORG $+3
$SG86864 DB	' %s ', 00H
	ORG $+3
$SG86886 DB	'%s/%d_%s.%s', 00H
$SG86889 DB	'%s/%d/%s_%02d.%s', 00H
	ORG $+3
$SG86908 DB	'%s/%d_%s', 00H
	ORG $+3
$SG86911 DB	'%s/%d/%s_%02d.%s', 00H
	ORG $+3
$SG86913 DB	'%s/%s', 00H
	ORG $+2
$SG86930 DB	'GetKeepInfo nStrLen < 2', 0aH, 00H
	ORG $+3
$SG86957 DB	'%s%s', 00H
	ORG $+3
$SG86970 DB	'%s%s', 00H
	ORG $+3
$SG86988 DB	'%s%s%c', 00H
	ORG $+1
$SG86989 DB	'%s%c', 00H
CONST	ENDS
PUBLIC	__tcsncpy
PUBLIC	__tcsrchr
PUBLIC	__tcscmp
PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_fprintf
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	_printf
PUBLIC	__vsnprintf_l
PUBLIC	__vsnprintf
PUBLIC	_vsnprintf
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	?ISINCLUDE@@YA_NHH@Z				; ISINCLUDE
PUBLIC	?comGlobalErrorProc@@YAXPADPBDH@Z		; comGlobalErrorProc
PUBLIC	?capacity@CQueueS@@QAEHXZ			; CQueueS::capacity
PUBLIC	?TimezoneString@CDateTime@@QAEPBDXZ		; CDateTime::TimezoneString
PUBLIC	?getIndex@@YAHH@Z				; getIndex
PUBLIC	?newBuf@CMemManager@@QAEPADH@Z			; CMemManager::newBuf
PUBLIC	?alloc@CSList@@QAEHHW4E_ALLOC_TYPE@@@Z		; CSList::alloc
PUBLIC	?getObj@CSList@@QAEPAXH@Z			; CSList::getObj
PUBLIC	?__autoclassinit2@CSList@@QAEXI@Z		; CSList::__autoclassinit2
PUBLIC	??_GCSList@@QAEPAXI@Z				; CSList::`scalar deleting destructor'
PUBLIC	??0CTimeExpManager@@QAE@XZ			; CTimeExpManager::CTimeExpManager
PUBLIC	??1CTimeExpManager@@QAE@XZ			; CTimeExpManager::~CTimeExpManager
PUBLIC	?initConfig@CTimeExpManager@@QAE_NPAD@Z		; CTimeExpManager::initConfig
PUBLIC	?getDTE@CTimeExpManager@@QAEPAUSTLogDateTimeExp@@H@Z ; CTimeExpManager::getDTE
PUBLIC	?__autoclassinit2@CTimeExpManager@@QAEXI@Z	; CTimeExpManager::__autoclassinit2
PUBLIC	??0CLogger@@QAE@XZ				; CLogger::CLogger
PUBLIC	??1CLogger@@QAE@XZ				; CLogger::~CLogger
PUBLIC	?initDefault@CLogger@@QAE_NPAD0HHH0@Z		; CLogger::initDefault
PUBLIC	?initConfig@CLogger@@QAE?AW4E_LOG_INIT_RES@@PAD0@Z ; CLogger::initConfig
PUBLIC	?OpenLogger@CLogger@@QAEXXZ			; CLogger::OpenLogger
PUBLIC	?setLogFlag@CLogger@@QAEXW4E_LOG_FLAG@@@Z	; CLogger::setLogFlag
PUBLIC	?clearLogFlag@CLogger@@QAEXW4E_LOG_FLAG@@@Z	; CLogger::clearLogFlag
PUBLIC	?isLogFlag@CLogger@@QAE_NW4E_LOG_FLAG@@@Z	; CLogger::isLogFlag
PUBLIC	?setHeader@CLogger@@QAEHPADH@Z			; CLogger::setHeader
PUBLIC	?PutLogQueue@CLogger@@QAAXHPBDZZ		; CLogger::PutLogQueue
PUBLIC	?PutLogQueue@CLogger@@QAEXHPAD@Z		; CLogger::PutLogQueue
PUBLIC	?Log@CLogger@@QAEXHPBD00_N@Z			; CLogger::Log
PUBLIC	?LogPrint@CLogger@@QAEXPAD@Z			; CLogger::LogPrint
PUBLIC	?LogPrint@CLogger@@QAAXHPBDZZ			; CLogger::LogPrint
PUBLIC	?WritePacket@CLogger@@QAEXHHHPADH@Z		; CLogger::WritePacket
PUBLIC	?disable@CLogger@@QAEXXZ			; CLogger::disable
PUBLIC	?checkChangeProc@CLogger@@QAEXH@Z		; CLogger::checkChangeProc
PUBLIC	?__debugLog@CLogger@@QAAXHPBDH0ZZ		; CLogger::__debugLog
PUBLIC	?getString@CLogger@@QAEHPAD@Z			; CLogger::getString
PUBLIC	?putQueue@CLogger@@QAEXPAD@Z			; CLogger::putQueue
PUBLIC	?_initCom@CLogger@@AAEXPAD000@Z			; CLogger::_initCom
PUBLIC	?_setHeaderFormat@CLogger@@AAE_NH@Z		; CLogger::_setHeaderFormat
PUBLIC	?_setLoggerBasic@CLogger@@AAEXHHH@Z		; CLogger::_setLoggerBasic
PUBLIC	?_setLoggerQueue@CLogger@@AAE_NH@Z		; CLogger::_setLoggerQueue
PUBLIC	?setLogName@CLogger@@AAEXPAD@Z			; CLogger::setLogName
PUBLIC	?setDateTimeFormat@CLogger@@AAEXPAUSTLogDateTimeExp@@@Z ; CLogger::setDateTimeFormat
PUBLIC	?GetKeepInfo@CLogger@@AAEHPBD@Z			; CLogger::GetKeepInfo
PUBLIC	?checkDeleteProc@CLogger@@AAEXXZ		; CLogger::checkDeleteProc
PUBLIC	?__openLogger@CLogger@@AAEXPBDH@Z		; CLogger::__openLogger
PUBLIC	?__autoclassinit2@CLogger@@QAEXI@Z		; CLogger::__autoclassinit2
PUBLIC	?changeToAbsolutePath@@YAXPADPBD@Z		; changeToAbsolutePath
PUBLIC	?changeToAbsolutePathFile@@YAXPADPBD@Z		; changeToAbsolutePathFile
PUBLIC	?GetProfilePath@@YAHPBD00PAD0@Z			; GetProfilePath
PUBLIC	?detachFullPath@@YAXPBDPAD1@Z			; detachFullPath
PUBLIC	?init@STDelInfo@@QAEXPAD_N1PAX@Z		; STDelInfo::init
PUBLIC	??$__vcrt_va_start_verify_argument_type@PBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const *>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_0BD@KEHDJCKJ@ERROR?$CB?5?$FL?$CFs?3?$CFd?$FN?5?$CFs?6?$AA@ ; `string'
PUBLIC	?gs_cLogger@@3VCLogger@@A			; gs_cLogger
PUBLIC	?gs_DTEManager@@3VCTimeExpManager@@A		; gs_DTEManager
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	_atexit:PROC
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memset:PROC
EXTRN	_strcpy:PROC
EXTRN	__imp___strdup:PROC
EXTRN	_strlen:PROC
EXTRN	__imp___mbscmp:PROC
EXTRN	__imp___mbsnbcpy:PROC
EXTRN	__imp___mbsrchr:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fflush:PROC
EXTRN	__imp__fopen:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	__imp__GetPrivateProfileIntA@16:PROC
EXTRN	__imp__GetPrivateProfileStringA@24:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp__atoi:PROC
EXTRN	__imp___time64:PROC
EXTRN	??0CQueueS@@QAE@XZ:PROC				; CQueueS::CQueueS
EXTRN	??1CQueueS@@QAE@XZ:PROC				; CQueueS::~CQueueS
EXTRN	?alloc@CQueueS@@QAE_NHW4E_ALLOC_TYPE@@@Z:PROC	; CQueueS::alloc
EXTRN	?realloc@CQueueS@@QAE_NH_N@Z:PROC		; CQueueS::realloc
EXTRN	?push@CQueueS@@QAE_NPAX@Z:PROC			; CQueueS::push
EXTRN	??0CFileTime@@QAE@XZ:PROC			; CFileTime::CFileTime
EXTRN	??1CFileTime@@QAE@XZ:PROC			; CFileTime::~CFileTime
EXTRN	?setFileTime@CFileTime@@QAEHPA_J@Z:PROC		; CFileTime::setFileTime
EXTRN	??0CDateTime@@QAE@W4DT_TYPE@@W4TZ_TYPE@@@Z:PROC	; CDateTime::CDateTime
EXTRN	??1CDateTime@@QAE@XZ:PROC			; CDateTime::~CDateTime
EXTRN	?SetSecondsValue@CDateTime@@QAEXH@Z:PROC	; CDateTime::SetSecondsValue
EXTRN	?setString@CDateTime@@QAEHPAD0W4DT_FORMAT@@@Z:PROC ; CDateTime::setString
EXTRN	?__newBuf@CMemManager@@AAEPADHI@Z:PROC		; CMemManager::__newBuf
EXTRN	??0CSList@@QAE@XZ:PROC				; CSList::CSList
EXTRN	??1CSList@@QAE@XZ:PROC				; CSList::~CSList
EXTRN	?push_back@CSList@@QAE_NPAXPAH@Z:PROC		; CSList::push_back
EXTRN	?__alloc@CSList@@AAEHH@Z:PROC			; CSList::__alloc
EXTRN	?filter_dateTimeCompare@@YA_NPADPAX1@Z:PROC	; filter_dateTimeCompare
EXTRN	?delDirectory@CFileUtil@@SAHPAUSTDelInfo@@PAUSTFilterData@@@Z:PROC ; CFileUtil::delDirectory
EXTRN	?MakeDirectory@CFileUtil@@SA_NPBD@Z:PROC	; CFileUtil::MakeDirectory
EXTRN	?renameFile@CFileUtil@@SA_NPBD0@Z:PROC		; CFileUtil::renameFile
EXTRN	?initSystem@CEnv@@SAHPAD@Z:PROC			; CEnv::initSystem
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__chkstk:PROC
EXTRN	_memset:PROC
EXTRN	?g_pWorkDir@@3PADA:DWORD			; g_pWorkDir
EXTRN	?g_szSystemError@@3PADA:BYTE			; g_szSystemError
EXTRN	?g_szMessage@@3PADA:BYTE			; g_szMessage
EXTRN	?gs_pMMgr@@3PAVCMemManager@@A:DWORD		; gs_pMMgr
EXTRN	?gs_today_time@@3USTTodayTime@@A:BYTE		; gs_today_time
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
?gs_cLogger@@3VCLogger@@A DB 0d8H DUP (?)		; gs_cLogger
?gs_DTEManager@@3VCTimeExpManager@@A DD 01H DUP (?)	; gs_DTEManager
_BSS	ENDS
CRT$XCU	SEGMENT
?gs_cLogger$initializer$@@3P6AXXZA DD FLAT:??__Egs_cLogger@@YAXXZ ; gs_cLogger$initializer$
CRT$XCU	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0BD@KEHDJCKJ@ERROR?$CB?5?$FL?$CFs?3?$CFd?$FN?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BD@KEHDJCKJ@ERROR?$CB?5?$FL?$CFs?3?$CFd?$FN?5?$CFs?6?$AA@ DB 'ERRO'
	DB	'R! [%s:%d] %s', 0aH, 00H			; `string'
CONST	ENDS
xdata$x	SEGMENT
__unwindtable$?checkDeleteProc@CLogger@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?checkDeleteProc@CLogger@@AAEXXZ$0
__unwindtable$?getString@CLogger@@QAEHPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getString@CLogger@@QAEHPAD@Z$0
__unwindtable$?setHeader@CLogger@@QAEHPADH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?setHeader@CLogger@@QAEHPADH@Z$0
__unwindtable$?initConfig@CTimeExpManager@@QAE_NPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?initConfig@CTimeExpManager@@QAE_NPAD@Z$0
__ehfuncinfo$?checkDeleteProc@CLogger@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?checkDeleteProc@CLogger@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?getString@CLogger@@QAEHPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?getString@CLogger@@QAEHPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?setHeader@CLogger@@QAEHPADH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?setHeader@CLogger@@QAEHPADH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??1CLogger@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__ehfuncinfo$?initConfig@CTimeExpManager@@QAE_NPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?initConfig@CTimeExpManager@@QAE_NPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
CRT$XCU	SEGMENT
?gs_DTEManager$initializer$@@3P6AXXZA DD FLAT:??__Egs_DTEManager@@YAXXZ ; gs_DTEManager$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@PBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@PBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const *>, COMDAT

; 144  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@PBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??__Fgs_DTEManager@@YAXXZ
text$yd	SEGMENT
??__Fgs_DTEManager@@YAXXZ PROC				; `dynamic atexit destructor for 'gs_DTEManager'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_DTEManager@@3VCTimeExpManager@@A ; gs_DTEManager
  00008	e8 00 00 00 00	 call	 ??1CTimeExpManager@@QAE@XZ ; CTimeExpManager::~CTimeExpManager
  0000d	3b ec		 cmp	 ebp, esp
  0000f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??__Fgs_DTEManager@@YAXXZ ENDP				; `dynamic atexit destructor for 'gs_DTEManager''
text$yd	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comlogger.cpp
;	COMDAT ??__Egs_DTEManager@@YAXXZ
text$di	SEGMENT
??__Egs_DTEManager@@YAXXZ PROC				; `dynamic initializer for 'gs_DTEManager'', COMDAT

; 24   : CTimeExpManager gs_DTEManager;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a 04		 push	 4
  00005	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_DTEManager@@3VCTimeExpManager@@A ; gs_DTEManager
  0000a	e8 00 00 00 00	 call	 ?__autoclassinit2@CTimeExpManager@@QAEXI@Z
  0000f	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_DTEManager@@3VCTimeExpManager@@A ; gs_DTEManager
  00014	e8 00 00 00 00	 call	 ??0CTimeExpManager@@QAE@XZ ; CTimeExpManager::CTimeExpManager
  00019	68 00 00 00 00	 push	 OFFSET ??__Fgs_DTEManager@@YAXXZ ; `dynamic atexit destructor for 'gs_DTEManager''
  0001e	e8 00 00 00 00	 call	 _atexit
  00023	83 c4 04	 add	 esp, 4
  00026	3b ec		 cmp	 ebp, esp
  00028	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
??__Egs_DTEManager@@YAXXZ ENDP				; `dynamic initializer for 'gs_DTEManager''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??__Fgs_cLogger@@YAXXZ
text$yd	SEGMENT
??__Fgs_cLogger@@YAXXZ PROC				; `dynamic atexit destructor for 'gs_cLogger'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  00008	e8 00 00 00 00	 call	 ??1CLogger@@QAE@XZ	; CLogger::~CLogger
  0000d	3b ec		 cmp	 ebp, esp
  0000f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??__Fgs_cLogger@@YAXXZ ENDP				; `dynamic atexit destructor for 'gs_cLogger''
text$yd	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comlogger.cpp
;	COMDAT ??__Egs_cLogger@@YAXXZ
text$di	SEGMENT
??__Egs_cLogger@@YAXXZ PROC				; `dynamic initializer for 'gs_cLogger'', COMDAT

; 23   : CLogger gs_cLogger;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 d8 00 00 00	 push	 216			; 000000d8H
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  0000d	e8 00 00 00 00	 call	 ?__autoclassinit2@CLogger@@QAEXI@Z
  00012	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  00017	e8 00 00 00 00	 call	 ??0CLogger@@QAE@XZ	; CLogger::CLogger
  0001c	68 00 00 00 00	 push	 OFFSET ??__Fgs_cLogger@@YAXXZ ; `dynamic atexit destructor for 'gs_cLogger''
  00021	e8 00 00 00 00	 call	 _atexit
  00026	83 c4 04	 add	 esp, 4
  00029	3b ec		 cmp	 ebp, esp
  0002b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
??__Egs_cLogger@@YAXXZ ENDP				; `dynamic initializer for 'gs_cLogger''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\comfileutil.h
;	COMDAT ?init@STDelInfo@@QAEXPAD_N1PAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dir$ = 8						; size = 4
_isRecursive$ = 12					; size = 1
_bDelDir$ = 16						; size = 1
_p$ = 20						; size = 4
?init@STDelInfo@@QAEXPAD_N1PAX@Z PROC			; STDelInfo::init, COMDAT
; _this$ = ecx

; 39   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 40   : 		pData = p;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 4d 14	 mov	 ecx, DWORD PTR _p$[ebp]
  00014	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 41   : 		root = dir;

  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 45 08	 mov	 eax, DWORD PTR _dir$[ebp]
  0001d	89 02		 mov	 DWORD PTR [edx], eax

; 42   : 		nFlag = 0;

  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 43   : 		if (isRecursive) nFlag = DIR_RECURSIVE;

  00029	0f b6 55 0c	 movzx	 edx, BYTE PTR _isRecursive$[ebp]
  0002d	85 d2		 test	 edx, edx
  0002f	74 0a		 je	 SHORT $LN2@init
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [eax+4], 1
$LN2@init:

; 44   : 		if (bDelDir) nFlag |= DEL_DIRECTORY;

  0003b	0f b6 4d 10	 movzx	 ecx, BYTE PTR _bDelDir$[ebp]
  0003f	85 c9		 test	 ecx, ecx
  00041	74 0f		 je	 SHORT $LN1@init
  00043	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00046	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00049	83 c8 02	 or	 eax, 2
  0004c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN1@init:

; 45   : 	}

  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 10 00	 ret	 16			; 00000010H
?init@STDelInfo@@QAEXPAD_N1PAX@Z ENDP			; STDelInfo::init
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comlogger.cpp
_TEXT	SEGMENT
_pRear$ = -8						; size = 4
_nLen$ = -4						; size = 4
_fullpath$ = 8						; size = 4
_dir$ = 12						; size = 4
_name$ = 16						; size = 4
?detachFullPath@@YAXPBDPAD1@Z PROC			; detachFullPath

; 859  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 860  : 	size_t nLen;
; 861  : 
; 862  : 	const TCHAR *pRear = _tcsrchr(fullpath, g_s);

  00014	6a 5c		 push	 92			; 0000005cH
  00016	8b 45 08	 mov	 eax, DWORD PTR _fullpath$[ebp]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 __tcsrchr
  0001f	83 c4 08	 add	 esp, 8
  00022	89 45 f8	 mov	 DWORD PTR _pRear$[ebp], eax

; 863  : 	nLen = pRear - fullpath + 1;

  00025	8b 4d f8	 mov	 ecx, DWORD PTR _pRear$[ebp]
  00028	2b 4d 08	 sub	 ecx, DWORD PTR _fullpath$[ebp]
  0002b	83 c1 01	 add	 ecx, 1
  0002e	89 4d fc	 mov	 DWORD PTR _nLen$[ebp], ecx

; 864  : 	_tcsncpy(dir, fullpath, nLen);

  00031	8b 55 fc	 mov	 edx, DWORD PTR _nLen$[ebp]
  00034	52		 push	 edx
  00035	8b 45 08	 mov	 eax, DWORD PTR _fullpath$[ebp]
  00038	50		 push	 eax
  00039	8b 4d 0c	 mov	 ecx, DWORD PTR _dir$[ebp]
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 __tcsncpy
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH

; 865  : 	dir[nLen] = 0;

  00045	8b 55 0c	 mov	 edx, DWORD PTR _dir$[ebp]
  00048	03 55 fc	 add	 edx, DWORD PTR _nLen$[ebp]
  0004b	c6 02 00	 mov	 BYTE PTR [edx], 0

; 866  : 	_tcscpy(name, pRear+1);

  0004e	8b 45 f8	 mov	 eax, DWORD PTR _pRear$[ebp]
  00051	83 c0 01	 add	 eax, 1
  00054	50		 push	 eax
  00055	8b 4d 10	 mov	 ecx, DWORD PTR _name$[ebp]
  00058	51		 push	 ecx
  00059	e8 00 00 00 00	 call	 _strcpy
  0005e	83 c4 08	 add	 esp, 8

; 867  : }

  00061	83 c4 08	 add	 esp, 8
  00064	3b ec		 cmp	 ebp, esp
  00066	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
?detachFullPath@@YAXPBDPAD1@Z ENDP			; detachFullPath
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comlogger.cpp
_TEXT	SEGMENT
_nRes$ = -272						; size = 4
_szDir$ = -264						; size = 256
__$ArrayPad$ = -4					; size = 4
_section$ = 8						; size = 4
_key$ = 12						; size = 4
_initVal$ = 16						; size = 4
_ret$ = 20						; size = 4
_fName$ = 24						; size = 4
?GetProfilePath@@YAHPBD00PAD0@Z PROC			; GetProfilePath

; 839  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 10 01 00
	00		 sub	 esp, 272		; 00000110H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd f0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-272]
  00011	b9 44 00 00 00	 mov	 ecx, 68			; 00000044H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 840  : 	TCHAR szDir[256];
; 841  : 	int nRes = GetPrivateProfileString(section, key, _T(""), szDir, sizeof(szDir), fName);

  00027	8b f4		 mov	 esi, esp
  00029	8b 45 18	 mov	 eax, DWORD PTR _fName$[ebp]
  0002c	50		 push	 eax
  0002d	68 00 01 00 00	 push	 256			; 00000100H
  00032	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _szDir$[ebp]
  00038	51		 push	 ecx
  00039	68 00 00 00 00	 push	 OFFSET $SG86983
  0003e	8b 55 0c	 mov	 edx, DWORD PTR _key$[ebp]
  00041	52		 push	 edx
  00042	8b 45 08	 mov	 eax, DWORD PTR _section$[ebp]
  00045	50		 push	 eax
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileStringA@24
  0004c	3b f4		 cmp	 esi, esp
  0004e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00053	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _nRes$[ebp], eax

; 842  : 
; 843  : 	if (!nRes) {

  00059	83 bd f0 fe ff
	ff 00		 cmp	 DWORD PTR _nRes$[ebp], 0
  00060	75 4e		 jne	 SHORT $LN2@GetProfile

; 844  : 		if (initVal) {

  00062	83 7d 10 00	 cmp	 DWORD PTR _initVal$[ebp], 0
  00066	74 26		 je	 SHORT $LN4@GetProfile

; 845  : 			nRes = _stprintf(ret, "%s%s%c", g_pWorkDir, initVal, g_s);

  00068	6a 5c		 push	 92			; 0000005cH
  0006a	8b 4d 10	 mov	 ecx, DWORD PTR _initVal$[ebp]
  0006d	51		 push	 ecx
  0006e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_pWorkDir@@3PADA ; g_pWorkDir
  00074	52		 push	 edx
  00075	68 00 00 00 00	 push	 OFFSET $SG86988
  0007a	8b 45 14	 mov	 eax, DWORD PTR _ret$[ebp]
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 _sprintf
  00083	83 c4 14	 add	 esp, 20			; 00000014H
  00086	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _nRes$[ebp], eax

; 846  : 		}
; 847  : 		else {

  0008c	eb 20		 jmp	 SHORT $LN5@GetProfile
$LN4@GetProfile:

; 848  : 			nRes = _stprintf(ret, "%s%c", g_pWorkDir, g_s);

  0008e	6a 5c		 push	 92			; 0000005cH
  00090	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_pWorkDir@@3PADA ; g_pWorkDir
  00096	51		 push	 ecx
  00097	68 00 00 00 00	 push	 OFFSET $SG86989
  0009c	8b 55 14	 mov	 edx, DWORD PTR _ret$[ebp]
  0009f	52		 push	 edx
  000a0	e8 00 00 00 00	 call	 _sprintf
  000a5	83 c4 10	 add	 esp, 16			; 00000010H
  000a8	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _nRes$[ebp], eax
$LN5@GetProfile:

; 849  : 		}

  000ae	eb 28		 jmp	 SHORT $LN3@GetProfile
$LN2@GetProfile:

; 850  : 	}
; 851  : 	else if (szDir[0] == '~') {

  000b0	b8 01 00 00 00	 mov	 eax, 1
  000b5	6b c8 00	 imul	 ecx, eax, 0
  000b8	0f be 94 0d f8
	fe ff ff	 movsx	 edx, BYTE PTR _szDir$[ebp+ecx]
  000c0	83 fa 7e	 cmp	 edx, 126		; 0000007eH
  000c3	75 13		 jne	 SHORT $LN3@GetProfile

; 852  : 		changeToAbsolutePath(ret, szDir);

  000c5	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szDir$[ebp]
  000cb	50		 push	 eax
  000cc	8b 4d 14	 mov	 ecx, DWORD PTR _ret$[ebp]
  000cf	51		 push	 ecx
  000d0	e8 00 00 00 00	 call	 ?changeToAbsolutePath@@YAXPADPBD@Z ; changeToAbsolutePath
  000d5	83 c4 08	 add	 esp, 8
$LN3@GetProfile:

; 853  : 	}
; 854  : 	return nRes;

  000d8	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _nRes$[ebp]

; 855  : }

  000de	52		 push	 edx
  000df	8b cd		 mov	 ecx, ebp
  000e1	50		 push	 eax
  000e2	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN10@GetProfile
  000e8	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000ed	58		 pop	 eax
  000ee	5a		 pop	 edx
  000ef	5f		 pop	 edi
  000f0	5e		 pop	 esi
  000f1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f4	33 cd		 xor	 ecx, ebp
  000f6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000fb	81 c4 10 01 00
	00		 add	 esp, 272		; 00000110H
  00101	3b ec		 cmp	 ebp, esp
  00103	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00108	8b e5		 mov	 esp, ebp
  0010a	5d		 pop	 ebp
  0010b	c3		 ret	 0
$LN10@GetProfile:
  0010c	01 00 00 00	 DD	 1
  00110	00 00 00 00	 DD	 $LN9@GetProfile
$LN9@GetProfile:
  00114	f8 fe ff ff	 DD	 -264			; fffffef8H
  00118	00 01 00 00	 DD	 256			; 00000100H
  0011c	00 00 00 00	 DD	 $LN8@GetProfile
$LN8@GetProfile:
  00120	73		 DB	 115			; 00000073H
  00121	7a		 DB	 122			; 0000007aH
  00122	44		 DB	 68			; 00000044H
  00123	69		 DB	 105			; 00000069H
  00124	72		 DB	 114			; 00000072H
  00125	00		 DB	 0
?GetProfilePath@@YAHPBD00PAD0@Z ENDP			; GetProfilePath
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comlogger.cpp
_TEXT	SEGMENT
_nRes$ = -1044						; size = 4
_pBuf$ = -1040						; size = 4
_szBuf$ = -1032						; size = 1024
__$ArrayPad$ = -4					; size = 4
_ret$ = 8						; size = 4
_path$ = 12						; size = 4
?changeToAbsolutePathFile@@YAXPADPBD@Z PROC		; changeToAbsolutePathFile

; 800  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 04 00
	00		 sub	 esp, 1044		; 00000414H
  00009	57		 push	 edi
  0000a	8d bd ec fb ff
	ff		 lea	 edi, DWORD PTR [ebp-1044]
  00010	b9 05 01 00 00	 mov	 ecx, 261		; 00000105H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 801  : 	TCHAR szBuf[1024];
; 802  : 	TCHAR *pBuf = (TCHAR *)szBuf;

  00026	8d 85 f8 fb ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  0002c	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _pBuf$[ebp], eax

; 803  : 	_tcscpy(szBuf, path);

  00032	8b 4d 0c	 mov	 ecx, DWORD PTR _path$[ebp]
  00035	51		 push	 ecx
  00036	8d 95 f8 fb ff
	ff		 lea	 edx, DWORD PTR _szBuf$[ebp]
  0003c	52		 push	 edx
  0003d	e8 00 00 00 00	 call	 _strcpy
  00042	83 c4 08	 add	 esp, 8

; 804  : 	int nRes = 0;

  00045	c7 85 ec fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _nRes$[ebp], 0

; 805  : 	CEnv::initSystem();

  0004f	6a 00		 push	 0
  00051	e8 00 00 00 00	 call	 ?initSystem@CEnv@@SAHPAD@Z ; CEnv::initSystem
  00056	83 c4 04	 add	 esp, 4

; 806  : 	if (pBuf[0] == '~') {

  00059	b8 01 00 00 00	 mov	 eax, 1
  0005e	6b c8 00	 imul	 ecx, eax, 0
  00061	8b 95 f0 fb ff
	ff		 mov	 edx, DWORD PTR _pBuf$[ebp]
  00067	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  0006b	83 f8 7e	 cmp	 eax, 126		; 0000007eH
  0006e	75 75		 jne	 SHORT $LN1@changeToAb

; 807  : 		pBuf++;

  00070	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _pBuf$[ebp]
  00076	83 c1 01	 add	 ecx, 1
  00079	89 8d f0 fb ff
	ff		 mov	 DWORD PTR _pBuf$[ebp], ecx
$LN2@changeToAb:

; 808  : 		while (*pBuf == '\\' || *pBuf == '/') {

  0007f	8b 95 f0 fb ff
	ff		 mov	 edx, DWORD PTR _pBuf$[ebp]
  00085	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00088	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  0008b	74 0e		 je	 SHORT $LN5@changeToAb
  0008d	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _pBuf$[ebp]
  00093	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00096	83 fa 2f	 cmp	 edx, 47			; 0000002fH
  00099	75 1a		 jne	 SHORT $LN3@changeToAb
$LN5@changeToAb:

; 809  : 			*pBuf = g_s;

  0009b	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _pBuf$[ebp]
  000a1	c6 00 5c	 mov	 BYTE PTR [eax], 92	; 0000005cH

; 810  : 			pBuf++;

  000a4	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _pBuf$[ebp]
  000aa	83 c1 01	 add	 ecx, 1
  000ad	89 8d f0 fb ff
	ff		 mov	 DWORD PTR _pBuf$[ebp], ecx

; 811  : 		}

  000b3	eb ca		 jmp	 SHORT $LN2@changeToAb
$LN3@changeToAb:

; 812  : 		nRes = _stprintf(ret, _T("%s%s"), g_pWorkDir, pBuf);

  000b5	8b 95 f0 fb ff
	ff		 mov	 edx, DWORD PTR _pBuf$[ebp]
  000bb	52		 push	 edx
  000bc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pWorkDir@@3PADA ; g_pWorkDir
  000c1	50		 push	 eax
  000c2	68 00 00 00 00	 push	 OFFSET $SG86957
  000c7	8b 4d 08	 mov	 ecx, DWORD PTR _ret$[ebp]
  000ca	51		 push	 ecx
  000cb	e8 00 00 00 00	 call	 _sprintf
  000d0	83 c4 10	 add	 esp, 16			; 00000010H
  000d3	89 85 ec fb ff
	ff		 mov	 DWORD PTR _nRes$[ebp], eax

; 813  : 		ret[nRes] = 0;

  000d9	8b 55 08	 mov	 edx, DWORD PTR _ret$[ebp]
  000dc	03 95 ec fb ff
	ff		 add	 edx, DWORD PTR _nRes$[ebp]
  000e2	c6 02 00	 mov	 BYTE PTR [edx], 0
$LN1@changeToAb:

; 814  : 	}
; 815  : }

  000e5	52		 push	 edx
  000e6	8b cd		 mov	 ecx, ebp
  000e8	50		 push	 eax
  000e9	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN9@changeToAb
  000ef	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000f4	58		 pop	 eax
  000f5	5a		 pop	 edx
  000f6	5f		 pop	 edi
  000f7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fa	33 cd		 xor	 ecx, ebp
  000fc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00101	81 c4 14 04 00
	00		 add	 esp, 1044		; 00000414H
  00107	3b ec		 cmp	 ebp, esp
  00109	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0010e	8b e5		 mov	 esp, ebp
  00110	5d		 pop	 ebp
  00111	c3		 ret	 0
  00112	66 90		 npad	 2
$LN9@changeToAb:
  00114	01 00 00 00	 DD	 1
  00118	00 00 00 00	 DD	 $LN8@changeToAb
$LN8@changeToAb:
  0011c	f8 fb ff ff	 DD	 -1032			; fffffbf8H
  00120	00 04 00 00	 DD	 1024			; 00000400H
  00124	00 00 00 00	 DD	 $LN7@changeToAb
$LN7@changeToAb:
  00128	73		 DB	 115			; 00000073H
  00129	7a		 DB	 122			; 0000007aH
  0012a	42		 DB	 66			; 00000042H
  0012b	75		 DB	 117			; 00000075H
  0012c	66		 DB	 102			; 00000066H
  0012d	00		 DB	 0
?changeToAbsolutePathFile@@YAXPADPBD@Z ENDP		; changeToAbsolutePathFile
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comlogger.cpp
_TEXT	SEGMENT
_nRes$ = -1044						; size = 4
_pBuf$ = -1040						; size = 4
_szBuf$ = -1032						; size = 1024
__$ArrayPad$ = -4					; size = 4
_ret$ = 8						; size = 4
_path$ = 12						; size = 4
?changeToAbsolutePath@@YAXPADPBD@Z PROC			; changeToAbsolutePath

; 818  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 04 00
	00		 sub	 esp, 1044		; 00000414H
  00009	57		 push	 edi
  0000a	8d bd ec fb ff
	ff		 lea	 edi, DWORD PTR [ebp-1044]
  00010	b9 05 01 00 00	 mov	 ecx, 261		; 00000105H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 819  : 	TCHAR szBuf[1024];
; 820  : 	TCHAR *pBuf = (TCHAR *)szBuf;

  00026	8d 85 f8 fb ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  0002c	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _pBuf$[ebp], eax

; 821  : 	_tcscpy(szBuf, path);

  00032	8b 4d 0c	 mov	 ecx, DWORD PTR _path$[ebp]
  00035	51		 push	 ecx
  00036	8d 95 f8 fb ff
	ff		 lea	 edx, DWORD PTR _szBuf$[ebp]
  0003c	52		 push	 edx
  0003d	e8 00 00 00 00	 call	 _strcpy
  00042	83 c4 08	 add	 esp, 8

; 822  : 	int nRes=0;

  00045	c7 85 ec fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _nRes$[ebp], 0

; 823  : 	CEnv::initSystem();

  0004f	6a 00		 push	 0
  00051	e8 00 00 00 00	 call	 ?initSystem@CEnv@@SAHPAD@Z ; CEnv::initSystem
  00056	83 c4 04	 add	 esp, 4

; 824  : 	if (pBuf[0] == '~') {

  00059	b8 01 00 00 00	 mov	 eax, 1
  0005e	6b c8 00	 imul	 ecx, eax, 0
  00061	8b 95 f0 fb ff
	ff		 mov	 edx, DWORD PTR _pBuf$[ebp]
  00067	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  0006b	83 f8 7e	 cmp	 eax, 126		; 0000007eH
  0006e	0f 85 c5 00 00
	00		 jne	 $LN1@changeToAb

; 825  : 		pBuf++;

  00074	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _pBuf$[ebp]
  0007a	83 c1 01	 add	 ecx, 1
  0007d	89 8d f0 fb ff
	ff		 mov	 DWORD PTR _pBuf$[ebp], ecx
$LN2@changeToAb:

; 826  : 		while (*pBuf == '\\' || *pBuf == '/') {

  00083	8b 95 f0 fb ff
	ff		 mov	 edx, DWORD PTR _pBuf$[ebp]
  00089	0f be 02	 movsx	 eax, BYTE PTR [edx]
  0008c	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  0008f	74 0e		 je	 SHORT $LN5@changeToAb
  00091	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _pBuf$[ebp]
  00097	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0009a	83 fa 2f	 cmp	 edx, 47			; 0000002fH
  0009d	75 1a		 jne	 SHORT $LN3@changeToAb
$LN5@changeToAb:

; 827  : 			*pBuf = g_s;

  0009f	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _pBuf$[ebp]
  000a5	c6 00 5c	 mov	 BYTE PTR [eax], 92	; 0000005cH

; 828  : 			pBuf++;

  000a8	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _pBuf$[ebp]
  000ae	83 c1 01	 add	 ecx, 1
  000b1	89 8d f0 fb ff
	ff		 mov	 DWORD PTR _pBuf$[ebp], ecx

; 829  : 		}

  000b7	eb ca		 jmp	 SHORT $LN2@changeToAb
$LN3@changeToAb:

; 830  : 		nRes = _stprintf(ret, _T("%s%s"), g_pWorkDir, pBuf);

  000b9	8b 95 f0 fb ff
	ff		 mov	 edx, DWORD PTR _pBuf$[ebp]
  000bf	52		 push	 edx
  000c0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pWorkDir@@3PADA ; g_pWorkDir
  000c5	50		 push	 eax
  000c6	68 00 00 00 00	 push	 OFFSET $SG86970
  000cb	8b 4d 08	 mov	 ecx, DWORD PTR _ret$[ebp]
  000ce	51		 push	 ecx
  000cf	e8 00 00 00 00	 call	 _sprintf
  000d4	83 c4 10	 add	 esp, 16			; 00000010H
  000d7	89 85 ec fb ff
	ff		 mov	 DWORD PTR _nRes$[ebp], eax

; 831  : 		pBuf = ret+(nRes - 1);

  000dd	8b 95 ec fb ff
	ff		 mov	 edx, DWORD PTR _nRes$[ebp]
  000e3	8b 45 08	 mov	 eax, DWORD PTR _ret$[ebp]
  000e6	8d 4c 10 ff	 lea	 ecx, DWORD PTR [eax+edx-1]
  000ea	89 8d f0 fb ff
	ff		 mov	 DWORD PTR _pBuf$[ebp], ecx

; 832  : 		if(*pBuf == '\\' || *pBuf == '/') *pBuf = g_s;

  000f0	8b 95 f0 fb ff
	ff		 mov	 edx, DWORD PTR _pBuf$[ebp]
  000f6	0f be 02	 movsx	 eax, BYTE PTR [edx]
  000f9	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  000fc	74 0e		 je	 SHORT $LN8@changeToAb
  000fe	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _pBuf$[ebp]
  00104	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00107	83 fa 2f	 cmp	 edx, 47			; 0000002fH
  0010a	75 0b		 jne	 SHORT $LN6@changeToAb
$LN8@changeToAb:
  0010c	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _pBuf$[ebp]
  00112	c6 00 5c	 mov	 BYTE PTR [eax], 92	; 0000005cH
  00115	eb 18		 jmp	 SHORT $LN7@changeToAb
$LN6@changeToAb:

; 833  : 		else { pBuf++; *pBuf = g_s;	}

  00117	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _pBuf$[ebp]
  0011d	83 c1 01	 add	 ecx, 1
  00120	89 8d f0 fb ff
	ff		 mov	 DWORD PTR _pBuf$[ebp], ecx
  00126	8b 95 f0 fb ff
	ff		 mov	 edx, DWORD PTR _pBuf$[ebp]
  0012c	c6 02 5c	 mov	 BYTE PTR [edx], 92	; 0000005cH
$LN7@changeToAb:

; 834  : 		*(pBuf + 1) = 0;

  0012f	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _pBuf$[ebp]
  00135	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0
$LN1@changeToAb:

; 835  : 	}
; 836  : }

  00139	52		 push	 edx
  0013a	8b cd		 mov	 ecx, ebp
  0013c	50		 push	 eax
  0013d	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN12@changeToAb
  00143	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00148	58		 pop	 eax
  00149	5a		 pop	 edx
  0014a	5f		 pop	 edi
  0014b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0014e	33 cd		 xor	 ecx, ebp
  00150	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00155	81 c4 14 04 00
	00		 add	 esp, 1044		; 00000414H
  0015b	3b ec		 cmp	 ebp, esp
  0015d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00162	8b e5		 mov	 esp, ebp
  00164	5d		 pop	 ebp
  00165	c3		 ret	 0
  00166	66 90		 npad	 2
$LN12@changeToAb:
  00168	01 00 00 00	 DD	 1
  0016c	00 00 00 00	 DD	 $LN11@changeToAb
$LN11@changeToAb:
  00170	f8 fb ff ff	 DD	 -1032			; fffffbf8H
  00174	00 04 00 00	 DD	 1024			; 00000400H
  00178	00 00 00 00	 DD	 $LN10@changeToAb
$LN10@changeToAb:
  0017c	73		 DB	 115			; 00000073H
  0017d	7a		 DB	 122			; 0000007aH
  0017e	42		 DB	 66			; 00000042H
  0017f	75		 DB	 117			; 00000075H
  00180	66		 DB	 102			; 00000066H
  00181	00		 DB	 0
?changeToAbsolutePath@@YAXPADPBD@Z ENDP			; changeToAbsolutePath
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?__autoclassinit2@CLogger@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@CLogger@@QAEXI@Z PROC			; CLogger::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR _classSize$[ebp]
  00011	50		 push	 eax
  00012	6a 00		 push	 0
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 _memset
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00020	83 c4 04	 add	 esp, 4
  00023	3b ec		 cmp	 ebp, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?__autoclassinit2@CLogger@@QAEXI@Z ENDP			; CLogger::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comlogger.cpp
_TEXT	SEGMENT
_bres$ = -273						; size = 1
_szFileName$ = -268					; size = 256
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_pFileName$ = 8						; size = 4
_nSeq$ = 12						; size = 4
?__openLogger@CLogger@@AAEXPBDH@Z PROC			; CLogger::__openLogger
; _this$ = ecx

; 429  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	51		 push	 ecx
  0000c	8d bd ec fe ff
	ff		 lea	 edi, DWORD PTR [ebp-276]
  00012	b9 45 00 00 00	 mov	 ecx, 69			; 00000045H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	59		 pop	 ecx
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c5		 xor	 eax, ebp
  00026	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00029	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 430  : 	// 기본적으로 현 파일 닫음
; 431  : 	TCHAR szFileName[256];
; 432  : 	bool bres;
; 433  : 
; 434  : 	//m_cLock.enter();
; 435  : 
; 436  : 	if (m_hFile) {

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	83 78 58 00	 cmp	 DWORD PTR [eax+88], 0
  00033	74 30		 je	 SHORT $LN2@openLogger

; 437  : 		clearLogFlag(IS_LOG_OPEN);

  00035	68 00 00 04 00	 push	 262144			; 00040000H
  0003a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?clearLogFlag@CLogger@@QAEXW4E_LOG_FLAG@@@Z ; CLogger::clearLogFlag

; 438  : 		fclose(m_hFile); m_hFile = NULL;

  00042	8b f4		 mov	 esi, esp
  00044	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	8b 51 58	 mov	 edx, DWORD PTR [ecx+88]
  0004a	52		 push	 edx
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00051	83 c4 04	 add	 esp, 4
  00054	3b f4		 cmp	 esi, esp
  00056	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [eax+88], 0
$LN2@openLogger:

; 439  : 	}
; 440  : 
; 441  : 	memset(szFileName, 0, sizeof(szFileName));

  00065	68 00 01 00 00	 push	 256			; 00000100H
  0006a	6a 00		 push	 0
  0006c	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _szFileName$[ebp]
  00072	51		 push	 ecx
  00073	e8 00 00 00 00	 call	 _memset
  00078	83 c4 0c	 add	 esp, 12			; 0000000cH

; 442  : 	if (nSeq) { // 기존 파일 이름을 변경.

  0007b	83 7d 0c 00	 cmp	 DWORD PTR _nSeq$[ebp], 0
  0007f	74 47		 je	 SHORT $LN3@openLogger

; 443  : 		_stprintf(szFileName, _T("%s.%d"), pFileName, nSeq); // pFileName == m_pFName

  00081	8b 55 0c	 mov	 edx, DWORD PTR _nSeq$[ebp]
  00084	52		 push	 edx
  00085	8b 45 08	 mov	 eax, DWORD PTR _pFileName$[ebp]
  00088	50		 push	 eax
  00089	68 00 00 00 00	 push	 OFFSET $SG86719
  0008e	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _szFileName$[ebp]
  00094	51		 push	 ecx
  00095	e8 00 00 00 00	 call	 _sprintf
  0009a	83 c4 10	 add	 esp, 16			; 00000010H

; 444  : 
; 445  : 		bres = CFileUtil::renameFile(pFileName, szFileName);

  0009d	8d 95 f4 fe ff
	ff		 lea	 edx, DWORD PTR _szFileName$[ebp]
  000a3	52		 push	 edx
  000a4	8b 45 08	 mov	 eax, DWORD PTR _pFileName$[ebp]
  000a7	50		 push	 eax
  000a8	e8 00 00 00 00	 call	 ?renameFile@CFileUtil@@SA_NPBD0@Z ; CFileUtil::renameFile
  000ad	83 c4 08	 add	 esp, 8
  000b0	88 85 ef fe ff
	ff		 mov	 BYTE PTR _bres$[ebp], al

; 446  : 		// 기존 파일 이름으로 아래에서 새로 생성하여 파일 오픈.
; 447  : 		if (!bres) {

  000b6	0f b6 8d ef fe
	ff ff		 movzx	 ecx, BYTE PTR _bres$[ebp]
  000bd	85 c9		 test	 ecx, ecx
  000bf	75 05		 jne	 SHORT $LN5@openLogger

; 448  : 			//m_cLock.leave();
; 449  : 			return;

  000c1	e9 b4 00 00 00	 jmp	 $LN1@openLogger
$LN5@openLogger:

; 450  : 		}		
; 451  : 	}
; 452  : 	else {

  000c6	eb 3e		 jmp	 SHORT $LN4@openLogger
$LN3@openLogger:

; 453  : 		if (m_pFName) free(m_pFName);

  000c8	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000cb	83 7a 5c 00	 cmp	 DWORD PTR [edx+92], 0
  000cf	74 19		 je	 SHORT $LN6@openLogger
  000d1	8b f4		 mov	 esi, esp
  000d3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000d6	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  000d9	51		 push	 ecx
  000da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  000e0	83 c4 04	 add	 esp, 4
  000e3	3b f4		 cmp	 esi, esp
  000e5	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN6@openLogger:

; 454  : 		m_pFName = _tcsdup(pFileName);

  000ea	8b f4		 mov	 esi, esp
  000ec	8b 55 08	 mov	 edx, DWORD PTR _pFileName$[ebp]
  000ef	52		 push	 edx
  000f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___strdup
  000f6	83 c4 04	 add	 esp, 4
  000f9	3b f4		 cmp	 esi, esp
  000fb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00100	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00103	89 41 5c	 mov	 DWORD PTR [ecx+92], eax
$LN4@openLogger:

; 455  : 	}
; 456  : 
; 457  : 	bres = CFileUtil::MakeDirectory(pFileName);

  00106	8b 55 08	 mov	 edx, DWORD PTR _pFileName$[ebp]
  00109	52		 push	 edx
  0010a	e8 00 00 00 00	 call	 ?MakeDirectory@CFileUtil@@SA_NPBD@Z ; CFileUtil::MakeDirectory
  0010f	83 c4 04	 add	 esp, 4
  00112	88 85 ef fe ff
	ff		 mov	 BYTE PTR _bres$[ebp], al

; 458  : 
; 459  : 	if (bres) {

  00118	0f b6 85 ef fe
	ff ff		 movzx	 eax, BYTE PTR _bres$[ebp]
  0011f	85 c0		 test	 eax, eax
  00121	74 57		 je	 SHORT $LN1@openLogger

; 460  : 		m_hFile = _tfopen(pFileName, _T("a+"));

  00123	8b f4		 mov	 esi, esp
  00125	68 00 00 00 00	 push	 OFFSET $SG86723
  0012a	8b 4d 08	 mov	 ecx, DWORD PTR _pFileName$[ebp]
  0012d	51		 push	 ecx
  0012e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00134	83 c4 08	 add	 esp, 8
  00137	3b f4		 cmp	 esi, esp
  00139	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0013e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00141	89 42 58	 mov	 DWORD PTR [edx+88], eax

; 461  : 		if (m_hFile == NULL) {

  00144	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00147	83 78 58 00	 cmp	 DWORD PTR [eax+88], 0
  0014b	75 13		 jne	 SHORT $LN8@openLogger

; 462  : 			_tprintf(_T("Can't create log file [%s]\n"), pFileName);

  0014d	8b 4d 08	 mov	 ecx, DWORD PTR _pFileName$[ebp]
  00150	51		 push	 ecx
  00151	68 00 00 00 00	 push	 OFFSET $SG86725
  00156	e8 00 00 00 00	 call	 _printf
  0015b	83 c4 08	 add	 esp, 8

; 463  : 			//m_cLock.leave();
; 464  : 			return;

  0015e	eb 1a		 jmp	 SHORT $LN1@openLogger
$LN8@openLogger:

; 465  : 		}
; 466  : 
; 467  : 		m_nLogSize = 0;

  00160	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00163	c7 82 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+132], 0

; 468  : 		setLogFlag(IS_LOG_OPEN);

  0016d	68 00 00 04 00	 push	 262144			; 00040000H
  00172	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00175	e8 00 00 00 00	 call	 ?setLogFlag@CLogger@@QAEXW4E_LOG_FLAG@@@Z ; CLogger::setLogFlag
$LN1@openLogger:

; 469  : 	}
; 470  : 	//m_cLock.leave();
; 471  : }

  0017a	52		 push	 edx
  0017b	8b cd		 mov	 ecx, ebp
  0017d	50		 push	 eax
  0017e	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN12@openLogger
  00184	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00189	58		 pop	 eax
  0018a	5a		 pop	 edx
  0018b	5f		 pop	 edi
  0018c	5e		 pop	 esi
  0018d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00190	33 cd		 xor	 ecx, ebp
  00192	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00197	81 c4 14 01 00
	00		 add	 esp, 276		; 00000114H
  0019d	3b ec		 cmp	 ebp, esp
  0019f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001a4	8b e5		 mov	 esp, ebp
  001a6	5d		 pop	 ebp
  001a7	c2 08 00	 ret	 8
  001aa	66 90		 npad	 2
$LN12@openLogger:
  001ac	01 00 00 00	 DD	 1
  001b0	00 00 00 00	 DD	 $LN11@openLogger
$LN11@openLogger:
  001b4	f4 fe ff ff	 DD	 -268			; fffffef4H
  001b8	00 01 00 00	 DD	 256			; 00000100H
  001bc	00 00 00 00	 DD	 $LN10@openLogger
$LN10@openLogger:
  001c0	73		 DB	 115			; 00000073H
  001c1	7a		 DB	 122			; 0000007aH
  001c2	46		 DB	 70			; 00000046H
  001c3	69		 DB	 105			; 00000069H
  001c4	6c		 DB	 108			; 0000006cH
  001c5	65		 DB	 101			; 00000065H
  001c6	4e		 DB	 78			; 0000004eH
  001c7	61		 DB	 97			; 00000061H
  001c8	6d		 DB	 109			; 0000006dH
  001c9	65		 DB	 101			; 00000065H
  001ca	00		 DB	 0
?__openLogger@CLogger@@AAEXPBDH@Z ENDP			; CLogger::__openLogger
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comlogger.cpp
_TEXT	SEGMENT
tv94 = -100						; size = 4
_stFilter$2 = -92					; size = 8
_stDelInfo$3 = -76					; size = 12
_cFileTime$ = -56					; size = 8
_basic$ = -40						; size = 8
_t$ = -28						; size = 8
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?checkDeleteProc@CLogger@@AAEXXZ PROC			; CLogger::checkDeleteProc
; _this$ = ecx

; 720  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?checkDeleteProc@CLogger@@AAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 58	 sub	 esp, 88			; 00000058H
  00014	57		 push	 edi
  00015	51		 push	 ecx
  00016	8d 7d 9c	 lea	 edi, DWORD PTR [ebp-100]
  00019	b9 16 00 00 00	 mov	 ecx, 22			; 00000016H
  0001e	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00023	f3 ab		 rep stosd
  00025	59		 pop	 ecx
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	33 c5		 xor	 eax, ebp
  0002d	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00030	50		 push	 eax
  00031	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00034	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003a	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 721  : 	time_t t, basic;
; 722  : 	CFileTime cFileTime;

  0003d	8d 4d c8	 lea	 ecx, DWORD PTR _cFileTime$[ebp]
  00040	e8 00 00 00 00	 call	 ??0CFileTime@@QAE@XZ	; CFileTime::CFileTime
  00045	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 723  : 	t = time(NULL);

  0004c	6a 00		 push	 0
  0004e	e8 00 00 00 00	 call	 _time
  00053	83 c4 04	 add	 esp, 4
  00056	89 45 e4	 mov	 DWORD PTR _t$[ebp], eax
  00059	89 55 e8	 mov	 DWORD PTR _t$[ebp+4], edx

; 724  : 	if (m_tDeleteGoal <= t) { // proc delete

  0005c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	89 45 9c	 mov	 DWORD PTR tv94[ebp], eax
  00062	8b 4d 9c	 mov	 ecx, DWORD PTR tv94[ebp]
  00065	8b 91 cc 00 00
	00		 mov	 edx, DWORD PTR [ecx+204]
  0006b	3b 55 e8	 cmp	 edx, DWORD PTR _t$[ebp+4]
  0006e	0f 8f 87 00 00
	00		 jg	 $LN2@checkDelet
  00074	7c 0e		 jl	 SHORT $LN5@checkDelet
  00076	8b 45 9c	 mov	 eax, DWORD PTR tv94[ebp]
  00079	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]
  0007f	3b 4d e4	 cmp	 ecx, DWORD PTR _t$[ebp]
  00082	77 77		 ja	 SHORT $LN2@checkDelet
$LN5@checkDelet:

; 725  : 		basic = t - m_nDeleteInterval;

  00084	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00087	8b 82 d0 00 00
	00		 mov	 eax, DWORD PTR [edx+208]
  0008d	99		 cdq
  0008e	8b 4d e4	 mov	 ecx, DWORD PTR _t$[ebp]
  00091	2b c8		 sub	 ecx, eax
  00093	8b 45 e8	 mov	 eax, DWORD PTR _t$[ebp+4]
  00096	1b c2		 sbb	 eax, edx
  00098	89 4d d8	 mov	 DWORD PTR _basic$[ebp], ecx
  0009b	89 45 dc	 mov	 DWORD PTR _basic$[ebp+4], eax

; 726  : 		cFileTime.setFileTime(&basic);

  0009e	8d 4d d8	 lea	 ecx, DWORD PTR _basic$[ebp]
  000a1	51		 push	 ecx
  000a2	8d 4d c8	 lea	 ecx, DWORD PTR _cFileTime$[ebp]
  000a5	e8 00 00 00 00	 call	 ?setFileTime@CFileTime@@QAEHPA_J@Z ; CFileTime::setFileTime

; 727  : 		STDelInfo stDelInfo;
; 728  : 		STFilterData stFilter;
; 729  : 		stDelInfo.init(m_pLogDir, true, true);

  000aa	6a 00		 push	 0
  000ac	6a 01		 push	 1
  000ae	6a 01		 push	 1
  000b0	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000b3	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  000b6	50		 push	 eax
  000b7	8d 4d b4	 lea	 ecx, DWORD PTR _stDelInfo$3[ebp]
  000ba	e8 00 00 00 00	 call	 ?init@STDelInfo@@QAEXPAD_N1PAX@Z ; STDelInfo::init

; 730  : 		stFilter.pData = &cFileTime;

  000bf	8d 4d c8	 lea	 ecx, DWORD PTR _cFileTime$[ebp]
  000c2	89 4d a8	 mov	 DWORD PTR _stFilter$2[ebp+4], ecx

; 731  : 		stFilter.pFunc = filter_dateTimeCompare;

  000c5	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _stFilter$2[ebp], OFFSET ?filter_dateTimeCompare@@YA_NPADPAX1@Z ; filter_dateTimeCompare

; 732  : 		CFileUtil::delDirectory(&stDelInfo, &stFilter);

  000cc	8d 55 a4	 lea	 edx, DWORD PTR _stFilter$2[ebp]
  000cf	52		 push	 edx
  000d0	8d 45 b4	 lea	 eax, DWORD PTR _stDelInfo$3[ebp]
  000d3	50		 push	 eax
  000d4	e8 00 00 00 00	 call	 ?delDirectory@CFileUtil@@SAHPAUSTDelInfo@@PAUSTFilterData@@@Z ; CFileUtil::delDirectory
  000d9	83 c4 08	 add	 esp, 8

; 733  : 		m_tDeleteGoal = t + m_nDeleteInterval;

  000dc	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000df	8b 81 d0 00 00
	00		 mov	 eax, DWORD PTR [ecx+208]
  000e5	99		 cdq
  000e6	03 45 e4	 add	 eax, DWORD PTR _t$[ebp]
  000e9	13 55 e8	 adc	 edx, DWORD PTR _t$[ebp+4]
  000ec	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ef	89 81 c8 00 00
	00		 mov	 DWORD PTR [ecx+200], eax
  000f5	89 91 cc 00 00
	00		 mov	 DWORD PTR [ecx+204], edx
$LN2@checkDelet:

; 734  : 	}
; 735  : }

  000fb	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00102	8d 4d c8	 lea	 ecx, DWORD PTR _cFileTime$[ebp]
  00105	e8 00 00 00 00	 call	 ??1CFileTime@@QAE@XZ	; CFileTime::~CFileTime
  0010a	52		 push	 edx
  0010b	8b cd		 mov	 ecx, ebp
  0010d	50		 push	 eax
  0010e	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN12@checkDelet
  00114	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00119	58		 pop	 eax
  0011a	5a		 pop	 edx
  0011b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0011e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00125	59		 pop	 ecx
  00126	5f		 pop	 edi
  00127	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0012a	33 cd		 xor	 ecx, ebp
  0012c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00131	83 c4 64	 add	 esp, 100		; 00000064H
  00134	3b ec		 cmp	 ebp, esp
  00136	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0013b	8b e5		 mov	 esp, ebp
  0013d	5d		 pop	 ebp
  0013e	c3		 ret	 0
  0013f	90		 npad	 1
$LN12@checkDelet:
  00140	04 00 00 00	 DD	 4
  00144	00 00 00 00	 DD	 $LN11@checkDelet
$LN11@checkDelet:
  00148	d8 ff ff ff	 DD	 -40			; ffffffd8H
  0014c	08 00 00 00	 DD	 8
  00150	00 00 00 00	 DD	 $LN6@checkDelet
  00154	c8 ff ff ff	 DD	 -56			; ffffffc8H
  00158	08 00 00 00	 DD	 8
  0015c	00 00 00 00	 DD	 $LN7@checkDelet
  00160	b4 ff ff ff	 DD	 -76			; ffffffb4H
  00164	0c 00 00 00	 DD	 12			; 0000000cH
  00168	00 00 00 00	 DD	 $LN8@checkDelet
  0016c	a4 ff ff ff	 DD	 -92			; ffffffa4H
  00170	08 00 00 00	 DD	 8
  00174	00 00 00 00	 DD	 $LN9@checkDelet
$LN9@checkDelet:
  00178	73		 DB	 115			; 00000073H
  00179	74		 DB	 116			; 00000074H
  0017a	46		 DB	 70			; 00000046H
  0017b	69		 DB	 105			; 00000069H
  0017c	6c		 DB	 108			; 0000006cH
  0017d	74		 DB	 116			; 00000074H
  0017e	65		 DB	 101			; 00000065H
  0017f	72		 DB	 114			; 00000072H
  00180	00		 DB	 0
$LN8@checkDelet:
  00181	73		 DB	 115			; 00000073H
  00182	74		 DB	 116			; 00000074H
  00183	44		 DB	 68			; 00000044H
  00184	65		 DB	 101			; 00000065H
  00185	6c		 DB	 108			; 0000006cH
  00186	49		 DB	 73			; 00000049H
  00187	6e		 DB	 110			; 0000006eH
  00188	66		 DB	 102			; 00000066H
  00189	6f		 DB	 111			; 0000006fH
  0018a	00		 DB	 0
$LN7@checkDelet:
  0018b	63		 DB	 99			; 00000063H
  0018c	46		 DB	 70			; 00000046H
  0018d	69		 DB	 105			; 00000069H
  0018e	6c		 DB	 108			; 0000006cH
  0018f	65		 DB	 101			; 00000065H
  00190	54		 DB	 84			; 00000054H
  00191	69		 DB	 105			; 00000069H
  00192	6d		 DB	 109			; 0000006dH
  00193	65		 DB	 101			; 00000065H
  00194	00		 DB	 0
$LN6@checkDelet:
  00195	62		 DB	 98			; 00000062H
  00196	61		 DB	 97			; 00000061H
  00197	73		 DB	 115			; 00000073H
  00198	69		 DB	 105			; 00000069H
  00199	63		 DB	 99			; 00000063H
  0019a	00		 DB	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?checkDeleteProc@CLogger@@AAEXXZ$0:
  00000	8d 4d c8	 lea	 ecx, DWORD PTR _cFileTime$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CFileTime@@QAE@XZ	; CFileTime::~CFileTime
__ehhandler$?checkDeleteProc@CLogger@@AAEXXZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?checkDeleteProc@CLogger@@AAEXXZ
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?checkDeleteProc@CLogger@@AAEXXZ ENDP			; CLogger::checkDeleteProc
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comlogger.cpp
_TEXT	SEGMENT
$T1 = -72						; size = 4
_i$ = -68						; size = 4
_nNum$ = -64						; size = 4
_nUnitSecond$ = -60					; size = 4
_nStrLen$ = -56						; size = 4
_chKeepFileUnit$ = -49					; size = 1
_szBuf$ = -44						; size = 32
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_pValue$ = 8						; size = 4
?GetKeepInfo@CLogger@@AAEHPBD@Z PROC			; CLogger::GetKeepInfo
; _this$ = ecx

; 753  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	51		 push	 ecx
  00009	8d 7d b8	 lea	 edi, DWORD PTR [ebp-72]
  0000c	b9 12 00 00 00	 mov	 ecx, 18			; 00000012H
  00011	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00016	f3 ab		 rep stosd
  00018	59		 pop	 ecx
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00023	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 754  : 	char szBuf[32];
; 755  : 	char chKeepFileUnit;
; 756  : 	int nStrLen;
; 757  : 	int nUnitSecond, nNum;
; 758  : 
; 759  : 	strcpy(szBuf, pValue);

  00026	8b 45 08	 mov	 eax, DWORD PTR _pValue$[ebp]
  00029	50		 push	 eax
  0002a	8d 4d d4	 lea	 ecx, DWORD PTR _szBuf$[ebp]
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 _strcpy
  00033	83 c4 08	 add	 esp, 8

; 760  : 	nStrLen = (int)strlen(szBuf);

  00036	8d 55 d4	 lea	 edx, DWORD PTR _szBuf$[ebp]
  00039	52		 push	 edx
  0003a	e8 00 00 00 00	 call	 _strlen
  0003f	83 c4 04	 add	 esp, 4
  00042	89 45 c8	 mov	 DWORD PTR _nStrLen$[ebp], eax

; 761  : 	if (nStrLen < 2)

  00045	83 7d c8 02	 cmp	 DWORD PTR _nStrLen$[ebp], 2
  00049	7d 15		 jge	 SHORT $LN5@GetKeepInf

; 762  : 	{
; 763  : 		printf("GetKeepInfo nStrLen < 2\n");

  0004b	68 00 00 00 00	 push	 OFFSET $SG86930
  00050	e8 00 00 00 00	 call	 _printf
  00055	83 c4 04	 add	 esp, 4

; 764  : 		return -1;

  00058	83 c8 ff	 or	 eax, -1
  0005b	e9 37 01 00 00	 jmp	 $LN20@GetKeepInf
$LN5@GetKeepInf:

; 765  : 	}
; 766  : 
; 767  : 	nStrLen = nStrLen - 1;

  00060	8b 45 c8	 mov	 eax, DWORD PTR _nStrLen$[ebp]
  00063	83 e8 01	 sub	 eax, 1
  00066	89 45 c8	 mov	 DWORD PTR _nStrLen$[ebp], eax

; 768  : 	chKeepFileUnit = szBuf[nStrLen];

  00069	8b 4d c8	 mov	 ecx, DWORD PTR _nStrLen$[ebp]
  0006c	8a 54 0d d4	 mov	 dl, BYTE PTR _szBuf$[ebp+ecx]
  00070	88 55 cf	 mov	 BYTE PTR _chKeepFileUnit$[ebp], dl

; 769  : 	szBuf[nStrLen] = '\0';

  00073	8b 45 c8	 mov	 eax, DWORD PTR _nStrLen$[ebp]
  00076	89 45 b8	 mov	 DWORD PTR $T1[ebp], eax
  00079	83 7d b8 20	 cmp	 DWORD PTR $T1[ebp], 32	; 00000020H
  0007d	73 02		 jae	 SHORT $LN21@GetKeepInf
  0007f	eb 05		 jmp	 SHORT $LN22@GetKeepInf
$LN21@GetKeepInf:
  00081	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN22@GetKeepInf:
  00086	8b 4d b8	 mov	 ecx, DWORD PTR $T1[ebp]
  00089	c6 44 0d d4 00	 mov	 BYTE PTR _szBuf$[ebp+ecx], 0

; 770  : 
; 771  : 	int i;
; 772  : 	for (i = 0; i < nStrLen; i++) {

  0008e	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00095	eb 09		 jmp	 SHORT $LN4@GetKeepInf
$LN2@GetKeepInf:
  00097	8b 55 bc	 mov	 edx, DWORD PTR _i$[ebp]
  0009a	83 c2 01	 add	 edx, 1
  0009d	89 55 bc	 mov	 DWORD PTR _i$[ebp], edx
$LN4@GetKeepInf:
  000a0	8b 45 bc	 mov	 eax, DWORD PTR _i$[ebp]
  000a3	3b 45 c8	 cmp	 eax, DWORD PTR _nStrLen$[ebp]
  000a6	7d 26		 jge	 SHORT $LN3@GetKeepInf

; 773  : 		if ((szBuf[i] < '0') || (szBuf[i] > '9')) return -2;

  000a8	8b 4d bc	 mov	 ecx, DWORD PTR _i$[ebp]
  000ab	0f be 54 0d d4	 movsx	 edx, BYTE PTR _szBuf$[ebp+ecx]
  000b0	83 fa 30	 cmp	 edx, 48			; 00000030H
  000b3	7c 0d		 jl	 SHORT $LN7@GetKeepInf
  000b5	8b 45 bc	 mov	 eax, DWORD PTR _i$[ebp]
  000b8	0f be 4c 05 d4	 movsx	 ecx, BYTE PTR _szBuf$[ebp+eax]
  000bd	83 f9 39	 cmp	 ecx, 57			; 00000039H
  000c0	7e 0a		 jle	 SHORT $LN6@GetKeepInf
$LN7@GetKeepInf:
  000c2	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  000c7	e9 cb 00 00 00	 jmp	 $LN20@GetKeepInf
$LN6@GetKeepInf:

; 774  : 	}

  000cc	eb c9		 jmp	 SHORT $LN2@GetKeepInf
$LN3@GetKeepInf:

; 775  : 
; 776  : 	nNum = atoi(szBuf);

  000ce	8b f4		 mov	 esi, esp
  000d0	8d 55 d4	 lea	 edx, DWORD PTR _szBuf$[ebp]
  000d3	52		 push	 edx
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  000da	83 c4 04	 add	 esp, 4
  000dd	3b f4		 cmp	 esi, esp
  000df	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e4	89 45 c0	 mov	 DWORD PTR _nNum$[ebp], eax

; 777  : 
; 778  : 	if ((chKeepFileUnit == 's') || (chKeepFileUnit == 'S')) {

  000e7	0f be 45 cf	 movsx	 eax, BYTE PTR _chKeepFileUnit$[ebp]
  000eb	83 f8 73	 cmp	 eax, 115		; 00000073H
  000ee	74 09		 je	 SHORT $LN10@GetKeepInf
  000f0	0f be 4d cf	 movsx	 ecx, BYTE PTR _chKeepFileUnit$[ebp]
  000f4	83 f9 53	 cmp	 ecx, 83			; 00000053H
  000f7	75 09		 jne	 SHORT $LN8@GetKeepInf
$LN10@GetKeepInf:

; 779  : 		nUnitSecond = 1;

  000f9	c7 45 c4 01 00
	00 00		 mov	 DWORD PTR _nUnitSecond$[ebp], 1
  00100	eb 58		 jmp	 SHORT $LN9@GetKeepInf
$LN8@GetKeepInf:

; 780  : 	}
; 781  : 	else if ((chKeepFileUnit == 'm') || (chKeepFileUnit == 'M')) {

  00102	0f be 55 cf	 movsx	 edx, BYTE PTR _chKeepFileUnit$[ebp]
  00106	83 fa 6d	 cmp	 edx, 109		; 0000006dH
  00109	74 09		 je	 SHORT $LN13@GetKeepInf
  0010b	0f be 45 cf	 movsx	 eax, BYTE PTR _chKeepFileUnit$[ebp]
  0010f	83 f8 4d	 cmp	 eax, 77			; 0000004dH
  00112	75 09		 jne	 SHORT $LN11@GetKeepInf
$LN13@GetKeepInf:

; 782  : 		nUnitSecond = 60;

  00114	c7 45 c4 3c 00
	00 00		 mov	 DWORD PTR _nUnitSecond$[ebp], 60 ; 0000003cH
  0011b	eb 3d		 jmp	 SHORT $LN9@GetKeepInf
$LN11@GetKeepInf:

; 783  : 	}
; 784  : 	else if ((chKeepFileUnit == 'h') || (chKeepFileUnit == 'H')) {

  0011d	0f be 4d cf	 movsx	 ecx, BYTE PTR _chKeepFileUnit$[ebp]
  00121	83 f9 68	 cmp	 ecx, 104		; 00000068H
  00124	74 09		 je	 SHORT $LN16@GetKeepInf
  00126	0f be 55 cf	 movsx	 edx, BYTE PTR _chKeepFileUnit$[ebp]
  0012a	83 fa 48	 cmp	 edx, 72			; 00000048H
  0012d	75 09		 jne	 SHORT $LN14@GetKeepInf
$LN16@GetKeepInf:

; 785  : 		nUnitSecond = 60 * 60;

  0012f	c7 45 c4 10 0e
	00 00		 mov	 DWORD PTR _nUnitSecond$[ebp], 3600 ; 00000e10H
  00136	eb 22		 jmp	 SHORT $LN9@GetKeepInf
$LN14@GetKeepInf:

; 786  : 	}
; 787  : 	else if ((chKeepFileUnit == 'd') || (chKeepFileUnit == 'D')) {

  00138	0f be 45 cf	 movsx	 eax, BYTE PTR _chKeepFileUnit$[ebp]
  0013c	83 f8 64	 cmp	 eax, 100		; 00000064H
  0013f	74 09		 je	 SHORT $LN19@GetKeepInf
  00141	0f be 4d cf	 movsx	 ecx, BYTE PTR _chKeepFileUnit$[ebp]
  00145	83 f9 44	 cmp	 ecx, 68			; 00000044H
  00148	75 09		 jne	 SHORT $LN17@GetKeepInf
$LN19@GetKeepInf:

; 788  : 		nUnitSecond = 60 * 60 * 24;

  0014a	c7 45 c4 80 51
	01 00		 mov	 DWORD PTR _nUnitSecond$[ebp], 86400 ; 00015180H

; 789  : 	}
; 790  : 	else

  00151	eb 07		 jmp	 SHORT $LN9@GetKeepInf
$LN17@GetKeepInf:

; 791  : 	{
; 792  : 		return -5;

  00153	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  00158	eb 3d		 jmp	 SHORT $LN20@GetKeepInf
$LN9@GetKeepInf:

; 793  : 	}
; 794  : 	m_nDeleteInterval = nNum * nUnitSecond;

  0015a	8b 55 c0	 mov	 edx, DWORD PTR _nNum$[ebp]
  0015d	0f af 55 c4	 imul	 edx, DWORD PTR _nUnitSecond$[ebp]
  00161	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00164	89 90 d0 00 00
	00		 mov	 DWORD PTR [eax+208], edx

; 795  : 	m_tDeleteGoal = time(NULL) + m_nDeleteInterval;

  0016a	6a 00		 push	 0
  0016c	e8 00 00 00 00	 call	 _time
  00171	83 c4 04	 add	 esp, 4
  00174	8b c8		 mov	 ecx, eax
  00176	8b f2		 mov	 esi, edx
  00178	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0017b	8b 82 d0 00 00
	00		 mov	 eax, DWORD PTR [edx+208]
  00181	99		 cdq
  00182	03 c8		 add	 ecx, eax
  00184	13 f2		 adc	 esi, edx
  00186	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00189	89 88 c8 00 00
	00		 mov	 DWORD PTR [eax+200], ecx
  0018f	89 b0 cc 00 00
	00		 mov	 DWORD PTR [eax+204], esi

; 796  : 	return 0;

  00195	33 c0		 xor	 eax, eax
$LN20@GetKeepInf:

; 797  : }

  00197	52		 push	 edx
  00198	8b cd		 mov	 ecx, ebp
  0019a	50		 push	 eax
  0019b	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN25@GetKeepInf
  001a1	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001a6	58		 pop	 eax
  001a7	5a		 pop	 edx
  001a8	5f		 pop	 edi
  001a9	5e		 pop	 esi
  001aa	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ad	33 cd		 xor	 ecx, ebp
  001af	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b4	83 c4 48	 add	 esp, 72			; 00000048H
  001b7	3b ec		 cmp	 ebp, esp
  001b9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001be	8b e5		 mov	 esp, ebp
  001c0	5d		 pop	 ebp
  001c1	c2 04 00	 ret	 4
$LN25@GetKeepInf:
  001c4	01 00 00 00	 DD	 1
  001c8	00 00 00 00	 DD	 $LN24@GetKeepInf
$LN24@GetKeepInf:
  001cc	d4 ff ff ff	 DD	 -44			; ffffffd4H
  001d0	20 00 00 00	 DD	 32			; 00000020H
  001d4	00 00 00 00	 DD	 $LN23@GetKeepInf
$LN23@GetKeepInf:
  001d8	73		 DB	 115			; 00000073H
  001d9	7a		 DB	 122			; 0000007aH
  001da	42		 DB	 66			; 00000042H
  001db	75		 DB	 117			; 00000075H
  001dc	66		 DB	 102			; 00000066H
  001dd	00		 DB	 0
?GetKeepInfo@CLogger@@AAEHPBD@Z ENDP			; CLogger::GetKeepInfo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comlogger.cpp
_TEXT	SEGMENT
tv184 = -20						; size = 4
tv128 = -16						; size = 4
tv80 = -12						; size = 4
_nRes$ = -8						; size = 4
_this$ = -4						; size = 4
_pLogDTE$ = 8						; size = 4
?setDateTimeFormat@CLogger@@AAEXPAUSTLogDateTimeExp@@@Z PROC ; CLogger::setDateTimeFormat
; _this$ = ecx

; 367  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000e	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00011	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00014	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00017	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001a	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 368  : 	int nRes = 0;

  0001d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _nRes$[ebp], 0

; 369  : 
; 370  : 	if (pLogDTE->bBracketEnclosed) m_szHeaderFormat[nRes++] = _T('[');

  00024	8b 45 08	 mov	 eax, DWORD PTR _pLogDTE$[ebp]
  00027	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0002a	85 c9		 test	 ecx, ecx
  0002c	74 16		 je	 SHORT $LN8@setDateTim
  0002e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00031	03 55 f8	 add	 edx, DWORD PTR _nRes$[ebp]
  00034	c6 82 88 00 00
	00 5b		 mov	 BYTE PTR [edx+136], 91	; 0000005bH
  0003b	8b 45 f8	 mov	 eax, DWORD PTR _nRes$[ebp]
  0003e	83 c0 01	 add	 eax, 1
  00041	89 45 f8	 mov	 DWORD PTR _nRes$[ebp], eax
$LN8@setDateTim:

; 371  : 
; 372  : 	if (pLogDTE->nYearLen == 4) {

  00044	8b 4d 08	 mov	 ecx, DWORD PTR _pLogDTE$[ebp]
  00047	0f be 51 03	 movsx	 edx, BYTE PTR [ecx+3]
  0004b	83 fa 04	 cmp	 edx, 4
  0004e	75 79		 jne	 SHORT $LN9@setDateTim

; 373  : 		_tcscpy(m_szHeaderFormat + nRes, _T("%04d")); nRes += 4;

  00050	68 00 00 00 00	 push	 OFFSET $SG86667
  00055	8b 45 f8	 mov	 eax, DWORD PTR _nRes$[ebp]
  00058	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	8d 94 01 88 00
	00 00		 lea	 edx, DWORD PTR [ecx+eax+136]
  00062	52		 push	 edx
  00063	e8 00 00 00 00	 call	 _strcpy
  00068	83 c4 08	 add	 esp, 8
  0006b	8b 45 f8	 mov	 eax, DWORD PTR _nRes$[ebp]
  0006e	83 c0 04	 add	 eax, 4
  00071	89 45 f8	 mov	 DWORD PTR _nRes$[ebp], eax

; 374  : 		switch (pLogDTE->nLastType) {

  00074	8b 4d 08	 mov	 ecx, DWORD PTR _pLogDTE$[ebp]
  00077	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007a	89 55 f4	 mov	 DWORD PTR tv80[ebp], edx
  0007d	8b 45 f4	 mov	 eax, DWORD PTR tv80[ebp]
  00080	83 e8 01	 sub	 eax, 1
  00083	89 45 f4	 mov	 DWORD PTR tv80[ebp], eax
  00086	83 7d f4 03	 cmp	 DWORD PTR tv80[ebp], 3
  0008a	77 38		 ja	 SHORT $LN2@setDateTim
  0008c	8b 4d f4	 mov	 ecx, DWORD PTR tv80[ebp]
  0008f	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN30@setDateTim[ecx*4]
$LN11@setDateTim:

; 375  : 		case DT_SEC: m_nDateTimeFormat = LOG_DATE_YYYYMMDDHHMMSS; break;

  00096	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00099	c7 42 50 01 00
	00 00		 mov	 DWORD PTR [edx+80], 1
  000a0	eb 22		 jmp	 SHORT $LN2@setDateTim
$LN12@setDateTim:

; 376  : 		case DT_MILLISEC: m_nDateTimeFormat = LOG_DATE_YYYYMMDDHHMMSS3; break;

  000a2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a5	c7 40 50 02 00
	00 00		 mov	 DWORD PTR [eax+80], 2
  000ac	eb 16		 jmp	 SHORT $LN2@setDateTim
$LN13@setDateTim:

; 377  : 		case DT_MICROSEC: m_nDateTimeFormat = LOG_DATE_YYYYMMDDHHMMSS6; break;

  000ae	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b1	c7 41 50 03 00
	00 00		 mov	 DWORD PTR [ecx+80], 3
  000b8	eb 0a		 jmp	 SHORT $LN2@setDateTim
$LN14@setDateTim:

; 378  : 		case DT_NANOSEC: m_nDateTimeFormat = LOG_DATE_YYYYMMDDHHMMSS9; break;

  000ba	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000bd	c7 42 50 04 00
	00 00		 mov	 DWORD PTR [edx+80], 4
$LN2@setDateTim:

; 379  : 		}
; 380  : 	}
; 381  : 	else if (pLogDTE->nYearLen == 2) {

  000c4	e9 8c 00 00 00	 jmp	 $LN10@setDateTim
$LN9@setDateTim:
  000c9	8b 45 08	 mov	 eax, DWORD PTR _pLogDTE$[ebp]
  000cc	0f be 48 03	 movsx	 ecx, BYTE PTR [eax+3]
  000d0	83 f9 02	 cmp	 ecx, 2
  000d3	75 76		 jne	 SHORT $LN15@setDateTim

; 382  : 		_tcscpy(m_szHeaderFormat + nRes, _T("%s")); nRes += 2;

  000d5	68 00 00 00 00	 push	 OFFSET $SG86674
  000da	8b 55 f8	 mov	 edx, DWORD PTR _nRes$[ebp]
  000dd	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e0	8d 8c 10 88 00
	00 00		 lea	 ecx, DWORD PTR [eax+edx+136]
  000e7	51		 push	 ecx
  000e8	e8 00 00 00 00	 call	 _strcpy
  000ed	83 c4 08	 add	 esp, 8
  000f0	8b 55 f8	 mov	 edx, DWORD PTR _nRes$[ebp]
  000f3	83 c2 02	 add	 edx, 2
  000f6	89 55 f8	 mov	 DWORD PTR _nRes$[ebp], edx

; 383  : 		switch (pLogDTE->nLastType) {

  000f9	8b 45 08	 mov	 eax, DWORD PTR _pLogDTE$[ebp]
  000fc	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ff	89 4d f0	 mov	 DWORD PTR tv128[ebp], ecx
  00102	8b 55 f0	 mov	 edx, DWORD PTR tv128[ebp]
  00105	83 ea 01	 sub	 edx, 1
  00108	89 55 f0	 mov	 DWORD PTR tv128[ebp], edx
  0010b	83 7d f0 03	 cmp	 DWORD PTR tv128[ebp], 3
  0010f	77 38		 ja	 SHORT $LN4@setDateTim
  00111	8b 45 f0	 mov	 eax, DWORD PTR tv128[ebp]
  00114	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN31@setDateTim[eax*4]
$LN17@setDateTim:

; 384  : 		case DT_SEC: m_nDateTimeFormat = LOG_DATE_YYMMDDHHMMSS; break;

  0011b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0011e	c7 41 50 05 00
	00 00		 mov	 DWORD PTR [ecx+80], 5
  00125	eb 22		 jmp	 SHORT $LN4@setDateTim
$LN18@setDateTim:

; 385  : 		case DT_MILLISEC: m_nDateTimeFormat = LOG_DATE_YYMMDDHHMMSS3; break;

  00127	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0012a	c7 42 50 06 00
	00 00		 mov	 DWORD PTR [edx+80], 6
  00131	eb 16		 jmp	 SHORT $LN4@setDateTim
$LN19@setDateTim:

; 386  : 		case DT_MICROSEC: m_nDateTimeFormat = LOG_DATE_YYMMDDHHMMSS6; break;

  00133	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00136	c7 40 50 07 00
	00 00		 mov	 DWORD PTR [eax+80], 7
  0013d	eb 0a		 jmp	 SHORT $LN4@setDateTim
$LN20@setDateTim:

; 387  : 		case DT_NANOSEC: m_nDateTimeFormat = LOG_DATE_YYMMDDHHMMSS9; break;

  0013f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00142	c7 41 50 08 00
	00 00		 mov	 DWORD PTR [ecx+80], 8
$LN4@setDateTim:

; 388  : 		}
; 389  : 	}
; 390  : 	else {

  00149	eb 0a		 jmp	 SHORT $LN10@setDateTim
$LN15@setDateTim:

; 391  : 		m_nDateTimeFormat = LOG_DATE_NONE;

  0014b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0014e	c7 42 50 00 00
	00 00		 mov	 DWORD PTR [edx+80], 0
$LN10@setDateTim:

; 392  : 	}
; 393  : 
; 394  : 	if (pLogDTE->cDateDelimeter) nRes += _stprintf(m_szHeaderFormat + nRes, "%c", pLogDTE->cDateDelimeter);

  00155	8b 45 08	 mov	 eax, DWORD PTR _pLogDTE$[ebp]
  00158	0f be 48 01	 movsx	 ecx, BYTE PTR [eax+1]
  0015c	85 c9		 test	 ecx, ecx
  0015e	74 29		 je	 SHORT $LN21@setDateTim
  00160	8b 55 08	 mov	 edx, DWORD PTR _pLogDTE$[ebp]
  00163	0f be 42 01	 movsx	 eax, BYTE PTR [edx+1]
  00167	50		 push	 eax
  00168	68 00 00 00 00	 push	 OFFSET $SG86680
  0016d	8b 4d f8	 mov	 ecx, DWORD PTR _nRes$[ebp]
  00170	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00173	8d 84 0a 88 00
	00 00		 lea	 eax, DWORD PTR [edx+ecx+136]
  0017a	50		 push	 eax
  0017b	e8 00 00 00 00	 call	 _sprintf
  00180	83 c4 0c	 add	 esp, 12			; 0000000cH
  00183	03 45 f8	 add	 eax, DWORD PTR _nRes$[ebp]
  00186	89 45 f8	 mov	 DWORD PTR _nRes$[ebp], eax
$LN21@setDateTim:

; 395  : 	_tcscpy(m_szHeaderFormat + nRes, _T("%02d")); nRes += 4;

  00189	68 00 00 00 00	 push	 OFFSET $SG86681
  0018e	8b 4d f8	 mov	 ecx, DWORD PTR _nRes$[ebp]
  00191	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00194	8d 84 0a 88 00
	00 00		 lea	 eax, DWORD PTR [edx+ecx+136]
  0019b	50		 push	 eax
  0019c	e8 00 00 00 00	 call	 _strcpy
  001a1	83 c4 08	 add	 esp, 8
  001a4	8b 4d f8	 mov	 ecx, DWORD PTR _nRes$[ebp]
  001a7	83 c1 04	 add	 ecx, 4
  001aa	89 4d f8	 mov	 DWORD PTR _nRes$[ebp], ecx

; 396  : 	if (pLogDTE->cDateDelimeter) nRes += _stprintf(m_szHeaderFormat + nRes, "%c", pLogDTE->cDateDelimeter);

  001ad	8b 55 08	 mov	 edx, DWORD PTR _pLogDTE$[ebp]
  001b0	0f be 42 01	 movsx	 eax, BYTE PTR [edx+1]
  001b4	85 c0		 test	 eax, eax
  001b6	74 29		 je	 SHORT $LN22@setDateTim
  001b8	8b 4d 08	 mov	 ecx, DWORD PTR _pLogDTE$[ebp]
  001bb	0f be 51 01	 movsx	 edx, BYTE PTR [ecx+1]
  001bf	52		 push	 edx
  001c0	68 00 00 00 00	 push	 OFFSET $SG86683
  001c5	8b 45 f8	 mov	 eax, DWORD PTR _nRes$[ebp]
  001c8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001cb	8d 94 01 88 00
	00 00		 lea	 edx, DWORD PTR [ecx+eax+136]
  001d2	52		 push	 edx
  001d3	e8 00 00 00 00	 call	 _sprintf
  001d8	83 c4 0c	 add	 esp, 12			; 0000000cH
  001db	03 45 f8	 add	 eax, DWORD PTR _nRes$[ebp]
  001de	89 45 f8	 mov	 DWORD PTR _nRes$[ebp], eax
$LN22@setDateTim:

; 397  : 	_tcscpy(m_szHeaderFormat + nRes, _T("%02d ")); nRes += 5;

  001e1	68 00 00 00 00	 push	 OFFSET $SG86684
  001e6	8b 45 f8	 mov	 eax, DWORD PTR _nRes$[ebp]
  001e9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001ec	8d 94 01 88 00
	00 00		 lea	 edx, DWORD PTR [ecx+eax+136]
  001f3	52		 push	 edx
  001f4	e8 00 00 00 00	 call	 _strcpy
  001f9	83 c4 08	 add	 esp, 8
  001fc	8b 45 f8	 mov	 eax, DWORD PTR _nRes$[ebp]
  001ff	83 c0 05	 add	 eax, 5
  00202	89 45 f8	 mov	 DWORD PTR _nRes$[ebp], eax

; 398  : 
; 399  : 	if (pLogDTE->bTimeDelimeter) { _tcscpy(m_szHeaderFormat + nRes, _T("%02d:%02d:%02d")); nRes += 14; }

  00205	8b 4d 08	 mov	 ecx, DWORD PTR _pLogDTE$[ebp]
  00208	0f be 51 02	 movsx	 edx, BYTE PTR [ecx+2]
  0020c	85 d2		 test	 edx, edx
  0020e	74 26		 je	 SHORT $LN23@setDateTim
  00210	68 00 00 00 00	 push	 OFFSET $SG86687
  00215	8b 45 f8	 mov	 eax, DWORD PTR _nRes$[ebp]
  00218	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0021b	8d 94 01 88 00
	00 00		 lea	 edx, DWORD PTR [ecx+eax+136]
  00222	52		 push	 edx
  00223	e8 00 00 00 00	 call	 _strcpy
  00228	83 c4 08	 add	 esp, 8
  0022b	8b 45 f8	 mov	 eax, DWORD PTR _nRes$[ebp]
  0022e	83 c0 0e	 add	 eax, 14			; 0000000eH
  00231	89 45 f8	 mov	 DWORD PTR _nRes$[ebp], eax
  00234	eb 24		 jmp	 SHORT $LN24@setDateTim
$LN23@setDateTim:

; 400  : 	else { _tcscpy(m_szHeaderFormat + nRes, _T("%02d%02d%02d")); nRes += 12; }

  00236	68 00 00 00 00	 push	 OFFSET $SG86688
  0023b	8b 4d f8	 mov	 ecx, DWORD PTR _nRes$[ebp]
  0023e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00241	8d 84 0a 88 00
	00 00		 lea	 eax, DWORD PTR [edx+ecx+136]
  00248	50		 push	 eax
  00249	e8 00 00 00 00	 call	 _strcpy
  0024e	83 c4 08	 add	 esp, 8
  00251	8b 4d f8	 mov	 ecx, DWORD PTR _nRes$[ebp]
  00254	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00257	89 4d f8	 mov	 DWORD PTR _nRes$[ebp], ecx
$LN24@setDateTim:

; 401  : 
; 402  : 	switch (pLogDTE->nLastType) {

  0025a	8b 55 08	 mov	 edx, DWORD PTR _pLogDTE$[ebp]
  0025d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00260	89 45 ec	 mov	 DWORD PTR tv184[ebp], eax
  00263	83 7d ec 02	 cmp	 DWORD PTR tv184[ebp], 2
  00267	74 0e		 je	 SHORT $LN25@setDateTim
  00269	83 7d ec 03	 cmp	 DWORD PTR tv184[ebp], 3
  0026d	74 2e		 je	 SHORT $LN26@setDateTim
  0026f	83 7d ec 04	 cmp	 DWORD PTR tv184[ebp], 4
  00273	74 4e		 je	 SHORT $LN27@setDateTim
  00275	eb 70		 jmp	 SHORT $LN6@setDateTim
$LN25@setDateTim:

; 403  : 	case DT_MILLISEC: _tcscpy(m_szHeaderFormat + nRes, _T(".%03d")); nRes += 5; break;

  00277	68 00 00 00 00	 push	 OFFSET $SG86690
  0027c	8b 4d f8	 mov	 ecx, DWORD PTR _nRes$[ebp]
  0027f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00282	8d 84 0a 88 00
	00 00		 lea	 eax, DWORD PTR [edx+ecx+136]
  00289	50		 push	 eax
  0028a	e8 00 00 00 00	 call	 _strcpy
  0028f	83 c4 08	 add	 esp, 8
  00292	8b 4d f8	 mov	 ecx, DWORD PTR _nRes$[ebp]
  00295	83 c1 05	 add	 ecx, 5
  00298	89 4d f8	 mov	 DWORD PTR _nRes$[ebp], ecx
  0029b	eb 4a		 jmp	 SHORT $LN6@setDateTim
$LN26@setDateTim:

; 404  : 	case DT_MICROSEC: _tcscpy(m_szHeaderFormat + nRes, _T(".%06d")); nRes += 5; break;

  0029d	68 00 00 00 00	 push	 OFFSET $SG86692
  002a2	8b 55 f8	 mov	 edx, DWORD PTR _nRes$[ebp]
  002a5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002a8	8d 8c 10 88 00
	00 00		 lea	 ecx, DWORD PTR [eax+edx+136]
  002af	51		 push	 ecx
  002b0	e8 00 00 00 00	 call	 _strcpy
  002b5	83 c4 08	 add	 esp, 8
  002b8	8b 55 f8	 mov	 edx, DWORD PTR _nRes$[ebp]
  002bb	83 c2 05	 add	 edx, 5
  002be	89 55 f8	 mov	 DWORD PTR _nRes$[ebp], edx
  002c1	eb 24		 jmp	 SHORT $LN6@setDateTim
$LN27@setDateTim:

; 405  : 	case DT_NANOSEC: _tcscpy(m_szHeaderFormat + nRes, _T(".%09d")); nRes += 5; break;

  002c3	68 00 00 00 00	 push	 OFFSET $SG86694
  002c8	8b 45 f8	 mov	 eax, DWORD PTR _nRes$[ebp]
  002cb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002ce	8d 94 01 88 00
	00 00		 lea	 edx, DWORD PTR [ecx+eax+136]
  002d5	52		 push	 edx
  002d6	e8 00 00 00 00	 call	 _strcpy
  002db	83 c4 08	 add	 esp, 8
  002de	8b 45 f8	 mov	 eax, DWORD PTR _nRes$[ebp]
  002e1	83 c0 05	 add	 eax, 5
  002e4	89 45 f8	 mov	 DWORD PTR _nRes$[ebp], eax
$LN6@setDateTim:

; 406  : 	}
; 407  : 
; 408  : 	if (pLogDTE->bBracketEnclosed) m_szHeaderFormat[nRes++] = _T(']');

  002e7	8b 4d 08	 mov	 ecx, DWORD PTR _pLogDTE$[ebp]
  002ea	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  002ed	85 d2		 test	 edx, edx
  002ef	74 16		 je	 SHORT $LN28@setDateTim
  002f1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002f4	03 45 f8	 add	 eax, DWORD PTR _nRes$[ebp]
  002f7	c6 80 88 00 00
	00 5d		 mov	 BYTE PTR [eax+136], 93	; 0000005dH
  002fe	8b 4d f8	 mov	 ecx, DWORD PTR _nRes$[ebp]
  00301	83 c1 01	 add	 ecx, 1
  00304	89 4d f8	 mov	 DWORD PTR _nRes$[ebp], ecx
$LN28@setDateTim:

; 409  : 	m_szHeaderFormat[nRes] = 0;

  00307	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0030a	03 55 f8	 add	 edx, DWORD PTR _nRes$[ebp]
  0030d	c6 82 88 00 00
	00 00		 mov	 BYTE PTR [edx+136], 0

; 410  : }

  00314	83 c4 14	 add	 esp, 20			; 00000014H
  00317	3b ec		 cmp	 ebp, esp
  00319	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0031e	8b e5		 mov	 esp, ebp
  00320	5d		 pop	 ebp
  00321	c2 04 00	 ret	 4
$LN30@setDateTim:
  00324	00 00 00 00	 DD	 $LN11@setDateTim
  00328	00 00 00 00	 DD	 $LN12@setDateTim
  0032c	00 00 00 00	 DD	 $LN13@setDateTim
  00330	00 00 00 00	 DD	 $LN14@setDateTim
$LN31@setDateTim:
  00334	00 00 00 00	 DD	 $LN17@setDateTim
  00338	00 00 00 00	 DD	 $LN18@setDateTim
  0033c	00 00 00 00	 DD	 $LN19@setDateTim
  00340	00 00 00 00	 DD	 $LN20@setDateTim
?setDateTimeFormat@CLogger@@AAEXPAUSTLogDateTimeExp@@@Z ENDP ; CLogger::setDateTimeFormat
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comlogger.cpp
_TEXT	SEGMENT
_szBuf$ = -140						; size = 128
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_pTarget$ = 8						; size = 4
?setLogName@CLogger@@AAEXPAD@Z PROC			; CLogger::setLogName
; _this$ = ecx

; 738  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H
  00009	57		 push	 edi
  0000a	51		 push	 ecx
  0000b	8d bd 70 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-144]
  00011	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	59		 pop	 ecx
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 739  : 	TCHAR szBuf[128];
; 740  : 	if (m_nLogFlag & LOG_FLAG_DAILY) {

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 48 74	 mov	 ecx, DWORD PTR [eax+116]
  00031	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  00037	74 2b		 je	 SHORT $LN2@setLogName

; 741  : 		_stprintf(szBuf, _T("%s/%d_%s"), m_pLogDir, gs_today_time.date, m_pLogName);

  00039	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0003c	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  0003f	50		 push	 eax
  00040	8b 0d 18 00 00
	00		 mov	 ecx, DWORD PTR ?gs_today_time@@3USTTodayTime@@A+24
  00046	51		 push	 ecx
  00047	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0004a	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  0004d	50		 push	 eax
  0004e	68 00 00 00 00	 push	 OFFSET $SG86908
  00053	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _szBuf$[ebp]
  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 _sprintf
  0005f	83 c4 14	 add	 esp, 20			; 00000014H
  00062	eb 76		 jmp	 SHORT $LN1@setLogName
$LN2@setLogName:

; 742  : 	}
; 743  : 	else if (m_nLogFlag & LOG_FLAG_HOURLY) {

  00064	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00067	8b 42 74	 mov	 eax, DWORD PTR [edx+116]
  0006a	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  0006f	74 39		 je	 SHORT $LN4@setLogName

; 744  : 		_stprintf(szBuf, _T("%s/%d/%s_%02d.%s"), m_pLogDir, gs_today_time.date, m_pLogName, gs_today_time.hour, m_szFileExtension);

  00071	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	83 c1 68	 add	 ecx, 104		; 00000068H
  00077	51		 push	 ecx
  00078	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR ?gs_today_time@@3USTTodayTime@@A+12
  0007e	52		 push	 edx
  0007f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00082	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  00085	51		 push	 ecx
  00086	8b 15 18 00 00
	00		 mov	 edx, DWORD PTR ?gs_today_time@@3USTTodayTime@@A+24
  0008c	52		 push	 edx
  0008d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00090	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00093	51		 push	 ecx
  00094	68 00 00 00 00	 push	 OFFSET $SG86911
  00099	8d 95 74 ff ff
	ff		 lea	 edx, DWORD PTR _szBuf$[ebp]
  0009f	52		 push	 edx
  000a0	e8 00 00 00 00	 call	 _sprintf
  000a5	83 c4 1c	 add	 esp, 28			; 0000001cH
  000a8	eb 30		 jmp	 SHORT $LN1@setLogName
$LN4@setLogName:

; 745  : 	}
; 746  : 	else if (m_nLogFlag & LOG_FLAG_FILE) {

  000aa	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ad	8b 48 74	 mov	 ecx, DWORD PTR [eax+116]
  000b0	81 e1 00 08 00
	00		 and	 ecx, 2048		; 00000800H
  000b6	74 22		 je	 SHORT $LN1@setLogName

; 747  : 		_stprintf(szBuf, _T("%s/%s"), m_pLogDir, m_pLogName);

  000b8	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000bb	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  000be	50		 push	 eax
  000bf	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c2	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  000c5	52		 push	 edx
  000c6	68 00 00 00 00	 push	 OFFSET $SG86913
  000cb	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  000d1	50		 push	 eax
  000d2	e8 00 00 00 00	 call	 _sprintf
  000d7	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@setLogName:

; 748  : 	}
; 749  : }

  000da	52		 push	 edx
  000db	8b cd		 mov	 ecx, ebp
  000dd	50		 push	 eax
  000de	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN10@setLogName
  000e4	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000e9	58		 pop	 eax
  000ea	5a		 pop	 edx
  000eb	5f		 pop	 edi
  000ec	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ef	33 cd		 xor	 ecx, ebp
  000f1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f6	81 c4 90 00 00
	00		 add	 esp, 144		; 00000090H
  000fc	3b ec		 cmp	 ebp, esp
  000fe	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00103	8b e5		 mov	 esp, ebp
  00105	5d		 pop	 ebp
  00106	c2 04 00	 ret	 4
  00109	0f 1f 00	 npad	 3
$LN10@setLogName:
  0010c	01 00 00 00	 DD	 1
  00110	00 00 00 00	 DD	 $LN9@setLogName
$LN9@setLogName:
  00114	74 ff ff ff	 DD	 -140			; ffffff74H
  00118	80 00 00 00	 DD	 128			; 00000080H
  0011c	00 00 00 00	 DD	 $LN8@setLogName
$LN8@setLogName:
  00120	73		 DB	 115			; 00000073H
  00121	7a		 DB	 122			; 0000007aH
  00122	42		 DB	 66			; 00000042H
  00123	75		 DB	 117			; 00000075H
  00124	66		 DB	 102			; 00000066H
  00125	00		 DB	 0
?setLogName@CLogger@@AAEXPAD@Z ENDP			; CLogger::setLogName
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comlogger.cpp
_TEXT	SEGMENT
_nQueueMax$ = -8					; size = 4
_this$ = -4						; size = 4
_nMax$ = 8						; size = 4
?_setLoggerQueue@CLogger@@AAE_NH@Z PROC			; CLogger::_setLoggerQueue
; _this$ = ecx

; 297  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 298  : 	int nQueueMax = m_sLogQueue.capacity();

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?capacity@CQueueS@@QAEHXZ ; CQueueS::capacity
  0001f	89 45 f8	 mov	 DWORD PTR _nQueueMax$[ebp], eax

; 299  : 	if (!nQueueMax) { // empty

  00022	83 7d f8 00	 cmp	 DWORD PTR _nQueueMax$[ebp], 0
  00026	75 44		 jne	 SHORT $LN2@setLoggerQ

; 300  : 		if (!m_sLogQueue.alloc(nMax, eAlloc_Type_BufPool)) {

  00028	6a 04		 push	 4
  0002a	8b 45 08	 mov	 eax, DWORD PTR _nMax$[ebp]
  0002d	50		 push	 eax
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ?alloc@CQueueS@@QAE_NHW4E_ALLOC_TYPE@@@Z ; CQueueS::alloc
  00036	0f b6 c8	 movzx	 ecx, al
  00039	85 c9		 test	 ecx, ecx
  0003b	75 2d		 jne	 SHORT $LN4@setLoggerQ

; 301  : 			_stprintf(g_szMessage, _T("m_sLogQueue.alloc(20, eAlloc_Type_BufPool) has Failed"));

  0003d	68 00 00 00 00	 push	 OFFSET $SG86610
  00042	68 00 00 00 00	 push	 OFFSET ?g_szMessage@@3PADA ; g_szMessage
  00047	e8 00 00 00 00	 call	 _sprintf
  0004c	83 c4 08	 add	 esp, 8

; 302  : 			comErrorPrint(g_szMessage);

  0004f	68 2e 01 00 00	 push	 302			; 0000012eH
  00054	68 00 00 00 00	 push	 OFFSET $SG86611
  00059	68 00 00 00 00	 push	 OFFSET ?g_szMessage@@3PADA ; g_szMessage
  0005e	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPADPBDH@Z ; comGlobalErrorProc
  00063	83 c4 0c	 add	 esp, 12			; 0000000cH

; 303  : 			return false;

  00066	32 c0		 xor	 al, al
  00068	eb 52		 jmp	 SHORT $LN1@setLoggerQ
$LN4@setLoggerQ:

; 304  : 		}
; 305  : 	}

  0006a	eb 4e		 jmp	 SHORT $LN3@setLoggerQ
$LN2@setLoggerQ:

; 306  : 	else if (nQueueMax < nMax) {

  0006c	8b 55 f8	 mov	 edx, DWORD PTR _nQueueMax$[ebp]
  0006f	3b 55 08	 cmp	 edx, DWORD PTR _nMax$[ebp]
  00072	7d 46		 jge	 SHORT $LN3@setLoggerQ

; 307  : 		if (!m_sLogQueue.realloc(nMax, true)) {

  00074	6a 01		 push	 1
  00076	8b 45 08	 mov	 eax, DWORD PTR _nMax$[ebp]
  00079	50		 push	 eax
  0007a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	e8 00 00 00 00	 call	 ?realloc@CQueueS@@QAE_NH_N@Z ; CQueueS::realloc
  00082	0f b6 c8	 movzx	 ecx, al
  00085	85 c9		 test	 ecx, ecx
  00087	75 31		 jne	 SHORT $LN3@setLoggerQ

; 308  : 			_stprintf(g_szMessage, _T("m_sLogQueue.realloc(%d,true) has Failed"), nMax);

  00089	8b 55 08	 mov	 edx, DWORD PTR _nMax$[ebp]
  0008c	52		 push	 edx
  0008d	68 00 00 00 00	 push	 OFFSET $SG86614
  00092	68 00 00 00 00	 push	 OFFSET ?g_szMessage@@3PADA ; g_szMessage
  00097	e8 00 00 00 00	 call	 _sprintf
  0009c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 309  : 			comErrorPrint(g_szMessage);

  0009f	68 35 01 00 00	 push	 309			; 00000135H
  000a4	68 00 00 00 00	 push	 OFFSET $SG86615
  000a9	68 00 00 00 00	 push	 OFFSET ?g_szMessage@@3PADA ; g_szMessage
  000ae	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPADPBDH@Z ; comGlobalErrorProc
  000b3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 310  : 			return false;

  000b6	32 c0		 xor	 al, al
  000b8	eb 02		 jmp	 SHORT $LN1@setLoggerQ
$LN3@setLoggerQ:

; 311  : 		}
; 312  : 	}
; 313  : 	return true;

  000ba	b0 01		 mov	 al, 1
$LN1@setLoggerQ:

; 314  : }

  000bc	83 c4 08	 add	 esp, 8
  000bf	3b ec		 cmp	 ebp, esp
  000c1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c6	8b e5		 mov	 esp, ebp
  000c8	5d		 pop	 ebp
  000c9	c2 04 00	 ret	 4
?_setLoggerQueue@CLogger@@AAE_NH@Z ENDP			; CLogger::_setLoggerQueue
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comlogger.cpp
_TEXT	SEGMENT
tv64 = -8						; size = 4
_this$ = -4						; size = 4
_nLogType$ = 8						; size = 4
_nPrintLevel$ = 12					; size = 4
_nSizeLimit$ = 16					; size = 4
?_setLoggerBasic@CLogger@@AAEXHHH@Z PROC		; CLogger::_setLoggerBasic
; _this$ = ecx

; 316  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 317  : 	switch (nLogType){

  00017	8b 45 08	 mov	 eax, DWORD PTR _nLogType$[ebp]
  0001a	89 45 f8	 mov	 DWORD PTR tv64[ebp], eax
  0001d	83 7d f8 01	 cmp	 DWORD PTR tv64[ebp], 1
  00021	74 0e		 je	 SHORT $LN4@setLoggerB
  00023	83 7d f8 02	 cmp	 DWORD PTR tv64[ebp], 2
  00027	74 2e		 je	 SHORT $LN5@setLoggerB
  00029	83 7d f8 03	 cmp	 DWORD PTR tv64[ebp], 3
  0002d	74 4e		 je	 SHORT $LN6@setLoggerB
  0002f	eb 70		 jmp	 SHORT $LN2@setLoggerB
$LN4@setLoggerB:

; 318  : 		case LOG_TYPE_DAILY: {
; 319  : 			m_nLogFlag |= LOG_FLAG_DAILY; m_nLogFlag &= ~(LOG_FLAG_HOURLY | LOG_FLAG_FILE);

  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	8b 51 74	 mov	 edx, DWORD PTR [ecx+116]
  00037	81 ca 00 02 00
	00		 or	 edx, 512		; 00000200H
  0003d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00040	89 50 74	 mov	 DWORD PTR [eax+116], edx
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	8b 51 74	 mov	 edx, DWORD PTR [ecx+116]
  00049	81 e2 ff f3 ff
	ff		 and	 edx, -3073		; fffff3ffH
  0004f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00052	89 50 74	 mov	 DWORD PTR [eax+116], edx

; 320  : 		} break;

  00055	eb 4a		 jmp	 SHORT $LN2@setLoggerB
$LN5@setLoggerB:

; 321  : 		case LOG_TYPE_HOURLY: {
; 322  : 			m_nLogFlag |= LOG_FLAG_HOURLY; m_nLogFlag &= ~(LOG_FLAG_DAILY | LOG_FLAG_FILE);

  00057	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	8b 51 74	 mov	 edx, DWORD PTR [ecx+116]
  0005d	81 ca 00 04 00
	00		 or	 edx, 1024		; 00000400H
  00063	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00066	89 50 74	 mov	 DWORD PTR [eax+116], edx
  00069	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	8b 51 74	 mov	 edx, DWORD PTR [ecx+116]
  0006f	81 e2 ff f5 ff
	ff		 and	 edx, -2561		; fffff5ffH
  00075	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00078	89 50 74	 mov	 DWORD PTR [eax+116], edx

; 323  : 		}  break;

  0007b	eb 24		 jmp	 SHORT $LN2@setLoggerB
$LN6@setLoggerB:

; 324  : 		case LOG_TYPE_FILE: {
; 325  : 			m_nLogFlag |= LOG_FLAG_FILE; m_nLogFlag &= ~(LOG_FLAG_DAILY | LOG_FLAG_HOURLY);

  0007d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00080	8b 51 74	 mov	 edx, DWORD PTR [ecx+116]
  00083	81 ca 00 08 00
	00		 or	 edx, 2048		; 00000800H
  00089	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0008c	89 50 74	 mov	 DWORD PTR [eax+116], edx
  0008f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00092	8b 51 74	 mov	 edx, DWORD PTR [ecx+116]
  00095	81 e2 ff f9 ff
	ff		 and	 edx, -1537		; fffff9ffH
  0009b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009e	89 50 74	 mov	 DWORD PTR [eax+116], edx
$LN2@setLoggerB:

; 326  : 		} break;
; 327  : 	}
; 328  : 	if (nPrintLevel) m_nLogFlag |= IS_PRINT_LEVEL;

  000a1	83 7d 0c 00	 cmp	 DWORD PTR _nPrintLevel$[ebp], 0
  000a5	74 14		 je	 SHORT $LN7@setLoggerB
  000a7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000aa	8b 51 74	 mov	 edx, DWORD PTR [ecx+116]
  000ad	81 ca 00 40 00
	00		 or	 edx, 16384		; 00004000H
  000b3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b6	89 50 74	 mov	 DWORD PTR [eax+116], edx
  000b9	eb 12		 jmp	 SHORT $LN8@setLoggerB
$LN7@setLoggerB:

; 329  : 	else m_nLogFlag &= ~IS_PRINT_LEVEL;

  000bb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000be	8b 51 74	 mov	 edx, DWORD PTR [ecx+116]
  000c1	81 e2 ff bf ff
	ff		 and	 edx, -16385		; ffffbfffH
  000c7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ca	89 50 74	 mov	 DWORD PTR [eax+116], edx
$LN8@setLoggerB:

; 330  : 
; 331  : 	if (nSizeLimit) m_nLogFlag |= LOG_FLAG_SIZEOVER;

  000cd	83 7d 10 00	 cmp	 DWORD PTR _nSizeLimit$[ebp], 0
  000d1	74 14		 je	 SHORT $LN9@setLoggerB
  000d3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d6	8b 51 74	 mov	 edx, DWORD PTR [ecx+116]
  000d9	81 ca 00 10 00
	00		 or	 edx, 4096		; 00001000H
  000df	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e2	89 50 74	 mov	 DWORD PTR [eax+116], edx
  000e5	eb 12		 jmp	 SHORT $LN10@setLoggerB
$LN9@setLoggerB:

; 332  : 	else m_nLogFlag &= ~LOG_FLAG_SIZEOVER;

  000e7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ea	8b 51 74	 mov	 edx, DWORD PTR [ecx+116]
  000ed	81 e2 ff ef ff
	ff		 and	 edx, -4097		; ffffefffH
  000f3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000f6	89 50 74	 mov	 DWORD PTR [eax+116], edx
$LN10@setLoggerB:

; 333  : 	m_nSizeLimit = nSizeLimit;

  000f9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000fc	8b 55 10	 mov	 edx, DWORD PTR _nSizeLimit$[ebp]
  000ff	89 91 80 00 00
	00		 mov	 DWORD PTR [ecx+128], edx

; 334  : }

  00105	8b e5		 mov	 esp, ebp
  00107	5d		 pop	 ebp
  00108	c2 0c 00	 ret	 12			; 0000000cH
?_setLoggerBasic@CLogger@@AAEXHHH@Z ENDP		; CLogger::_setLoggerBasic
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comlogger.cpp
_TEXT	SEGMENT
_pDTE$ = -8						; size = 4
_this$ = -4						; size = 4
_nTimeStempNo$ = 8					; size = 4
?_setHeaderFormat@CLogger@@AAE_NH@Z PROC		; CLogger::_setHeaderFormat
; _this$ = ecx

; 336  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 337  : 	STLogDateTimeExp *pDTE = gs_DTEManager.getDTE(nTimeStempNo);

  00017	8b 45 08	 mov	 eax, DWORD PTR _nTimeStempNo$[ebp]
  0001a	50		 push	 eax
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_DTEManager@@3VCTimeExpManager@@A ; gs_DTEManager
  00020	e8 00 00 00 00	 call	 ?getDTE@CTimeExpManager@@QAEPAUSTLogDateTimeExp@@H@Z ; CTimeExpManager::getDTE
  00025	89 45 f8	 mov	 DWORD PTR _pDTE$[ebp], eax

; 338  : 	if (!pDTE) {

  00028	83 7d f8 00	 cmp	 DWORD PTR _pDTE$[ebp], 0
  0002c	75 33		 jne	 SHORT $LN2@setHeaderF

; 339  : 		_stprintf(g_szMessage, _T("m_pDTE is NULL! nTimeStempNo[%d]"), nTimeStempNo);

  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _nTimeStempNo$[ebp]
  00031	51		 push	 ecx
  00032	68 00 00 00 00	 push	 OFFSET $SG86638
  00037	68 00 00 00 00	 push	 OFFSET ?g_szMessage@@3PADA ; g_szMessage
  0003c	e8 00 00 00 00	 call	 _sprintf
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH

; 340  : 		comErrorPrint(g_szMessage);

  00044	68 54 01 00 00	 push	 340			; 00000154H
  00049	68 00 00 00 00	 push	 OFFSET $SG86639
  0004e	68 00 00 00 00	 push	 OFFSET ?g_szMessage@@3PADA ; g_szMessage
  00053	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPADPBDH@Z ; comGlobalErrorProc
  00058	83 c4 0c	 add	 esp, 12			; 0000000cH

; 341  : 		return false;

  0005b	32 c0		 xor	 al, al
  0005d	eb 24		 jmp	 SHORT $LN1@setHeaderF
  0005f	eb 20		 jmp	 SHORT $LN3@setHeaderF
$LN2@setHeaderF:

; 342  : 	}
; 343  : 	else if (m_pDTE != pDTE) {

  00061	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00064	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  00067	3b 45 f8	 cmp	 eax, DWORD PTR _pDTE$[ebp]
  0006a	74 15		 je	 SHORT $LN3@setHeaderF

; 344  : 		setDateTimeFormat(pDTE);

  0006c	8b 4d f8	 mov	 ecx, DWORD PTR _pDTE$[ebp]
  0006f	51		 push	 ecx
  00070	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	e8 00 00 00 00	 call	 ?setDateTimeFormat@CLogger@@AAEXPAUSTLogDateTimeExp@@@Z ; CLogger::setDateTimeFormat

; 345  : 		m_pDTE = pDTE;

  00078	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0007b	8b 45 f8	 mov	 eax, DWORD PTR _pDTE$[ebp]
  0007e	89 42 54	 mov	 DWORD PTR [edx+84], eax
$LN3@setHeaderF:

; 346  : 	}
; 347  : 	return true;

  00081	b0 01		 mov	 al, 1
$LN1@setHeaderF:

; 348  : }

  00083	83 c4 08	 add	 esp, 8
  00086	3b ec		 cmp	 ebp, esp
  00088	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c2 04 00	 ret	 4
?_setHeaderFormat@CLogger@@AAE_NH@Z ENDP		; CLogger::_setHeaderFormat
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comlogger.cpp
_TEXT	SEGMENT
$T1 = -28						; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
_bSet$ = -9						; size = 1
_nStrLen$ = -8						; size = 4
_this$ = -4						; size = 4
_pDir$ = 8						; size = 4
_pName$ = 12						; size = 4
_pFileExtension$ = 16					; size = 4
_pKeepDuration$ = 20					; size = 4
?_initCom@CLogger@@AAEXPAD000@Z PROC			; CLogger::_initCom
; _this$ = ecx

; 261  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0000e	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00011	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00014	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00017	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001a	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001d	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00020	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 262  : 	size_t nStrLen = _tcslen(pDir);

  00023	8b 45 08	 mov	 eax, DWORD PTR _pDir$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 _strlen
  0002c	83 c4 04	 add	 esp, 4
  0002f	89 45 f8	 mov	 DWORD PTR _nStrLen$[ebp], eax

; 263  : 	bool bSet = true;

  00032	c6 45 f7 01	 mov	 BYTE PTR _bSet$[ebp], 1

; 264  : 	if (m_pLogDir) {

  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	83 79 60 00	 cmp	 DWORD PTR [ecx+96], 0
  0003d	74 32		 je	 SHORT $LN2@initCom

; 265  : 		if (_tcscmp(pDir, m_pLogDir)) {

  0003f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00042	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  00045	50		 push	 eax
  00046	8b 4d 08	 mov	 ecx, DWORD PTR _pDir$[ebp]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 __tcscmp
  0004f	83 c4 08	 add	 esp, 8
  00052	85 c0		 test	 eax, eax
  00054	74 17		 je	 SHORT $LN3@initCom

; 266  : 			delete[] m_pLogDir;

  00056	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00059	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  0005c	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  0005f	8b 4d f0	 mov	 ecx, DWORD PTR $T4[ebp]
  00062	51		 push	 ecx
  00063	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00068	83 c4 04	 add	 esp, 4
  0006b	eb 04		 jmp	 SHORT $LN2@initCom
$LN3@initCom:

; 267  : 		}
; 268  : 		else bSet = false;

  0006d	c6 45 f7 00	 mov	 BYTE PTR _bSet$[ebp], 0
$LN2@initCom:

; 269  : 	}
; 270  : 
; 271  : 	if (bSet) {

  00071	0f b6 55 f7	 movzx	 edx, BYTE PTR _bSet$[ebp]
  00075	85 d2		 test	 edx, edx
  00077	74 2e		 je	 SHORT $LN5@initCom

; 272  : 		m_pLogDir = new TCHAR[nStrLen + 1];

  00079	8b 45 f8	 mov	 eax, DWORD PTR _nStrLen$[ebp]
  0007c	83 c0 01	 add	 eax, 1
  0007f	50		 push	 eax
  00080	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00085	83 c4 04	 add	 esp, 4
  00088	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
  0008b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008e	8b 55 ec	 mov	 edx, DWORD PTR $T3[ebp]
  00091	89 51 60	 mov	 DWORD PTR [ecx+96], edx

; 273  : 		_tcscpy(m_pLogDir, pDir);

  00094	8b 45 08	 mov	 eax, DWORD PTR _pDir$[ebp]
  00097	50		 push	 eax
  00098	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  0009e	52		 push	 edx
  0009f	e8 00 00 00 00	 call	 _strcpy
  000a4	83 c4 08	 add	 esp, 8
$LN5@initCom:

; 274  : 	}
; 275  : 
; 276  : 	bSet = true;

  000a7	c6 45 f7 01	 mov	 BYTE PTR _bSet$[ebp], 1

; 277  : 	if (m_pLogName) {

  000ab	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	83 78 64 00	 cmp	 DWORD PTR [eax+100], 0
  000b2	74 32		 je	 SHORT $LN6@initCom

; 278  : 		if (_tcscmp(pDir, m_pLogName)) {

  000b4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b7	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  000ba	52		 push	 edx
  000bb	8b 45 08	 mov	 eax, DWORD PTR _pDir$[ebp]
  000be	50		 push	 eax
  000bf	e8 00 00 00 00	 call	 __tcscmp
  000c4	83 c4 08	 add	 esp, 8
  000c7	85 c0		 test	 eax, eax
  000c9	74 17		 je	 SHORT $LN7@initCom

; 279  : 			delete[] m_pLogName;

  000cb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ce	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  000d1	89 55 e8	 mov	 DWORD PTR $T2[ebp], edx
  000d4	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  000d7	50		 push	 eax
  000d8	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  000dd	83 c4 04	 add	 esp, 4
  000e0	eb 04		 jmp	 SHORT $LN6@initCom
$LN7@initCom:

; 280  : 		}
; 281  : 		else bSet = false;

  000e2	c6 45 f7 00	 mov	 BYTE PTR _bSet$[ebp], 0
$LN6@initCom:

; 282  : 	}
; 283  : 
; 284  : 	if (bSet) {

  000e6	0f b6 4d f7	 movzx	 ecx, BYTE PTR _bSet$[ebp]
  000ea	85 c9		 test	 ecx, ecx
  000ec	74 3d		 je	 SHORT $LN9@initCom

; 285  : 		nStrLen = _tcslen(pName);

  000ee	8b 55 0c	 mov	 edx, DWORD PTR _pName$[ebp]
  000f1	52		 push	 edx
  000f2	e8 00 00 00 00	 call	 _strlen
  000f7	83 c4 04	 add	 esp, 4
  000fa	89 45 f8	 mov	 DWORD PTR _nStrLen$[ebp], eax

; 286  : 		m_pLogName = new TCHAR[nStrLen + 1];

  000fd	8b 45 f8	 mov	 eax, DWORD PTR _nStrLen$[ebp]
  00100	83 c0 01	 add	 eax, 1
  00103	50		 push	 eax
  00104	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00109	83 c4 04	 add	 esp, 4
  0010c	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
  0010f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00112	8b 55 e4	 mov	 edx, DWORD PTR $T1[ebp]
  00115	89 51 64	 mov	 DWORD PTR [ecx+100], edx

; 287  : 		_tcscpy(m_pLogName, pName);

  00118	8b 45 0c	 mov	 eax, DWORD PTR _pName$[ebp]
  0011b	50		 push	 eax
  0011c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0011f	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  00122	52		 push	 edx
  00123	e8 00 00 00 00	 call	 _strcpy
  00128	83 c4 08	 add	 esp, 8
$LN9@initCom:

; 288  : 	}
; 289  : 
; 290  : 	if (_tcscmp(pFileExtension, m_szFileExtension)) {

  0012b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0012e	83 c0 68	 add	 eax, 104		; 00000068H
  00131	50		 push	 eax
  00132	8b 4d 10	 mov	 ecx, DWORD PTR _pFileExtension$[ebp]
  00135	51		 push	 ecx
  00136	e8 00 00 00 00	 call	 __tcscmp
  0013b	83 c4 08	 add	 esp, 8
  0013e	85 c0		 test	 eax, eax
  00140	74 13		 je	 SHORT $LN10@initCom

; 291  : 		_tcscpy(m_szFileExtension, pFileExtension);

  00142	8b 55 10	 mov	 edx, DWORD PTR _pFileExtension$[ebp]
  00145	52		 push	 edx
  00146	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00149	83 c0 68	 add	 eax, 104		; 00000068H
  0014c	50		 push	 eax
  0014d	e8 00 00 00 00	 call	 _strcpy
  00152	83 c4 08	 add	 esp, 8
$LN10@initCom:

; 292  : 	}
; 293  : 
; 294  : 	GetKeepInfo(pKeepDuration);

  00155	8b 4d 14	 mov	 ecx, DWORD PTR _pKeepDuration$[ebp]
  00158	51		 push	 ecx
  00159	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0015c	e8 00 00 00 00	 call	 ?GetKeepInfo@CLogger@@AAEHPBD@Z ; CLogger::GetKeepInfo

; 295  : }

  00161	83 c4 1c	 add	 esp, 28			; 0000001cH
  00164	3b ec		 cmp	 ebp, esp
  00166	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0016b	8b e5		 mov	 esp, ebp
  0016d	5d		 pop	 ebp
  0016e	c2 10 00	 ret	 16			; 00000010H
?_initCom@CLogger@@AAEXPAD000@Z ENDP			; CLogger::_initCom
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\comlogger.h
;	COMDAT ?putQueue@CLogger@@QAEXPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_p$ = 8							; size = 4
?putQueue@CLogger@@QAEXPAD@Z PROC			; CLogger::putQueue, COMDAT
; _this$ = ecx

; 207  : 	void putQueue(TCHAR *p) { if (m_sLogQueue.push(p)) m_pCondition->signal(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000f	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00012	50		 push	 eax
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ?push@CQueueS@@QAE_NPAX@Z ; CQueueS::push
  0001b	0f b6 c8	 movzx	 ecx, al
  0001e	85 c9		 test	 ecx, ecx
  00020	74 1c		 je	 SHORT $LN1@putQueue
  00022	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00025	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	8b 10		 mov	 edx, DWORD PTR [eax]
  0002d	8b f4		 mov	 esi, esp
  0002f	8b 49 44	 mov	 ecx, DWORD PTR [ecx+68]
  00032	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00035	ff d0		 call	 eax
  00037	3b f4		 cmp	 esi, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@putQueue:
  0003e	5e		 pop	 esi
  0003f	83 c4 04	 add	 esp, 4
  00042	3b ec		 cmp	 ebp, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
?putQueue@CLogger@@QAEXPAD@Z ENDP			; CLogger::putQueue
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comlogger.cpp
_TEXT	SEGMENT
$T2 = -212						; size = 4
_cDateTime$ = -204					; size = 104
_szBuf$ = -92						; size = 64
_nLen$ = -24						; size = 4
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pDest$ = 8						; size = 4
?getString@CLogger@@QAEHPAD@Z PROC			; CLogger::getString
; _this$ = ecx

; 229  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?getString@CLogger@@QAEHPAD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00017	57		 push	 edi
  00018	51		 push	 ecx
  00019	8d bd 2c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-212]
  0001f	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00024	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00029	f3 ab		 rep stosd
  0002b	59		 pop	 ecx
  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00031	33 c5		 xor	 eax, ebp
  00033	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00036	50		 push	 eax
  00037	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00040	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 230  : 	int nLen;
; 231  : 	if (!isLogFlag(IS_LOG_SET_COMPLETE)) {

  00043	68 00 00 02 00	 push	 131072			; 00020000H
  00048	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	e8 00 00 00 00	 call	 ?isLogFlag@CLogger@@QAE_NW4E_LOG_FLAG@@@Z ; CLogger::isLogFlag
  00050	0f b6 c0	 movzx	 eax, al
  00053	85 c0		 test	 eax, eax
  00055	75 11		 jne	 SHORT $LN2@getString

; 232  : 		_tcscpy(pDest, _T("Logger is not Initialized!"));

  00057	68 00 00 00 00	 push	 OFFSET $SG86562
  0005c	8b 4d 08	 mov	 ecx, DWORD PTR _pDest$[ebp]
  0005f	51		 push	 ecx
  00060	e8 00 00 00 00	 call	 _strcpy
  00065	83 c4 08	 add	 esp, 8
$LN2@getString:

; 233  : 	}
; 234  : 
; 235  : 	TCHAR szBuf[64];
; 236  : 	CDateTime cDateTime(DT_NONE);

  00068	6a 00		 push	 0
  0006a	6a 00		 push	 0
  0006c	8d 8d 34 ff ff
	ff		 lea	 ecx, DWORD PTR _cDateTime$[ebp]
  00072	e8 00 00 00 00	 call	 ??0CDateTime@@QAE@W4DT_TYPE@@W4TZ_TYPE@@@Z ; CDateTime::CDateTime
  00077	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 237  : 
; 238  : 	if (m_nLogFlag & LOG_FLAG_DAILY) {

  0007e	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00081	8b 42 74	 mov	 eax, DWORD PTR [edx+116]
  00084	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00089	74 13		 je	 SHORT $LN3@getString

; 239  : 		_tcscpy(szBuf, _T("TYPE_DAILY"));

  0008b	68 00 00 00 00	 push	 OFFSET $SG86565
  00090	8d 4d a4	 lea	 ecx, DWORD PTR _szBuf$[ebp]
  00093	51		 push	 ecx
  00094	e8 00 00 00 00	 call	 _strcpy
  00099	83 c4 08	 add	 esp, 8
  0009c	eb 3e		 jmp	 SHORT $LN4@getString
$LN3@getString:

; 240  : 	}
; 241  : 	else if (m_nLogFlag & LOG_FLAG_HOURLY) {

  0009e	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000a1	8b 42 74	 mov	 eax, DWORD PTR [edx+116]
  000a4	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  000a9	74 13		 je	 SHORT $LN5@getString

; 242  : 		_tcscpy(szBuf, _T("TYPE_HOURLY"));

  000ab	68 00 00 00 00	 push	 OFFSET $SG86568
  000b0	8d 4d a4	 lea	 ecx, DWORD PTR _szBuf$[ebp]
  000b3	51		 push	 ecx
  000b4	e8 00 00 00 00	 call	 _strcpy
  000b9	83 c4 08	 add	 esp, 8
  000bc	eb 1e		 jmp	 SHORT $LN4@getString
$LN5@getString:

; 243  : 	}
; 244  : 	else if (m_nLogFlag & LOG_FLAG_FILE) {

  000be	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000c1	8b 42 74	 mov	 eax, DWORD PTR [edx+116]
  000c4	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  000c9	74 11		 je	 SHORT $LN4@getString

; 245  : 		_tcscpy(szBuf, _T("TYPE_FILE"));

  000cb	68 00 00 00 00	 push	 OFFSET $SG86570
  000d0	8d 4d a4	 lea	 ecx, DWORD PTR _szBuf$[ebp]
  000d3	51		 push	 ecx
  000d4	e8 00 00 00 00	 call	 _strcpy
  000d9	83 c4 08	 add	 esp, 8
$LN4@getString:

; 246  : 	}
; 247  : 
; 248  : 	nLen = _stprintf(pDest, _T("================================================\n"));

  000dc	68 00 00 00 00	 push	 OFFSET $SG86571
  000e1	8b 55 08	 mov	 edx, DWORD PTR _pDest$[ebp]
  000e4	52		 push	 edx
  000e5	e8 00 00 00 00	 call	 _sprintf
  000ea	83 c4 08	 add	 esp, 8
  000ed	89 45 e8	 mov	 DWORD PTR _nLen$[ebp], eax

; 249  : 	nLen += _stprintf(pDest + nLen, _T("Logger Path[%s] Prefix[%s] Extension[%s]\n"), m_pLogDir, m_pLogName, m_szFileExtension);

  000f0	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000f3	83 c0 68	 add	 eax, 104		; 00000068H
  000f6	50		 push	 eax
  000f7	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000fa	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  000fd	52		 push	 edx
  000fe	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00101	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00104	51		 push	 ecx
  00105	68 00 00 00 00	 push	 OFFSET $SG86572
  0010a	8b 55 08	 mov	 edx, DWORD PTR _pDest$[ebp]
  0010d	03 55 e8	 add	 edx, DWORD PTR _nLen$[ebp]
  00110	52		 push	 edx
  00111	e8 00 00 00 00	 call	 _sprintf
  00116	83 c4 14	 add	 esp, 20			; 00000014H
  00119	03 45 e8	 add	 eax, DWORD PTR _nLen$[ebp]
  0011c	89 45 e8	 mov	 DWORD PTR _nLen$[ebp], eax

; 250  : 	nLen += _stprintf(pDest + nLen, _T("Logger SizeLimit[%d] LogLevel[%d] LogType[%s]\n"), m_nSizeLimit, m_nLogLevel, szBuf);

  0011f	8d 45 a4	 lea	 eax, DWORD PTR _szBuf$[ebp]
  00122	50		 push	 eax
  00123	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00126	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  00129	52		 push	 edx
  0012a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0012d	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  00133	51		 push	 ecx
  00134	68 00 00 00 00	 push	 OFFSET $SG86573
  00139	8b 55 08	 mov	 edx, DWORD PTR _pDest$[ebp]
  0013c	03 55 e8	 add	 edx, DWORD PTR _nLen$[ebp]
  0013f	52		 push	 edx
  00140	e8 00 00 00 00	 call	 _sprintf
  00145	83 c4 14	 add	 esp, 20			; 00000014H
  00148	03 45 e8	 add	 eax, DWORD PTR _nLen$[ebp]
  0014b	89 45 e8	 mov	 DWORD PTR _nLen$[ebp], eax

; 251  : 
; 252  : 	cDateTime.SetSecondsValue(m_nDeleteInterval);

  0014e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00151	8b 88 d0 00 00
	00		 mov	 ecx, DWORD PTR [eax+208]
  00157	51		 push	 ecx
  00158	8d 8d 34 ff ff
	ff		 lea	 ecx, DWORD PTR _cDateTime$[ebp]
  0015e	e8 00 00 00 00	 call	 ?SetSecondsValue@CDateTime@@QAEXH@Z ; CDateTime::SetSecondsValue

; 253  : 	cDateTime.setString(szBuf, _T("KeepDuration : %02d days %02d:%02d:%02d"), LOG_DATE_DDHHMMSS);

  00163	6a 09		 push	 9
  00165	68 00 00 00 00	 push	 OFFSET $SG86574
  0016a	8d 55 a4	 lea	 edx, DWORD PTR _szBuf$[ebp]
  0016d	52		 push	 edx
  0016e	8d 8d 34 ff ff
	ff		 lea	 ecx, DWORD PTR _cDateTime$[ebp]
  00174	e8 00 00 00 00	 call	 ?setString@CDateTime@@QAEHPAD0W4DT_FORMAT@@@Z ; CDateTime::setString

; 254  : 
; 255  : 	nLen += _stprintf(pDest + nLen, _T("Logger KeepDuration[%s]\n"), szBuf);

  00179	8d 45 a4	 lea	 eax, DWORD PTR _szBuf$[ebp]
  0017c	50		 push	 eax
  0017d	68 00 00 00 00	 push	 OFFSET $SG86575
  00182	8b 4d 08	 mov	 ecx, DWORD PTR _pDest$[ebp]
  00185	03 4d e8	 add	 ecx, DWORD PTR _nLen$[ebp]
  00188	51		 push	 ecx
  00189	e8 00 00 00 00	 call	 _sprintf
  0018e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00191	03 45 e8	 add	 eax, DWORD PTR _nLen$[ebp]
  00194	89 45 e8	 mov	 DWORD PTR _nLen$[ebp], eax

; 256  : 	nLen += _stprintf(pDest + nLen, _T("================================================\n"));

  00197	68 00 00 00 00	 push	 OFFSET $SG86576
  0019c	8b 55 08	 mov	 edx, DWORD PTR _pDest$[ebp]
  0019f	03 55 e8	 add	 edx, DWORD PTR _nLen$[ebp]
  001a2	52		 push	 edx
  001a3	e8 00 00 00 00	 call	 _sprintf
  001a8	83 c4 08	 add	 esp, 8
  001ab	03 45 e8	 add	 eax, DWORD PTR _nLen$[ebp]
  001ae	89 45 e8	 mov	 DWORD PTR _nLen$[ebp], eax

; 257  : 	return nLen;

  001b1	8b 45 e8	 mov	 eax, DWORD PTR _nLen$[ebp]
  001b4	89 85 2c ff ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
  001ba	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001c1	8d 8d 34 ff ff
	ff		 lea	 ecx, DWORD PTR _cDateTime$[ebp]
  001c7	e8 00 00 00 00	 call	 ??1CDateTime@@QAE@XZ	; CDateTime::~CDateTime
  001cc	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]

; 258  : }

  001d2	52		 push	 edx
  001d3	8b cd		 mov	 ecx, ebp
  001d5	50		 push	 eax
  001d6	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN14@getString
  001dc	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001e1	58		 pop	 eax
  001e2	5a		 pop	 edx
  001e3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001e6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001ed	59		 pop	 ecx
  001ee	5f		 pop	 edi
  001ef	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001f2	33 cd		 xor	 ecx, ebp
  001f4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f9	81 c4 d4 00 00
	00		 add	 esp, 212		; 000000d4H
  001ff	3b ec		 cmp	 ebp, esp
  00201	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00206	8b e5		 mov	 esp, ebp
  00208	5d		 pop	 ebp
  00209	c2 04 00	 ret	 4
$LN14@getString:
  0020c	02 00 00 00	 DD	 2
  00210	00 00 00 00	 DD	 $LN13@getString
$LN13@getString:
  00214	a4 ff ff ff	 DD	 -92			; ffffffa4H
  00218	40 00 00 00	 DD	 64			; 00000040H
  0021c	00 00 00 00	 DD	 $LN10@getString
  00220	34 ff ff ff	 DD	 -204			; ffffff34H
  00224	68 00 00 00	 DD	 104			; 00000068H
  00228	00 00 00 00	 DD	 $LN11@getString
$LN11@getString:
  0022c	63		 DB	 99			; 00000063H
  0022d	44		 DB	 68			; 00000044H
  0022e	61		 DB	 97			; 00000061H
  0022f	74		 DB	 116			; 00000074H
  00230	65		 DB	 101			; 00000065H
  00231	54		 DB	 84			; 00000054H
  00232	69		 DB	 105			; 00000069H
  00233	6d		 DB	 109			; 0000006dH
  00234	65		 DB	 101			; 00000065H
  00235	00		 DB	 0
$LN10@getString:
  00236	73		 DB	 115			; 00000073H
  00237	7a		 DB	 122			; 0000007aH
  00238	42		 DB	 66			; 00000042H
  00239	75		 DB	 117			; 00000075H
  0023a	66		 DB	 102			; 00000066H
  0023b	00		 DB	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?getString@CLogger@@QAEHPAD@Z$0:
  00000	8d 8d 34 ff ff
	ff		 lea	 ecx, DWORD PTR _cDateTime$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CDateTime@@QAE@XZ	; CDateTime::~CDateTime
__ehhandler$?getString@CLogger@@QAEHPAD@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a 30 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-208]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?getString@CLogger@@QAEHPAD@Z
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?getString@CLogger@@QAEHPAD@Z ENDP			; CLogger::getString
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comlogger.cpp
_TEXT	SEGMENT
_pBuf$ = -8740						; size = 4
_ap$ = -8736						; size = 4
_header$ = -8728					; size = 512
_msgBuf$ = -8208					; size = 8192
_nLen2$ = -12						; size = 4
_nLen$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_this$ = 8						; size = 4
_level$ = 12						; size = 4
__szFunc$ = 16						; size = 4
__nLine$ = 20						; size = 4
__szFormat$ = 24					; size = 4
?__debugLog@CLogger@@QAAXHPBDH0ZZ PROC			; CLogger::__debugLog

; 607  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 24 22 00 00	 mov	 eax, 8740		; 00002224H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	57		 push	 edi
  0000e	8d bd dc dd ff
	ff		 lea	 edi, DWORD PTR [ebp-8740]
  00014	b9 89 08 00 00	 mov	 ecx, 2185		; 00000889H
  00019	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001e	f3 ab		 rep stosd
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 608  : 	if (!isLogFlag(IS_LOG_ENABLE)) return;

  0002a	68 00 00 08 00	 push	 524288			; 00080000H
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?isLogFlag@CLogger@@QAE_NW4E_LOG_FLAG@@@Z ; CLogger::isLogFlag
  00037	0f b6 c0	 movzx	 eax, al
  0003a	85 c0		 test	 eax, eax
  0003c	75 05		 jne	 SHORT $LN2@debugLog
  0003e	e9 e4 00 00 00	 jmp	 $LN1@debugLog
$LN2@debugLog:

; 609  : 	if (level < m_nLogLevel) return;

  00043	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	8b 55 0c	 mov	 edx, DWORD PTR _level$[ebp]
  00049	3b 51 4c	 cmp	 edx, DWORD PTR [ecx+76]
  0004c	7d 05		 jge	 SHORT $LN3@debugLog
  0004e	e9 d4 00 00 00	 jmp	 $LN1@debugLog
$LN3@debugLog:

; 610  : 
; 611  : //	TCHAR tmpBuf[512];
; 612  : 	int nLen, nLen2=0;

  00053	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _nLen2$[ebp], 0

; 613  : 
; 614  : 	TCHAR	msgBuf[MAX_LOGBUF_LEN];
; 615  : 	TCHAR	header[512];
; 616  : 	va_list	ap;
; 617  : 
; 618  : 	nLen2 = setHeader(header, level);

  0005a	8b 45 0c	 mov	 eax, DWORD PTR _level$[ebp]
  0005d	50		 push	 eax
  0005e	8d 8d e8 dd ff
	ff		 lea	 ecx, DWORD PTR _header$[ebp]
  00064	51		 push	 ecx
  00065	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	e8 00 00 00 00	 call	 ?setHeader@CLogger@@QAEHPADH@Z ; CLogger::setHeader
  0006d	89 45 f4	 mov	 DWORD PTR _nLen2$[ebp], eax

; 619  : 	sprintf(header+nLen2, " %s, %d, %s ", _szFunc, _nLine, _szFormat);

  00070	8b 55 18	 mov	 edx, DWORD PTR __szFormat$[ebp]
  00073	52		 push	 edx
  00074	8b 45 14	 mov	 eax, DWORD PTR __nLine$[ebp]
  00077	50		 push	 eax
  00078	8b 4d 10	 mov	 ecx, DWORD PTR __szFunc$[ebp]
  0007b	51		 push	 ecx
  0007c	68 00 00 00 00	 push	 OFFSET $SG86841
  00081	8b 55 f4	 mov	 edx, DWORD PTR _nLen2$[ebp]
  00084	8d 84 15 e8 dd
	ff ff		 lea	 eax, DWORD PTR _header$[ebp+edx]
  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 _sprintf
  00091	83 c4 14	 add	 esp, 20			; 00000014H

; 620  : 	va_start(ap, _szFormat);

  00094	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@PBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const *>
  00099	8d 4d 1c	 lea	 ecx, DWORD PTR __szFormat$[ebp+4]
  0009c	89 8d e0 dd ff
	ff		 mov	 DWORD PTR _ap$[ebp], ecx

; 621  : 	nLen = vsnprintf(msgBuf, MAX_LOGBUF_LEN - 1, header, ap);

  000a2	8b 95 e0 dd ff
	ff		 mov	 edx, DWORD PTR _ap$[ebp]
  000a8	52		 push	 edx
  000a9	8d 85 e8 dd ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  000af	50		 push	 eax
  000b0	68 ff 1f 00 00	 push	 8191			; 00001fffH
  000b5	8d 8d f0 df ff
	ff		 lea	 ecx, DWORD PTR _msgBuf$[ebp]
  000bb	51		 push	 ecx
  000bc	e8 00 00 00 00	 call	 _vsnprintf
  000c1	83 c4 10	 add	 esp, 16			; 00000010H
  000c4	89 45 f8	 mov	 DWORD PTR _nLen$[ebp], eax

; 622  : 	va_end(ap);

  000c7	c7 85 e0 dd ff
	ff 00 00 00 00	 mov	 DWORD PTR _ap$[ebp], 0

; 623  : 
; 624  : 	TCHAR *pBuf = (TCHAR *)gs_pMMgr->newBuf(LEN_TO_SIZE(nLen + 2));

  000d1	8b 55 f8	 mov	 edx, DWORD PTR _nLen$[ebp]
  000d4	83 c2 02	 add	 edx, 2
  000d7	52		 push	 edx
  000d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pMMgr@@3PAVCMemManager@@A ; gs_pMMgr
  000de	e8 00 00 00 00	 call	 ?newBuf@CMemManager@@QAEPADH@Z ; CMemManager::newBuf
  000e3	89 85 dc dd ff
	ff		 mov	 DWORD PTR _pBuf$[ebp], eax

; 625  : 	_tcscpy(pBuf, msgBuf);

  000e9	8d 85 f0 df ff
	ff		 lea	 eax, DWORD PTR _msgBuf$[ebp]
  000ef	50		 push	 eax
  000f0	8b 8d dc dd ff
	ff		 mov	 ecx, DWORD PTR _pBuf$[ebp]
  000f6	51		 push	 ecx
  000f7	e8 00 00 00 00	 call	 _strcpy
  000fc	83 c4 08	 add	 esp, 8

; 626  : 	pBuf[nLen] = '\n';

  000ff	8b 95 dc dd ff
	ff		 mov	 edx, DWORD PTR _pBuf$[ebp]
  00105	03 55 f8	 add	 edx, DWORD PTR _nLen$[ebp]
  00108	c6 02 0a	 mov	 BYTE PTR [edx], 10	; 0000000aH

; 627  : 	pBuf[nLen + 1] = 0;

  0010b	8b 85 dc dd ff
	ff		 mov	 eax, DWORD PTR _pBuf$[ebp]
  00111	03 45 f8	 add	 eax, DWORD PTR _nLen$[ebp]
  00114	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 628  : 
; 629  : 	putQueue(pBuf);

  00118	8b 8d dc dd ff
	ff		 mov	 ecx, DWORD PTR _pBuf$[ebp]
  0011e	51		 push	 ecx
  0011f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00122	e8 00 00 00 00	 call	 ?putQueue@CLogger@@QAEXPAD@Z ; CLogger::putQueue
$LN1@debugLog:

; 630  : }

  00127	52		 push	 edx
  00128	8b cd		 mov	 ecx, ebp
  0012a	50		 push	 eax
  0012b	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@debugLog
  00131	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00136	58		 pop	 eax
  00137	5a		 pop	 edx
  00138	5f		 pop	 edi
  00139	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0013c	33 cd		 xor	 ecx, ebp
  0013e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00143	81 c4 24 22 00
	00		 add	 esp, 8740		; 00002224H
  00149	3b ec		 cmp	 ebp, esp
  0014b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00150	8b e5		 mov	 esp, ebp
  00152	5d		 pop	 ebp
  00153	c3		 ret	 0
$LN8@debugLog:
  00154	02 00 00 00	 DD	 2
  00158	00 00 00 00	 DD	 $LN7@debugLog
$LN7@debugLog:
  0015c	f0 df ff ff	 DD	 -8208			; ffffdff0H
  00160	00 20 00 00	 DD	 8192			; 00002000H
  00164	00 00 00 00	 DD	 $LN5@debugLog
  00168	e8 dd ff ff	 DD	 -8728			; ffffdde8H
  0016c	00 02 00 00	 DD	 512			; 00000200H
  00170	00 00 00 00	 DD	 $LN6@debugLog
$LN6@debugLog:
  00174	68		 DB	 104			; 00000068H
  00175	65		 DB	 101			; 00000065H
  00176	61		 DB	 97			; 00000061H
  00177	64		 DB	 100			; 00000064H
  00178	65		 DB	 101			; 00000065H
  00179	72		 DB	 114			; 00000072H
  0017a	00		 DB	 0
$LN5@debugLog:
  0017b	6d		 DB	 109			; 0000006dH
  0017c	73		 DB	 115			; 00000073H
  0017d	67		 DB	 103			; 00000067H
  0017e	42		 DB	 66			; 00000042H
  0017f	75		 DB	 117			; 00000075H
  00180	66		 DB	 102			; 00000066H
  00181	00		 DB	 0
?__debugLog@CLogger@@QAAXHPBDH0ZZ ENDP			; CLogger::__debugLog
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comlogger.cpp
_TEXT	SEGMENT
_szFile$ = -524						; size = 512
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_nFlag$ = 8						; size = 4
?checkChangeProc@CLogger@@QAEXH@Z PROC			; CLogger::checkChangeProc
; _this$ = ecx

; 685  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 10 02 00
	00		 sub	 esp, 528		; 00000210H
  00009	57		 push	 edi
  0000a	51		 push	 ecx
  0000b	8d bd f0 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-528]
  00011	b9 84 00 00 00	 mov	 ecx, 132		; 00000084H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	59		 pop	 ecx
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 686  : 	TCHAR szFile[512];
; 687  : 
; 688  : 	// delete proc
; 689  : 	if (m_nDeleteInterval) checkDeleteProc();

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	83 b8 d0 00 00
	00 00		 cmp	 DWORD PTR [eax+208], 0
  00035	74 08		 je	 SHORT $LN2@checkChang
  00037	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ?checkDeleteProc@CLogger@@AAEXXZ ; CLogger::checkDeleteProc
$LN2@checkChang:

; 690  : 
; 691  : 	if (nFlag & LOG_FLAG_DAYCHANGE) {

  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _nFlag$[ebp]
  00042	83 e1 01	 and	 ecx, 1
  00045	74 5d		 je	 SHORT $LN3@checkChang

; 692  : 		if (m_nLogFlag & LOG_FLAG_DAILY) { 

  00047	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0004a	8b 42 74	 mov	 eax, DWORD PTR [edx+116]
  0004d	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00052	74 50		 je	 SHORT $LN3@checkChang

; 693  : 			_stprintf(szFile, _T("%s/%d_%s.%s"), m_pLogDir, gs_today_time.date, m_pLogName, m_szFileExtension);

  00054	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	83 c1 68	 add	 ecx, 104		; 00000068H
  0005a	51		 push	 ecx
  0005b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0005e	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  00061	50		 push	 eax
  00062	8b 0d 18 00 00
	00		 mov	 ecx, DWORD PTR ?gs_today_time@@3USTTodayTime@@A+24
  00068	51		 push	 ecx
  00069	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0006c	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  0006f	50		 push	 eax
  00070	68 00 00 00 00	 push	 OFFSET $SG86886
  00075	8d 8d f4 fd ff
	ff		 lea	 ecx, DWORD PTR _szFile$[ebp]
  0007b	51		 push	 ecx
  0007c	e8 00 00 00 00	 call	 _sprintf
  00081	83 c4 18	 add	 esp, 24			; 00000018H

; 694  : 			__openLogger(szFile);

  00084	6a 00		 push	 0
  00086	8d 95 f4 fd ff
	ff		 lea	 edx, DWORD PTR _szFile$[ebp]
  0008c	52		 push	 edx
  0008d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00090	e8 00 00 00 00	 call	 ?__openLogger@CLogger@@AAEXPBDH@Z ; CLogger::__openLogger

; 695  : 			m_nSeq = 0;

  00095	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00098	c7 40 78 00 00
	00 00		 mov	 DWORD PTR [eax+120], 0

; 696  : 			return;

  0009f	e9 ae 00 00 00	 jmp	 $LN1@checkChang
$LN3@checkChang:

; 697  : 		}
; 698  : 	}
; 699  : 	if (nFlag & LOG_FLAG_HOURCHANGE) {

  000a4	8b 4d 08	 mov	 ecx, DWORD PTR _nFlag$[ebp]
  000a7	83 e1 02	 and	 ecx, 2
  000aa	74 61		 je	 SHORT $LN5@checkChang

; 700  : 		if (m_nLogFlag & LOG_FLAG_HOURLY) {

  000ac	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000af	8b 42 74	 mov	 eax, DWORD PTR [edx+116]
  000b2	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  000b7	74 54		 je	 SHORT $LN5@checkChang

; 701  : 			_stprintf(szFile, _T("%s/%d/%s_%02d.%s"), m_pLogDir, gs_today_time.date, m_pLogName, gs_today_time.hour, m_szFileExtension);

  000b9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000bc	83 c1 68	 add	 ecx, 104		; 00000068H
  000bf	51		 push	 ecx
  000c0	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR ?gs_today_time@@3USTTodayTime@@A+12
  000c6	52		 push	 edx
  000c7	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ca	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  000cd	51		 push	 ecx
  000ce	8b 15 18 00 00
	00		 mov	 edx, DWORD PTR ?gs_today_time@@3USTTodayTime@@A+24
  000d4	52		 push	 edx
  000d5	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000d8	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  000db	51		 push	 ecx
  000dc	68 00 00 00 00	 push	 OFFSET $SG86889
  000e1	8d 95 f4 fd ff
	ff		 lea	 edx, DWORD PTR _szFile$[ebp]
  000e7	52		 push	 edx
  000e8	e8 00 00 00 00	 call	 _sprintf
  000ed	83 c4 1c	 add	 esp, 28			; 0000001cH

; 702  : 			__openLogger(szFile);

  000f0	6a 00		 push	 0
  000f2	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szFile$[ebp]
  000f8	50		 push	 eax
  000f9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000fc	e8 00 00 00 00	 call	 ?__openLogger@CLogger@@AAEXPBDH@Z ; CLogger::__openLogger

; 703  : 			m_nSeq = 0;

  00101	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00104	c7 41 78 00 00
	00 00		 mov	 DWORD PTR [ecx+120], 0

; 704  : 			return;

  0010b	eb 45		 jmp	 SHORT $LN1@checkChang
$LN5@checkChang:

; 705  : 		}
; 706  : 	}
; 707  : 	if(m_nSizeLimit) {

  0010d	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00110	83 ba 80 00 00
	00 00		 cmp	 DWORD PTR [edx+128], 0
  00117	74 39		 je	 SHORT $LN1@checkChang

; 708  : 		if (m_nSizeLimit < m_nLogSize) {

  00119	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0011c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0011f	8b 90 80 00 00
	00		 mov	 edx, DWORD PTR [eax+128]
  00125	3b 91 84 00 00
	00		 cmp	 edx, DWORD PTR [ecx+132]
  0012b	73 25		 jae	 SHORT $LN1@checkChang

; 709  : 			m_nSeq++;

  0012d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00130	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  00133	83 c1 01	 add	 ecx, 1
  00136	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00139	89 4a 78	 mov	 DWORD PTR [edx+120], ecx

; 710  : 			__openLogger(m_pFName, m_nSeq);

  0013c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0013f	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  00142	51		 push	 ecx
  00143	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00146	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  00149	50		 push	 eax
  0014a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0014d	e8 00 00 00 00	 call	 ?__openLogger@CLogger@@AAEXPBDH@Z ; CLogger::__openLogger
$LN1@checkChang:

; 711  : 		}
; 712  : 	}
; 713  : 
; 714  : 	// LOG_FLAG_FILE
; 715  : 	// no need to open a new file
; 716  : 
; 717  : }

  00152	52		 push	 edx
  00153	8b cd		 mov	 ecx, ebp
  00155	50		 push	 eax
  00156	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN12@checkChang
  0015c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00161	58		 pop	 eax
  00162	5a		 pop	 edx
  00163	5f		 pop	 edi
  00164	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00167	33 cd		 xor	 ecx, ebp
  00169	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0016e	81 c4 10 02 00
	00		 add	 esp, 528		; 00000210H
  00174	3b ec		 cmp	 ebp, esp
  00176	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0017b	8b e5		 mov	 esp, ebp
  0017d	5d		 pop	 ebp
  0017e	c2 04 00	 ret	 4
  00181	0f 1f 00	 npad	 3
$LN12@checkChang:
  00184	01 00 00 00	 DD	 1
  00188	00 00 00 00	 DD	 $LN11@checkChang
$LN11@checkChang:
  0018c	f4 fd ff ff	 DD	 -524			; fffffdf4H
  00190	00 02 00 00	 DD	 512			; 00000200H
  00194	00 00 00 00	 DD	 $LN10@checkChang
$LN10@checkChang:
  00198	73		 DB	 115			; 00000073H
  00199	7a		 DB	 122			; 0000007aH
  0019a	46		 DB	 70			; 00000046H
  0019b	69		 DB	 105			; 00000069H
  0019c	6c		 DB	 108			; 0000006cH
  0019d	65		 DB	 101			; 00000065H
  0019e	00		 DB	 0
?checkChangeProc@CLogger@@QAEXH@Z ENDP			; CLogger::checkChangeProc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comlogger.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?disable@CLogger@@QAEXXZ PROC				; CLogger::disable
; _this$ = ecx

; 474  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 475  : 	clearLogFlag(IS_LOG_ENABLE);

  0000f	68 00 00 08 00	 push	 524288			; 00080000H
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?clearLogFlag@CLogger@@QAEXW4E_LOG_FLAG@@@Z ; CLogger::clearLogFlag

; 476  : 	if (m_hFile) {

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	83 78 58 00	 cmp	 DWORD PTR [eax+88], 0
  00023	74 30		 je	 SHORT $LN1@disable

; 477  : 		clearLogFlag(IS_LOG_OPEN);

  00025	68 00 00 04 00	 push	 262144			; 00040000H
  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ?clearLogFlag@CLogger@@QAEXW4E_LOG_FLAG@@@Z ; CLogger::clearLogFlag

; 478  : 		fclose(m_hFile); m_hFile = NULL;

  00032	8b f4		 mov	 esi, esp
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	8b 51 58	 mov	 edx, DWORD PTR [ecx+88]
  0003a	52		 push	 edx
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00041	83 c4 04	 add	 esp, 4
  00044	3b f4		 cmp	 esi, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [eax+88], 0
$LN1@disable:

; 479  : 	}
; 480  : }

  00055	5e		 pop	 esi
  00056	83 c4 04	 add	 esp, 4
  00059	3b ec		 cmp	 ebp, esp
  0005b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
?disable@CLogger@@QAEXXZ ENDP				; CLogger::disable
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comlogger.cpp
_TEXT	SEGMENT
tv129 = -128						; size = 4
_pBuf$ = -124						; size = 4
_nLen$ = -120						; size = 4
_nLCompare$ = -116					; size = 4
_i$ = -112						; size = 4
_fmtStr$ = -104						; size = 20
_header$ = -76						; size = 64
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_nLevel$ = 8						; size = 4
_nKind$ = 12						; size = 4
_nSocket$ = 16						; size = 4
_szBuffer$ = 20						; size = 4
_nPacketSize$ = 24					; size = 4
?WritePacket@CLogger@@QAEXHHHPADH@Z PROC		; CLogger::WritePacket
; _this$ = ecx

; 569  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	57		 push	 edi
  0000a	51		 push	 ecx
  0000b	8d 7d 80	 lea	 edi, DWORD PTR [ebp-128]
  0000e	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00013	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00018	f3 ab		 rep stosd
  0001a	59		 pop	 ecx
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00025	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 570  : 	if (!isLogFlag(IS_LOG_ENABLE)) return;

  00028	68 00 00 08 00	 push	 524288			; 00080000H
  0002d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?isLogFlag@CLogger@@QAE_NW4E_LOG_FLAG@@@Z ; CLogger::isLogFlag
  00035	0f b6 c0	 movzx	 eax, al
  00038	85 c0		 test	 eax, eax
  0003a	75 05		 jne	 SHORT $LN4@WritePacke
  0003c	e9 2d 01 00 00	 jmp	 $LN1@WritePacke
$LN4@WritePacke:

; 571  : 	if (nLevel < m_nLogLevel) return;

  00041	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	8b 55 08	 mov	 edx, DWORD PTR _nLevel$[ebp]
  00047	3b 51 4c	 cmp	 edx, DWORD PTR [ecx+76]
  0004a	7d 05		 jge	 SHORT $LN5@WritePacke
  0004c	e9 1d 01 00 00	 jmp	 $LN1@WritePacke
$LN5@WritePacke:

; 572  : 
; 573  : 	TCHAR header[LEN_LOG_HEADER];
; 574  : 	const TCHAR	*fmtStr[5] = {
; 575  : 		_T(" nSIdx[%d] Send [%d] PKIdx[%d] "),

  00051	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _fmtStr$[ebp], OFFSET $SG86808

; 576  : 		_T(" nSIdx[%d] Recv [%d] PKIdx[%d] "),

  00058	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _fmtStr$[ebp+4], OFFSET $SG86809

; 577  : 		_T(" nSIdx[%d] send Queue [%d] PKIdx[%d] "),

  0005f	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _fmtStr$[ebp+8], OFFSET $SG86810

; 578  : 		_T(" nSIdx[%d] recv Queue [%d] PKIdx[%d] "),

  00066	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _fmtStr$[ebp+12], OFFSET $SG86811

; 579  : 		_T(" Undefind nkind[%d] [%d] PKIdx[%d] ")

  0006d	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _fmtStr$[ebp+16], OFFSET $SG86812

; 580  : 	};
; 581  : 
; 582  : 	if (nKind < 0 || nKind > 4) nKind = 4;

  00074	83 7d 0c 00	 cmp	 DWORD PTR _nKind$[ebp], 0
  00078	7c 06		 jl	 SHORT $LN7@WritePacke
  0007a	83 7d 0c 04	 cmp	 DWORD PTR _nKind$[ebp], 4
  0007e	7e 07		 jle	 SHORT $LN6@WritePacke
$LN7@WritePacke:
  00080	c7 45 0c 04 00
	00 00		 mov	 DWORD PTR _nKind$[ebp], 4
$LN6@WritePacke:

; 583  : 
; 584  : 	int	i=0, nLCompare, nLen;

  00087	c7 45 90 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 585  : 	nLen = setHeader(header, nLevel);

  0008e	8b 45 08	 mov	 eax, DWORD PTR _nLevel$[ebp]
  00091	50		 push	 eax
  00092	8d 4d b4	 lea	 ecx, DWORD PTR _header$[ebp]
  00095	51		 push	 ecx
  00096	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	e8 00 00 00 00	 call	 ?setHeader@CLogger@@QAEHPADH@Z ; CLogger::setHeader
  0009e	89 45 88	 mov	 DWORD PTR _nLen$[ebp], eax

; 586  : 
; 587  : 
; 588  : 	nLen += _stprintf(header +nLen, fmtStr[nKind], nSocket, nPacketSize, nKind);

  000a1	8b 55 0c	 mov	 edx, DWORD PTR _nKind$[ebp]
  000a4	52		 push	 edx
  000a5	8b 45 18	 mov	 eax, DWORD PTR _nPacketSize$[ebp]
  000a8	50		 push	 eax
  000a9	8b 4d 10	 mov	 ecx, DWORD PTR _nSocket$[ebp]
  000ac	51		 push	 ecx
  000ad	8b 55 0c	 mov	 edx, DWORD PTR _nKind$[ebp]
  000b0	8b 44 95 98	 mov	 eax, DWORD PTR _fmtStr$[ebp+edx*4]
  000b4	50		 push	 eax
  000b5	8b 4d 88	 mov	 ecx, DWORD PTR _nLen$[ebp]
  000b8	8d 54 0d b4	 lea	 edx, DWORD PTR _header$[ebp+ecx]
  000bc	52		 push	 edx
  000bd	e8 00 00 00 00	 call	 _sprintf
  000c2	83 c4 14	 add	 esp, 20			; 00000014H
  000c5	03 45 88	 add	 eax, DWORD PTR _nLen$[ebp]
  000c8	89 45 88	 mov	 DWORD PTR _nLen$[ebp], eax

; 589  : 	nLCompare = (int)_tcslen(szBuffer);

  000cb	8b 45 14	 mov	 eax, DWORD PTR _szBuffer$[ebp]
  000ce	50		 push	 eax
  000cf	e8 00 00 00 00	 call	 _strlen
  000d4	83 c4 04	 add	 esp, 4
  000d7	89 45 8c	 mov	 DWORD PTR _nLCompare$[ebp], eax

; 590  : 	
; 591  : 	TCHAR *pBuf = (TCHAR *)gs_pMMgr->newBuf(LEN_TO_SIZE(nLen + nLCompare + 2));

  000da	8b 4d 8c	 mov	 ecx, DWORD PTR _nLCompare$[ebp]
  000dd	8b 55 88	 mov	 edx, DWORD PTR _nLen$[ebp]
  000e0	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  000e4	50		 push	 eax
  000e5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pMMgr@@3PAVCMemManager@@A ; gs_pMMgr
  000eb	e8 00 00 00 00	 call	 ?newBuf@CMemManager@@QAEPADH@Z ; CMemManager::newBuf
  000f0	89 45 84	 mov	 DWORD PTR _pBuf$[ebp], eax

; 592  : 
; 593  : 	_tcscpy(pBuf, header);

  000f3	8d 4d b4	 lea	 ecx, DWORD PTR _header$[ebp]
  000f6	51		 push	 ecx
  000f7	8b 55 84	 mov	 edx, DWORD PTR _pBuf$[ebp]
  000fa	52		 push	 edx
  000fb	e8 00 00 00 00	 call	 _strcpy
  00100	83 c4 08	 add	 esp, 8
$LN2@WritePacke:

; 594  : 
; 595  : 	while (nPacketSize--) {

  00103	8b 45 18	 mov	 eax, DWORD PTR _nPacketSize$[ebp]
  00106	89 45 80	 mov	 DWORD PTR tv129[ebp], eax
  00109	8b 4d 18	 mov	 ecx, DWORD PTR _nPacketSize$[ebp]
  0010c	83 e9 01	 sub	 ecx, 1
  0010f	89 4d 18	 mov	 DWORD PTR _nPacketSize$[ebp], ecx
  00112	83 7d 80 00	 cmp	 DWORD PTR tv129[ebp], 0
  00116	74 37		 je	 SHORT $LN3@WritePacke

; 596  : 		_stprintf(pBuf+nLen, _T("%02x "), szBuffer[i] & 0x0ff);

  00118	8b 55 14	 mov	 edx, DWORD PTR _szBuffer$[ebp]
  0011b	03 55 90	 add	 edx, DWORD PTR _i$[ebp]
  0011e	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00121	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00126	50		 push	 eax
  00127	68 00 00 00 00	 push	 OFFSET $SG86815
  0012c	8b 4d 84	 mov	 ecx, DWORD PTR _pBuf$[ebp]
  0012f	03 4d 88	 add	 ecx, DWORD PTR _nLen$[ebp]
  00132	51		 push	 ecx
  00133	e8 00 00 00 00	 call	 _sprintf
  00138	83 c4 0c	 add	 esp, 12			; 0000000cH

; 597  : 		nLen += 3; i++;

  0013b	8b 55 88	 mov	 edx, DWORD PTR _nLen$[ebp]
  0013e	83 c2 03	 add	 edx, 3
  00141	89 55 88	 mov	 DWORD PTR _nLen$[ebp], edx
  00144	8b 45 90	 mov	 eax, DWORD PTR _i$[ebp]
  00147	83 c0 01	 add	 eax, 1
  0014a	89 45 90	 mov	 DWORD PTR _i$[ebp], eax

; 598  : 	}

  0014d	eb b4		 jmp	 SHORT $LN2@WritePacke
$LN3@WritePacke:

; 599  : 	pBuf[nLen] = '\n';

  0014f	8b 4d 84	 mov	 ecx, DWORD PTR _pBuf$[ebp]
  00152	03 4d 88	 add	 ecx, DWORD PTR _nLen$[ebp]
  00155	c6 01 0a	 mov	 BYTE PTR [ecx], 10	; 0000000aH

; 600  : 	pBuf[nLen + 1] = 0;

  00158	8b 55 84	 mov	 edx, DWORD PTR _pBuf$[ebp]
  0015b	03 55 88	 add	 edx, DWORD PTR _nLen$[ebp]
  0015e	c6 42 01 00	 mov	 BYTE PTR [edx+1], 0

; 601  : 
; 602  : 	putQueue(pBuf);

  00162	8b 45 84	 mov	 eax, DWORD PTR _pBuf$[ebp]
  00165	50		 push	 eax
  00166	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00169	e8 00 00 00 00	 call	 ?putQueue@CLogger@@QAEXPAD@Z ; CLogger::putQueue
$LN1@WritePacke:

; 603  : }

  0016e	52		 push	 edx
  0016f	8b cd		 mov	 ecx, ebp
  00171	50		 push	 eax
  00172	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN12@WritePacke
  00178	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0017d	58		 pop	 eax
  0017e	5a		 pop	 edx
  0017f	5f		 pop	 edi
  00180	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00183	33 cd		 xor	 ecx, ebp
  00185	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0018a	81 c4 80 00 00
	00		 add	 esp, 128		; 00000080H
  00190	3b ec		 cmp	 ebp, esp
  00192	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00197	8b e5		 mov	 esp, ebp
  00199	5d		 pop	 ebp
  0019a	c2 14 00	 ret	 20			; 00000014H
  0019d	0f 1f 00	 npad	 3
$LN12@WritePacke:
  001a0	02 00 00 00	 DD	 2
  001a4	00 00 00 00	 DD	 $LN11@WritePacke
$LN11@WritePacke:
  001a8	b4 ff ff ff	 DD	 -76			; ffffffb4H
  001ac	40 00 00 00	 DD	 64			; 00000040H
  001b0	00 00 00 00	 DD	 $LN9@WritePacke
  001b4	98 ff ff ff	 DD	 -104			; ffffff98H
  001b8	14 00 00 00	 DD	 20			; 00000014H
  001bc	00 00 00 00	 DD	 $LN10@WritePacke
$LN10@WritePacke:
  001c0	66		 DB	 102			; 00000066H
  001c1	6d		 DB	 109			; 0000006dH
  001c2	74		 DB	 116			; 00000074H
  001c3	53		 DB	 83			; 00000053H
  001c4	74		 DB	 116			; 00000074H
  001c5	72		 DB	 114			; 00000072H
  001c6	00		 DB	 0
$LN9@WritePacke:
  001c7	68		 DB	 104			; 00000068H
  001c8	65		 DB	 101			; 00000065H
  001c9	61		 DB	 97			; 00000061H
  001ca	64		 DB	 100			; 00000064H
  001cb	65		 DB	 101			; 00000065H
  001cc	72		 DB	 114			; 00000072H
  001cd	00		 DB	 0
?WritePacket@CLogger@@QAEXHHHPADH@Z ENDP		; CLogger::WritePacket
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comlogger.cpp
_TEXT	SEGMENT
_pBuf$ = -8736						; size = 4
_ap$ = -8732						; size = 4
_header$ = -8724					; size = 512
_msgBuf$ = -8204					; size = 8192
_nLen$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_this$ = 8						; size = 4
_level$ = 12						; size = 4
__szFormat$ = 16					; size = 4
?LogPrint@CLogger@@QAAXHPBDZZ PROC			; CLogger::LogPrint

; 542  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 20 22 00 00	 mov	 eax, 8736		; 00002220H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	57		 push	 edi
  0000e	8d bd e0 dd ff
	ff		 lea	 edi, DWORD PTR [ebp-8736]
  00014	b9 88 08 00 00	 mov	 ecx, 2184		; 00000888H
  00019	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001e	f3 ab		 rep stosd
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 543  : 	if (!isLogFlag(IS_LOG_ENABLE)) return;

  0002a	68 00 00 08 00	 push	 524288			; 00080000H
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?isLogFlag@CLogger@@QAE_NW4E_LOG_FLAG@@@Z ; CLogger::isLogFlag
  00037	0f b6 c0	 movzx	 eax, al
  0003a	85 c0		 test	 eax, eax
  0003c	75 05		 jne	 SHORT $LN2@LogPrint
  0003e	e9 d5 00 00 00	 jmp	 $LN1@LogPrint
$LN2@LogPrint:

; 544  : 	if (level < m_nLogLevel) return;

  00043	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	8b 55 0c	 mov	 edx, DWORD PTR _level$[ebp]
  00049	3b 51 4c	 cmp	 edx, DWORD PTR [ecx+76]
  0004c	7d 05		 jge	 SHORT $LN3@LogPrint
  0004e	e9 c5 00 00 00	 jmp	 $LN1@LogPrint
$LN3@LogPrint:

; 545  : 
; 546  : //	char tmpBuf[512];
; 547  : 	int nLen;
; 548  : 
; 549  : 	TCHAR	msgBuf[MAX_LOGBUF_LEN];
; 550  : 	TCHAR	header[512];
; 551  : 	va_list	ap;
; 552  : 
; 553  : 	nLen = setHeader(header, level);

  00053	8b 45 0c	 mov	 eax, DWORD PTR _level$[ebp]
  00056	50		 push	 eax
  00057	8d 8d ec dd ff
	ff		 lea	 ecx, DWORD PTR _header$[ebp]
  0005d	51		 push	 ecx
  0005e	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	e8 00 00 00 00	 call	 ?setHeader@CLogger@@QAEHPADH@Z ; CLogger::setHeader
  00066	89 45 f8	 mov	 DWORD PTR _nLen$[ebp], eax

; 554  : 	sprintf(header + nLen, " %s ", _szFormat);

  00069	8b 55 10	 mov	 edx, DWORD PTR __szFormat$[ebp]
  0006c	52		 push	 edx
  0006d	68 00 00 00 00	 push	 OFFSET $SG86787
  00072	8b 45 f8	 mov	 eax, DWORD PTR _nLen$[ebp]
  00075	8d 8c 05 ec dd
	ff ff		 lea	 ecx, DWORD PTR _header$[ebp+eax]
  0007c	51		 push	 ecx
  0007d	e8 00 00 00 00	 call	 _sprintf
  00082	83 c4 0c	 add	 esp, 12			; 0000000cH

; 555  : 	va_start(ap, _szFormat);

  00085	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@PBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const *>
  0008a	8d 55 14	 lea	 edx, DWORD PTR __szFormat$[ebp+4]
  0008d	89 95 e4 dd ff
	ff		 mov	 DWORD PTR _ap$[ebp], edx

; 556  : 	nLen = vsnprintf(msgBuf, MAX_LOGBUF_LEN - 1, header, ap);

  00093	8b 85 e4 dd ff
	ff		 mov	 eax, DWORD PTR _ap$[ebp]
  00099	50		 push	 eax
  0009a	8d 8d ec dd ff
	ff		 lea	 ecx, DWORD PTR _header$[ebp]
  000a0	51		 push	 ecx
  000a1	68 ff 1f 00 00	 push	 8191			; 00001fffH
  000a6	8d 95 f4 df ff
	ff		 lea	 edx, DWORD PTR _msgBuf$[ebp]
  000ac	52		 push	 edx
  000ad	e8 00 00 00 00	 call	 _vsnprintf
  000b2	83 c4 10	 add	 esp, 16			; 00000010H
  000b5	89 45 f8	 mov	 DWORD PTR _nLen$[ebp], eax

; 557  : 	va_end(ap);

  000b8	c7 85 e4 dd ff
	ff 00 00 00 00	 mov	 DWORD PTR _ap$[ebp], 0

; 558  : 
; 559  : 	TCHAR *pBuf = (TCHAR *)gs_pMMgr->newBuf(LEN_TO_SIZE(nLen + 2));

  000c2	8b 45 f8	 mov	 eax, DWORD PTR _nLen$[ebp]
  000c5	83 c0 02	 add	 eax, 2
  000c8	50		 push	 eax
  000c9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pMMgr@@3PAVCMemManager@@A ; gs_pMMgr
  000cf	e8 00 00 00 00	 call	 ?newBuf@CMemManager@@QAEPADH@Z ; CMemManager::newBuf
  000d4	89 85 e0 dd ff
	ff		 mov	 DWORD PTR _pBuf$[ebp], eax

; 560  : 	_tcscpy(pBuf, msgBuf);

  000da	8d 8d f4 df ff
	ff		 lea	 ecx, DWORD PTR _msgBuf$[ebp]
  000e0	51		 push	 ecx
  000e1	8b 95 e0 dd ff
	ff		 mov	 edx, DWORD PTR _pBuf$[ebp]
  000e7	52		 push	 edx
  000e8	e8 00 00 00 00	 call	 _strcpy
  000ed	83 c4 08	 add	 esp, 8

; 561  : 	pBuf[nLen] = '\n';

  000f0	8b 85 e0 dd ff
	ff		 mov	 eax, DWORD PTR _pBuf$[ebp]
  000f6	03 45 f8	 add	 eax, DWORD PTR _nLen$[ebp]
  000f9	c6 00 0a	 mov	 BYTE PTR [eax], 10	; 0000000aH

; 562  : 	pBuf[nLen + 1] = 0;

  000fc	8b 8d e0 dd ff
	ff		 mov	 ecx, DWORD PTR _pBuf$[ebp]
  00102	03 4d f8	 add	 ecx, DWORD PTR _nLen$[ebp]
  00105	c6 41 01 00	 mov	 BYTE PTR [ecx+1], 0

; 563  : 
; 564  : 	LogPrint(pBuf);

  00109	8b 95 e0 dd ff
	ff		 mov	 edx, DWORD PTR _pBuf$[ebp]
  0010f	52		 push	 edx
  00110	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00113	e8 00 00 00 00	 call	 ?LogPrint@CLogger@@QAEXPAD@Z ; CLogger::LogPrint
$LN1@LogPrint:

; 565  : }

  00118	52		 push	 edx
  00119	8b cd		 mov	 ecx, ebp
  0011b	50		 push	 eax
  0011c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@LogPrint
  00122	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00127	58		 pop	 eax
  00128	5a		 pop	 edx
  00129	5f		 pop	 edi
  0012a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0012d	33 cd		 xor	 ecx, ebp
  0012f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00134	81 c4 20 22 00
	00		 add	 esp, 8736		; 00002220H
  0013a	3b ec		 cmp	 ebp, esp
  0013c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00141	8b e5		 mov	 esp, ebp
  00143	5d		 pop	 ebp
  00144	c3		 ret	 0
  00145	0f 1f 00	 npad	 3
$LN8@LogPrint:
  00148	02 00 00 00	 DD	 2
  0014c	00 00 00 00	 DD	 $LN7@LogPrint
$LN7@LogPrint:
  00150	f4 df ff ff	 DD	 -8204			; ffffdff4H
  00154	00 20 00 00	 DD	 8192			; 00002000H
  00158	00 00 00 00	 DD	 $LN5@LogPrint
  0015c	ec dd ff ff	 DD	 -8724			; ffffddecH
  00160	00 02 00 00	 DD	 512			; 00000200H
  00164	00 00 00 00	 DD	 $LN6@LogPrint
$LN6@LogPrint:
  00168	68		 DB	 104			; 00000068H
  00169	65		 DB	 101			; 00000065H
  0016a	61		 DB	 97			; 00000061H
  0016b	64		 DB	 100			; 00000064H
  0016c	65		 DB	 101			; 00000065H
  0016d	72		 DB	 114			; 00000072H
  0016e	00		 DB	 0
$LN5@LogPrint:
  0016f	6d		 DB	 109			; 0000006dH
  00170	73		 DB	 115			; 00000073H
  00171	67		 DB	 103			; 00000067H
  00172	42		 DB	 66			; 00000042H
  00173	75		 DB	 117			; 00000075H
  00174	66		 DB	 102			; 00000066H
  00175	00		 DB	 0
?LogPrint@CLogger@@QAAXHPBDZZ ENDP			; CLogger::LogPrint
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comlogger.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pLog$ = 8						; size = 4
?LogPrint@CLogger@@QAEXPAD@Z PROC			; CLogger::LogPrint
; _this$ = ecx

; 483  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 484  : 	if (m_fpDataProc) m_fpDataProc(pLog, m_pObj);

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  00016	74 1f		 je	 SHORT $LN2@LogPrint
  00018	8b f4		 mov	 esi, esp
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  00020	52		 push	 edx
  00021	8b 45 08	 mov	 eax, DWORD PTR _pLog$[ebp]
  00024	50		 push	 eax
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  0002b	ff d2		 call	 edx
  0002d	83 c4 08	 add	 esp, 8
  00030	3b f4		 cmp	 esi, esp
  00032	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@LogPrint:

; 485  : 	if (m_hFile) {

  00037	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	83 78 58 00	 cmp	 DWORD PTR [eax+88], 0
  0003e	74 5a		 je	 SHORT $LN1@LogPrint

; 486  : 		if (m_nLogFlag & IS_PRINT) _tprintf(pLog);

  00040	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	8b 51 74	 mov	 edx, DWORD PTR [ecx+116]
  00046	81 e2 00 20 00
	00		 and	 edx, 8192		; 00002000H
  0004c	74 0c		 je	 SHORT $LN4@LogPrint
  0004e	8b 45 08	 mov	 eax, DWORD PTR _pLog$[ebp]
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 _printf
  00057	83 c4 04	 add	 esp, 4
$LN4@LogPrint:

; 487  : 		if (isLogFlag(IS_LOG_OPEN)) {

  0005a	68 00 00 04 00	 push	 262144			; 00040000H
  0005f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00062	e8 00 00 00 00	 call	 ?isLogFlag@CLogger@@QAE_NW4E_LOG_FLAG@@@Z ; CLogger::isLogFlag
  00067	0f b6 c8	 movzx	 ecx, al
  0006a	85 c9		 test	 ecx, ecx
  0006c	74 2c		 je	 SHORT $LN1@LogPrint

; 488  : 			_ftprintf(m_hFile, pLog);

  0006e	8b 55 08	 mov	 edx, DWORD PTR _pLog$[ebp]
  00071	52		 push	 edx
  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  00078	51		 push	 ecx
  00079	e8 00 00 00 00	 call	 _fprintf
  0007e	83 c4 08	 add	 esp, 8

; 489  : 			fflush(m_hFile);

  00081	8b f4		 mov	 esi, esp
  00083	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00086	8b 42 58	 mov	 eax, DWORD PTR [edx+88]
  00089	50		 push	 eax
  0008a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fflush
  00090	83 c4 04	 add	 esp, 4
  00093	3b f4		 cmp	 esi, esp
  00095	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@LogPrint:

; 490  : 		}
; 491  : 		//else {
; 492  : 		//	//m_cLock.enter();
; 493  : 		//	_ftprintf(m_hFile, pLog);
; 494  : 		//	fflush(m_hFile);
; 495  : 		//	//m_cLock.leave();
; 496  : 		//}
; 497  : 
; 498  : 	}
; 499  : }

  0009a	5e		 pop	 esi
  0009b	83 c4 04	 add	 esp, 4
  0009e	3b ec		 cmp	 ebp, esp
  000a0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	c2 04 00	 ret	 4
?LogPrint@CLogger@@QAEXPAD@Z ENDP			; CLogger::LogPrint
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comlogger.cpp
_TEXT	SEGMENT
_pBuf$ = -8224						; size = 4
_headerBuf$ = -8216					; size = 8192
_totlen$ = -20						; size = 4
_bodyLen$ = -16						; size = 4
_headerLen$ = -12					; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_level$ = 8						; size = 4
_body$ = 12						; size = 4
_header$ = 16						; size = 4
_tail$ = 20						; size = 4
_bToFile$ = 24						; size = 1
?Log@CLogger@@QAEXHPBD00_N@Z PROC			; CLogger::Log
; _this$ = ecx

; 502  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 20 20 00 00	 mov	 eax, 8224		; 00002020H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	51		 push	 ecx
  00010	8d bd e0 df ff
	ff		 lea	 edi, DWORD PTR [ebp-8224]
  00016	b9 08 08 00 00	 mov	 ecx, 2056		; 00000808H
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	59		 pop	 ecx
  00023	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00028	33 c5		 xor	 eax, ebp
  0002a	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 503  : 	if (!isLogFlag(IS_LOG_ENABLE)) return;

  00030	68 00 00 08 00	 push	 524288			; 00080000H
  00035	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ?isLogFlag@CLogger@@QAE_NW4E_LOG_FLAG@@@Z ; CLogger::isLogFlag
  0003d	0f b6 c0	 movzx	 eax, al
  00040	85 c0		 test	 eax, eax
  00042	75 05		 jne	 SHORT $LN2@Log
  00044	e9 7c 01 00 00	 jmp	 $LN1@Log
$LN2@Log:

; 504  : 	if (level < m_nLogLevel) return;

  00049	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	8b 55 08	 mov	 edx, DWORD PTR _level$[ebp]
  0004f	3b 51 4c	 cmp	 edx, DWORD PTR [ecx+76]
  00052	7d 05		 jge	 SHORT $LN3@Log
  00054	e9 6c 01 00 00	 jmp	 $LN1@Log
$LN3@Log:

; 505  : 
; 506  : 	int headerLen, bodyLen=0, totlen=0;

  00059	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _bodyLen$[ebp], 0
  00060	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _totlen$[ebp], 0

; 507  : 
; 508  : 	TCHAR    headerBuf[MAX_LOGBUF_LEN];
; 509  : 	TCHAR *pBuf;
; 510  : 
; 511  : 	headerLen = setHeader(headerBuf, level);

  00067	8b 45 08	 mov	 eax, DWORD PTR _level$[ebp]
  0006a	50		 push	 eax
  0006b	8d 8d e8 df ff
	ff		 lea	 ecx, DWORD PTR _headerBuf$[ebp]
  00071	51		 push	 ecx
  00072	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	e8 00 00 00 00	 call	 ?setHeader@CLogger@@QAEHPADH@Z ; CLogger::setHeader
  0007a	89 45 f4	 mov	 DWORD PTR _headerLen$[ebp], eax

; 512  : 
; 513  : 	// calculate total length ----------------
; 514  : 	if (header) {

  0007d	83 7d 10 00	 cmp	 DWORD PTR _header$[ebp], 0
  00081	74 29		 je	 SHORT $LN4@Log

; 515  : 		_tcscpy(headerBuf + headerLen, header); headerLen += (int)_tcslen(header);;

  00083	8b 55 10	 mov	 edx, DWORD PTR _header$[ebp]
  00086	52		 push	 edx
  00087	8b 45 f4	 mov	 eax, DWORD PTR _headerLen$[ebp]
  0008a	8d 8c 05 e8 df
	ff ff		 lea	 ecx, DWORD PTR _headerBuf$[ebp+eax]
  00091	51		 push	 ecx
  00092	e8 00 00 00 00	 call	 _strcpy
  00097	83 c4 08	 add	 esp, 8
  0009a	8b 55 10	 mov	 edx, DWORD PTR _header$[ebp]
  0009d	52		 push	 edx
  0009e	e8 00 00 00 00	 call	 _strlen
  000a3	83 c4 04	 add	 esp, 4
  000a6	03 45 f4	 add	 eax, DWORD PTR _headerLen$[ebp]
  000a9	89 45 f4	 mov	 DWORD PTR _headerLen$[ebp], eax
$LN4@Log:

; 516  : 	}
; 517  : 	bodyLen = (int)_tcslen(body);

  000ac	8b 45 0c	 mov	 eax, DWORD PTR _body$[ebp]
  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 _strlen
  000b5	83 c4 04	 add	 esp, 4
  000b8	89 45 f0	 mov	 DWORD PTR _bodyLen$[ebp], eax

; 518  : 	if (tail) { 

  000bb	83 7d 14 00	 cmp	 DWORD PTR _tail$[ebp], 0
  000bf	74 76		 je	 SHORT $LN5@Log

; 519  : 		totlen = headerLen + bodyLen + (int)_tcslen(tail);

  000c1	8b 75 f4	 mov	 esi, DWORD PTR _headerLen$[ebp]
  000c4	03 75 f0	 add	 esi, DWORD PTR _bodyLen$[ebp]
  000c7	8b 4d 14	 mov	 ecx, DWORD PTR _tail$[ebp]
  000ca	51		 push	 ecx
  000cb	e8 00 00 00 00	 call	 _strlen
  000d0	83 c4 04	 add	 esp, 4
  000d3	03 f0		 add	 esi, eax
  000d5	89 75 ec	 mov	 DWORD PTR _totlen$[ebp], esi

; 520  : 		pBuf = (TCHAR *)gs_pMMgr->newBuf(LEN_TO_SIZE(totlen + 2));

  000d8	8b 55 ec	 mov	 edx, DWORD PTR _totlen$[ebp]
  000db	83 c2 02	 add	 edx, 2
  000de	52		 push	 edx
  000df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pMMgr@@3PAVCMemManager@@A ; gs_pMMgr
  000e5	e8 00 00 00 00	 call	 ?newBuf@CMemManager@@QAEPADH@Z ; CMemManager::newBuf
  000ea	89 85 e0 df ff
	ff		 mov	 DWORD PTR _pBuf$[ebp], eax

; 521  : 		_tcscpy(pBuf, headerBuf);

  000f0	8d 85 e8 df ff
	ff		 lea	 eax, DWORD PTR _headerBuf$[ebp]
  000f6	50		 push	 eax
  000f7	8b 8d e0 df ff
	ff		 mov	 ecx, DWORD PTR _pBuf$[ebp]
  000fd	51		 push	 ecx
  000fe	e8 00 00 00 00	 call	 _strcpy
  00103	83 c4 08	 add	 esp, 8

; 522  : 		_tcscpy(pBuf + headerLen, body);

  00106	8b 55 0c	 mov	 edx, DWORD PTR _body$[ebp]
  00109	52		 push	 edx
  0010a	8b 85 e0 df ff
	ff		 mov	 eax, DWORD PTR _pBuf$[ebp]
  00110	03 45 f4	 add	 eax, DWORD PTR _headerLen$[ebp]
  00113	50		 push	 eax
  00114	e8 00 00 00 00	 call	 _strcpy
  00119	83 c4 08	 add	 esp, 8

; 523  : 		_tcscpy(pBuf + headerLen + bodyLen, tail);

  0011c	8b 4d 14	 mov	 ecx, DWORD PTR _tail$[ebp]
  0011f	51		 push	 ecx
  00120	8b 95 e0 df ff
	ff		 mov	 edx, DWORD PTR _pBuf$[ebp]
  00126	03 55 f4	 add	 edx, DWORD PTR _headerLen$[ebp]
  00129	03 55 f0	 add	 edx, DWORD PTR _bodyLen$[ebp]
  0012c	52		 push	 edx
  0012d	e8 00 00 00 00	 call	 _strcpy
  00132	83 c4 08	 add	 esp, 8

; 524  : 	}
; 525  : 	else {

  00135	eb 4d		 jmp	 SHORT $LN6@Log
$LN5@Log:

; 526  : 		totlen = headerLen + bodyLen;

  00137	8b 45 f4	 mov	 eax, DWORD PTR _headerLen$[ebp]
  0013a	03 45 f0	 add	 eax, DWORD PTR _bodyLen$[ebp]
  0013d	89 45 ec	 mov	 DWORD PTR _totlen$[ebp], eax

; 527  : 		pBuf = (TCHAR *)gs_pMMgr->newBuf(LEN_TO_SIZE(totlen + 2));

  00140	8b 4d ec	 mov	 ecx, DWORD PTR _totlen$[ebp]
  00143	83 c1 02	 add	 ecx, 2
  00146	51		 push	 ecx
  00147	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pMMgr@@3PAVCMemManager@@A ; gs_pMMgr
  0014d	e8 00 00 00 00	 call	 ?newBuf@CMemManager@@QAEPADH@Z ; CMemManager::newBuf
  00152	89 85 e0 df ff
	ff		 mov	 DWORD PTR _pBuf$[ebp], eax

; 528  : 		_tcscpy(pBuf, headerBuf);

  00158	8d 95 e8 df ff
	ff		 lea	 edx, DWORD PTR _headerBuf$[ebp]
  0015e	52		 push	 edx
  0015f	8b 85 e0 df ff
	ff		 mov	 eax, DWORD PTR _pBuf$[ebp]
  00165	50		 push	 eax
  00166	e8 00 00 00 00	 call	 _strcpy
  0016b	83 c4 08	 add	 esp, 8

; 529  : 		_tcscpy(pBuf + headerLen, body);

  0016e	8b 4d 0c	 mov	 ecx, DWORD PTR _body$[ebp]
  00171	51		 push	 ecx
  00172	8b 95 e0 df ff
	ff		 mov	 edx, DWORD PTR _pBuf$[ebp]
  00178	03 55 f4	 add	 edx, DWORD PTR _headerLen$[ebp]
  0017b	52		 push	 edx
  0017c	e8 00 00 00 00	 call	 _strcpy
  00181	83 c4 08	 add	 esp, 8
$LN6@Log:

; 530  : 	}
; 531  : 	// calcuate end -------------------------
; 532  : 
; 533  : 	pBuf[totlen] = '\n';

  00184	8b 85 e0 df ff
	ff		 mov	 eax, DWORD PTR _pBuf$[ebp]
  0018a	03 45 ec	 add	 eax, DWORD PTR _totlen$[ebp]
  0018d	c6 00 0a	 mov	 BYTE PTR [eax], 10	; 0000000aH

; 534  : 	pBuf[totlen+1] = 0;

  00190	8b 8d e0 df ff
	ff		 mov	 ecx, DWORD PTR _pBuf$[ebp]
  00196	03 4d ec	 add	 ecx, DWORD PTR _totlen$[ebp]
  00199	c6 41 01 00	 mov	 BYTE PTR [ecx+1], 0

; 535  : 	if (bToFile) {

  0019d	0f b6 55 18	 movzx	 edx, BYTE PTR _bToFile$[ebp]
  001a1	85 d2		 test	 edx, edx
  001a3	74 11		 je	 SHORT $LN7@Log

; 536  : 		LogPrint(pBuf); return;

  001a5	8b 85 e0 df ff
	ff		 mov	 eax, DWORD PTR _pBuf$[ebp]
  001ab	50		 push	 eax
  001ac	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001af	e8 00 00 00 00	 call	 ?LogPrint@CLogger@@QAEXPAD@Z ; CLogger::LogPrint
  001b4	eb 0f		 jmp	 SHORT $LN1@Log
$LN7@Log:

; 537  : 	}
; 538  : 	putQueue(pBuf);

  001b6	8b 8d e0 df ff
	ff		 mov	 ecx, DWORD PTR _pBuf$[ebp]
  001bc	51		 push	 ecx
  001bd	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001c0	e8 00 00 00 00	 call	 ?putQueue@CLogger@@QAEXPAD@Z ; CLogger::putQueue
$LN1@Log:

; 539  : }

  001c5	52		 push	 edx
  001c6	8b cd		 mov	 ecx, ebp
  001c8	50		 push	 eax
  001c9	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN11@Log
  001cf	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001d4	58		 pop	 eax
  001d5	5a		 pop	 edx
  001d6	5f		 pop	 edi
  001d7	5e		 pop	 esi
  001d8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001db	33 cd		 xor	 ecx, ebp
  001dd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e2	81 c4 20 20 00
	00		 add	 esp, 8224		; 00002020H
  001e8	3b ec		 cmp	 ebp, esp
  001ea	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001ef	8b e5		 mov	 esp, ebp
  001f1	5d		 pop	 ebp
  001f2	c2 14 00	 ret	 20			; 00000014H
  001f5	0f 1f 00	 npad	 3
$LN11@Log:
  001f8	01 00 00 00	 DD	 1
  001fc	00 00 00 00	 DD	 $LN10@Log
$LN10@Log:
  00200	e8 df ff ff	 DD	 -8216			; ffffdfe8H
  00204	00 20 00 00	 DD	 8192			; 00002000H
  00208	00 00 00 00	 DD	 $LN9@Log
$LN9@Log:
  0020c	68		 DB	 104			; 00000068H
  0020d	65		 DB	 101			; 00000065H
  0020e	61		 DB	 97			; 00000061H
  0020f	64		 DB	 100			; 00000064H
  00210	65		 DB	 101			; 00000065H
  00211	72		 DB	 114			; 00000072H
  00212	42		 DB	 66			; 00000042H
  00213	75		 DB	 117			; 00000075H
  00214	66		 DB	 102			; 00000066H
  00215	00		 DB	 0
?Log@CLogger@@QAEXHPBD00_N@Z ENDP			; CLogger::Log
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comlogger.cpp
_TEXT	SEGMENT
_pBuf$ = -540						; size = 4
_nLen$ = -536						; size = 4
_nLen2$ = -532						; size = 4
_header$ = -524						; size = 512
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_level$ = 8						; size = 4
_pBody$ = 12						; size = 4
?PutLogQueue@CLogger@@QAEXHPAD@Z PROC			; CLogger::PutLogQueue
; _this$ = ecx

; 667  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 1c 02 00
	00		 sub	 esp, 540		; 0000021cH
  00009	57		 push	 edi
  0000a	51		 push	 ecx
  0000b	8d bd e4 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-540]
  00011	b9 87 00 00 00	 mov	 ecx, 135		; 00000087H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	59		 pop	 ecx
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 668  : 	if (!isLogFlag(IS_LOG_ENABLE)) return;

  0002b	68 00 00 08 00	 push	 524288			; 00080000H
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ?isLogFlag@CLogger@@QAE_NW4E_LOG_FLAG@@@Z ; CLogger::isLogFlag
  00038	0f b6 c0	 movzx	 eax, al
  0003b	85 c0		 test	 eax, eax
  0003d	75 05		 jne	 SHORT $LN2@PutLogQueu
  0003f	e9 b9 00 00 00	 jmp	 $LN1@PutLogQueu
$LN2@PutLogQueu:

; 669  : 	if (level < m_nLogLevel) return;

  00044	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	8b 55 08	 mov	 edx, DWORD PTR _level$[ebp]
  0004a	3b 51 4c	 cmp	 edx, DWORD PTR [ecx+76]
  0004d	7d 05		 jge	 SHORT $LN3@PutLogQueu
  0004f	e9 a9 00 00 00	 jmp	 $LN1@PutLogQueu
$LN3@PutLogQueu:

; 670  : 	
; 671  : 	TCHAR	header[512];
; 672  : 
; 673  : 	int nLen2	= setHeader(header, level);

  00054	8b 45 08	 mov	 eax, DWORD PTR _level$[ebp]
  00057	50		 push	 eax
  00058	8d 8d f4 fd ff
	ff		 lea	 ecx, DWORD PTR _header$[ebp]
  0005e	51		 push	 ecx
  0005f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00062	e8 00 00 00 00	 call	 ?setHeader@CLogger@@QAEHPADH@Z ; CLogger::setHeader
  00067	89 85 ec fd ff
	ff		 mov	 DWORD PTR _nLen2$[ebp], eax

; 674  : 	int nLen = (int)_tcslen(pBody) + nLen2;

  0006d	8b 55 0c	 mov	 edx, DWORD PTR _pBody$[ebp]
  00070	52		 push	 edx
  00071	e8 00 00 00 00	 call	 _strlen
  00076	83 c4 04	 add	 esp, 4
  00079	03 85 ec fd ff
	ff		 add	 eax, DWORD PTR _nLen2$[ebp]
  0007f	89 85 e8 fd ff
	ff		 mov	 DWORD PTR _nLen$[ebp], eax

; 675  : 
; 676  : 	TCHAR *pBuf = (TCHAR *)gs_pMMgr->newBuf(LEN_TO_SIZE(nLen + 2));

  00085	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _nLen$[ebp]
  0008b	83 c0 02	 add	 eax, 2
  0008e	50		 push	 eax
  0008f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pMMgr@@3PAVCMemManager@@A ; gs_pMMgr
  00095	e8 00 00 00 00	 call	 ?newBuf@CMemManager@@QAEPADH@Z ; CMemManager::newBuf
  0009a	89 85 e4 fd ff
	ff		 mov	 DWORD PTR _pBuf$[ebp], eax

; 677  : 	_tcscpy(pBuf, header);

  000a0	8d 8d f4 fd ff
	ff		 lea	 ecx, DWORD PTR _header$[ebp]
  000a6	51		 push	 ecx
  000a7	8b 95 e4 fd ff
	ff		 mov	 edx, DWORD PTR _pBuf$[ebp]
  000ad	52		 push	 edx
  000ae	e8 00 00 00 00	 call	 _strcpy
  000b3	83 c4 08	 add	 esp, 8

; 678  : 	_tcscpy(pBuf + nLen2, pBody);

  000b6	8b 45 0c	 mov	 eax, DWORD PTR _pBody$[ebp]
  000b9	50		 push	 eax
  000ba	8b 8d e4 fd ff
	ff		 mov	 ecx, DWORD PTR _pBuf$[ebp]
  000c0	03 8d ec fd ff
	ff		 add	 ecx, DWORD PTR _nLen2$[ebp]
  000c6	51		 push	 ecx
  000c7	e8 00 00 00 00	 call	 _strcpy
  000cc	83 c4 08	 add	 esp, 8

; 679  : 	pBuf[nLen] = '\n';

  000cf	8b 95 e4 fd ff
	ff		 mov	 edx, DWORD PTR _pBuf$[ebp]
  000d5	03 95 e8 fd ff
	ff		 add	 edx, DWORD PTR _nLen$[ebp]
  000db	c6 02 0a	 mov	 BYTE PTR [edx], 10	; 0000000aH

; 680  : 	pBuf[nLen + 1] = 0;

  000de	8b 85 e4 fd ff
	ff		 mov	 eax, DWORD PTR _pBuf$[ebp]
  000e4	03 85 e8 fd ff
	ff		 add	 eax, DWORD PTR _nLen$[ebp]
  000ea	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 681  : 	putQueue(pBuf);

  000ee	8b 8d e4 fd ff
	ff		 mov	 ecx, DWORD PTR _pBuf$[ebp]
  000f4	51		 push	 ecx
  000f5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000f8	e8 00 00 00 00	 call	 ?putQueue@CLogger@@QAEXPAD@Z ; CLogger::putQueue
$LN1@PutLogQueu:

; 682  : }

  000fd	52		 push	 edx
  000fe	8b cd		 mov	 ecx, ebp
  00100	50		 push	 eax
  00101	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN7@PutLogQueu
  00107	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0010c	58		 pop	 eax
  0010d	5a		 pop	 edx
  0010e	5f		 pop	 edi
  0010f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00112	33 cd		 xor	 ecx, ebp
  00114	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00119	81 c4 1c 02 00
	00		 add	 esp, 540		; 0000021cH
  0011f	3b ec		 cmp	 ebp, esp
  00121	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00126	8b e5		 mov	 esp, ebp
  00128	5d		 pop	 ebp
  00129	c2 08 00	 ret	 8
$LN7@PutLogQueu:
  0012c	01 00 00 00	 DD	 1
  00130	00 00 00 00	 DD	 $LN6@PutLogQueu
$LN6@PutLogQueu:
  00134	f4 fd ff ff	 DD	 -524			; fffffdf4H
  00138	00 02 00 00	 DD	 512			; 00000200H
  0013c	00 00 00 00	 DD	 $LN5@PutLogQueu
$LN5@PutLogQueu:
  00140	68		 DB	 104			; 00000068H
  00141	65		 DB	 101			; 00000065H
  00142	61		 DB	 97			; 00000061H
  00143	64		 DB	 100			; 00000064H
  00144	65		 DB	 101			; 00000065H
  00145	72		 DB	 114			; 00000072H
  00146	00		 DB	 0
?PutLogQueue@CLogger@@QAEXHPAD@Z ENDP			; CLogger::PutLogQueue
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comlogger.cpp
_TEXT	SEGMENT
_pBuf$ = -8736						; size = 4
_ap$ = -8732						; size = 4
_header$ = -8724					; size = 512
_msgBuf$ = -8204					; size = 8192
_nLen$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_this$ = 8						; size = 4
_level$ = 12						; size = 4
__szFormat$ = 16					; size = 4
?PutLogQueue@CLogger@@QAAXHPBDZZ PROC			; CLogger::PutLogQueue

; 644  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 20 22 00 00	 mov	 eax, 8736		; 00002220H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	57		 push	 edi
  0000e	8d bd e0 dd ff
	ff		 lea	 edi, DWORD PTR [ebp-8736]
  00014	b9 88 08 00 00	 mov	 ecx, 2184		; 00000888H
  00019	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001e	f3 ab		 rep stosd
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 645  : 	if (!isLogFlag(IS_LOG_ENABLE)) return;

  0002a	68 00 00 08 00	 push	 524288			; 00080000H
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?isLogFlag@CLogger@@QAE_NW4E_LOG_FLAG@@@Z ; CLogger::isLogFlag
  00037	0f b6 c0	 movzx	 eax, al
  0003a	85 c0		 test	 eax, eax
  0003c	75 05		 jne	 SHORT $LN2@PutLogQueu
  0003e	e9 d5 00 00 00	 jmp	 $LN1@PutLogQueu
$LN2@PutLogQueu:

; 646  : 	if (level < m_nLogLevel) return;

  00043	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	8b 55 0c	 mov	 edx, DWORD PTR _level$[ebp]
  00049	3b 51 4c	 cmp	 edx, DWORD PTR [ecx+76]
  0004c	7d 05		 jge	 SHORT $LN3@PutLogQueu
  0004e	e9 c5 00 00 00	 jmp	 $LN1@PutLogQueu
$LN3@PutLogQueu:

; 647  : 
; 648  : 	int nLen;
; 649  : 
; 650  : 	TCHAR	msgBuf[MAX_LOGBUF_LEN];
; 651  : 	TCHAR	header[512];
; 652  : 	va_list	ap;
; 653  : 
; 654  : 	nLen = setHeader(header, level);

  00053	8b 45 0c	 mov	 eax, DWORD PTR _level$[ebp]
  00056	50		 push	 eax
  00057	8d 8d ec dd ff
	ff		 lea	 ecx, DWORD PTR _header$[ebp]
  0005d	51		 push	 ecx
  0005e	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	e8 00 00 00 00	 call	 ?setHeader@CLogger@@QAEHPADH@Z ; CLogger::setHeader
  00066	89 45 f8	 mov	 DWORD PTR _nLen$[ebp], eax

; 655  : 	sprintf(header + nLen, " %s ", _szFormat);

  00069	8b 55 10	 mov	 edx, DWORD PTR __szFormat$[ebp]
  0006c	52		 push	 edx
  0006d	68 00 00 00 00	 push	 OFFSET $SG86864
  00072	8b 45 f8	 mov	 eax, DWORD PTR _nLen$[ebp]
  00075	8d 8c 05 ec dd
	ff ff		 lea	 ecx, DWORD PTR _header$[ebp+eax]
  0007c	51		 push	 ecx
  0007d	e8 00 00 00 00	 call	 _sprintf
  00082	83 c4 0c	 add	 esp, 12			; 0000000cH

; 656  : 	va_start(ap, _szFormat);

  00085	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@PBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const *>
  0008a	8d 55 14	 lea	 edx, DWORD PTR __szFormat$[ebp+4]
  0008d	89 95 e4 dd ff
	ff		 mov	 DWORD PTR _ap$[ebp], edx

; 657  : 	nLen = _vsntprintf(msgBuf, MAX_LOGBUF_LEN - 1, header, ap);

  00093	8b 85 e4 dd ff
	ff		 mov	 eax, DWORD PTR _ap$[ebp]
  00099	50		 push	 eax
  0009a	8d 8d ec dd ff
	ff		 lea	 ecx, DWORD PTR _header$[ebp]
  000a0	51		 push	 ecx
  000a1	68 ff 1f 00 00	 push	 8191			; 00001fffH
  000a6	8d 95 f4 df ff
	ff		 lea	 edx, DWORD PTR _msgBuf$[ebp]
  000ac	52		 push	 edx
  000ad	e8 00 00 00 00	 call	 __vsnprintf
  000b2	83 c4 10	 add	 esp, 16			; 00000010H
  000b5	89 45 f8	 mov	 DWORD PTR _nLen$[ebp], eax

; 658  : 	va_end(ap);

  000b8	c7 85 e4 dd ff
	ff 00 00 00 00	 mov	 DWORD PTR _ap$[ebp], 0

; 659  : 	TCHAR *pBuf = (TCHAR *)gs_pMMgr->newBuf(LEN_TO_SIZE(nLen+2));

  000c2	8b 45 f8	 mov	 eax, DWORD PTR _nLen$[ebp]
  000c5	83 c0 02	 add	 eax, 2
  000c8	50		 push	 eax
  000c9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pMMgr@@3PAVCMemManager@@A ; gs_pMMgr
  000cf	e8 00 00 00 00	 call	 ?newBuf@CMemManager@@QAEPADH@Z ; CMemManager::newBuf
  000d4	89 85 e0 dd ff
	ff		 mov	 DWORD PTR _pBuf$[ebp], eax

; 660  : 	_tcscpy(pBuf, msgBuf);

  000da	8d 8d f4 df ff
	ff		 lea	 ecx, DWORD PTR _msgBuf$[ebp]
  000e0	51		 push	 ecx
  000e1	8b 95 e0 dd ff
	ff		 mov	 edx, DWORD PTR _pBuf$[ebp]
  000e7	52		 push	 edx
  000e8	e8 00 00 00 00	 call	 _strcpy
  000ed	83 c4 08	 add	 esp, 8

; 661  : 	pBuf[nLen] = '\n';

  000f0	8b 85 e0 dd ff
	ff		 mov	 eax, DWORD PTR _pBuf$[ebp]
  000f6	03 45 f8	 add	 eax, DWORD PTR _nLen$[ebp]
  000f9	c6 00 0a	 mov	 BYTE PTR [eax], 10	; 0000000aH

; 662  : 	pBuf[nLen + 1] = 0;

  000fc	8b 8d e0 dd ff
	ff		 mov	 ecx, DWORD PTR _pBuf$[ebp]
  00102	03 4d f8	 add	 ecx, DWORD PTR _nLen$[ebp]
  00105	c6 41 01 00	 mov	 BYTE PTR [ecx+1], 0

; 663  : 	putQueue(pBuf);

  00109	8b 95 e0 dd ff
	ff		 mov	 edx, DWORD PTR _pBuf$[ebp]
  0010f	52		 push	 edx
  00110	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00113	e8 00 00 00 00	 call	 ?putQueue@CLogger@@QAEXPAD@Z ; CLogger::putQueue
$LN1@PutLogQueu:

; 664  : }

  00118	52		 push	 edx
  00119	8b cd		 mov	 ecx, ebp
  0011b	50		 push	 eax
  0011c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@PutLogQueu
  00122	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00127	58		 pop	 eax
  00128	5a		 pop	 edx
  00129	5f		 pop	 edi
  0012a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0012d	33 cd		 xor	 ecx, ebp
  0012f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00134	81 c4 20 22 00
	00		 add	 esp, 8736		; 00002220H
  0013a	3b ec		 cmp	 ebp, esp
  0013c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00141	8b e5		 mov	 esp, ebp
  00143	5d		 pop	 ebp
  00144	c3		 ret	 0
  00145	0f 1f 00	 npad	 3
$LN8@PutLogQueu:
  00148	02 00 00 00	 DD	 2
  0014c	00 00 00 00	 DD	 $LN7@PutLogQueu
$LN7@PutLogQueu:
  00150	f4 df ff ff	 DD	 -8204			; ffffdff4H
  00154	00 20 00 00	 DD	 8192			; 00002000H
  00158	00 00 00 00	 DD	 $LN5@PutLogQueu
  0015c	ec dd ff ff	 DD	 -8724			; ffffddecH
  00160	00 02 00 00	 DD	 512			; 00000200H
  00164	00 00 00 00	 DD	 $LN6@PutLogQueu
$LN6@PutLogQueu:
  00168	68		 DB	 104			; 00000068H
  00169	65		 DB	 101			; 00000065H
  0016a	61		 DB	 97			; 00000061H
  0016b	64		 DB	 100			; 00000064H
  0016c	65		 DB	 101			; 00000065H
  0016d	72		 DB	 114			; 00000072H
  0016e	00		 DB	 0
$LN5@PutLogQueu:
  0016f	6d		 DB	 109			; 0000006dH
  00170	73		 DB	 115			; 00000073H
  00171	67		 DB	 103			; 00000067H
  00172	42		 DB	 66			; 00000042H
  00173	75		 DB	 117			; 00000075H
  00174	66		 DB	 102			; 00000066H
  00175	00		 DB	 0
?PutLogQueue@CLogger@@QAAXHPBDZZ ENDP			; CLogger::PutLogQueue
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comlogger.cpp
_TEXT	SEGMENT
$T2 = -140						; size = 4
_nLen$ = -136						; size = 4
_cDateTime$ = -128					; size = 104
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pHeader$ = 8						; size = 4
_nLevel$ = 12						; size = 4
?setHeader@CLogger@@QAEHPADH@Z PROC			; CLogger::setHeader
; _this$ = ecx

; 414  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?setHeader@CLogger@@QAEHPADH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00017	57		 push	 edi
  00018	51		 push	 ecx
  00019	8d bd 74 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-140]
  0001f	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00024	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00029	f3 ab		 rep stosd
  0002b	59		 pop	 ecx
  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00031	33 c5		 xor	 eax, ebp
  00033	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00036	50		 push	 eax
  00037	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00040	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 415  : 	CDateTime	cDateTime(m_pDTE->nLastType, m_pDTE->nTZType);

  00043	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00046	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  00049	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0004c	52		 push	 edx
  0004d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  00053	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00056	52		 push	 edx
  00057	8d 4d 80	 lea	 ecx, DWORD PTR _cDateTime$[ebp]
  0005a	e8 00 00 00 00	 call	 ??0CDateTime@@QAE@W4DT_TYPE@@W4TZ_TYPE@@@Z ; CDateTime::CDateTime
  0005f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 416  : 	int nLen = 0;

  00066	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _nLen$[ebp], 0

; 417  : 	nLen = cDateTime.setString(pHeader, m_szHeaderFormat, (DT_FORMAT)m_nDateTimeFormat);

  00070	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00073	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  00076	51		 push	 ecx
  00077	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0007a	81 c2 88 00 00
	00		 add	 edx, 136		; 00000088H
  00080	52		 push	 edx
  00081	8b 45 08	 mov	 eax, DWORD PTR _pHeader$[ebp]
  00084	50		 push	 eax
  00085	8d 4d 80	 lea	 ecx, DWORD PTR _cDateTime$[ebp]
  00088	e8 00 00 00 00	 call	 ?setString@CDateTime@@QAEHPAD0W4DT_FORMAT@@@Z ; CDateTime::setString
  0008d	89 85 78 ff ff
	ff		 mov	 DWORD PTR _nLen$[ebp], eax

; 418  : 	if (m_pDTE->nTZType) {

  00093	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  00099	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  0009d	74 2c		 je	 SHORT $LN2@setHeader

; 419  : 		nLen += _stprintf(pHeader + nLen, _T("%s"), cDateTime.TimezoneString());

  0009f	8d 4d 80	 lea	 ecx, DWORD PTR _cDateTime$[ebp]
  000a2	e8 00 00 00 00	 call	 ?TimezoneString@CDateTime@@QAEPBDXZ ; CDateTime::TimezoneString
  000a7	50		 push	 eax
  000a8	68 00 00 00 00	 push	 OFFSET $SG86705
  000ad	8b 45 08	 mov	 eax, DWORD PTR _pHeader$[ebp]
  000b0	03 85 78 ff ff
	ff		 add	 eax, DWORD PTR _nLen$[ebp]
  000b6	50		 push	 eax
  000b7	e8 00 00 00 00	 call	 _sprintf
  000bc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bf	03 85 78 ff ff
	ff		 add	 eax, DWORD PTR _nLen$[ebp]
  000c5	89 85 78 ff ff
	ff		 mov	 DWORD PTR _nLen$[ebp], eax
$LN2@setHeader:

; 420  : 	}
; 421  : 	if (m_nLogFlag & IS_PRINT_LEVEL)

  000cb	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ce	8b 51 74	 mov	 edx, DWORD PTR [ecx+116]
  000d1	81 e2 00 40 00
	00		 and	 edx, 16384		; 00004000H
  000d7	74 2d		 je	 SHORT $LN3@setHeader

; 422  : 	{
; 423  : 		nLen += _stprintf(pHeader + nLen,_T(" %s"), gs_fmtStr[nLevel]);

  000d9	6b 45 0c 0c	 imul	 eax, DWORD PTR _nLevel$[ebp], 12
  000dd	05 00 00 00 00	 add	 eax, OFFSET ?gs_fmtStr@@3QAY0M@$$CBDA
  000e2	50		 push	 eax
  000e3	68 00 00 00 00	 push	 OFFSET $SG86707
  000e8	8b 4d 08	 mov	 ecx, DWORD PTR _pHeader$[ebp]
  000eb	03 8d 78 ff ff
	ff		 add	 ecx, DWORD PTR _nLen$[ebp]
  000f1	51		 push	 ecx
  000f2	e8 00 00 00 00	 call	 _sprintf
  000f7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000fa	03 85 78 ff ff
	ff		 add	 eax, DWORD PTR _nLen$[ebp]
  00100	89 85 78 ff ff
	ff		 mov	 DWORD PTR _nLen$[ebp], eax
$LN3@setHeader:

; 424  : 	}
; 425  : 	return nLen;

  00106	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _nLen$[ebp]
  0010c	89 95 74 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], edx
  00112	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00119	8d 4d 80	 lea	 ecx, DWORD PTR _cDateTime$[ebp]
  0011c	e8 00 00 00 00	 call	 ??1CDateTime@@QAE@XZ	; CDateTime::~CDateTime
  00121	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]

; 426  : }

  00127	52		 push	 edx
  00128	8b cd		 mov	 ecx, ebp
  0012a	50		 push	 eax
  0012b	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN9@setHeader
  00131	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00136	58		 pop	 eax
  00137	5a		 pop	 edx
  00138	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0013b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00142	59		 pop	 ecx
  00143	5f		 pop	 edi
  00144	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00147	33 cd		 xor	 ecx, ebp
  00149	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0014e	81 c4 8c 00 00
	00		 add	 esp, 140		; 0000008cH
  00154	3b ec		 cmp	 ebp, esp
  00156	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0015b	8b e5		 mov	 esp, ebp
  0015d	5d		 pop	 ebp
  0015e	c2 08 00	 ret	 8
  00161	0f 1f 00	 npad	 3
$LN9@setHeader:
  00164	01 00 00 00	 DD	 1
  00168	00 00 00 00	 DD	 $LN8@setHeader
$LN8@setHeader:
  0016c	80 ff ff ff	 DD	 -128			; ffffff80H
  00170	68 00 00 00	 DD	 104			; 00000068H
  00174	00 00 00 00	 DD	 $LN6@setHeader
$LN6@setHeader:
  00178	63		 DB	 99			; 00000063H
  00179	44		 DB	 68			; 00000044H
  0017a	61		 DB	 97			; 00000061H
  0017b	74		 DB	 116			; 00000074H
  0017c	65		 DB	 101			; 00000065H
  0017d	54		 DB	 84			; 00000054H
  0017e	69		 DB	 105			; 00000069H
  0017f	6d		 DB	 109			; 0000006dH
  00180	65		 DB	 101			; 00000065H
  00181	00		 DB	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?setHeader@CLogger@@QAEHPADH@Z$0:
  00000	8d 4d 80	 lea	 ecx, DWORD PTR _cDateTime$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CDateTime@@QAE@XZ	; CDateTime::~CDateTime
__ehhandler$?setHeader@CLogger@@QAEHPADH@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 8a 78 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-136]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?setHeader@CLogger@@QAEHPADH@Z
  0002b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?setHeader@CLogger@@QAEHPADH@Z ENDP			; CLogger::setHeader
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\comlogger.h
;	COMDAT ?isLogFlag@CLogger@@QAE_NW4E_LOG_FLAG@@@Z
_TEXT	SEGMENT
tv67 = -5						; size = 1
_this$ = -4						; size = 4
_nFlag$ = 8						; size = 4
?isLogFlag@CLogger@@QAE_NW4E_LOG_FLAG@@@Z PROC		; CLogger::isLogFlag, COMDAT
; _this$ = ecx

; 185  : 	inline bool isLogFlag(E_LOG_FLAG nFlag) { return (m_nLogFlag & nFlag)?true:false; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 48 74	 mov	 ecx, DWORD PTR [eax+116]
  0001d	23 4d 08	 and	 ecx, DWORD PTR _nFlag$[ebp]
  00020	74 06		 je	 SHORT $LN3@isLogFlag
  00022	c6 45 fb 01	 mov	 BYTE PTR tv67[ebp], 1
  00026	eb 04		 jmp	 SHORT $LN4@isLogFlag
$LN3@isLogFlag:
  00028	c6 45 fb 00	 mov	 BYTE PTR tv67[ebp], 0
$LN4@isLogFlag:
  0002c	8a 45 fb	 mov	 al, BYTE PTR tv67[ebp]
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
?isLogFlag@CLogger@@QAE_NW4E_LOG_FLAG@@@Z ENDP		; CLogger::isLogFlag
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\comlogger.h
;	COMDAT ?clearLogFlag@CLogger@@QAEXW4E_LOG_FLAG@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nFlag$ = 8						; size = 4
?clearLogFlag@CLogger@@QAEXW4E_LOG_FLAG@@@Z PROC	; CLogger::clearLogFlag, COMDAT
; _this$ = ecx

; 184  : 	inline void clearLogFlag(E_LOG_FLAG nFlag) { m_nLogFlag &= ~nFlag; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR _nFlag$[ebp]
  00011	f7 d0		 not	 eax
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	23 41 74	 and	 eax, DWORD PTR [ecx+116]
  00019	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001c	89 42 74	 mov	 DWORD PTR [edx+116], eax
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?clearLogFlag@CLogger@@QAEXW4E_LOG_FLAG@@@Z ENDP	; CLogger::clearLogFlag
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\comlogger.h
;	COMDAT ?setLogFlag@CLogger@@QAEXW4E_LOG_FLAG@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nFlag$ = 8						; size = 4
?setLogFlag@CLogger@@QAEXW4E_LOG_FLAG@@@Z PROC		; CLogger::setLogFlag, COMDAT
; _this$ = ecx

; 183  : 	inline void setLogFlag(E_LOG_FLAG nFlag) { m_nLogFlag |= nFlag; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 48 74	 mov	 ecx, DWORD PTR [eax+116]
  00014	0b 4d 08	 or	 ecx, DWORD PTR _nFlag$[ebp]
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	89 4a 74	 mov	 DWORD PTR [edx+116], ecx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?setLogFlag@CLogger@@QAEXW4E_LOG_FLAG@@@Z ENDP		; CLogger::setLogFlag
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comlogger.cpp
_TEXT	SEGMENT
_szBuf$ = -140						; size = 128
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?OpenLogger@CLogger@@QAEXXZ PROC			; CLogger::OpenLogger
; _this$ = ecx

; 351  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H
  00009	57		 push	 edi
  0000a	51		 push	 ecx
  0000b	8d bd 70 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-144]
  00011	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	59		 pop	 ecx
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 352  : 	TCHAR szBuf[128];
; 353  : 	if (m_nLogFlag & LOG_FLAG_DAILY) {

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 48 74	 mov	 ecx, DWORD PTR [eax+116]
  00031	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  00037	74 32		 je	 SHORT $LN2@OpenLogger

; 354  : 		_stprintf(szBuf, _T("%s%d_%s.%s"), m_pLogDir, gs_today_time.date, m_pLogName, m_szFileExtension);

  00039	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0003c	83 c2 68	 add	 edx, 104		; 00000068H
  0003f	52		 push	 edx
  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  00046	51		 push	 ecx
  00047	8b 15 18 00 00
	00		 mov	 edx, DWORD PTR ?gs_today_time@@3USTTodayTime@@A+24
  0004d	52		 push	 edx
  0004e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00051	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00054	51		 push	 ecx
  00055	68 00 00 00 00	 push	 OFFSET $SG86647
  0005a	8d 95 74 ff ff
	ff		 lea	 edx, DWORD PTR _szBuf$[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 _sprintf
  00066	83 c4 18	 add	 esp, 24			; 00000018H
  00069	eb 7e		 jmp	 SHORT $LN3@OpenLogger
$LN2@OpenLogger:

; 355  : 	}
; 356  : 	else if (m_nLogFlag & LOG_FLAG_HOURLY) {

  0006b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	8b 48 74	 mov	 ecx, DWORD PTR [eax+116]
  00071	81 e1 00 04 00
	00		 and	 ecx, 1024		; 00000400H
  00077	74 39		 je	 SHORT $LN4@OpenLogger

; 357  : 		_stprintf(szBuf, _T("%s%d%c%s_%02d.%s"), m_pLogDir, gs_today_time.date, g_s, m_pLogName, gs_today_time.hour, m_szFileExtension);

  00079	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0007c	83 c2 68	 add	 edx, 104		; 00000068H
  0007f	52		 push	 edx
  00080	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?gs_today_time@@3USTTodayTime@@A+12
  00085	50		 push	 eax
  00086	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00089	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  0008c	52		 push	 edx
  0008d	6a 5c		 push	 92			; 0000005cH
  0008f	a1 18 00 00 00	 mov	 eax, DWORD PTR ?gs_today_time@@3USTTodayTime@@A+24
  00094	50		 push	 eax
  00095	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00098	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  0009b	52		 push	 edx
  0009c	68 00 00 00 00	 push	 OFFSET $SG86650
  000a1	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  000a7	50		 push	 eax
  000a8	e8 00 00 00 00	 call	 _sprintf
  000ad	83 c4 20	 add	 esp, 32			; 00000020H
  000b0	eb 37		 jmp	 SHORT $LN3@OpenLogger
$LN4@OpenLogger:

; 358  : 	}
; 359  : 	else if (m_nLogFlag & LOG_FLAG_FILE) {

  000b2	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b5	8b 51 74	 mov	 edx, DWORD PTR [ecx+116]
  000b8	81 e2 00 08 00
	00		 and	 edx, 2048		; 00000800H
  000be	74 29		 je	 SHORT $LN3@OpenLogger

; 360  : 		_stprintf(szBuf, _T("%s%s.%s"), m_pLogDir, m_pLogName, m_szFileExtension);

  000c0	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000c3	83 c0 68	 add	 eax, 104		; 00000068H
  000c6	50		 push	 eax
  000c7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ca	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  000cd	52		 push	 edx
  000ce	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000d1	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  000d4	51		 push	 ecx
  000d5	68 00 00 00 00	 push	 OFFSET $SG86652
  000da	8d 95 74 ff ff
	ff		 lea	 edx, DWORD PTR _szBuf$[ebp]
  000e0	52		 push	 edx
  000e1	e8 00 00 00 00	 call	 _sprintf
  000e6	83 c4 14	 add	 esp, 20			; 00000014H
$LN3@OpenLogger:

; 361  : 	}
; 362  : 
; 363  : 	__openLogger(szBuf);

  000e9	6a 00		 push	 0
  000eb	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  000f1	50		 push	 eax
  000f2	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000f5	e8 00 00 00 00	 call	 ?__openLogger@CLogger@@AAEXPBDH@Z ; CLogger::__openLogger

; 364  : }

  000fa	52		 push	 edx
  000fb	8b cd		 mov	 ecx, ebp
  000fd	50		 push	 eax
  000fe	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN10@OpenLogger
  00104	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00109	58		 pop	 eax
  0010a	5a		 pop	 edx
  0010b	5f		 pop	 edi
  0010c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010f	33 cd		 xor	 ecx, ebp
  00111	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00116	81 c4 90 00 00
	00		 add	 esp, 144		; 00000090H
  0011c	3b ec		 cmp	 ebp, esp
  0011e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00123	8b e5		 mov	 esp, ebp
  00125	5d		 pop	 ebp
  00126	c3		 ret	 0
  00127	90		 npad	 1
$LN10@OpenLogger:
  00128	01 00 00 00	 DD	 1
  0012c	00 00 00 00	 DD	 $LN9@OpenLogger
$LN9@OpenLogger:
  00130	74 ff ff ff	 DD	 -140			; ffffff74H
  00134	80 00 00 00	 DD	 128			; 00000080H
  00138	00 00 00 00	 DD	 $LN8@OpenLogger
$LN8@OpenLogger:
  0013c	73		 DB	 115			; 00000073H
  0013d	7a		 DB	 122			; 0000007aH
  0013e	42		 DB	 66			; 00000042H
  0013f	75		 DB	 117			; 00000075H
  00140	66		 DB	 102			; 00000066H
  00141	00		 DB	 0
?OpenLogger@CLogger@@QAEXXZ ENDP			; CLogger::OpenLogger
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comlogger.cpp
_TEXT	SEGMENT
_eRes$ = -328						; size = 4
_szValue4$ = -320					; size = 8
_szValue3$ = -304					; size = 8
_szValue2$ = -288					; size = 128
_szValue$ = -152					; size = 128
_nVal$ = -20						; size = 4
_nRes$ = -16						; size = 4
_nMax$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_pConfig$ = 8						; size = 4
_pSection$ = 12						; size = 4
?initConfig@CLogger@@QAE?AW4E_LOG_INIT_RES@@PAD0@Z PROC	; CLogger::initConfig
; _this$ = ecx

; 172  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 48 01 00
	00		 sub	 esp, 328		; 00000148H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	51		 push	 ecx
  0000c	8d bd b8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-328]
  00012	b9 52 00 00 00	 mov	 ecx, 82			; 00000052H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	59		 pop	 ecx
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c5		 xor	 eax, ebp
  00026	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00029	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 173  : 	int nMax, nRes, nVal;
; 174  : 	TCHAR szValue[128], szValue2[128], szValue3[8], szValue4[8];
; 175  : 	E_LOG_INIT_RES eRes;
; 176  : 
; 177  : 	nRes = GetPrivateProfileString(pSection, "LOGNAME", "", szValue2, 128, pConfig);

  0002c	8b f4		 mov	 esi, esp
  0002e	8b 45 08	 mov	 eax, DWORD PTR _pConfig$[ebp]
  00031	50		 push	 eax
  00032	68 80 00 00 00	 push	 128			; 00000080H
  00037	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _szValue2$[ebp]
  0003d	51		 push	 ecx
  0003e	68 00 00 00 00	 push	 OFFSET $SG86519
  00043	68 00 00 00 00	 push	 OFFSET $SG86520
  00048	8b 55 0c	 mov	 edx, DWORD PTR _pSection$[ebp]
  0004b	52		 push	 edx
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileStringA@24
  00052	3b f4		 cmp	 esi, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	89 45 f0	 mov	 DWORD PTR _nRes$[ebp], eax

; 178  : 	if (!nRes) {

  0005c	83 7d f0 00	 cmp	 DWORD PTR _nRes$[ebp], 0
  00060	75 3e		 jne	 SHORT $LN2@initConfig

; 179  : 		if (&gs_cLogger == this) { eRes = LOG_INIT_NO_FILE; goto SET_DISABLE; }

  00062	81 7d f8 00 00
	00 00		 cmp	 DWORD PTR _this$[ebp], OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  00069	75 16		 jne	 SHORT $LN3@initConfig
  0006b	c7 85 b8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _eRes$[ebp], 0
  00075	e9 15 03 00 00	 jmp	 $SET_DISABLE$21
  0007a	e9 10 03 00 00	 jmp	 $SET_DISABLE$21
  0007f	eb 1f		 jmp	 SHORT $LN2@initConfig
$LN3@initConfig:

; 180  : 		else {	comErrorPrint(_T("LOGNAME is NULL!"));	return LOG_INIT_ERROR;}

  00081	68 b4 00 00 00	 push	 180			; 000000b4H
  00086	68 00 00 00 00	 push	 OFFSET $SG86525
  0008b	68 00 00 00 00	 push	 OFFSET $SG86526
  00090	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPADPBDH@Z ; comGlobalErrorProc
  00095	83 c4 0c	 add	 esp, 12			; 0000000cH
  00098	83 c8 ff	 or	 eax, -1
  0009b	e9 16 03 00 00	 jmp	 $LN1@initConfig
$LN2@initConfig:

; 181  : 	}
; 182  : 	nRes = GetPrivateProfileInt(pSection, _T("ISENABLE"), 0, pConfig);

  000a0	8b f4		 mov	 esi, esp
  000a2	8b 45 08	 mov	 eax, DWORD PTR _pConfig$[ebp]
  000a5	50		 push	 eax
  000a6	6a 00		 push	 0
  000a8	68 00 00 00 00	 push	 OFFSET $SG86527
  000ad	8b 4d 0c	 mov	 ecx, DWORD PTR _pSection$[ebp]
  000b0	51		 push	 ecx
  000b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  000b7	3b f4		 cmp	 esi, esp
  000b9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000be	89 45 f0	 mov	 DWORD PTR _nRes$[ebp], eax

; 183  : 	if (!nRes) { eRes = LOG_INIT_SUCCESS; goto SET_DISABLE; }

  000c1	83 7d f0 00	 cmp	 DWORD PTR _nRes$[ebp], 0
  000c5	75 14		 jne	 SHORT $LN6@initConfig
  000c7	c7 85 b8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _eRes$[ebp], 1
  000d1	e9 b9 02 00 00	 jmp	 $SET_DISABLE$21
  000d6	e9 b4 02 00 00	 jmp	 $SET_DISABLE$21
$LN6@initConfig:

; 184  : 
; 185  : 	nRes = GetProfilePath(pSection, _T("LOGDIR"), _T("Log"), szValue, pConfig);

  000db	8b 55 08	 mov	 edx, DWORD PTR _pConfig$[ebp]
  000de	52		 push	 edx
  000df	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _szValue$[ebp]
  000e5	50		 push	 eax
  000e6	68 00 00 00 00	 push	 OFFSET $SG86530
  000eb	68 00 00 00 00	 push	 OFFSET $SG86531
  000f0	8b 4d 0c	 mov	 ecx, DWORD PTR _pSection$[ebp]
  000f3	51		 push	 ecx
  000f4	e8 00 00 00 00	 call	 ?GetProfilePath@@YAHPBD00PAD0@Z ; GetProfilePath
  000f9	83 c4 14	 add	 esp, 20			; 00000014H
  000fc	89 45 f0	 mov	 DWORD PTR _nRes$[ebp], eax

; 186  : 	GetPrivateProfileString(pSection, _T("EXTENSION"), g_szLogExtension, szValue3, sizeof(szValue3), pConfig);

  000ff	8b f4		 mov	 esi, esp
  00101	8b 55 08	 mov	 edx, DWORD PTR _pConfig$[ebp]
  00104	52		 push	 edx
  00105	6a 08		 push	 8
  00107	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR _szValue3$[ebp]
  0010d	50		 push	 eax
  0010e	68 00 00 00 00	 push	 OFFSET ?g_szLogExtension@@3PADA ; g_szLogExtension
  00113	68 00 00 00 00	 push	 OFFSET $SG86532
  00118	8b 4d 0c	 mov	 ecx, DWORD PTR _pSection$[ebp]
  0011b	51		 push	 ecx
  0011c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileStringA@24
  00122	3b f4		 cmp	 esi, esp
  00124	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 187  : 	GetPrivateProfileString(pSection, _T("KEEP_DURATION"), g_szKeepDuratrion, szValue4, sizeof(szValue4), pConfig);

  00129	8b f4		 mov	 esi, esp
  0012b	8b 55 08	 mov	 edx, DWORD PTR _pConfig$[ebp]
  0012e	52		 push	 edx
  0012f	6a 08		 push	 8
  00131	8d 85 c0 fe ff
	ff		 lea	 eax, DWORD PTR _szValue4$[ebp]
  00137	50		 push	 eax
  00138	68 00 00 00 00	 push	 OFFSET ?g_szKeepDuratrion@@3PADA ; g_szKeepDuratrion
  0013d	68 00 00 00 00	 push	 OFFSET $SG86533
  00142	8b 4d 0c	 mov	 ecx, DWORD PTR _pSection$[ebp]
  00145	51		 push	 ecx
  00146	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileStringA@24
  0014c	3b f4		 cmp	 esi, esp
  0014e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 188  : 	_initCom(szValue, szValue2, szValue3, szValue4);

  00153	8d 95 c0 fe ff
	ff		 lea	 edx, DWORD PTR _szValue4$[ebp]
  00159	52		 push	 edx
  0015a	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR _szValue3$[ebp]
  00160	50		 push	 eax
  00161	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _szValue2$[ebp]
  00167	51		 push	 ecx
  00168	8d 95 68 ff ff
	ff		 lea	 edx, DWORD PTR _szValue$[ebp]
  0016e	52		 push	 edx
  0016f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00172	e8 00 00 00 00	 call	 ?_initCom@CLogger@@AAEXPAD000@Z ; CLogger::_initCom

; 189  : 
; 190  : 	nMax = GetPrivateProfileInt(pSection, _T("LIST_MAX"), eLDOPT_LISTMAX, pConfig);

  00177	8b f4		 mov	 esi, esp
  00179	8b 45 08	 mov	 eax, DWORD PTR _pConfig$[ebp]
  0017c	50		 push	 eax
  0017d	6a 14		 push	 20			; 00000014H
  0017f	68 00 00 00 00	 push	 OFFSET $SG86534
  00184	8b 4d 0c	 mov	 ecx, DWORD PTR _pSection$[ebp]
  00187	51		 push	 ecx
  00188	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  0018e	3b f4		 cmp	 esi, esp
  00190	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00195	89 45 f4	 mov	 DWORD PTR _nMax$[ebp], eax

; 191  : 	if (!_setLoggerQueue(nMax)) {

  00198	8b 55 f4	 mov	 edx, DWORD PTR _nMax$[ebp]
  0019b	52		 push	 edx
  0019c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0019f	e8 00 00 00 00	 call	 ?_setLoggerQueue@CLogger@@AAE_NH@Z ; CLogger::_setLoggerQueue
  001a4	0f b6 c0	 movzx	 eax, al
  001a7	85 c0		 test	 eax, eax
  001a9	75 1f		 jne	 SHORT $LN8@initConfig

; 192  : 		comErrorPrint(_T("_setLoggerQueue has Failed"));

  001ab	68 c0 00 00 00	 push	 192			; 000000c0H
  001b0	68 00 00 00 00	 push	 OFFSET $SG86536
  001b5	68 00 00 00 00	 push	 OFFSET $SG86537
  001ba	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPADPBDH@Z ; comGlobalErrorProc
  001bf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 193  : 		return LOG_INIT_ERROR;

  001c2	83 c8 ff	 or	 eax, -1
  001c5	e9 ec 01 00 00	 jmp	 $LN1@initConfig
$LN8@initConfig:

; 194  : 	}
; 195  : 	nRes = GetPrivateProfileInt(pSection, _T("TIMESTEMP_NO"), eLDOPT_TIMESTEMP_NO, pConfig);

  001ca	8b f4		 mov	 esi, esp
  001cc	8b 4d 08	 mov	 ecx, DWORD PTR _pConfig$[ebp]
  001cf	51		 push	 ecx
  001d0	6a 00		 push	 0
  001d2	68 00 00 00 00	 push	 OFFSET $SG86538
  001d7	8b 55 0c	 mov	 edx, DWORD PTR _pSection$[ebp]
  001da	52		 push	 edx
  001db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  001e1	3b f4		 cmp	 esi, esp
  001e3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001e8	89 45 f0	 mov	 DWORD PTR _nRes$[ebp], eax

; 196  : 	if (nRes < 0) {

  001eb	83 7d f0 00	 cmp	 DWORD PTR _nRes$[ebp], 0
  001ef	7d 39		 jge	 SHORT $LN9@initConfig

; 197  : 		_stprintf(g_szMessage, _T("invalid value[%d]! pSection[%s]"), nRes, pSection);

  001f1	8b 45 0c	 mov	 eax, DWORD PTR _pSection$[ebp]
  001f4	50		 push	 eax
  001f5	8b 4d f0	 mov	 ecx, DWORD PTR _nRes$[ebp]
  001f8	51		 push	 ecx
  001f9	68 00 00 00 00	 push	 OFFSET $SG86540
  001fe	68 00 00 00 00	 push	 OFFSET ?g_szMessage@@3PADA ; g_szMessage
  00203	e8 00 00 00 00	 call	 _sprintf
  00208	83 c4 10	 add	 esp, 16			; 00000010H

; 198  : 		comErrorPrint(g_szMessage);

  0020b	68 c6 00 00 00	 push	 198			; 000000c6H
  00210	68 00 00 00 00	 push	 OFFSET $SG86541
  00215	68 00 00 00 00	 push	 OFFSET ?g_szMessage@@3PADA ; g_szMessage
  0021a	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPADPBDH@Z ; comGlobalErrorProc
  0021f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 199  : 		return LOG_INIT_ERROR;

  00222	83 c8 ff	 or	 eax, -1
  00225	e9 8c 01 00 00	 jmp	 $LN1@initConfig
$LN9@initConfig:

; 200  : 	}
; 201  : 	if (!_setHeaderFormat(nRes)) {

  0022a	8b 55 f0	 mov	 edx, DWORD PTR _nRes$[ebp]
  0022d	52		 push	 edx
  0022e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00231	e8 00 00 00 00	 call	 ?_setHeaderFormat@CLogger@@AAE_NH@Z ; CLogger::_setHeaderFormat
  00236	0f b6 c0	 movzx	 eax, al
  00239	85 c0		 test	 eax, eax
  0023b	75 1f		 jne	 SHORT $LN10@initConfig

; 202  : 		comErrorPrint(_T("_setHeaderFormat has Failed"));

  0023d	68 ca 00 00 00	 push	 202			; 000000caH
  00242	68 00 00 00 00	 push	 OFFSET $SG86543
  00247	68 00 00 00 00	 push	 OFFSET $SG86544
  0024c	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPADPBDH@Z ; comGlobalErrorProc
  00251	83 c4 0c	 add	 esp, 12			; 0000000cH

; 203  : 		return LOG_INIT_ERROR;

  00254	83 c8 ff	 or	 eax, -1
  00257	e9 5a 01 00 00	 jmp	 $LN1@initConfig
$LN10@initConfig:

; 204  : 	}
; 205  : 	m_nStlNo = GetPrivateProfileInt(pSection, _T("STL_NO"), eLDOPT_STL_NO, pConfig);

  0025c	8b f4		 mov	 esi, esp
  0025e	8b 4d 08	 mov	 ecx, DWORD PTR _pConfig$[ebp]
  00261	51		 push	 ecx
  00262	6a 00		 push	 0
  00264	68 00 00 00 00	 push	 OFFSET $SG86545
  00269	8b 55 0c	 mov	 edx, DWORD PTR _pSection$[ebp]
  0026c	52		 push	 edx
  0026d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00273	3b f4		 cmp	 esi, esp
  00275	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0027a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0027d	89 41 7c	 mov	 DWORD PTR [ecx+124], eax

; 206  : 
; 207  : 	nRes = GetPrivateProfileInt(pSection, _T("LOGTYPE"), eLDOPT_LOGTYPE, pConfig);

  00280	8b f4		 mov	 esi, esp
  00282	8b 55 08	 mov	 edx, DWORD PTR _pConfig$[ebp]
  00285	52		 push	 edx
  00286	6a 03		 push	 3
  00288	68 00 00 00 00	 push	 OFFSET $SG86546
  0028d	8b 45 0c	 mov	 eax, DWORD PTR _pSection$[ebp]
  00290	50		 push	 eax
  00291	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00297	3b f4		 cmp	 esi, esp
  00299	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0029e	89 45 f0	 mov	 DWORD PTR _nRes$[ebp], eax

; 208  : 	m_nSizeLimit = GetPrivateProfileInt(pSection, _T("SIZE_LIMIT"), eLDOPT_SIZE_LIMIT, pConfig);

  002a1	8b f4		 mov	 esi, esp
  002a3	8b 4d 08	 mov	 ecx, DWORD PTR _pConfig$[ebp]
  002a6	51		 push	 ecx
  002a7	6a 00		 push	 0
  002a9	68 00 00 00 00	 push	 OFFSET $SG86547
  002ae	8b 55 0c	 mov	 edx, DWORD PTR _pSection$[ebp]
  002b1	52		 push	 edx
  002b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  002b8	3b f4		 cmp	 esi, esp
  002ba	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002bf	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002c2	89 81 80 00 00
	00		 mov	 DWORD PTR [ecx+128], eax

; 209  : 	nVal = GetPrivateProfileInt(pSection, _T("IS_PRINT_LEVEL"), eLDOPT_IS_PRINT_LEVEL, pConfig);

  002c8	8b f4		 mov	 esi, esp
  002ca	8b 55 08	 mov	 edx, DWORD PTR _pConfig$[ebp]
  002cd	52		 push	 edx
  002ce	6a 01		 push	 1
  002d0	68 00 00 00 00	 push	 OFFSET $SG86548
  002d5	8b 45 0c	 mov	 eax, DWORD PTR _pSection$[ebp]
  002d8	50		 push	 eax
  002d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  002df	3b f4		 cmp	 esi, esp
  002e1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002e6	89 45 ec	 mov	 DWORD PTR _nVal$[ebp], eax

; 210  : 	_setLoggerBasic(nRes, nVal, m_nSizeLimit);

  002e9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002ec	8b 91 80 00 00
	00		 mov	 edx, DWORD PTR [ecx+128]
  002f2	52		 push	 edx
  002f3	8b 45 ec	 mov	 eax, DWORD PTR _nVal$[ebp]
  002f6	50		 push	 eax
  002f7	8b 4d f0	 mov	 ecx, DWORD PTR _nRes$[ebp]
  002fa	51		 push	 ecx
  002fb	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002fe	e8 00 00 00 00	 call	 ?_setLoggerBasic@CLogger@@AAEXHHH@Z ; CLogger::_setLoggerBasic

; 211  : 
; 212  : 	nRes = GetPrivateProfileInt(pSection, _T("IS_PRINT"), eLDOPT_ISPRINTF, pConfig);

  00303	8b f4		 mov	 esi, esp
  00305	8b 55 08	 mov	 edx, DWORD PTR _pConfig$[ebp]
  00308	52		 push	 edx
  00309	6a 00		 push	 0
  0030b	68 00 00 00 00	 push	 OFFSET $SG86549
  00310	8b 45 0c	 mov	 eax, DWORD PTR _pSection$[ebp]
  00313	50		 push	 eax
  00314	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  0031a	3b f4		 cmp	 esi, esp
  0031c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00321	89 45 f0	 mov	 DWORD PTR _nRes$[ebp], eax

; 213  : 	if (nRes) m_nLogFlag |= IS_PRINT;

  00324	83 7d f0 00	 cmp	 DWORD PTR _nRes$[ebp], 0
  00328	74 12		 je	 SHORT $LN11@initConfig
  0032a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0032d	8b 51 74	 mov	 edx, DWORD PTR [ecx+116]
  00330	81 ca 00 20 00
	00		 or	 edx, 8192		; 00002000H
  00336	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00339	89 50 74	 mov	 DWORD PTR [eax+116], edx
$LN11@initConfig:

; 214  : 	m_nLogLevel = GetPrivateProfileInt(pSection, _T("LOGLEVEL"), eLDOPT_LOGLEVEL, pConfig);

  0033c	8b f4		 mov	 esi, esp
  0033e	8b 4d 08	 mov	 ecx, DWORD PTR _pConfig$[ebp]
  00341	51		 push	 ecx
  00342	6a 03		 push	 3
  00344	68 00 00 00 00	 push	 OFFSET $SG86551
  00349	8b 55 0c	 mov	 edx, DWORD PTR _pSection$[ebp]
  0034c	52		 push	 edx
  0034d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00353	3b f4		 cmp	 esi, esp
  00355	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0035a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0035d	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 215  : 
; 216  : 	if (isLogFlag(IS_LOG_ENABLE)) return LOG_INIT_CHANGED_SUCCESS;

  00360	68 00 00 08 00	 push	 524288			; 00080000H
  00365	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00368	e8 00 00 00 00	 call	 ?isLogFlag@CLogger@@QAE_NW4E_LOG_FLAG@@@Z ; CLogger::isLogFlag
  0036d	0f b6 d0	 movzx	 edx, al
  00370	85 d2		 test	 edx, edx
  00372	74 07		 je	 SHORT $LN12@initConfig
  00374	b8 02 00 00 00	 mov	 eax, 2
  00379	eb 3b		 jmp	 SHORT $LN1@initConfig
$LN12@initConfig:

; 217  : 
; 218  : 	setLogFlag(IS_LOG_SET_COMPLETE);

  0037b	68 00 00 02 00	 push	 131072			; 00020000H
  00380	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00383	e8 00 00 00 00	 call	 ?setLogFlag@CLogger@@QAEXW4E_LOG_FLAG@@@Z ; CLogger::setLogFlag

; 219  : 	return LOG_INIT_SUCCESS;

  00388	b8 01 00 00 00	 mov	 eax, 1
  0038d	eb 27		 jmp	 SHORT $LN1@initConfig
$SET_DISABLE$21:

; 220  : 
; 221  : SET_DISABLE : 
; 222  : 	if (isLogFlag(IS_LOG_ENABLE)) {

  0038f	68 00 00 08 00	 push	 524288			; 00080000H
  00394	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00397	e8 00 00 00 00	 call	 ?isLogFlag@CLogger@@QAE_NW4E_LOG_FLAG@@@Z ; CLogger::isLogFlag
  0039c	0f b6 c0	 movzx	 eax, al
  0039f	85 c0		 test	 eax, eax
  003a1	74 0d		 je	 SHORT $LN13@initConfig

; 223  : 		clearLogFlag(IS_LOG_ENABLE);

  003a3	68 00 00 08 00	 push	 524288			; 00080000H
  003a8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  003ab	e8 00 00 00 00	 call	 ?clearLogFlag@CLogger@@QAEXW4E_LOG_FLAG@@@Z ; CLogger::clearLogFlag
$LN13@initConfig:

; 224  : 	}
; 225  : 	return eRes;

  003b0	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _eRes$[ebp]
$LN1@initConfig:

; 226  : }

  003b6	52		 push	 edx
  003b7	8b cd		 mov	 ecx, ebp
  003b9	50		 push	 eax
  003ba	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN20@initConfig
  003c0	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  003c5	58		 pop	 eax
  003c6	5a		 pop	 edx
  003c7	5f		 pop	 edi
  003c8	5e		 pop	 esi
  003c9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003cc	33 cd		 xor	 ecx, ebp
  003ce	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003d3	81 c4 48 01 00
	00		 add	 esp, 328		; 00000148H
  003d9	3b ec		 cmp	 ebp, esp
  003db	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003e0	8b e5		 mov	 esp, ebp
  003e2	5d		 pop	 ebp
  003e3	c2 08 00	 ret	 8
  003e6	66 90		 npad	 2
$LN20@initConfig:
  003e8	04 00 00 00	 DD	 4
  003ec	00 00 00 00	 DD	 $LN19@initConfig
$LN19@initConfig:
  003f0	68 ff ff ff	 DD	 -152			; ffffff68H
  003f4	80 00 00 00	 DD	 128			; 00000080H
  003f8	00 00 00 00	 DD	 $LN15@initConfig
  003fc	e0 fe ff ff	 DD	 -288			; fffffee0H
  00400	80 00 00 00	 DD	 128			; 00000080H
  00404	00 00 00 00	 DD	 $LN16@initConfig
  00408	d0 fe ff ff	 DD	 -304			; fffffed0H
  0040c	08 00 00 00	 DD	 8
  00410	00 00 00 00	 DD	 $LN17@initConfig
  00414	c0 fe ff ff	 DD	 -320			; fffffec0H
  00418	08 00 00 00	 DD	 8
  0041c	00 00 00 00	 DD	 $LN18@initConfig
$LN18@initConfig:
  00420	73		 DB	 115			; 00000073H
  00421	7a		 DB	 122			; 0000007aH
  00422	56		 DB	 86			; 00000056H
  00423	61		 DB	 97			; 00000061H
  00424	6c		 DB	 108			; 0000006cH
  00425	75		 DB	 117			; 00000075H
  00426	65		 DB	 101			; 00000065H
  00427	34		 DB	 52			; 00000034H
  00428	00		 DB	 0
$LN17@initConfig:
  00429	73		 DB	 115			; 00000073H
  0042a	7a		 DB	 122			; 0000007aH
  0042b	56		 DB	 86			; 00000056H
  0042c	61		 DB	 97			; 00000061H
  0042d	6c		 DB	 108			; 0000006cH
  0042e	75		 DB	 117			; 00000075H
  0042f	65		 DB	 101			; 00000065H
  00430	33		 DB	 51			; 00000033H
  00431	00		 DB	 0
$LN16@initConfig:
  00432	73		 DB	 115			; 00000073H
  00433	7a		 DB	 122			; 0000007aH
  00434	56		 DB	 86			; 00000056H
  00435	61		 DB	 97			; 00000061H
  00436	6c		 DB	 108			; 0000006cH
  00437	75		 DB	 117			; 00000075H
  00438	65		 DB	 101			; 00000065H
  00439	32		 DB	 50			; 00000032H
  0043a	00		 DB	 0
$LN15@initConfig:
  0043b	73		 DB	 115			; 00000073H
  0043c	7a		 DB	 122			; 0000007aH
  0043d	56		 DB	 86			; 00000056H
  0043e	61		 DB	 97			; 00000061H
  0043f	6c		 DB	 108			; 0000006cH
  00440	75		 DB	 117			; 00000075H
  00441	65		 DB	 101			; 00000065H
  00442	00		 DB	 0
?initConfig@CLogger@@QAE?AW4E_LOG_INIT_RES@@PAD0@Z ENDP	; CLogger::initConfig
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comlogger.cpp
_TEXT	SEGMENT
_szValue2$ = -276					; size = 128
_szValue$ = -140					; size = 128
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_pDir$ = 8						; size = 4
_pName$ = 12						; size = 4
_nLogType$ = 16						; size = 4
_nLogLevel$ = 20					; size = 4
_nSizeLimit$ = 24					; size = 4
_pFileExtension$ = 28					; size = 4
?initDefault@CLogger@@QAE_NPAD0HHH0@Z PROC		; CLogger::initDefault
; _this$ = ecx

; 135  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	57		 push	 edi
  0000a	51		 push	 ecx
  0000b	8d bd e8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-280]
  00011	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	59		 pop	 ecx
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 136  : 	TCHAR szValue[128], szValue2[128];
; 137  : 
; 138  : 	if (!pDir) {

  0002b	83 7d 08 00	 cmp	 DWORD PTR _pDir$[ebp], 0
  0002f	75 1e		 jne	 SHORT $LN2@initDefaul

; 139  : 		comErrorPrint(_T("pDir is NULL"));

  00031	68 8b 00 00 00	 push	 139			; 0000008bH
  00036	68 00 00 00 00	 push	 OFFSET $SG86494
  0003b	68 00 00 00 00	 push	 OFFSET $SG86495
  00040	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPADPBDH@Z ; comGlobalErrorProc
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH

; 140  : 		return false;

  00048	32 c0		 xor	 al, al
  0004a	e9 09 01 00 00	 jmp	 $LN1@initDefaul
$LN2@initDefaul:

; 141  : 	}
; 142  : 	if (pName) {

  0004f	83 7d 0c 00	 cmp	 DWORD PTR _pName$[ebp], 0
  00053	74 32		 je	 SHORT $LN3@initDefaul

; 143  : 		if (pDir[0] == '~') {

  00055	b8 01 00 00 00	 mov	 eax, 1
  0005a	6b c8 00	 imul	 ecx, eax, 0
  0005d	8b 55 08	 mov	 edx, DWORD PTR _pDir$[ebp]
  00060	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00064	83 f8 7e	 cmp	 eax, 126		; 0000007eH
  00067	75 1c		 jne	 SHORT $LN5@initDefaul

; 144  : 			changeToAbsolutePath(szValue, pDir);

  00069	8b 4d 08	 mov	 ecx, DWORD PTR _pDir$[ebp]
  0006c	51		 push	 ecx
  0006d	8d 95 74 ff ff
	ff		 lea	 edx, DWORD PTR _szValue$[ebp]
  00073	52		 push	 edx
  00074	e8 00 00 00 00	 call	 ?changeToAbsolutePath@@YAXPADPBD@Z ; changeToAbsolutePath
  00079	83 c4 08	 add	 esp, 8

; 145  : 			pDir = szValue;

  0007c	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _szValue$[ebp]
  00082	89 45 08	 mov	 DWORD PTR _pDir$[ebp], eax
$LN5@initDefaul:

; 146  : 		}
; 147  : 	}
; 148  : 	else {

  00085	eb 2c		 jmp	 SHORT $LN4@initDefaul
$LN3@initDefaul:

; 149  : 		detachFullPath(pDir, szValue, szValue2);

  00087	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _szValue2$[ebp]
  0008d	51		 push	 ecx
  0008e	8d 95 74 ff ff
	ff		 lea	 edx, DWORD PTR _szValue$[ebp]
  00094	52		 push	 edx
  00095	8b 45 08	 mov	 eax, DWORD PTR _pDir$[ebp]
  00098	50		 push	 eax
  00099	e8 00 00 00 00	 call	 ?detachFullPath@@YAXPBDPAD1@Z ; detachFullPath
  0009e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 150  : 		pDir = szValue; pName = szValue2;

  000a1	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _szValue$[ebp]
  000a7	89 4d 08	 mov	 DWORD PTR _pDir$[ebp], ecx
  000aa	8d 95 ec fe ff
	ff		 lea	 edx, DWORD PTR _szValue2$[ebp]
  000b0	89 55 0c	 mov	 DWORD PTR _pName$[ebp], edx
$LN4@initDefaul:

; 151  : 	}
; 152  : 
; 153  : 	_initCom(pDir, pName, pFileExtension);

  000b3	68 00 00 00 00	 push	 OFFSET ?g_szKeepDuratrion@@3PADA ; g_szKeepDuratrion
  000b8	8b 45 1c	 mov	 eax, DWORD PTR _pFileExtension$[ebp]
  000bb	50		 push	 eax
  000bc	8b 4d 0c	 mov	 ecx, DWORD PTR _pName$[ebp]
  000bf	51		 push	 ecx
  000c0	8b 55 08	 mov	 edx, DWORD PTR _pDir$[ebp]
  000c3	52		 push	 edx
  000c4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c7	e8 00 00 00 00	 call	 ?_initCom@CLogger@@AAEXPAD000@Z ; CLogger::_initCom

; 154  : 
; 155  : 	if (!_setLoggerQueue(eLDOPT_LISTMAX)) {

  000cc	6a 14		 push	 20			; 00000014H
  000ce	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d1	e8 00 00 00 00	 call	 ?_setLoggerQueue@CLogger@@AAE_NH@Z ; CLogger::_setLoggerQueue
  000d6	0f b6 c0	 movzx	 eax, al
  000d9	85 c0		 test	 eax, eax
  000db	75 1b		 jne	 SHORT $LN6@initDefaul

; 156  : 		comErrorPrint(_T("_setLoggerQueue has Failed"));

  000dd	68 9c 00 00 00	 push	 156			; 0000009cH
  000e2	68 00 00 00 00	 push	 OFFSET $SG86500
  000e7	68 00 00 00 00	 push	 OFFSET $SG86501
  000ec	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPADPBDH@Z ; comGlobalErrorProc
  000f1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 157  : 		return false;

  000f4	32 c0		 xor	 al, al
  000f6	eb 60		 jmp	 SHORT $LN1@initDefaul
$LN6@initDefaul:

; 158  : 	}
; 159  : 	if (!_setHeaderFormat(eLDOPT_TIMESTEMP_NO)) {

  000f8	6a 00		 push	 0
  000fa	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000fd	e8 00 00 00 00	 call	 ?_setHeaderFormat@CLogger@@AAE_NH@Z ; CLogger::_setHeaderFormat
  00102	0f b6 c8	 movzx	 ecx, al
  00105	85 c9		 test	 ecx, ecx
  00107	75 1b		 jne	 SHORT $LN7@initDefaul

; 160  : 		comErrorPrint(_T("_setHeaderFormat has Failed"));

  00109	68 a0 00 00 00	 push	 160			; 000000a0H
  0010e	68 00 00 00 00	 push	 OFFSET $SG86503
  00113	68 00 00 00 00	 push	 OFFSET $SG86504
  00118	e8 00 00 00 00	 call	 ?comGlobalErrorProc@@YAXPADPBDH@Z ; comGlobalErrorProc
  0011d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 161  : 		return false;

  00120	32 c0		 xor	 al, al
  00122	eb 34		 jmp	 SHORT $LN1@initDefaul
$LN7@initDefaul:

; 162  : 	}
; 163  : 
; 164  : 	m_nStlNo = 0;

  00124	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00127	c7 42 7c 00 00
	00 00		 mov	 DWORD PTR [edx+124], 0

; 165  : 	m_nLogLevel = nLogLevel;

  0012e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00131	8b 4d 14	 mov	 ecx, DWORD PTR _nLogLevel$[ebp]
  00134	89 48 4c	 mov	 DWORD PTR [eax+76], ecx

; 166  : 	_setLoggerBasic(nLogType, eLDOPT_IS_PRINT_LEVEL, nSizeLimit);

  00137	8b 55 18	 mov	 edx, DWORD PTR _nSizeLimit$[ebp]
  0013a	52		 push	 edx
  0013b	6a 01		 push	 1
  0013d	8b 45 10	 mov	 eax, DWORD PTR _nLogType$[ebp]
  00140	50		 push	 eax
  00141	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00144	e8 00 00 00 00	 call	 ?_setLoggerBasic@CLogger@@AAEXHHH@Z ; CLogger::_setLoggerBasic

; 167  : 	setLogFlag(IS_LOG_SET_COMPLETE);

  00149	68 00 00 02 00	 push	 131072			; 00020000H
  0014e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00151	e8 00 00 00 00	 call	 ?setLogFlag@CLogger@@QAEXW4E_LOG_FLAG@@@Z ; CLogger::setLogFlag

; 168  : 	return true;

  00156	b0 01		 mov	 al, 1
$LN1@initDefaul:

; 169  : }

  00158	52		 push	 edx
  00159	8b cd		 mov	 ecx, ebp
  0015b	50		 push	 eax
  0015c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN12@initDefaul
  00162	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00167	58		 pop	 eax
  00168	5a		 pop	 edx
  00169	5f		 pop	 edi
  0016a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0016d	33 cd		 xor	 ecx, ebp
  0016f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00174	81 c4 18 01 00
	00		 add	 esp, 280		; 00000118H
  0017a	3b ec		 cmp	 ebp, esp
  0017c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00181	8b e5		 mov	 esp, ebp
  00183	5d		 pop	 ebp
  00184	c2 18 00	 ret	 24			; 00000018H
  00187	90		 npad	 1
$LN12@initDefaul:
  00188	02 00 00 00	 DD	 2
  0018c	00 00 00 00	 DD	 $LN11@initDefaul
$LN11@initDefaul:
  00190	74 ff ff ff	 DD	 -140			; ffffff74H
  00194	80 00 00 00	 DD	 128			; 00000080H
  00198	00 00 00 00	 DD	 $LN9@initDefaul
  0019c	ec fe ff ff	 DD	 -276			; fffffeecH
  001a0	80 00 00 00	 DD	 128			; 00000080H
  001a4	00 00 00 00	 DD	 $LN10@initDefaul
$LN10@initDefaul:
  001a8	73		 DB	 115			; 00000073H
  001a9	7a		 DB	 122			; 0000007aH
  001aa	56		 DB	 86			; 00000056H
  001ab	61		 DB	 97			; 00000061H
  001ac	6c		 DB	 108			; 0000006cH
  001ad	75		 DB	 117			; 00000075H
  001ae	65		 DB	 101			; 00000065H
  001af	32		 DB	 50			; 00000032H
  001b0	00		 DB	 0
$LN9@initDefaul:
  001b1	73		 DB	 115			; 00000073H
  001b2	7a		 DB	 122			; 0000007aH
  001b3	56		 DB	 86			; 00000056H
  001b4	61		 DB	 97			; 00000061H
  001b5	6c		 DB	 108			; 0000006cH
  001b6	75		 DB	 117			; 00000075H
  001b7	65		 DB	 101			; 00000065H
  001b8	00		 DB	 0
?initDefault@CLogger@@QAE_NPAD0HHH0@Z ENDP		; CLogger::initDefault
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comlogger.cpp
_TEXT	SEGMENT
$T2 = -28						; size = 4
$T3 = -24						; size = 4
$T4 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CLogger@@QAE@XZ PROC					; CLogger::~CLogger
; _this$ = ecx

; 118  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CLogger@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	56		 push	 esi
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0001d	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00020	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00023	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	33 c5		 xor	 eax, ebp
  0002d	50		 push	 eax
  0002e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00031	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00037	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 119  : 	if (isLogFlag(IS_LOG_ENABLE)) {

  0003a	68 00 00 08 00	 push	 524288			; 00080000H
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?isLogFlag@CLogger@@QAE_NW4E_LOG_FLAG@@@Z ; CLogger::isLogFlag
  00047	0f b6 c0	 movzx	 eax, al
  0004a	85 c0		 test	 eax, eax
  0004c	74 0d		 je	 SHORT $LN2@CLogger

; 120  : 		clearLogFlag(IS_LOG_ENABLE);

  0004e	68 00 00 08 00	 push	 524288			; 00080000H
  00053	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	e8 00 00 00 00	 call	 ?clearLogFlag@CLogger@@QAEXW4E_LOG_FLAG@@@Z ; CLogger::clearLogFlag
$LN2@CLogger:

; 121  : 	}
; 122  : 	if (m_hFile) { fclose(m_hFile); m_hFile = NULL;	}

  0005b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	83 79 58 00	 cmp	 DWORD PTR [ecx+88], 0
  00062	74 23		 je	 SHORT $LN3@CLogger
  00064	8b f4		 mov	 esi, esp
  00066	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00069	8b 42 58	 mov	 eax, DWORD PTR [edx+88]
  0006c	50		 push	 eax
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00073	83 c4 04	 add	 esp, 4
  00076	3b f4		 cmp	 esi, esp
  00078	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00080	c7 41 58 00 00
	00 00		 mov	 DWORD PTR [ecx+88], 0
$LN3@CLogger:

; 123  : 	if (m_pLogDir) {

  00087	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0008a	83 7a 60 00	 cmp	 DWORD PTR [edx+96], 0
  0008e	74 21		 je	 SHORT $LN4@CLogger

; 124  : 		delete m_pLogDir; m_pLogDir = NULL;

  00090	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00093	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00096	89 4d ec	 mov	 DWORD PTR $T4[ebp], ecx
  00099	6a 01		 push	 1
  0009b	8b 55 ec	 mov	 edx, DWORD PTR $T4[ebp]
  0009e	52		 push	 edx
  0009f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000a4	83 c4 08	 add	 esp, 8
  000a7	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000aa	c7 40 60 00 00
	00 00		 mov	 DWORD PTR [eax+96], 0
$LN4@CLogger:

; 125  : 	}
; 126  : 	if (m_pLogName) {

  000b1	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000b4	83 79 64 00	 cmp	 DWORD PTR [ecx+100], 0
  000b8	74 21		 je	 SHORT $LN5@CLogger

; 127  : 		delete m_pLogName; m_pLogName = NULL;

  000ba	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000bd	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  000c0	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
  000c3	6a 01		 push	 1
  000c5	8b 4d e8	 mov	 ecx, DWORD PTR $T3[ebp]
  000c8	51		 push	 ecx
  000c9	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000ce	83 c4 08	 add	 esp, 8
  000d1	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000d4	c7 42 64 00 00
	00 00		 mov	 DWORD PTR [edx+100], 0
$LN5@CLogger:

; 128  : 	}
; 129  : 	if (m_pFName) {

  000db	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000de	83 78 5c 00	 cmp	 DWORD PTR [eax+92], 0
  000e2	74 21		 je	 SHORT $LN1@CLogger

; 130  : 		delete m_pFName; m_pFName = NULL;

  000e4	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000e7	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  000ea	89 55 e4	 mov	 DWORD PTR $T2[ebp], edx
  000ed	6a 01		 push	 1
  000ef	8b 45 e4	 mov	 eax, DWORD PTR $T2[ebp]
  000f2	50		 push	 eax
  000f3	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000f8	83 c4 08	 add	 esp, 8
  000fb	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000fe	c7 41 5c 00 00
	00 00		 mov	 DWORD PTR [ecx+92], 0
$LN1@CLogger:

; 131  : 	}
; 132  : }

  00105	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00108	e8 00 00 00 00	 call	 ??1CQueueS@@QAE@XZ	; CQueueS::~CQueueS
  0010d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00110	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00117	59		 pop	 ecx
  00118	5e		 pop	 esi
  00119	83 c4 1c	 add	 esp, 28			; 0000001cH
  0011c	3b ec		 cmp	 ebp, esp
  0011e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00123	8b e5		 mov	 esp, ebp
  00125	5d		 pop	 ebp
  00126	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
__ehhandler$??1CLogger@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CLogger@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CLogger@@QAE@XZ ENDP					; CLogger::~CLogger
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comlogger.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CLogger@@QAE@XZ PROC					; CLogger::CLogger
; _this$ = ecx

; 90   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??0CQueueS@@QAE@XZ	; CQueueS::CQueueS

; 91   : 	m_hFile = NULL;

  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [eax+88], 0

; 92   : 	m_pFName = NULL;

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	c7 41 5c 00 00
	00 00		 mov	 DWORD PTR [ecx+92], 0

; 93   : 
; 94   : 	m_nLogLevel = eLDOPT_LOGLEVEL;

  0002a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002d	c7 42 4c 03 00
	00 00		 mov	 DWORD PTR [edx+76], 3

; 95   : 	m_nLogSize = 0;

  00034	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00037	c7 80 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+132], 0

; 96   : 	m_nLogFlag = 0;

  00041	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	c7 41 74 00 00
	00 00		 mov	 DWORD PTR [ecx+116], 0

; 97   : 	m_nStlNo = eLDOPT_STL_NO;

  0004b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004e	c7 42 7c 00 00
	00 00		 mov	 DWORD PTR [edx+124], 0

; 98   : 
; 99   : 	m_pLogDir = NULL;

  00055	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00058	c7 40 60 00 00
	00 00		 mov	 DWORD PTR [eax+96], 0

; 100  : 	m_pLogName = NULL;

  0005f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00062	c7 41 64 00 00
	00 00		 mov	 DWORD PTR [ecx+100], 0

; 101  : 	strcpy(m_szFileExtension,g_szLogExtension);

  00069	68 00 00 00 00	 push	 OFFSET ?g_szLogExtension@@3PADA ; g_szLogExtension
  0006e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00071	83 c2 68	 add	 edx, 104		; 00000068H
  00074	52		 push	 edx
  00075	e8 00 00 00 00	 call	 _strcpy
  0007a	83 c4 08	 add	 esp, 8

; 102  : 	m_nSeq = 0;

  0007d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00080	c7 40 78 00 00
	00 00		 mov	 DWORD PTR [eax+120], 0

; 103  : 	m_nSizeLimit = eLDOPT_SIZE_LIMIT;

  00087	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008a	c7 81 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+128], 0

; 104  : 	m_nLogSize = 0;

  00094	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00097	c7 82 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+132], 0

; 105  : 	m_nDateTimeFormat = 0;

  000a1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a4	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [eax+80], 0

; 106  : 	m_fpDataProc = NULL;

  000ab	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ae	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0

; 107  : 
; 108  : 	m_szHeaderFormat[0] = 0;

  000b5	ba 01 00 00 00	 mov	 edx, 1
  000ba	6b c2 00	 imul	 eax, edx, 0
  000bd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c0	c6 84 01 88 00
	00 00 00	 mov	 BYTE PTR [ecx+eax+136], 0

; 109  : 	m_pObj = NULL;

  000c8	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000cb	c7 42 48 00 00
	00 00		 mov	 DWORD PTR [edx+72], 0

; 110  : 
; 111  : 	m_nDeleteInterval = 0;

  000d2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000d5	c7 80 d0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+208], 0

; 112  : 	m_tDeleteGoal = 0;

  000df	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e2	c7 81 c8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+200], 0
  000ec	c7 81 cc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+204], 0

; 113  : }

  000f6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000f9	83 c4 04	 add	 esp, 4
  000fc	3b ec		 cmp	 ebp, esp
  000fe	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00103	8b e5		 mov	 esp, ebp
  00105	5d		 pop	 ebp
  00106	c3		 ret	 0
??0CLogger@@QAE@XZ ENDP					; CLogger::CLogger
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?__autoclassinit2@CTimeExpManager@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@CTimeExpManager@@QAEXI@Z PROC		; CTimeExpManager::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR _classSize$[ebp]
  00011	50		 push	 eax
  00012	6a 00		 push	 0
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 _memset
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00020	83 c4 04	 add	 esp, 4
  00023	3b ec		 cmp	 ebp, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?__autoclassinit2@CTimeExpManager@@QAEXI@Z ENDP		; CTimeExpManager::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comlogger.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nIdx$ = 8						; size = 4
?getDTE@CTimeExpManager@@QAEPAUSTLogDateTimeExp@@H@Z PROC ; CTimeExpManager::getDTE
; _this$ = ecx

; 38   : STLogDateTimeExp *CTimeExpManager::getDTE(int nIdx) { if (!m_pTimeExpList) return NULL;  return (STLogDateTimeExp *)m_pTimeExpList->getObj(nIdx); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 38 00	 cmp	 DWORD PTR [eax], 0
  00014	75 04		 jne	 SHORT $LN2@getDTE
  00016	33 c0		 xor	 eax, eax
  00018	eb 0e		 jmp	 SHORT $LN1@getDTE
$LN2@getDTE:
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _nIdx$[ebp]
  0001d	51		 push	 ecx
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00021	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00023	e8 00 00 00 00	 call	 ?getObj@CSList@@QAEPAXH@Z ; CSList::getObj
$LN1@getDTE:
  00028	83 c4 04	 add	 esp, 4
  0002b	3b ec		 cmp	 ebp, esp
  0002d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
?getDTE@CTimeExpManager@@QAEPAUSTLogDateTimeExp@@H@Z ENDP ; CTimeExpManager::getDTE
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comlogger.cpp
_TEXT	SEGMENT
tv83 = -120						; size = 4
$T2 = -116						; size = 4
$T3 = -112						; size = 4
_i$ = -108						; size = 4
_nCount$ = -104						; size = 4
_nDTESize$ = -100					; size = 4
_pDTE$ = -96						; size = 4
_szSection$ = -88					; size = 64
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pConfig$ = 8						; size = 4
?initConfig@CTimeExpManager@@QAE_NPAD@Z PROC		; CTimeExpManager::initConfig
; _this$ = ecx

; 41   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?initConfig@CTimeExpManager@@QAE_NPAD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	51		 push	 ecx
  00017	8d 7d 88	 lea	 edi, DWORD PTR [ebp-120]
  0001a	b9 1b 00 00 00	 mov	 ecx, 27			; 0000001bH
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	59		 pop	 ecx
  00027	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002c	33 c5		 xor	 eax, ebp
  0002e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00031	50		 push	 eax
  00032	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00035	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003b	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 42   : 	TCHAR szSection[64];
; 43   : 	STLogDateTimeExp *pDTE;
; 44   : 	size_t nDTESize = sizeof(STLogDateTimeExp);

  0003e	c7 45 9c 0c 00
	00 00		 mov	 DWORD PTR _nDTESize$[ebp], 12 ; 0000000cH

; 45   : 	int nCount;
; 46   : 
; 47   : 
; 48   : 	nCount = GetPrivateProfileInt(_T("DATETIME_EXPRESSION"), _T("LIST_MAX"), 0, pConfig);

  00045	8b f4		 mov	 esi, esp
  00047	8b 45 08	 mov	 eax, DWORD PTR _pConfig$[ebp]
  0004a	50		 push	 eax
  0004b	6a 00		 push	 0
  0004d	68 00 00 00 00	 push	 OFFSET $SG86447
  00052	68 00 00 00 00	 push	 OFFSET $SG86448
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  0005d	3b f4		 cmp	 esi, esp
  0005f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00064	89 45 98	 mov	 DWORD PTR _nCount$[ebp], eax

; 49   : 	int i;
; 50   : 	m_pTimeExpList = new CSList();

  00067	6a 18		 push	 24			; 00000018H
  00069	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0006e	83 c4 04	 add	 esp, 4
  00071	89 45 8c	 mov	 DWORD PTR $T2[ebp], eax
  00074	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0007b	83 7d 8c 00	 cmp	 DWORD PTR $T2[ebp], 0
  0007f	74 17		 je	 SHORT $LN10@initConfig
  00081	6a 18		 push	 24			; 00000018H
  00083	8b 4d 8c	 mov	 ecx, DWORD PTR $T2[ebp]
  00086	e8 00 00 00 00	 call	 ?__autoclassinit2@CSList@@QAEXI@Z
  0008b	8b 4d 8c	 mov	 ecx, DWORD PTR $T2[ebp]
  0008e	e8 00 00 00 00	 call	 ??0CSList@@QAE@XZ	; CSList::CSList
  00093	89 45 88	 mov	 DWORD PTR tv83[ebp], eax
  00096	eb 07		 jmp	 SHORT $LN11@initConfig
$LN10@initConfig:
  00098	c7 45 88 00 00
	00 00		 mov	 DWORD PTR tv83[ebp], 0
$LN11@initConfig:
  0009f	8b 4d 88	 mov	 ecx, DWORD PTR tv83[ebp]
  000a2	89 4d 90	 mov	 DWORD PTR $T3[ebp], ecx
  000a5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000ac	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000af	8b 45 90	 mov	 eax, DWORD PTR $T3[ebp]
  000b2	89 02		 mov	 DWORD PTR [edx], eax

; 51   : 	if (!m_pTimeExpList) {

  000b4	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000b7	83 39 00	 cmp	 DWORD PTR [ecx], 0
  000ba	75 1b		 jne	 SHORT $LN5@initConfig

; 52   : 		printf("new CList() is NULL!\t%s%d\n", __FUNCTION__, __LINE__);

  000bc	6a 34		 push	 52			; 00000034H
  000be	68 00 00 00 00	 push	 OFFSET $SG86451
  000c3	68 00 00 00 00	 push	 OFFSET $SG86452
  000c8	e8 00 00 00 00	 call	 _printf
  000cd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 53   : 		return false;

  000d0	32 c0		 xor	 al, al
  000d2	e9 d6 01 00 00	 jmp	 $LN1@initConfig
$LN5@initConfig:

; 54   : 	}
; 55   : 	if (!m_pTimeExpList->alloc(nCount + LIST_ADD_COUNT, eAlloc_Type_alloc)) {

  000d7	6a 03		 push	 3
  000d9	8b 55 98	 mov	 edx, DWORD PTR _nCount$[ebp]
  000dc	83 c2 0a	 add	 edx, 10			; 0000000aH
  000df	52		 push	 edx
  000e0	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e5	e8 00 00 00 00	 call	 ?alloc@CSList@@QAEHHW4E_ALLOC_TYPE@@@Z ; CSList::alloc
  000ea	85 c0		 test	 eax, eax
  000ec	75 1b		 jne	 SHORT $LN6@initConfig

; 56   : 		printf("m_pTimeExpList->alloc has Failed!\t%s%d\n", __FUNCTION__, __LINE__);

  000ee	6a 38		 push	 56			; 00000038H
  000f0	68 00 00 00 00	 push	 OFFSET $SG86454
  000f5	68 00 00 00 00	 push	 OFFSET $SG86455
  000fa	e8 00 00 00 00	 call	 _printf
  000ff	83 c4 0c	 add	 esp, 12			; 0000000cH

; 57   : 		return false;

  00102	32 c0		 xor	 al, al
  00104	e9 a4 01 00 00	 jmp	 $LN1@initConfig
$LN6@initConfig:

; 58   : 	}
; 59   : 	
; 60   : 	// Default
; 61   : 	if (!nCount) {

  00109	83 7d 98 00	 cmp	 DWORD PTR _nCount$[ebp], 0
  0010d	75 64		 jne	 SHORT $LN7@initConfig

; 62   : 		nCount = 1;

  0010f	c7 45 98 01 00
	00 00		 mov	 DWORD PTR _nCount$[ebp], 1

; 63   : 		pDTE = (STLogDateTimeExp *)malloc(nDTESize);

  00116	8b f4		 mov	 esi, esp
  00118	8b 4d 9c	 mov	 ecx, DWORD PTR _nDTESize$[ebp]
  0011b	51		 push	 ecx
  0011c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00122	83 c4 04	 add	 esp, 4
  00125	3b f4		 cmp	 esi, esp
  00127	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0012c	89 45 a0	 mov	 DWORD PTR _pDTE$[ebp], eax

; 64   : 		pDTE->bTimeDelimeter = 1;

  0012f	8b 55 a0	 mov	 edx, DWORD PTR _pDTE$[ebp]
  00132	c6 42 02 01	 mov	 BYTE PTR [edx+2], 1

; 65   : 		pDTE->cDateDelimeter = '/';

  00136	8b 45 a0	 mov	 eax, DWORD PTR _pDTE$[ebp]
  00139	c6 40 01 2f	 mov	 BYTE PTR [eax+1], 47	; 0000002fH

; 66   : 		pDTE->bBracketEnclosed = 1;

  0013d	8b 4d a0	 mov	 ecx, DWORD PTR _pDTE$[ebp]
  00140	c6 01 01	 mov	 BYTE PTR [ecx], 1

; 67   : 		pDTE->nLastType = DT_MILLISEC;

  00143	8b 55 a0	 mov	 edx, DWORD PTR _pDTE$[ebp]
  00146	c7 42 04 02 00
	00 00		 mov	 DWORD PTR [edx+4], 2

; 68   : 		pDTE->nYearLen = 4;

  0014d	8b 45 a0	 mov	 eax, DWORD PTR _pDTE$[ebp]
  00150	c6 40 03 04	 mov	 BYTE PTR [eax+3], 4

; 69   : 		pDTE->nTZType = TZ_NONE;

  00154	8b 4d a0	 mov	 ecx, DWORD PTR _pDTE$[ebp]
  00157	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 70   : 		m_pTimeExpList->push_back(pDTE);

  0015e	6a 00		 push	 0
  00160	8b 55 a0	 mov	 edx, DWORD PTR _pDTE$[ebp]
  00163	52		 push	 edx
  00164	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00167	8b 08		 mov	 ecx, DWORD PTR [eax]
  00169	e8 00 00 00 00	 call	 ?push_back@CSList@@QAE_NPAXPAH@Z ; CSList::push_back

; 71   : 	}
; 72   : 	else {

  0016e	e9 38 01 00 00	 jmp	 $LN8@initConfig
$LN7@initConfig:

; 73   : 		for (i = 0; i < nCount; i++) {

  00173	c7 45 94 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0017a	eb 09		 jmp	 SHORT $LN4@initConfig
$LN2@initConfig:
  0017c	8b 4d 94	 mov	 ecx, DWORD PTR _i$[ebp]
  0017f	83 c1 01	 add	 ecx, 1
  00182	89 4d 94	 mov	 DWORD PTR _i$[ebp], ecx
$LN4@initConfig:
  00185	8b 55 94	 mov	 edx, DWORD PTR _i$[ebp]
  00188	3b 55 98	 cmp	 edx, DWORD PTR _nCount$[ebp]
  0018b	0f 8d 1a 01 00
	00		 jge	 $LN8@initConfig

; 74   : 			pDTE = (STLogDateTimeExp *)malloc(nDTESize);

  00191	8b f4		 mov	 esi, esp
  00193	8b 45 9c	 mov	 eax, DWORD PTR _nDTESize$[ebp]
  00196	50		 push	 eax
  00197	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0019d	83 c4 04	 add	 esp, 4
  001a0	3b f4		 cmp	 esi, esp
  001a2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001a7	89 45 a0	 mov	 DWORD PTR _pDTE$[ebp], eax

; 75   : 			_stprintf(szSection, _T("DATETIME_EXPRESSION_%d"), i);

  001aa	8b 4d 94	 mov	 ecx, DWORD PTR _i$[ebp]
  001ad	51		 push	 ecx
  001ae	68 00 00 00 00	 push	 OFFSET $SG86458
  001b3	8d 55 a8	 lea	 edx, DWORD PTR _szSection$[ebp]
  001b6	52		 push	 edx
  001b7	e8 00 00 00 00	 call	 _sprintf
  001bc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 76   : 			pDTE->bTimeDelimeter = GetPrivateProfileInt(szSection, _T("IS_TIME_DELIMETER"), 1, pConfig);

  001bf	8b f4		 mov	 esi, esp
  001c1	8b 45 08	 mov	 eax, DWORD PTR _pConfig$[ebp]
  001c4	50		 push	 eax
  001c5	6a 01		 push	 1
  001c7	68 00 00 00 00	 push	 OFFSET $SG86459
  001cc	8d 4d a8	 lea	 ecx, DWORD PTR _szSection$[ebp]
  001cf	51		 push	 ecx
  001d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  001d6	3b f4		 cmp	 esi, esp
  001d8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001dd	8b 55 a0	 mov	 edx, DWORD PTR _pDTE$[ebp]
  001e0	88 42 02	 mov	 BYTE PTR [edx+2], al

; 77   : 			pDTE->cDateDelimeter = (char)GetPrivateProfileInt(szSection, _T("DATE_DELIMETER"), '/', pConfig);

  001e3	8b f4		 mov	 esi, esp
  001e5	8b 45 08	 mov	 eax, DWORD PTR _pConfig$[ebp]
  001e8	50		 push	 eax
  001e9	6a 2f		 push	 47			; 0000002fH
  001eb	68 00 00 00 00	 push	 OFFSET $SG86460
  001f0	8d 4d a8	 lea	 ecx, DWORD PTR _szSection$[ebp]
  001f3	51		 push	 ecx
  001f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  001fa	3b f4		 cmp	 esi, esp
  001fc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00201	8b 55 a0	 mov	 edx, DWORD PTR _pDTE$[ebp]
  00204	88 42 01	 mov	 BYTE PTR [edx+1], al

; 78   : 			pDTE->bBracketEnclosed = GetPrivateProfileInt(szSection, _T("IS_BRACKET_ENCLOSED"), 1, pConfig);

  00207	8b f4		 mov	 esi, esp
  00209	8b 45 08	 mov	 eax, DWORD PTR _pConfig$[ebp]
  0020c	50		 push	 eax
  0020d	6a 01		 push	 1
  0020f	68 00 00 00 00	 push	 OFFSET $SG86461
  00214	8d 4d a8	 lea	 ecx, DWORD PTR _szSection$[ebp]
  00217	51		 push	 ecx
  00218	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  0021e	3b f4		 cmp	 esi, esp
  00220	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00225	8b 55 a0	 mov	 edx, DWORD PTR _pDTE$[ebp]
  00228	88 02		 mov	 BYTE PTR [edx], al

; 79   : 			pDTE->nLastType = (DT_TYPE)GetPrivateProfileInt(szSection, _T("LAST_TYPE"), DT_MILLISEC, pConfig);

  0022a	8b f4		 mov	 esi, esp
  0022c	8b 45 08	 mov	 eax, DWORD PTR _pConfig$[ebp]
  0022f	50		 push	 eax
  00230	6a 02		 push	 2
  00232	68 00 00 00 00	 push	 OFFSET $SG86462
  00237	8d 4d a8	 lea	 ecx, DWORD PTR _szSection$[ebp]
  0023a	51		 push	 ecx
  0023b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00241	3b f4		 cmp	 esi, esp
  00243	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00248	8b 55 a0	 mov	 edx, DWORD PTR _pDTE$[ebp]
  0024b	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 80   : 			pDTE->nYearLen = GetPrivateProfileInt(szSection, _T("YEAR_LEN"), 4, pConfig);

  0024e	8b f4		 mov	 esi, esp
  00250	8b 45 08	 mov	 eax, DWORD PTR _pConfig$[ebp]
  00253	50		 push	 eax
  00254	6a 04		 push	 4
  00256	68 00 00 00 00	 push	 OFFSET $SG86463
  0025b	8d 4d a8	 lea	 ecx, DWORD PTR _szSection$[ebp]
  0025e	51		 push	 ecx
  0025f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00265	3b f4		 cmp	 esi, esp
  00267	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0026c	8b 55 a0	 mov	 edx, DWORD PTR _pDTE$[ebp]
  0026f	88 42 03	 mov	 BYTE PTR [edx+3], al

; 81   : 			pDTE->nTZType = (TZ_TYPE)GetPrivateProfileInt(szSection, _T("TZ_TYPE"), TZ_NONE, pConfig);

  00272	8b f4		 mov	 esi, esp
  00274	8b 45 08	 mov	 eax, DWORD PTR _pConfig$[ebp]
  00277	50		 push	 eax
  00278	6a 00		 push	 0
  0027a	68 00 00 00 00	 push	 OFFSET $SG86464
  0027f	8d 4d a8	 lea	 ecx, DWORD PTR _szSection$[ebp]
  00282	51		 push	 ecx
  00283	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00289	3b f4		 cmp	 esi, esp
  0028b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00290	8b 55 a0	 mov	 edx, DWORD PTR _pDTE$[ebp]
  00293	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 82   : 			m_pTimeExpList->push_back(pDTE);

  00296	6a 00		 push	 0
  00298	8b 45 a0	 mov	 eax, DWORD PTR _pDTE$[ebp]
  0029b	50		 push	 eax
  0029c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0029f	8b 09		 mov	 ecx, DWORD PTR [ecx]
  002a1	e8 00 00 00 00	 call	 ?push_back@CSList@@QAE_NPAXPAH@Z ; CSList::push_back

; 83   : 		}

  002a6	e9 d1 fe ff ff	 jmp	 $LN2@initConfig
$LN8@initConfig:

; 84   : 	}
; 85   : 	return true;

  002ab	b0 01		 mov	 al, 1
$LN1@initConfig:

; 86   : }

  002ad	52		 push	 edx
  002ae	8b cd		 mov	 ecx, ebp
  002b0	50		 push	 eax
  002b1	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN16@initConfig
  002b7	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  002bc	58		 pop	 eax
  002bd	5a		 pop	 edx
  002be	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  002c1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002c8	59		 pop	 ecx
  002c9	5f		 pop	 edi
  002ca	5e		 pop	 esi
  002cb	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002ce	33 cd		 xor	 ecx, ebp
  002d0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002d5	83 c4 78	 add	 esp, 120		; 00000078H
  002d8	3b ec		 cmp	 ebp, esp
  002da	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002df	8b e5		 mov	 esp, ebp
  002e1	5d		 pop	 ebp
  002e2	c2 04 00	 ret	 4
  002e5	0f 1f 00	 npad	 3
$LN16@initConfig:
  002e8	01 00 00 00	 DD	 1
  002ec	00 00 00 00	 DD	 $LN15@initConfig
$LN15@initConfig:
  002f0	a8 ff ff ff	 DD	 -88			; ffffffa8H
  002f4	40 00 00 00	 DD	 64			; 00000040H
  002f8	00 00 00 00	 DD	 $LN13@initConfig
$LN13@initConfig:
  002fc	73		 DB	 115			; 00000073H
  002fd	7a		 DB	 122			; 0000007aH
  002fe	53		 DB	 83			; 00000053H
  002ff	65		 DB	 101			; 00000065H
  00300	63		 DB	 99			; 00000063H
  00301	74		 DB	 116			; 00000074H
  00302	69		 DB	 105			; 00000069H
  00303	6f		 DB	 111			; 0000006fH
  00304	6e		 DB	 110			; 0000006eH
  00305	00		 DB	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?initConfig@CTimeExpManager@@QAE_NPAD@Z$0:
  00000	6a 18		 push	 24			; 00000018H
  00002	8b 45 8c	 mov	 eax, DWORD PTR $T2[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
__ehhandler$?initConfig@CTimeExpManager@@QAE_NPAD@Z:
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a 88	 mov	 ecx, DWORD PTR [edx-120]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?initConfig@CTimeExpManager@@QAE_NPAD@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?initConfig@CTimeExpManager@@QAE_NPAD@Z ENDP		; CTimeExpManager::initConfig
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comlogger.cpp
_TEXT	SEGMENT
tv71 = -16						; size = 4
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
??1CTimeExpManager@@QAE@XZ PROC				; CTimeExpManager::~CTimeExpManager
; _this$ = ecx

; 34   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 35   : 	if (m_pTimeExpList) delete m_pTimeExpList; // 내부 malloc 까지 전부 destroy

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	83 38 00	 cmp	 DWORD PTR [eax], 0
  00020	74 2a		 je	 SHORT $LN3@CTimeExpMa
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	8b 11		 mov	 edx, DWORD PTR [ecx]
  00027	89 55 f4	 mov	 DWORD PTR $T1[ebp], edx
  0002a	8b 45 f4	 mov	 eax, DWORD PTR $T1[ebp]
  0002d	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
  00030	83 7d f8 00	 cmp	 DWORD PTR $T2[ebp], 0
  00034	74 0f		 je	 SHORT $LN4@CTimeExpMa
  00036	6a 01		 push	 1
  00038	8b 4d f8	 mov	 ecx, DWORD PTR $T2[ebp]
  0003b	e8 00 00 00 00	 call	 ??_GCSList@@QAEPAXI@Z
  00040	89 45 f0	 mov	 DWORD PTR tv71[ebp], eax
  00043	eb 07		 jmp	 SHORT $LN3@CTimeExpMa
$LN4@CTimeExpMa:
  00045	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$LN3@CTimeExpMa:

; 36   : }

  0004c	83 c4 10	 add	 esp, 16			; 00000010H
  0004f	3b ec		 cmp	 ebp, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
??1CTimeExpManager@@QAE@XZ ENDP				; CTimeExpManager::~CTimeExpManager
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comlogger.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CTimeExpManager@@QAE@XZ PROC				; CTimeExpManager::CTimeExpManager
; _this$ = ecx

; 30   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 31   : 	m_pTimeExpList = NULL;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 32   : }

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0CTimeExpManager@@QAE@XZ ENDP				; CTimeExpManager::CTimeExpManager
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_GCSList@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCSList@@QAEPAXI@Z PROC				; CSList::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1CSList@@QAE@XZ	; CSList::~CSList
  00016	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00019	83 e0 01	 and	 eax, 1
  0001c	74 0e		 je	 SHORT $LN2@scalar
  0001e	6a 18		 push	 24			; 00000018H
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00029	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b ec		 cmp	 ebp, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
??_GCSList@@QAEPAXI@Z ENDP				; CSList::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?__autoclassinit2@CSList@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@CSList@@QAEXI@Z PROC			; CSList::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR _classSize$[ebp]
  00011	50		 push	 eax
  00012	6a 00		 push	 0
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 _memset
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00020	83 c4 04	 add	 esp, 4
  00023	3b ec		 cmp	 ebp, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?__autoclassinit2@CSList@@QAEXI@Z ENDP			; CSList::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\comlist.h
;	COMDAT ?getObj@CSList@@QAEPAXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?getObj@CSList@@QAEPAXH@Z PROC				; CSList::getObj, COMDAT
; _this$ = ecx

; 33   : 	inline void* getObj(int i) { if (ISINCLUDE(i, m_nMax)) return m_pArray[i]; return NULL; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00014	51		 push	 ecx
  00015	8b 55 08	 mov	 edx, DWORD PTR _i$[ebp]
  00018	52		 push	 edx
  00019	e8 00 00 00 00	 call	 ?ISINCLUDE@@YA_NHH@Z	; ISINCLUDE
  0001e	83 c4 08	 add	 esp, 8
  00021	0f b6 c0	 movzx	 eax, al
  00024	85 c0		 test	 eax, eax
  00026	74 0d		 je	 SHORT $LN2@getObj
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002d	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00030	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  00033	eb 02		 jmp	 SHORT $LN1@getObj
$LN2@getObj:
  00035	33 c0		 xor	 eax, eax
$LN1@getObj:
  00037	83 c4 04	 add	 esp, 4
  0003a	3b ec		 cmp	 ebp, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
?getObj@CSList@@QAEPAXH@Z ENDP				; CSList::getObj
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\comlist.h
;	COMDAT ?alloc@CSList@@QAEHHW4E_ALLOC_TYPE@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nMaxCount$ = 8						; size = 4
_type$ = 12						; size = 4
?alloc@CSList@@QAEHHW4E_ALLOC_TYPE@@@Z PROC		; CSList::alloc, COMDAT
; _this$ = ecx

; 27   : 	inline int alloc(int nMaxCount, E_ALLOC_TYPE type = eAlloc_Type_new) { m_nObjAllocType = type;  m_nMax = __alloc(nMaxCount); return m_nMax; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 4d 0c	 mov	 ecx, DWORD PTR _type$[ebp]
  00014	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR _nMaxCount$[ebp]
  0001a	52		 push	 edx
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?__alloc@CSList@@AAEHH@Z ; CSList::__alloc
  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  00029	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002c	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b ec		 cmp	 ebp, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
?alloc@CSList@@QAEHHW4E_ALLOC_TYPE@@@Z ENDP		; CSList::alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\commemmanager.h
;	COMDAT ?newBuf@CMemManager@@QAEPADH@Z
_TEXT	SEGMENT
_nIdx$ = -8						; size = 4
_this$ = -4						; size = 4
_nSize$ = 8						; size = 4
?newBuf@CMemManager@@QAEPADH@Z PROC			; CMemManager::newBuf, COMDAT
; _this$ = ecx

; 34   : 	inline char *newBuf(int nSize) { int nIdx = getIndex(nSize);  return __newBuf(nIdx, nSize); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00017	8b 45 08	 mov	 eax, DWORD PTR _nSize$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ?getIndex@@YAHH@Z	; getIndex
  00020	83 c4 04	 add	 esp, 4
  00023	89 45 f8	 mov	 DWORD PTR _nIdx$[ebp], eax
  00026	8b 4d 08	 mov	 ecx, DWORD PTR _nSize$[ebp]
  00029	51		 push	 ecx
  0002a	8b 55 f8	 mov	 edx, DWORD PTR _nIdx$[ebp]
  0002d	52		 push	 edx
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ?__newBuf@CMemManager@@AAEPADHI@Z ; CMemManager::__newBuf
  00036	83 c4 08	 add	 esp, 8
  00039	3b ec		 cmp	 ebp, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 04 00	 ret	 4
?newBuf@CMemManager@@QAEPADH@Z ENDP			; CMemManager::newBuf
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\combufpool.h
;	COMDAT ?getIndex@@YAHH@Z
_TEXT	SEGMENT
tv73 = -24						; size = 4
_$S1$ = -16						; size = 8
_m$ = -4						; size = 4
_s$ = 8							; size = 4
?getIndex@@YAHH@Z PROC					; getIndex, COMDAT

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0000e	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00011	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00014	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00017	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001a	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001d	f2 0f 2a 45 08	 cvtsi2sd xmm0, DWORD PTR _s$[ebp]
  00022	f2 0f 11 45 f0	 movsd	 QWORD PTR _$S1$[ebp], xmm0
  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	c1 e0 00	 shl	 eax, 0
  0002f	8b 4c 05 f0	 mov	 ecx, DWORD PTR _$S1$[ebp+eax]
  00033	c1 f9 14	 sar	 ecx, 20			; 00000014H
  00036	81 e9 ff 03 00
	00		 sub	 ecx, 1023		; 000003ffH
  0003c	89 4d fc	 mov	 DWORD PTR _m$[ebp], ecx
  0003f	ba 01 00 00 00	 mov	 edx, 1
  00044	8b 4d fc	 mov	 ecx, DWORD PTR _m$[ebp]
  00047	d3 e2		 shl	 edx, cl
  00049	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0004c	2b c2		 sub	 eax, edx
  0004e	23 45 08	 and	 eax, DWORD PTR _s$[ebp]
  00051	74 09		 je	 SHORT $LN3@getIndex
  00053	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv73[ebp], 1
  0005a	eb 07		 jmp	 SHORT $LN4@getIndex
$LN3@getIndex:
  0005c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
$LN4@getIndex:
  00063	8b 45 fc	 mov	 eax, DWORD PTR _m$[ebp]
  00066	03 45 e8	 add	 eax, DWORD PTR tv73[ebp]
  00069	52		 push	 edx
  0006a	8b cd		 mov	 ecx, ebp
  0006c	50		 push	 eax
  0006d	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN7@getIndex
  00073	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00078	58		 pop	 eax
  00079	5a		 pop	 edx
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
  0007e	66 90		 npad	 2
$LN7@getIndex:
  00080	01 00 00 00	 DD	 1
  00084	00 00 00 00	 DD	 $LN6@getIndex
$LN6@getIndex:
  00088	f0 ff ff ff	 DD	 -16			; fffffff0H
  0008c	08 00 00 00	 DD	 8
  00090	00 00 00 00	 DD	 $LN5@getIndex
$LN5@getIndex:
  00094	24		 DB	 36			; 00000024H
  00095	53		 DB	 83			; 00000053H
  00096	31		 DB	 49			; 00000031H
  00097	00		 DB	 0
?getIndex@@YAHH@Z ENDP					; getIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\comdatetime.h
;	COMDAT ?TimezoneString@CDateTime@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?TimezoneString@CDateTime@@QAEPBDXZ PROC		; CDateTime::TimezoneString, COMDAT
; _this$ = ecx

; 224  : 	inline const TCHAR *TimezoneString() { return m_szTimezone; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 c0 5c	 add	 eax, 92			; 0000005cH
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?TimezoneString@CDateTime@@QAEPBDXZ ENDP		; CDateTime::TimezoneString
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\comqueue.h
;	COMDAT ?capacity@CQueueS@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@CQueueS@@QAEHXZ PROC				; CQueueS::capacity, COMDAT
; _this$ = ecx

; 43   :     inline int  capacity()   { return m_nMax; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?capacity@CQueueS@@QAEHXZ ENDP				; CQueueS::capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\comtypes.h
;	COMDAT ?comGlobalErrorProc@@YAXPADPBDH@Z
_TEXT	SEGMENT
_pMsg$ = 8						; size = 4
__szFunc$ = 12						; size = 4
__nLine$ = 16						; size = 4
?comGlobalErrorProc@@YAXPADPBDH@Z PROC			; comGlobalErrorProc, COMDAT

; 324  : inline void comGlobalErrorProc(char *pMsg, const char *_szFunc, const int _nLine) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 325  : 	sprintf(g_szSystemError, "ERROR! [%s:%d] %s\n", _szFunc, _nLine, pMsg);

  00003	8b 45 08	 mov	 eax, DWORD PTR _pMsg$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 10	 mov	 ecx, DWORD PTR __nLine$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 0c	 mov	 edx, DWORD PTR __szFunc$[ebp]
  0000e	52		 push	 edx
  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@KEHDJCKJ@ERROR?$CB?5?$FL?$CFs?3?$CFd?$FN?5?$CFs?6?$AA@
  00014	68 00 00 00 00	 push	 OFFSET ?g_szSystemError@@3PADA ; g_szSystemError
  00019	e8 00 00 00 00	 call	 _sprintf
  0001e	83 c4 14	 add	 esp, 20			; 00000014H

; 326  : 	printf(g_szSystemError);

  00021	68 00 00 00 00	 push	 OFFSET ?g_szSystemError@@3PADA ; g_szSystemError
  00026	e8 00 00 00 00	 call	 _printf
  0002b	83 c4 04	 add	 esp, 4

; 327  : }

  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?comGlobalErrorProc@@YAXPADPBDH@Z ENDP			; comGlobalErrorProc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\comtypes.h
;	COMDAT ?ISINCLUDE@@YA_NHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
_max$ = 12						; size = 4
?ISINCLUDE@@YA_NHH@Z PROC				; ISINCLUDE, COMDAT

; 322  : inline bool ISINCLUDE(int i, int max) { if (0 <= i && i < max) return true; return false; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 7d 08 00	 cmp	 DWORD PTR _i$[ebp], 0
  00007	7c 0c		 jl	 SHORT $LN2@ISINCLUDE
  00009	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  0000c	3b 45 0c	 cmp	 eax, DWORD PTR _max$[ebp]
  0000f	7d 04		 jge	 SHORT $LN2@ISINCLUDE
  00011	b0 01		 mov	 al, 1
  00013	eb 02		 jmp	 SHORT $LN1@ISINCLUDE
$LN2@ISINCLUDE:
  00015	32 c0		 xor	 al, al
$LN1@ISINCLUDE:
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?ISINCLUDE@@YA_NHH@Z ENDP				; ISINCLUDE
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_time	PROC

; 534  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 535  :             return _time64(_Time);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 08	 mov	 eax, DWORD PTR __Time$[ebp]
  00009	50		 push	 eax
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___time64
  00010	83 c4 04	 add	 esp, 4
  00013	3b f4		 cmp	 esi, esp
  00015	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 536  :         }

  0001a	5e		 pop	 esi
  0001b	3b ec		 cmp	 ebp, esp
  0001d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
_time	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

  00014	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
  00019	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0001c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __ArgList$[ebp]
  00022	51		 push	 ecx
  00023	6a 00		 push	 0
  00025	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00028	52		 push	 edx
  00029	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 __vsprintf_l
  00032	83 c4 10	 add	 esp, 16			; 00000010H
  00035	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

  00038	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1787 :     return _Result;

  0003f	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 1788 : }

  00042	83 c4 08	 add	 esp, 8
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00003	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  0000e	52		 push	 edx
  0000f	6a ff		 push	 -1
  00011	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 __vsnprintf_l
  0001a	83 c4 14	 add	 esp, 20			; 00000014H

; 1459 :     #pragma warning(pop)
; 1460 : }

  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vsnprintf
_TEXT	SEGMENT
tv74 = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
_vsnprintf PROC						; COMDAT

; 1435 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1436 :     int const _Result = __stdio_common_vsprintf(

  00015	8b f4		 mov	 esi, esp
  00017	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0001a	50		 push	 eax
  0001b	6a 00		 push	 0
  0001d	8b 4d 10	 mov	 ecx, DWORD PTR __Format$[ebp]
  00020	51		 push	 ecx
  00021	8b 55 0c	 mov	 edx, DWORD PTR __BufferCount$[ebp]
  00024	52		 push	 edx
  00025	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	83 c9 02	 or	 ecx, 2
  00033	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00036	52		 push	 edx
  00037	51		 push	 ecx
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf
  0003e	83 c4 1c	 add	 esp, 28			; 0000001cH
  00041	3b f4		 cmp	 esi, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1437 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1438 :         _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1439 : 
; 1440 :     return _Result < 0 ? -1 : _Result;

  0004b	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  0004f	7d 09		 jge	 SHORT $LN3@vsnprintf
  00051	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  00058	eb 06		 jmp	 SHORT $LN4@vsnprintf
$LN3@vsnprintf:
  0005a	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]
  0005d	89 45 f8	 mov	 DWORD PTR tv74[ebp], eax
$LN4@vsnprintf:
  00060	8b 45 f8	 mov	 eax, DWORD PTR tv74[ebp]

; 1441 : }

  00063	5e		 pop	 esi
  00064	83 c4 08	 add	 esp, 8
  00067	3b ec		 cmp	 ebp, esp
  00069	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
_vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsnprintf PROC					; COMDAT

; 1405 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1406 :     #pragma warning(push)
; 1407 :     #pragma warning(disable: 4996) // Deprecation
; 1408 :     return _vsnprintf_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

  00003	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	8b 4d 10	 mov	 ecx, DWORD PTR __Format$[ebp]
  0000c	51		 push	 ecx
  0000d	8b 55 0c	 mov	 edx, DWORD PTR __BufferCount$[ebp]
  00010	52		 push	 edx
  00011	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 __vsnprintf_l
  0001a	83 c4 14	 add	 esp, 20			; 00000014H

; 1409 :     #pragma warning(pop)
; 1410 : }

  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
__vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00015	8b f4		 mov	 esi, esp
  00017	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00022	52		 push	 edx
  00023	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00030	8b 10		 mov	 edx, DWORD PTR [eax]
  00032	83 ca 01	 or	 edx, 1
  00035	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00038	50		 push	 eax
  00039	52		 push	 edx
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf
  00040	83 c4 1c	 add	 esp, 28			; 0000001cH
  00043	3b f4		 cmp	 esi, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  0004d	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  00051	7d 09		 jge	 SHORT $LN3@vsnprintf_
  00053	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  0005a	eb 06		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0005c	8b 4d fc	 mov	 ecx, DWORD PTR __Result$[ebp]
  0005f	89 4d f8	 mov	 DWORD PTR tv74[ebp], ecx
$LN4@vsnprintf_:
  00062	8b 45 f8	 mov	 eax, DWORD PTR tv74[ebp]

; 1391 : }

  00065	5e		 pop	 esi
  00066	83 c4 08	 add	 esp, 8
  00069	3b ec		 cmp	 ebp, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 950  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 951  :     int _Result;
; 952  :     va_list _ArgList;
; 953  :     __crt_va_start(_ArgList, _Format);

  00015	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
  0001a	8d 45 0c	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0001d	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 954  :     _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00020	8b 4d f8	 mov	 ecx, DWORD PTR __ArgList$[ebp]
  00023	51		 push	 ecx
  00024	6a 00		 push	 0
  00026	8b 55 08	 mov	 edx, DWORD PTR __Format$[ebp]
  00029	52		 push	 edx
  0002a	8b f4		 mov	 esi, esp
  0002c	6a 01		 push	 1
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  00034	83 c4 04	 add	 esp, 4
  00037	3b f4		 cmp	 esi, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 __vfprintf_l
  00044	83 c4 10	 add	 esp, 16			; 00000010H
  00047	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 955  :     __crt_va_end(_ArgList);

  0004a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 956  :     return _Result;

  00051	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 957  : }

  00054	5e		 pop	 esi
  00055	83 c4 08	 add	 esp, 8
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 144  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 831  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 832  :     int _Result;
; 833  :     va_list _ArgList;
; 834  :     __crt_va_start(_ArgList, _Format);

  00014	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
  00019	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0001c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 835  :     _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __ArgList$[ebp]
  00022	51		 push	 ecx
  00023	6a 00		 push	 0
  00025	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00028	52		 push	 edx
  00029	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 __vfprintf_l
  00032	83 c4 10	 add	 esp, 16			; 00000010H
  00035	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 836  :     __crt_va_end(_ArgList);

  00038	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 837  :     return _Result;

  0003f	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 838  : }

  00042	83 c4 08	 add	 esp, 8
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 638  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00011	52		 push	 edx
  00012	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0001b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001e	51		 push	 ecx
  0001f	8b 10		 mov	 edx, DWORD PTR [eax]
  00021	52		 push	 edx
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vfprintf
  00028	83 c4 18	 add	 esp, 24			; 00000018H
  0002b	3b f4		 cmp	 esi, esp
  0002d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 640  : }

  00032	5e		 pop	 esi
  00033	3b ec		 cmp	 ebp, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
;	COMDAT __tcscmp
_TEXT	SEGMENT
__s1$ = 8						; size = 4
__s2$ = 12						; size = 4
__tcscmp PROC						; COMDAT

; 1669 : _Check_return_ __inline int _tcscmp(_In_ _CPC _s1,_In_ _CPC _s2) {return _mbscmp((_CPUC)_s1,(_CPUC)_s2);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f4		 mov	 esi, esp
  00006	8b 45 0c	 mov	 eax, DWORD PTR __s2$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __s1$[ebp]
  0000d	51		 push	 ecx
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mbscmp
  00014	83 c4 08	 add	 esp, 8
  00017	3b f4		 cmp	 esi, esp
  00019	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001e	5e		 pop	 esi
  0001f	3b ec		 cmp	 ebp, esp
  00021	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
__tcscmp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
;	COMDAT __tcsrchr
_TEXT	SEGMENT
__s1$ = 8						; size = 4
__c$ = 12						; size = 4
__tcsrchr PROC						; COMDAT

; 1569 : _Check_return_ __inline _CRPC _tcsrchr(_In_ _CPC _s1,_In_ _UI _c) {return (_CRPC)_mbsrchr((_CPUC)_s1,_c);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f4		 mov	 esi, esp
  00006	8b 45 0c	 mov	 eax, DWORD PTR __c$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __s1$[ebp]
  0000d	51		 push	 ecx
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mbsrchr
  00014	83 c4 08	 add	 esp, 8
  00017	3b f4		 cmp	 esi, esp
  00019	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001e	5e		 pop	 esi
  0001f	3b ec		 cmp	 ebp, esp
  00021	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
__tcsrchr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
;	COMDAT __tcsncpy
_TEXT	SEGMENT
__Dst$ = 8						; size = 4
__Source$ = 12						; size = 4
__Count$ = 16						; size = 4
__tcsncpy PROC						; COMDAT

; 1542 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1543 : #pragma warning(push)
; 1544 : #pragma warning(disable:4996)
; 1545 :     return (char *)_mbsnbcpy((unsigned char *)_Dst,(const unsigned char *)_Source,_Count);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Source$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 08	 mov	 edx, DWORD PTR __Dst$[ebp]
  00011	52		 push	 edx
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mbsnbcpy
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001b	3b f4		 cmp	 esi, esp
  0001d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1546 : #pragma warning(pop)
; 1547 : }

  00022	5e		 pop	 esi
  00023	3b ec		 cmp	 ebp, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
__tcsncpy ENDP
_TEXT	ENDS
END
