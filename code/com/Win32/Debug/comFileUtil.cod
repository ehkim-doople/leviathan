; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	E:\InfiniA-Library-3.0\com\src\comFileUtil.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG87124 DB	'pList calloc is NULL', 00H
	ORG $+3
$SG87157 DB	'pList calloc is NULL', 00H
	ORG $+3
$SG86390 DB	'%s*.*', 00H
	ORG $+2
$SG86412 DB	'.', 00H
	ORG $+2
$SG86413 DB	'..', 00H
	ORG $+1
$SG86453 DB	'.', 00H
	ORG $+2
$SG86454 DB	'..', 00H
	ORG $+1
$SG86455 DB	'%s%s', 00H
	ORG $+3
$SG86464 DB	'%s%s%c', 00H
	ORG $+1
$SG86472 DB	'FAILED _tremove[%s] nResult[%d]', 00H
$SG86473 DB	'CFileUtil::delDirectory', 00H
$SG86474 DB	'SUCCESS _tremove[%s] nResult[%d]', 00H
	ORG $+3
$SG86475 DB	'CFileUtil::delDirectory', 00H
$SG86480 DB	'SUCCESS rmdir[%s]', 00H
	ORG $+2
$SG86481 DB	'CFileUtil::delDirectory', 00H
$SG86482 DB	'FAILED rmdir[%s]', 00H
	ORG $+3
$SG86483 DB	'CFileUtil::delDirectory', 00H
$SG86577 DB	'fname[%s] nCount[%d]', 00H
	ORG $+3
$SG86578 DB	' fname[%d] ftype[%d]', 00H
	ORG $+3
$SG86579 DB	'CFileUtil::appendFileList', 00H
	ORG $+2
$SG86598 DB	'.\', 00H
	ORG $+1
$SG86599 DB	'..\', 00H
$SG86606 DB	'com_mkdir has Failed! [%s]', 00H
	ORG $+1
$SG86607 DB	'CFileUtil::MakeDirectory', 00H
	ORG $+3
$SG86625 DB	'rb', 00H
	ORG $+1
$SG86627 DB	'wb+', 00H
$SG86643 DB	'rb', 00H
	ORG $+1
$SG86645 DB	'CDFSFile::read pFile open FAIL [%s]', 00H
$SG86734 DB	'new pList', 00H
	ORG $+2
$SG86735 DB	'CFileUtil::fileToFieldRecord', 00H
	ORG $+3
$SG86738 DB	'alloc pList', 00H
$SG86739 DB	'CFileUtil::fileToFieldRecord', 00H
	ORG $+3
$SG86744 DB	'add pLineList', 00H
	ORG $+2
$SG86745 DB	'CFileUtil::fileToFieldRecord', 00H
	ORG $+3
$SG86788 DB	'rb', 00H
	ORG $+1
$SG86790 DB	'CDFSFile::read pFile open FAIL [%s]', 00H
$SG86794 DB	'CFileUtil::readNalloc malloc error! size[%ld]', 00H
	ORG $+2
$SG86796 DB	'fread errno[%d]', 0aH, 00H
	ORG $+3
$SG86812 DB	'CFileUtil::getNextLine gs_pMMgr->newBuf error! size[%ld]'
	DB	00H
	ORG $+3
$SG86820 DB	'a+', 00H
	ORG $+1
$SG86822 DB	'a+', 00H
	ORG $+1
$SG86824 DB	'CDFSFile::add pFile open FAIL [%s]', 00H
	ORG $+1
$SG86840 DB	'FILEMOVE error code[%d]', 00H
$SG86846 DB	'r', 00H
	ORG $+2
$SG86861 DB	'CFileUtil::tryopen pFile open FAIL', 00H
	ORG $+1
$SG86868 DB	'w', 00H
	ORG $+2
$SG86870 DB	'w', 00H
	ORG $+2
$SG86872 DB	'CFileUtil::modify pFile open FAIL [%s]', 00H
	ORG $+1
$SG86883 DB	'r', 00H
	ORG $+2
$SG86903 DB	'rb', 00H
	ORG $+1
$SG86905 DB	'CDFSFile::readLoop pFile open FAIL [%s]', 00H
$SG86929 DB	'rb', 00H
	ORG $+1
$SG86932 DB	'CDFSFile::nextReadLoop pFile open FAIL [%s]', 00H
$SG86944 DB	'rb', 00H
	ORG $+1
$SG86946 DB	'CDFSFile::nextRead pFile open FAIL [%s]', 00H
$SG86957 DB	'w', 00H
	ORG $+2
$SG86959 DB	'w', 00H
	ORG $+2
$SG86961 DB	'CDFSFile::modify pFile open FAIL [%s]', 00H
	ORG $+2
$SG86972 DB	'a+', 00H
	ORG $+1
$SG86974 DB	'a+', 00H
	ORG $+1
$SG86976 DB	'CDFSFile::add2 pFile open FAIL [%s]', 00H
CONST	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	_printf
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	?strchr@@YAPADQADH@Z				; strchr
PUBLIC	__tcschr
PUBLIC	__tcsncpy
PUBLIC	__tcsrchr
PUBLIC	__tcscmp
PUBLIC	?_tcschr@@YAPADPADI@Z				; _tcschr
PUBLIC	?_tcsrchr@@YAPADPADI@Z				; _tcsrchr
PUBLIC	?com_mkdir@@YA_NPBD@Z				; com_mkdir
PUBLIC	?com_isInvalid@@YA_NPBD@Z			; com_isInvalid
PUBLIC	?com_isFile@@YA_NPBD@Z				; com_isFile
PUBLIC	?com_isDirectory@@YA_NPAD@Z			; com_isDirectory
PUBLIC	?com_findFirstFile@@YAPAXPBDPAU_WIN32_FIND_DATAA@@@Z ; com_findFirstFile
PUBLIC	?com_nextFile@@YA_NPAXPAU_WIN32_FIND_DATAA@@@Z	; com_nextFile
PUBLIC	?com_getFileName@@YAXPAPADPAU_WIN32_FIND_DATAA@@@Z ; com_getFileName
PUBLIC	?jISREG@@YA_NPAU_WIN32_FIND_DATAA@@@Z		; jISREG
PUBLIC	?jISDIR@@YA_NPAU_WIN32_FIND_DATAA@@@Z		; jISDIR
PUBLIC	?getIndex@@YAHH@Z				; getIndex
PUBLIC	?newBuf@CMemManager@@QAEPADH@Z			; CMemManager::newBuf
PUBLIC	?newBuf@CMemManager@@QAEPADHPAH@Z		; CMemManager::newBuf
PUBLIC	?delBuf@CMemManager@@QAEXPADH@Z			; CMemManager::delBuf
PUBLIC	?alloc@CStringList@@QAEHH@Z			; CStringList::alloc
PUBLIC	?push_back@CStringList@@QAEPAVCmString@@PAD@Z	; CStringList::push_back
PUBLIC	?getNext@CStringList@@QAEPAVCmString@@PAH@Z	; CStringList::getNext
PUBLIC	?__getNext@CStringList@@AAEPAVCmString@@PAH@Z	; CStringList::__getNext
PUBLIC	?__autoclassinit2@CStringList@@QAEXI@Z		; CStringList::__autoclassinit2
PUBLIC	??_GCStringList@@QAEPAXI@Z			; CStringList::`scalar deleting destructor'
PUBLIC	?filter_stringCompare@@YA_NPADPAX1@Z		; filter_stringCompare
PUBLIC	?filter_dateTimeCompare@@YA_NPADPAX1@Z		; filter_dateTimeCompare
PUBLIC	?IsExistDirectory@CFileUtil@@SA_NPAD@Z		; CFileUtil::IsExistDirectory
PUBLIC	?GetFileList@CFileUtil@@SA_NPAUSTFileList@@PAUSTFilterData@@@Z ; CFileUtil::GetFileList
PUBLIC	?delDirectory@CFileUtil@@SAHPAUSTDelInfo@@PAUSTFilterData@@@Z ; CFileUtil::delDirectory
PUBLIC	?MakeDirectory@CFileUtil@@SA_NPBD@Z		; CFileUtil::MakeDirectory
PUBLIC	?FileCopy@CFileUtil@@SA_NPBD0@Z			; CFileUtil::FileCopy
PUBLIC	?IsAbsolutePath@CFileUtil@@SA_NPBD@Z		; CFileUtil::IsAbsolutePath
PUBLIC	?setDirectory@CFileUtil@@SA_NPADH@Z		; CFileUtil::setDirectory
PUBLIC	?changeDirName@CFileUtil@@SA_NPAD0@Z		; CFileUtil::changeDirName
PUBLIC	?read@CFileUtil@@SAHPAD0H@Z			; CFileUtil::read
PUBLIC	?readNalloc@CFileUtil@@SAHPADPAPADPAH@Z		; CFileUtil::readNalloc
PUBLIC	?getNextLine@CFileUtil@@SAHPAUSTStrInfo@@@Z	; CFileUtil::getNextLine
PUBLIC	?getFieldList@CFileUtil@@SA_NPADDPAVCStringList@@@Z ; CFileUtil::getFieldList
PUBLIC	?fileToFieldRecord@CFileUtil@@SA_NPADPAV?$CTList@VCStringList@@@@D@Z ; CFileUtil::fileToFieldRecord
PUBLIC	?add@CFileUtil@@SA_NPAD0@Z			; CFileUtil::add
PUBLIC	?getReFileName@CFileUtil@@SA_NPADPBD1@Z		; CFileUtil::getReFileName
PUBLIC	?renameFile@CFileUtil@@SA_NPBD0@Z		; CFileUtil::renameFile
PUBLIC	?getFileSize@CFileUtil@@SAHPAD@Z		; CFileUtil::getFileSize
PUBLIC	?tryopen@CFileUtil@@SAPAU_iobuf@@HPADPBDPAH@Z	; CFileUtil::tryopen
PUBLIC	?modify@CFileUtil@@SA_NPADH0@Z			; CFileUtil::modify
PUBLIC	?getFileSize2@CFileUtil@@SAHPADHPAHH@Z		; CFileUtil::getFileSize2
PUBLIC	?readLoop@CFileUtil@@SAHPADHHPAUSTFileMem@@H@Z	; CFileUtil::readLoop
PUBLIC	?nextReadLoop@CFileUtil@@SAHPADHHPAUSTFileMem@@HH@Z ; CFileUtil::nextReadLoop
PUBLIC	?nextRead@CFileUtil@@SAHPAD0HH@Z		; CFileUtil::nextRead
PUBLIC	?modify@CFileUtil@@SA_NPADHPAUSTFileMem@@@Z	; CFileUtil::modify
PUBLIC	?add@CFileUtil@@SA_NPADHPAUSTFileMem@@@Z	; CFileUtil::add
PUBLIC	?ehstrstr@CFileUtil@@SAPADPBD0@Z		; CFileUtil::ehstrstr
PUBLIC	?appendFileList@CFileUtil@@CA_NPAV?$CTList@UfileInfo@@@@PBDD@Z ; CFileUtil::appendFileList
PUBLIC	?CheckDirName@@YAXPAD@Z				; CheckDirName
PUBLIC	??0?$CTList@UfileInfo@@@@QAE@XZ			; CTList<fileInfo>::CTList<fileInfo>
PUBLIC	?alloc@?$CTList@UfileInfo@@@@QAEHHW4E_ALLOC_TYPE@@@Z ; CTList<fileInfo>::alloc
PUBLIC	?push_back@?$CTList@UfileInfo@@@@QAE_NPAUfileInfo@@PAH@Z ; CTList<fileInfo>::push_back
PUBLIC	?size@?$CTList@UfileInfo@@@@QAEHXZ		; CTList<fileInfo>::size
PUBLIC	?__alloc@?$CTList@UfileInfo@@@@AAEHH@Z		; CTList<fileInfo>::__alloc
PUBLIC	?__autoclassinit2@?$CTList@UfileInfo@@@@QAEXI@Z	; CTList<fileInfo>::__autoclassinit2
PUBLIC	?push_back@?$CTList@VCStringList@@@@QAE_NPAVCStringList@@PAH@Z ; CTList<CStringList>::push_back
PUBLIC	?getNext@?$CTList@VCStringList@@@@QAEPAVCStringList@@PAH@Z ; CTList<CStringList>::getNext
PUBLIC	?__alloc@?$CTList@VCStringList@@@@AAEHH@Z	; CTList<CStringList>::__alloc
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fflush:PROC
EXTRN	__imp__fopen:PROC
EXTRN	__imp__fread:PROC
EXTRN	__imp__fseek:PROC
EXTRN	__imp__ftell:PROC
EXTRN	__imp__fwrite:PROC
EXTRN	__imp__remove:PROC
EXTRN	__imp__rename:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	__imp___errno:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__strchr:PROC
EXTRN	_strcmp:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__calloc:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp___mbschr:PROC
EXTRN	__imp___mbscmp:PROC
EXTRN	__imp___mbsnbcpy:PROC
EXTRN	__imp___mbsrchr:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__FindClose@4:PROC
EXTRN	__imp__CreateDirectoryA@8:PROC
EXTRN	__imp__RemoveDirectoryA@4:PROC
EXTRN	__imp__GetFileAttributesA@4:PROC
EXTRN	__imp__FindFirstFileA@8:PROC
EXTRN	__imp__FindNextFileA@8:PROC
EXTRN	__imp__MoveFileA@8:PROC
EXTRN	??2@YAPAXIABUnothrow_t@std@@@Z:PROC		; operator new
EXTRN	??3@YAXPAXABUnothrow_t@std@@@Z:PROC		; operator delete
EXTRN	??0CFileTime@@QAE@XZ:PROC			; CFileTime::CFileTime
EXTRN	??1CFileTime@@QAE@XZ:PROC			; CFileTime::~CFileTime
EXTRN	?setFileTime@CFileTime@@QAEHPAU_FILETIME@@@Z:PROC ; CFileTime::setFileTime
EXTRN	?isCompare@CFileTime@@QAE_NPAV1@W4E_OPERATOR@@@Z:PROC ; CFileTime::isCompare
EXTRN	?delBufByIndex@CMemManager@@QAEXPADH@Z:PROC	; CMemManager::delBufByIndex
EXTRN	?__newBuf@CMemManager@@AAEPADHI@Z:PROC		; CMemManager::__newBuf
EXTRN	?PutLogQueue@CLogger@@QAAXHPBDZZ:PROC		; CLogger::PutLogQueue
EXTRN	?__debugLog@CLogger@@QAAXHPBDH0ZZ:PROC		; CLogger::__debugLog
EXTRN	?compare@CmString@@QAEHPBD@Z:PROC		; CmString::compare
EXTRN	??0CStringList@@QAE@XZ:PROC			; CStringList::CStringList
EXTRN	??1CStringList@@QAE@XZ:PROC			; CStringList::~CStringList
EXTRN	?__alloc@CStringList@@AAEHH@Z:PROC		; CStringList::__alloc
EXTRN	?__add@CStringList@@AAEPAVCmString@@PADH@Z:PROC	; CStringList::__add
EXTRN	?newIdx@CStringList@@AAEHXZ:PROC		; CStringList::newIdx
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__chkstk:PROC
EXTRN	_memset:PROC
EXTRN	?nothrow@std@@3Unothrow_t@1@B:BYTE		; std::nothrow
EXTRN	?g_szMessage@@3PADA:BYTE			; g_szMessage
EXTRN	?gs_pMMgr@@3PAVCMemManager@@A:DWORD		; gs_pMMgr
EXTRN	?gs_cLogger@@3VCLogger@@A:BYTE			; gs_cLogger
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
xdata$x	SEGMENT
__unwindtable$?appendFileList@CFileUtil@@CA_NPAV?$CTList@UfileInfo@@@@PBDD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?appendFileList@CFileUtil@@CA_NPAV?$CTList@UfileInfo@@@@PBDD@Z$0
__unwindtable$?fileToFieldRecord@CFileUtil@@SA_NPADPAV?$CTList@VCStringList@@@@D@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?fileToFieldRecord@CFileUtil@@SA_NPADPAV?$CTList@VCStringList@@@@D@Z$7
__unwindtable$?delDirectory@CFileUtil@@SAHPAUSTDelInfo@@PAUSTFilterData@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?delDirectory@CFileUtil@@SAHPAUSTDelInfo@@PAUSTFilterData@@@Z$0
__unwindtable$?filter_stringCompare@@YA_NPADPAX1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?filter_stringCompare@@YA_NPADPAX1@Z$0
__ehfuncinfo$?appendFileList@CFileUtil@@CA_NPAV?$CTList@UfileInfo@@@@PBDD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?appendFileList@CFileUtil@@CA_NPAV?$CTList@UfileInfo@@@@PBDD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?fileToFieldRecord@CFileUtil@@SA_NPADPAV?$CTList@VCStringList@@@@D@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?fileToFieldRecord@CFileUtil@@SA_NPADPAV?$CTList@VCStringList@@@@D@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?delDirectory@CFileUtil@@SAHPAUSTDelInfo@@PAUSTFilterData@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?delDirectory@CFileUtil@@SAHPAUSTDelInfo@@PAUSTFilterData@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?filter_stringCompare@@YA_NPADPAX1@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?filter_stringCompare@@YA_NPADPAX1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?__alloc@?$CTList@VCStringList@@@@AAEHH@Z
_TEXT	SEGMENT
_pList$ = -8						; size = 4
_this$ = -4						; size = 4
_nMaxCount$ = 8						; size = 4
?__alloc@?$CTList@VCStringList@@@@AAEHH@Z PROC		; CTList<CStringList>::__alloc, COMDAT
; _this$ = ecx

; 402  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00015	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 403  : 	T** pList = (T**)calloc(nMaxCount, sizeof(T*));

  00018	8b f4		 mov	 esi, esp
  0001a	6a 04		 push	 4
  0001c	8b 45 08	 mov	 eax, DWORD PTR _nMaxCount$[ebp]
  0001f	50		 push	 eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  00026	83 c4 08	 add	 esp, 8
  00029	3b f4		 cmp	 esi, esp
  0002b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00030	89 45 f8	 mov	 DWORD PTR _pList$[ebp], eax

; 404  : 	if (!pList) {

  00033	83 7d f8 00	 cmp	 DWORD PTR _pList$[ebp], 0
  00037	75 16		 jne	 SHORT $LN2@alloc

; 405  : 		_stprintf(g_szMessage, "pList calloc is NULL");

  00039	68 00 00 00 00	 push	 OFFSET $SG87157
  0003e	68 00 00 00 00	 push	 OFFSET ?g_szMessage@@3PADA ; g_szMessage
  00043	e8 00 00 00 00	 call	 _sprintf
  00048	83 c4 08	 add	 esp, 8

; 406  : 		return 0;

  0004b	33 c0		 xor	 eax, eax
  0004d	eb 47		 jmp	 SHORT $LN1@alloc
$LN2@alloc:

; 407  : 	}
; 408  : 	//_stprintf(g_szMessage, _T("CTList::__alloc list m_nMaxCount[%d]"), nMaxCount);
; 409  : 	if (m_pArray) {

  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00055	74 34		 je	 SHORT $LN3@alloc

; 410  : 		memcpy(pList, m_pArray, m_nMax * sizeof(T*));

  00057	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0005a	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0005d	c1 e0 02	 shl	 eax, 2
  00060	50		 push	 eax
  00061	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	8b 11		 mov	 edx, DWORD PTR [ecx]
  00066	52		 push	 edx
  00067	8b 45 f8	 mov	 eax, DWORD PTR _pList$[ebp]
  0006a	50		 push	 eax
  0006b	e8 00 00 00 00	 call	 _memcpy
  00070	83 c4 0c	 add	 esp, 12			; 0000000cH

; 411  : 		free(m_pArray);

  00073	8b f4		 mov	 esi, esp
  00075	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007a	52		 push	 edx
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00081	83 c4 04	 add	 esp, 4
  00084	3b f4		 cmp	 esi, esp
  00086	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@alloc:

; 412  : 	}
; 413  : 	m_pArray = pList;

  0008b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0008e	8b 4d f8	 mov	 ecx, DWORD PTR _pList$[ebp]
  00091	89 08		 mov	 DWORD PTR [eax], ecx

; 414  : 	return nMaxCount;

  00093	8b 45 08	 mov	 eax, DWORD PTR _nMaxCount$[ebp]
$LN1@alloc:

; 415  : }

  00096	5e		 pop	 esi
  00097	83 c4 08	 add	 esp, 8
  0009a	3b ec		 cmp	 ebp, esp
  0009c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c2 04 00	 ret	 4
?__alloc@?$CTList@VCStringList@@@@AAEHH@Z ENDP		; CTList<CStringList>::__alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?getNext@?$CTList@VCStringList@@@@QAEPAVCStringList@@PAH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pIdx$ = 8						; size = 4
?getNext@?$CTList@VCStringList@@@@QAEPAVCStringList@@PAH@Z PROC ; CTList<CStringList>::getNext, COMDAT
; _this$ = ecx

; 334  : 	inline T* getNext(int *pIdx) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 335  : 		for (*pIdx; *pIdx < m_nMax; (*pIdx)++) {

  0000e	eb 0d		 jmp	 SHORT $LN4@getNext
$LN2@getNext:
  00010	8b 45 08	 mov	 eax, DWORD PTR _pIdx$[ebp]
  00013	8b 08		 mov	 ecx, DWORD PTR [eax]
  00015	83 c1 01	 add	 ecx, 1
  00018	8b 55 08	 mov	 edx, DWORD PTR _pIdx$[ebp]
  0001b	89 0a		 mov	 DWORD PTR [edx], ecx
$LN4@getNext:
  0001d	8b 45 08	 mov	 eax, DWORD PTR _pIdx$[ebp]
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 10		 mov	 edx, DWORD PTR [eax]
  00025	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  00028	7d 21		 jge	 SHORT $LN3@getNext

; 336  : 			if (m_pArray[*pIdx]) { return m_pArray[*pIdx]; }

  0002a	8b 45 08	 mov	 eax, DWORD PTR _pIdx$[ebp]
  0002d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00032	8b 02		 mov	 eax, DWORD PTR [edx]
  00034	83 3c 88 00	 cmp	 DWORD PTR [eax+ecx*4], 0
  00038	74 0f		 je	 SHORT $LN5@getNext
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR _pIdx$[ebp]
  0003d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 08		 mov	 ecx, DWORD PTR [eax]
  00044	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  00047	eb 04		 jmp	 SHORT $LN1@getNext
$LN5@getNext:

; 337  : 		}

  00049	eb c5		 jmp	 SHORT $LN2@getNext
$LN3@getNext:

; 338  : 		return NULL;

  0004b	33 c0		 xor	 eax, eax
$LN1@getNext:

; 339  : 	}

  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c2 04 00	 ret	 4
?getNext@?$CTList@VCStringList@@@@QAEPAVCStringList@@PAH@Z ENDP ; CTList<CStringList>::getNext
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?push_back@?$CTList@VCStringList@@@@QAE_NPAVCStringList@@PAH@Z
_TEXT	SEGMENT
_i$ = -12						; size = 4
_nIdx$ = -8						; size = 4
_this$ = -4						; size = 4
_Obj$ = 8						; size = 4
_pIdx$ = 12						; size = 4
?push_back@?$CTList@VCStringList@@@@QAE_NPAVCStringList@@PAH@Z PROC ; CTList<CStringList>::push_back, COMDAT
; _this$ = ecx

; 472  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 473  : 	int nIdx, i;
; 474  : 
; 475  : 	if (m_nUse >= m_nMax) {

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00027	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  0002a	7c 39		 jl	 SHORT $LN5@push_back

; 476  : 		if (!__alloc(m_nMax + TLIST_ADD_SIZE)) return false;

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00032	83 c1 40	 add	 ecx, 64			; 00000040H
  00035	51		 push	 ecx
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?__alloc@?$CTList@VCStringList@@@@AAEHH@Z ; CTList<CStringList>::__alloc
  0003e	85 c0		 test	 eax, eax
  00040	75 07		 jne	 SHORT $LN6@push_back
  00042	32 c0		 xor	 al, al
  00044	e9 cf 00 00 00	 jmp	 $LN1@push_back
$LN6@push_back:

; 477  : 		nIdx = m_nMax;

  00049	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004c	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0004f	89 45 f8	 mov	 DWORD PTR _nIdx$[ebp], eax

; 478  : 		m_nMax += TLIST_ADD_SIZE;

  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00058	83 c2 40	 add	 edx, 64			; 00000040H
  0005b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 479  : 		goto ADD_SUCCESS;

  00061	eb 79		 jmp	 SHORT $ADD_SUCCESS$15
  00063	eb 77		 jmp	 SHORT $ADD_SUCCESS$15
$LN5@push_back:

; 480  : 	}
; 481  : 
; 482  : 	if (!m_pArray[m_nLast]) { nIdx = m_nLast;  goto ADD_SUCCESS; }

  00065	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00070	83 3c 91 00	 cmp	 DWORD PTR [ecx+edx*4], 0
  00074	75 0d		 jne	 SHORT $LN8@push_back
  00076	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00079	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0007c	89 45 f8	 mov	 DWORD PTR _nIdx$[ebp], eax
  0007f	eb 5b		 jmp	 SHORT $ADD_SUCCESS$15
  00081	eb 59		 jmp	 SHORT $ADD_SUCCESS$15
$LN8@push_back:

; 483  : 
; 484  : 	nIdx = m_nLast;

  00083	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00089	89 55 f8	 mov	 DWORD PTR _nIdx$[ebp], edx

; 485  : 	for (i = 0; i < m_nMax; i++)

  0008c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00093	eb 09		 jmp	 SHORT $LN4@push_back
$LN2@push_back:
  00095	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00098	83 c0 01	 add	 eax, 1
  0009b	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN4@push_back:
  0009e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a1	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  000a4	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  000a7	7d 2f		 jge	 SHORT $LN3@push_back

; 486  : 	{
; 487  : 		if (nIdx >= m_nMax) nIdx = 0;

  000a9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ac	8b 4d f8	 mov	 ecx, DWORD PTR _nIdx$[ebp]
  000af	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  000b2	7c 07		 jl	 SHORT $LN10@push_back
  000b4	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _nIdx$[ebp], 0
$LN10@push_back:

; 488  : 		if (!m_pArray[nIdx]) {

  000bb	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000be	8b 02		 mov	 eax, DWORD PTR [edx]
  000c0	8b 4d f8	 mov	 ecx, DWORD PTR _nIdx$[ebp]
  000c3	83 3c 88 00	 cmp	 DWORD PTR [eax+ecx*4], 0
  000c7	75 04		 jne	 SHORT $LN11@push_back

; 489  : 			goto ADD_SUCCESS;

  000c9	eb 11		 jmp	 SHORT $ADD_SUCCESS$15
  000cb	eb 0f		 jmp	 SHORT $ADD_SUCCESS$15
$LN11@push_back:

; 490  : 		}
; 491  : 		nIdx++;

  000cd	8b 55 f8	 mov	 edx, DWORD PTR _nIdx$[ebp]
  000d0	83 c2 01	 add	 edx, 1
  000d3	89 55 f8	 mov	 DWORD PTR _nIdx$[ebp], edx

; 492  : 	}

  000d6	eb bd		 jmp	 SHORT $LN2@push_back
$LN3@push_back:

; 493  : 	//_stprintf(m_szMessage, _T("add FAIL! m_nLast[%d] m_nCurCount[%d] m_nMax[%d]"), m_nLast, m_nUse, m_nMax);
; 494  : 	return false;

  000d8	32 c0		 xor	 al, al
  000da	eb 3c		 jmp	 SHORT $LN1@push_back
$ADD_SUCCESS$15:

; 495  : 
; 496  : ADD_SUCCESS:
; 497  : 	m_nUse++;

  000dc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000df	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000e2	83 c1 01	 add	 ecx, 1
  000e5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000e8	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 498  : 	m_pArray[nIdx] = Obj;

  000eb	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ee	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f0	8b 55 f8	 mov	 edx, DWORD PTR _nIdx$[ebp]
  000f3	8b 45 08	 mov	 eax, DWORD PTR _Obj$[ebp]
  000f6	89 04 91	 mov	 DWORD PTR [ecx+edx*4], eax

; 499  : 	m_nLast++;

  000f9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000fc	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000ff	83 c2 01	 add	 edx, 1
  00102	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00105	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 500  : 	//_stprintf(g_szMessage, _T("CMemList::add i[%d] m_nLast[%d] m_nCurCount[%d]"), nIdx, m_nLast, m_nUse);
; 501  : 	if (pIdx) *pIdx = nIdx;

  00108	83 7d 0c 00	 cmp	 DWORD PTR _pIdx$[ebp], 0
  0010c	74 08		 je	 SHORT $LN13@push_back
  0010e	8b 4d 0c	 mov	 ecx, DWORD PTR _pIdx$[ebp]
  00111	8b 55 f8	 mov	 edx, DWORD PTR _nIdx$[ebp]
  00114	89 11		 mov	 DWORD PTR [ecx], edx
$LN13@push_back:

; 502  : 	return true;

  00116	b0 01		 mov	 al, 1
$LN1@push_back:

; 503  : }

  00118	83 c4 0c	 add	 esp, 12			; 0000000cH
  0011b	3b ec		 cmp	 ebp, esp
  0011d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00122	8b e5		 mov	 esp, ebp
  00124	5d		 pop	 ebp
  00125	c2 08 00	 ret	 8
?push_back@?$CTList@VCStringList@@@@QAE_NPAVCStringList@@PAH@Z ENDP ; CTList<CStringList>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?__autoclassinit2@?$CTList@UfileInfo@@@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$CTList@UfileInfo@@@@QAEXI@Z PROC	; CTList<fileInfo>::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR _classSize$[ebp]
  00011	50		 push	 eax
  00012	6a 00		 push	 0
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 _memset
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00020	83 c4 04	 add	 esp, 4
  00023	3b ec		 cmp	 ebp, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?__autoclassinit2@?$CTList@UfileInfo@@@@QAEXI@Z ENDP	; CTList<fileInfo>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?__alloc@?$CTList@UfileInfo@@@@AAEHH@Z
_TEXT	SEGMENT
_pList$ = -8						; size = 4
_this$ = -4						; size = 4
_nMaxCount$ = 8						; size = 4
?__alloc@?$CTList@UfileInfo@@@@AAEHH@Z PROC		; CTList<fileInfo>::__alloc, COMDAT
; _this$ = ecx

; 402  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00015	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 403  : 	T** pList = (T**)calloc(nMaxCount, sizeof(T*));

  00018	8b f4		 mov	 esi, esp
  0001a	6a 04		 push	 4
  0001c	8b 45 08	 mov	 eax, DWORD PTR _nMaxCount$[ebp]
  0001f	50		 push	 eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  00026	83 c4 08	 add	 esp, 8
  00029	3b f4		 cmp	 esi, esp
  0002b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00030	89 45 f8	 mov	 DWORD PTR _pList$[ebp], eax

; 404  : 	if (!pList) {

  00033	83 7d f8 00	 cmp	 DWORD PTR _pList$[ebp], 0
  00037	75 16		 jne	 SHORT $LN2@alloc

; 405  : 		_stprintf(g_szMessage, "pList calloc is NULL");

  00039	68 00 00 00 00	 push	 OFFSET $SG87124
  0003e	68 00 00 00 00	 push	 OFFSET ?g_szMessage@@3PADA ; g_szMessage
  00043	e8 00 00 00 00	 call	 _sprintf
  00048	83 c4 08	 add	 esp, 8

; 406  : 		return 0;

  0004b	33 c0		 xor	 eax, eax
  0004d	eb 47		 jmp	 SHORT $LN1@alloc
$LN2@alloc:

; 407  : 	}
; 408  : 	//_stprintf(g_szMessage, _T("CTList::__alloc list m_nMaxCount[%d]"), nMaxCount);
; 409  : 	if (m_pArray) {

  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00055	74 34		 je	 SHORT $LN3@alloc

; 410  : 		memcpy(pList, m_pArray, m_nMax * sizeof(T*));

  00057	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0005a	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0005d	c1 e0 02	 shl	 eax, 2
  00060	50		 push	 eax
  00061	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	8b 11		 mov	 edx, DWORD PTR [ecx]
  00066	52		 push	 edx
  00067	8b 45 f8	 mov	 eax, DWORD PTR _pList$[ebp]
  0006a	50		 push	 eax
  0006b	e8 00 00 00 00	 call	 _memcpy
  00070	83 c4 0c	 add	 esp, 12			; 0000000cH

; 411  : 		free(m_pArray);

  00073	8b f4		 mov	 esi, esp
  00075	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007a	52		 push	 edx
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00081	83 c4 04	 add	 esp, 4
  00084	3b f4		 cmp	 esi, esp
  00086	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@alloc:

; 412  : 	}
; 413  : 	m_pArray = pList;

  0008b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0008e	8b 4d f8	 mov	 ecx, DWORD PTR _pList$[ebp]
  00091	89 08		 mov	 DWORD PTR [eax], ecx

; 414  : 	return nMaxCount;

  00093	8b 45 08	 mov	 eax, DWORD PTR _nMaxCount$[ebp]
$LN1@alloc:

; 415  : }

  00096	5e		 pop	 esi
  00097	83 c4 08	 add	 esp, 8
  0009a	3b ec		 cmp	 ebp, esp
  0009c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c2 04 00	 ret	 4
?__alloc@?$CTList@UfileInfo@@@@AAEHH@Z ENDP		; CTList<fileInfo>::__alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?size@?$CTList@UfileInfo@@@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$CTList@UfileInfo@@@@QAEHXZ PROC			; CTList<fileInfo>::size, COMDAT
; _this$ = ecx

; 347  : 	inline int  size() { return m_nUse; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?size@?$CTList@UfileInfo@@@@QAEHXZ ENDP			; CTList<fileInfo>::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?push_back@?$CTList@UfileInfo@@@@QAE_NPAUfileInfo@@PAH@Z
_TEXT	SEGMENT
_i$ = -12						; size = 4
_nIdx$ = -8						; size = 4
_this$ = -4						; size = 4
_Obj$ = 8						; size = 4
_pIdx$ = 12						; size = 4
?push_back@?$CTList@UfileInfo@@@@QAE_NPAUfileInfo@@PAH@Z PROC ; CTList<fileInfo>::push_back, COMDAT
; _this$ = ecx

; 472  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 473  : 	int nIdx, i;
; 474  : 
; 475  : 	if (m_nUse >= m_nMax) {

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00027	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  0002a	7c 39		 jl	 SHORT $LN5@push_back

; 476  : 		if (!__alloc(m_nMax + TLIST_ADD_SIZE)) return false;

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00032	83 c1 40	 add	 ecx, 64			; 00000040H
  00035	51		 push	 ecx
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?__alloc@?$CTList@UfileInfo@@@@AAEHH@Z ; CTList<fileInfo>::__alloc
  0003e	85 c0		 test	 eax, eax
  00040	75 07		 jne	 SHORT $LN6@push_back
  00042	32 c0		 xor	 al, al
  00044	e9 cf 00 00 00	 jmp	 $LN1@push_back
$LN6@push_back:

; 477  : 		nIdx = m_nMax;

  00049	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004c	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0004f	89 45 f8	 mov	 DWORD PTR _nIdx$[ebp], eax

; 478  : 		m_nMax += TLIST_ADD_SIZE;

  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00058	83 c2 40	 add	 edx, 64			; 00000040H
  0005b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 479  : 		goto ADD_SUCCESS;

  00061	eb 79		 jmp	 SHORT $ADD_SUCCESS$15
  00063	eb 77		 jmp	 SHORT $ADD_SUCCESS$15
$LN5@push_back:

; 480  : 	}
; 481  : 
; 482  : 	if (!m_pArray[m_nLast]) { nIdx = m_nLast;  goto ADD_SUCCESS; }

  00065	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00070	83 3c 91 00	 cmp	 DWORD PTR [ecx+edx*4], 0
  00074	75 0d		 jne	 SHORT $LN8@push_back
  00076	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00079	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0007c	89 45 f8	 mov	 DWORD PTR _nIdx$[ebp], eax
  0007f	eb 5b		 jmp	 SHORT $ADD_SUCCESS$15
  00081	eb 59		 jmp	 SHORT $ADD_SUCCESS$15
$LN8@push_back:

; 483  : 
; 484  : 	nIdx = m_nLast;

  00083	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00089	89 55 f8	 mov	 DWORD PTR _nIdx$[ebp], edx

; 485  : 	for (i = 0; i < m_nMax; i++)

  0008c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00093	eb 09		 jmp	 SHORT $LN4@push_back
$LN2@push_back:
  00095	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00098	83 c0 01	 add	 eax, 1
  0009b	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN4@push_back:
  0009e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a1	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  000a4	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  000a7	7d 2f		 jge	 SHORT $LN3@push_back

; 486  : 	{
; 487  : 		if (nIdx >= m_nMax) nIdx = 0;

  000a9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ac	8b 4d f8	 mov	 ecx, DWORD PTR _nIdx$[ebp]
  000af	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  000b2	7c 07		 jl	 SHORT $LN10@push_back
  000b4	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _nIdx$[ebp], 0
$LN10@push_back:

; 488  : 		if (!m_pArray[nIdx]) {

  000bb	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000be	8b 02		 mov	 eax, DWORD PTR [edx]
  000c0	8b 4d f8	 mov	 ecx, DWORD PTR _nIdx$[ebp]
  000c3	83 3c 88 00	 cmp	 DWORD PTR [eax+ecx*4], 0
  000c7	75 04		 jne	 SHORT $LN11@push_back

; 489  : 			goto ADD_SUCCESS;

  000c9	eb 11		 jmp	 SHORT $ADD_SUCCESS$15
  000cb	eb 0f		 jmp	 SHORT $ADD_SUCCESS$15
$LN11@push_back:

; 490  : 		}
; 491  : 		nIdx++;

  000cd	8b 55 f8	 mov	 edx, DWORD PTR _nIdx$[ebp]
  000d0	83 c2 01	 add	 edx, 1
  000d3	89 55 f8	 mov	 DWORD PTR _nIdx$[ebp], edx

; 492  : 	}

  000d6	eb bd		 jmp	 SHORT $LN2@push_back
$LN3@push_back:

; 493  : 	//_stprintf(m_szMessage, _T("add FAIL! m_nLast[%d] m_nCurCount[%d] m_nMax[%d]"), m_nLast, m_nUse, m_nMax);
; 494  : 	return false;

  000d8	32 c0		 xor	 al, al
  000da	eb 3c		 jmp	 SHORT $LN1@push_back
$ADD_SUCCESS$15:

; 495  : 
; 496  : ADD_SUCCESS:
; 497  : 	m_nUse++;

  000dc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000df	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000e2	83 c1 01	 add	 ecx, 1
  000e5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000e8	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 498  : 	m_pArray[nIdx] = Obj;

  000eb	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ee	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f0	8b 55 f8	 mov	 edx, DWORD PTR _nIdx$[ebp]
  000f3	8b 45 08	 mov	 eax, DWORD PTR _Obj$[ebp]
  000f6	89 04 91	 mov	 DWORD PTR [ecx+edx*4], eax

; 499  : 	m_nLast++;

  000f9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000fc	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000ff	83 c2 01	 add	 edx, 1
  00102	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00105	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 500  : 	//_stprintf(g_szMessage, _T("CMemList::add i[%d] m_nLast[%d] m_nCurCount[%d]"), nIdx, m_nLast, m_nUse);
; 501  : 	if (pIdx) *pIdx = nIdx;

  00108	83 7d 0c 00	 cmp	 DWORD PTR _pIdx$[ebp], 0
  0010c	74 08		 je	 SHORT $LN13@push_back
  0010e	8b 4d 0c	 mov	 ecx, DWORD PTR _pIdx$[ebp]
  00111	8b 55 f8	 mov	 edx, DWORD PTR _nIdx$[ebp]
  00114	89 11		 mov	 DWORD PTR [ecx], edx
$LN13@push_back:

; 502  : 	return true;

  00116	b0 01		 mov	 al, 1
$LN1@push_back:

; 503  : }

  00118	83 c4 0c	 add	 esp, 12			; 0000000cH
  0011b	3b ec		 cmp	 ebp, esp
  0011d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00122	8b e5		 mov	 esp, ebp
  00124	5d		 pop	 ebp
  00125	c2 08 00	 ret	 8
?push_back@?$CTList@UfileInfo@@@@QAE_NPAUfileInfo@@PAH@Z ENDP ; CTList<fileInfo>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ?alloc@?$CTList@UfileInfo@@@@QAEHHW4E_ALLOC_TYPE@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nMaxCount$ = 8						; size = 4
_type$ = 12						; size = 4
?alloc@?$CTList@UfileInfo@@@@QAEHHW4E_ALLOC_TYPE@@@Z PROC ; CTList<fileInfo>::alloc, COMDAT
; _this$ = ecx

; 326  : 	int alloc(int nMaxCount, E_ALLOC_TYPE type = eAlloc_Type_new) { m_nObjAllocType = type;  m_nMax = __alloc(nMaxCount); return m_nMax; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 4d 0c	 mov	 ecx, DWORD PTR _type$[ebp]
  00014	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR _nMaxCount$[ebp]
  0001a	52		 push	 edx
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?__alloc@?$CTList@UfileInfo@@@@AAEHH@Z ; CTList<fileInfo>::__alloc
  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  00029	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002c	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b ec		 cmp	 ebp, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
?alloc@?$CTList@UfileInfo@@@@QAEHHW4E_ALLOC_TYPE@@@Z ENDP ; CTList<fileInfo>::alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\comtlist.h
;	COMDAT ??0?$CTList@UfileInfo@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CTList@UfileInfo@@@@QAE@XZ PROC			; CTList<fileInfo>::CTList<fileInfo>, COMDAT
; _this$ = ecx

; 365  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 366  : 	m_pArray = NULL;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 367  : 	m_nUse = 0;

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 368  : 	m_nLast = 0;

  00021	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00024	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 369  : 	m_nDelIdx = 0;

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 370  : 	m_nMax = 0;

  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 371  : 	m_nObjAllocType = eAlloc_Type_none;

  0003f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00042	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0

; 372  : }

  00049	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
??0?$CTList@UfileInfo@@@@QAE@XZ ENDP			; CTList<fileInfo>::CTList<fileInfo>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
_TEXT	SEGMENT
_toChar$ = -2						; size = 1
_fromChar$ = -1						; size = 1
_dirName$ = 8						; size = 4
?CheckDirName@@YAXPAD@Z PROC				; CheckDirName

; 61   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 62   : #ifndef WIN32
; 63   : 	TCHAR	fromChar = '\\';
; 64   : 	TCHAR	toChar = '/';
; 65   : #else
; 66   : 	TCHAR	fromChar = '/';

  0000b	c6 45 ff 2f	 mov	 BYTE PTR _fromChar$[ebp], 47 ; 0000002fH

; 67   : 	TCHAR	toChar = '\\';

  0000f	c6 45 fe 5c	 mov	 BYTE PTR _toChar$[ebp], 92 ; 0000005cH
$LN2@CheckDirNa:

; 68   : #endif
; 69   : 
; 70   : 	while (dirName && *dirName)

  00013	83 7d 08 00	 cmp	 DWORD PTR _dirName$[ebp], 0
  00017	74 2b		 je	 SHORT $LN1@CheckDirNa
  00019	8b 45 08	 mov	 eax, DWORD PTR _dirName$[ebp]
  0001c	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0001f	85 c9		 test	 ecx, ecx
  00021	74 21		 je	 SHORT $LN1@CheckDirNa

; 71   : 	{
; 72   : 		if (*dirName == fromChar)

  00023	8b 55 08	 mov	 edx, DWORD PTR _dirName$[ebp]
  00026	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00029	0f be 4d ff	 movsx	 ecx, BYTE PTR _fromChar$[ebp]
  0002d	3b c1		 cmp	 eax, ecx
  0002f	75 08		 jne	 SHORT $LN4@CheckDirNa

; 73   : 			*dirName = toChar;

  00031	8b 55 08	 mov	 edx, DWORD PTR _dirName$[ebp]
  00034	8a 45 fe	 mov	 al, BYTE PTR _toChar$[ebp]
  00037	88 02		 mov	 BYTE PTR [edx], al
$LN4@CheckDirNa:

; 74   : 		dirName++;

  00039	8b 4d 08	 mov	 ecx, DWORD PTR _dirName$[ebp]
  0003c	83 c1 01	 add	 ecx, 1
  0003f	89 4d 08	 mov	 DWORD PTR _dirName$[ebp], ecx

; 75   : 	}

  00042	eb cf		 jmp	 SHORT $LN2@CheckDirNa
$LN1@CheckDirNa:

; 76   : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?CheckDirName@@YAXPAD@Z ENDP				; CheckDirName
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
_TEXT	SEGMENT
tv78 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
_pInfo$ = -40						; size = 4
_nLen$ = -36						; size = 4
_i$ = -32						; size = 4
_nIdx$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_flist$ = 8						; size = 4
_fname$ = 12						; size = 4
_ftype$ = 16						; size = 1
?appendFileList@CFileUtil@@CA_NPAV?$CTList@UfileInfo@@@@PBDD@Z PROC ; CFileUtil::appendFileList

; 272  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?appendFileList@CFileUtil@@CA_NPAV?$CTList@UfileInfo@@@@PBDD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 28	 sub	 esp, 40			; 00000028H
  00014	57		 push	 edi
  00015	8d 7d cc	 lea	 edi, DWORD PTR [ebp-52]
  00018	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  0001d	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00022	f3 ab		 rep stosd
  00024	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00029	33 c5		 xor	 eax, ebp
  0002b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002e	50		 push	 eax
  0002f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00032	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 273  : 	if (!flist) {

  00038	83 7d 08 00	 cmp	 DWORD PTR _flist$[ebp], 0
  0003c	75 6f		 jne	 SHORT $LN2@appendFile

; 274  : 		flist = new CTList<fileInfo>();

  0003e	6a 18		 push	 24			; 00000018H
  00040	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00045	83 c4 04	 add	 esp, 4
  00048	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
  0004b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00052	83 7d d0 00	 cmp	 DWORD PTR $T2[ebp], 0
  00056	74 17		 je	 SHORT $LN8@appendFile
  00058	6a 18		 push	 24			; 00000018H
  0005a	8b 4d d0	 mov	 ecx, DWORD PTR $T2[ebp]
  0005d	e8 00 00 00 00	 call	 ?__autoclassinit2@?$CTList@UfileInfo@@@@QAEXI@Z
  00062	8b 4d d0	 mov	 ecx, DWORD PTR $T2[ebp]
  00065	e8 00 00 00 00	 call	 ??0?$CTList@UfileInfo@@@@QAE@XZ ; CTList<fileInfo>::CTList<fileInfo>
  0006a	89 45 cc	 mov	 DWORD PTR tv78[ebp], eax
  0006d	eb 07		 jmp	 SHORT $LN9@appendFile
$LN8@appendFile:
  0006f	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
$LN9@appendFile:
  00076	8b 45 cc	 mov	 eax, DWORD PTR tv78[ebp]
  00079	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0007c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00083	8b 4d d4	 mov	 ecx, DWORD PTR $T3[ebp]
  00086	89 4d 08	 mov	 DWORD PTR _flist$[ebp], ecx

; 275  : 		if (!flist) return false;

  00089	83 7d 08 00	 cmp	 DWORD PTR _flist$[ebp], 0
  0008d	75 07		 jne	 SHORT $LN3@appendFile
  0008f	32 c0		 xor	 al, al
  00091	e9 dd 00 00 00	 jmp	 $LN1@appendFile
$LN3@appendFile:

; 276  : 		if (!flist->alloc(UNIT_FILE_LIST, eAlloc_Type_BufPool)) return false;

  00096	6a 04		 push	 4
  00098	6a 40		 push	 64			; 00000040H
  0009a	8b 4d 08	 mov	 ecx, DWORD PTR _flist$[ebp]
  0009d	e8 00 00 00 00	 call	 ?alloc@?$CTList@UfileInfo@@@@QAEHHW4E_ALLOC_TYPE@@@Z ; CTList<fileInfo>::alloc
  000a2	85 c0		 test	 eax, eax
  000a4	75 07		 jne	 SHORT $LN2@appendFile
  000a6	32 c0		 xor	 al, al
  000a8	e9 c6 00 00 00	 jmp	 $LN1@appendFile
$LN2@appendFile:

; 277  : 	}
; 278  : 
; 279  : 	int nIdx, i = 0, nLen = sizeof(FileInfo);

  000ad	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000b4	c7 45 dc 08 00
	00 00		 mov	 DWORD PTR _nLen$[ebp], 8

; 280  : 	FileInfo *pInfo = (FileInfo *)gs_pMMgr->newBuf(nLen, &nIdx);

  000bb	8d 55 e8	 lea	 edx, DWORD PTR _nIdx$[ebp]
  000be	52		 push	 edx
  000bf	8b 45 dc	 mov	 eax, DWORD PTR _nLen$[ebp]
  000c2	50		 push	 eax
  000c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pMMgr@@3PAVCMemManager@@A ; gs_pMMgr
  000c9	e8 00 00 00 00	 call	 ?newBuf@CMemManager@@QAEPADHPAH@Z ; CMemManager::newBuf
  000ce	89 45 d8	 mov	 DWORD PTR _pInfo$[ebp], eax

; 281  : 
; 282  : 	pInfo->fname = gs_pMMgr->newBuf((int)_tcslen(fname) + 1);

  000d1	8b 4d 0c	 mov	 ecx, DWORD PTR _fname$[ebp]
  000d4	51		 push	 ecx
  000d5	e8 00 00 00 00	 call	 _strlen
  000da	83 c4 04	 add	 esp, 4
  000dd	83 c0 01	 add	 eax, 1
  000e0	50		 push	 eax
  000e1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pMMgr@@3PAVCMemManager@@A ; gs_pMMgr
  000e7	e8 00 00 00 00	 call	 ?newBuf@CMemManager@@QAEPADH@Z ; CMemManager::newBuf
  000ec	8b 55 d8	 mov	 edx, DWORD PTR _pInfo$[ebp]
  000ef	89 02		 mov	 DWORD PTR [edx], eax

; 283  : 	_tcscpy(pInfo->fname, fname);

  000f1	8b 45 0c	 mov	 eax, DWORD PTR _fname$[ebp]
  000f4	50		 push	 eax
  000f5	8b 4d d8	 mov	 ecx, DWORD PTR _pInfo$[ebp]
  000f8	8b 11		 mov	 edx, DWORD PTR [ecx]
  000fa	52		 push	 edx
  000fb	e8 00 00 00 00	 call	 _strcpy
  00100	83 c4 08	 add	 esp, 8

; 284  : 	pInfo->stat = ftype;

  00103	8b 45 d8	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00106	8a 4d 10	 mov	 cl, BYTE PTR _ftype$[ebp]
  00109	88 48 04	 mov	 BYTE PTR [eax+4], cl

; 285  : 
; 286  : 	// add
; 287  : 	if (flist->push_back(pInfo)) {

  0010c	6a 00		 push	 0
  0010e	8b 55 d8	 mov	 edx, DWORD PTR _pInfo$[ebp]
  00111	52		 push	 edx
  00112	8b 4d 08	 mov	 ecx, DWORD PTR _flist$[ebp]
  00115	e8 00 00 00 00	 call	 ?push_back@?$CTList@UfileInfo@@@@QAE_NPAUfileInfo@@PAH@Z ; CTList<fileInfo>::push_back
  0011a	0f b6 c0	 movzx	 eax, al
  0011d	85 c0		 test	 eax, eax
  0011f	74 29		 je	 SHORT $LN5@appendFile

; 288  : 		gs_cLogger.PutLogQueue(LEVEL_TRACE, _T("fname[%s] nCount[%d]"), pInfo->fname, flist->size());

  00121	8b 4d 08	 mov	 ecx, DWORD PTR _flist$[ebp]
  00124	e8 00 00 00 00	 call	 ?size@?$CTList@UfileInfo@@@@QAEHXZ ; CTList<fileInfo>::size
  00129	50		 push	 eax
  0012a	8b 4d d8	 mov	 ecx, DWORD PTR _pInfo$[ebp]
  0012d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0012f	52		 push	 edx
  00130	68 00 00 00 00	 push	 OFFSET $SG86577
  00135	6a 02		 push	 2
  00137	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  0013c	e8 00 00 00 00	 call	 ?PutLogQueue@CLogger@@QAAXHPBDZZ ; CLogger::PutLogQueue
  00141	83 c4 14	 add	 esp, 20			; 00000014H

; 289  : 		return true;

  00144	b0 01		 mov	 al, 1
  00146	eb 2b		 jmp	 SHORT $LN1@appendFile

; 290  : 	}
; 291  : 	else {

  00148	eb 29		 jmp	 SHORT $LN1@appendFile
$LN5@appendFile:

; 292  : 		gs_cLogger.DebugLog(LEVEL_ERROR, _T(" fname[%d] ftype[%d]"), fname, ftype);

  0014a	0f be 45 10	 movsx	 eax, BYTE PTR _ftype$[ebp]
  0014e	50		 push	 eax
  0014f	8b 4d 0c	 mov	 ecx, DWORD PTR _fname$[ebp]
  00152	51		 push	 ecx
  00153	68 00 00 00 00	 push	 OFFSET $SG86578
  00158	68 24 01 00 00	 push	 292			; 00000124H
  0015d	68 00 00 00 00	 push	 OFFSET $SG86579
  00162	6a 05		 push	 5
  00164	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  00169	e8 00 00 00 00	 call	 ?__debugLog@CLogger@@QAAXHPBDH0ZZ ; CLogger::__debugLog
  0016e	83 c4 1c	 add	 esp, 28			; 0000001cH

; 293  : 		return false;

  00171	32 c0		 xor	 al, al
$LN1@appendFile:

; 294  : 	}
; 295  : }

  00173	52		 push	 edx
  00174	8b cd		 mov	 ecx, ebp
  00176	50		 push	 eax
  00177	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN14@appendFile
  0017d	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00182	58		 pop	 eax
  00183	5a		 pop	 edx
  00184	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00187	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0018e	59		 pop	 ecx
  0018f	5f		 pop	 edi
  00190	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00193	33 cd		 xor	 ecx, ebp
  00195	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0019a	83 c4 34	 add	 esp, 52			; 00000034H
  0019d	3b ec		 cmp	 ebp, esp
  0019f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001a4	8b e5		 mov	 esp, ebp
  001a6	5d		 pop	 ebp
  001a7	c3		 ret	 0
$LN14@appendFile:
  001a8	01 00 00 00	 DD	 1
  001ac	00 00 00 00	 DD	 $LN13@appendFile
$LN13@appendFile:
  001b0	e8 ff ff ff	 DD	 -24			; ffffffe8H
  001b4	04 00 00 00	 DD	 4
  001b8	00 00 00 00	 DD	 $LN11@appendFile
$LN11@appendFile:
  001bc	6e		 DB	 110			; 0000006eH
  001bd	49		 DB	 73			; 00000049H
  001be	64		 DB	 100			; 00000064H
  001bf	78		 DB	 120			; 00000078H
  001c0	00		 DB	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?appendFileList@CFileUtil@@CA_NPAV?$CTList@UfileInfo@@@@PBDD@Z$0:
  00000	6a 18		 push	 24			; 00000018H
  00002	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
__ehhandler$?appendFileList@CFileUtil@@CA_NPAV?$CTList@UfileInfo@@@@PBDD@Z:
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?appendFileList@CFileUtil@@CA_NPAV?$CTList@UfileInfo@@@@PBDD@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?appendFileList@CFileUtil@@CA_NPAV?$CTList@UfileInfo@@@@PBDD@Z ENDP ; CFileUtil::appendFileList
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
_TEXT	SEGMENT
tv76 = -24						; size = 4
tv75 = -20						; size = 4
tv74 = -16						; size = 4
_nLen$ = -12						; size = 4
_nIdx$ = -8						; size = 4
_pPos$ = -4						; size = 4
_pTarget$ = 8						; size = 4
_psubstr$ = 12						; size = 4
?ehstrstr@CFileUtil@@SAPADPBD0@Z PROC			; CFileUtil::ehstrstr

; 840  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0000e	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00011	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00014	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00017	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001a	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 841  : 	char *pPos = (char *)pTarget;

  0001d	8b 45 08	 mov	 eax, DWORD PTR _pTarget$[ebp]
  00020	89 45 fc	 mov	 DWORD PTR _pPos$[ebp], eax

; 842  : 	int nIdx=0, nLen= (int)strlen(psubstr);

  00023	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _nIdx$[ebp], 0
  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR _psubstr$[ebp]
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 _strlen
  00033	83 c4 04	 add	 esp, 4
  00036	89 45 f4	 mov	 DWORD PTR _nLen$[ebp], eax
$LN2@ehstrstr:

; 843  : 	while (*pPos) {

  00039	8b 55 fc	 mov	 edx, DWORD PTR _pPos$[ebp]
  0003c	0f be 02	 movsx	 eax, BYTE PTR [edx]
  0003f	85 c0		 test	 eax, eax
  00041	74 74		 je	 SHORT $LN3@ehstrstr
$LN4@ehstrstr:

; 844  : 		while (*pPos == psubstr[nIdx++]) {

  00043	8b 4d fc	 mov	 ecx, DWORD PTR _pPos$[ebp]
  00046	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00049	89 55 f0	 mov	 DWORD PTR tv74[ebp], edx
  0004c	8b 45 0c	 mov	 eax, DWORD PTR _psubstr$[ebp]
  0004f	03 45 f8	 add	 eax, DWORD PTR _nIdx$[ebp]
  00052	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00055	89 4d ec	 mov	 DWORD PTR tv75[ebp], ecx
  00058	8b 55 f8	 mov	 edx, DWORD PTR _nIdx$[ebp]
  0005b	83 c2 01	 add	 edx, 1
  0005e	89 55 f8	 mov	 DWORD PTR _nIdx$[ebp], edx
  00061	8b 45 f0	 mov	 eax, DWORD PTR tv74[ebp]
  00064	3b 45 ec	 cmp	 eax, DWORD PTR tv75[ebp]
  00067	75 09		 jne	 SHORT $LN9@ehstrstr
  00069	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  00070	eb 07		 jmp	 SHORT $LN10@ehstrstr
$LN9@ehstrstr:
  00072	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN10@ehstrstr:
  00079	83 7d e8 00	 cmp	 DWORD PTR tv76[ebp], 0
  0007d	74 26		 je	 SHORT $LN5@ehstrstr

; 845  : 			if (nIdx >= nLen) return pPos;

  0007f	8b 4d f8	 mov	 ecx, DWORD PTR _nIdx$[ebp]
  00082	3b 4d f4	 cmp	 ecx, DWORD PTR _nLen$[ebp]
  00085	7c 05		 jl	 SHORT $LN6@ehstrstr
  00087	8b 45 fc	 mov	 eax, DWORD PTR _pPos$[ebp]
  0008a	eb 2d		 jmp	 SHORT $LN1@ehstrstr
$LN6@ehstrstr:

; 846  : 			pPos++; if (!*pPos) return NULL;			

  0008c	8b 55 fc	 mov	 edx, DWORD PTR _pPos$[ebp]
  0008f	83 c2 01	 add	 edx, 1
  00092	89 55 fc	 mov	 DWORD PTR _pPos$[ebp], edx
  00095	8b 45 fc	 mov	 eax, DWORD PTR _pPos$[ebp]
  00098	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0009b	85 c9		 test	 ecx, ecx
  0009d	75 04		 jne	 SHORT $LN7@ehstrstr
  0009f	33 c0		 xor	 eax, eax
  000a1	eb 16		 jmp	 SHORT $LN1@ehstrstr
$LN7@ehstrstr:

; 847  : 		}

  000a3	eb 9e		 jmp	 SHORT $LN4@ehstrstr
$LN5@ehstrstr:

; 848  : 		nIdx = 0;

  000a5	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _nIdx$[ebp], 0

; 849  : 		pPos++;

  000ac	8b 55 fc	 mov	 edx, DWORD PTR _pPos$[ebp]
  000af	83 c2 01	 add	 edx, 1
  000b2	89 55 fc	 mov	 DWORD PTR _pPos$[ebp], edx

; 850  : 	}

  000b5	eb 82		 jmp	 SHORT $LN2@ehstrstr
$LN3@ehstrstr:

; 851  : 	return NULL;

  000b7	33 c0		 xor	 eax, eax
$LN1@ehstrstr:

; 852  : }

  000b9	83 c4 18	 add	 esp, 24			; 00000018H
  000bc	3b ec		 cmp	 ebp, esp
  000be	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c3	8b e5		 mov	 esp, ebp
  000c5	5d		 pop	 ebp
  000c6	c3		 ret	 0
?ehstrstr@CFileUtil@@SAPADPBD0@Z ENDP			; CFileUtil::ehstrstr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
_TEXT	SEGMENT
_pFile$ = -8						; size = 4
_i$ = -4						; size = 4
_pFilePath$ = 8						; size = 4
_nLoopCnt$ = 12						; size = 4
_pBuf$ = 16						; size = 4
?add@CFileUtil@@SA_NPADHPAUSTFileMem@@@Z PROC		; CFileUtil::add

; 813  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 814  : 	int i;
; 815  : 	FILE *pFile = _tfopen(pFilePath, _T("a+"));

  00015	8b f4		 mov	 esi, esp
  00017	68 00 00 00 00	 push	 OFFSET $SG86972
  0001c	8b 45 08	 mov	 eax, DWORD PTR _pFilePath$[ebp]
  0001f	50		 push	 eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00026	83 c4 08	 add	 esp, 8
  00029	3b f4		 cmp	 esi, esp
  0002b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00030	89 45 f8	 mov	 DWORD PTR _pFile$[ebp], eax

; 816  : 
; 817  : 	if (!pFile) {

  00033	83 7d f8 00	 cmp	 DWORD PTR _pFile$[ebp], 0
  00037	75 4c		 jne	 SHORT $LN5@add

; 818  : 
; 819  : 		CFileUtil::MakeDirectory(pFilePath);

  00039	8b 4d 08	 mov	 ecx, DWORD PTR _pFilePath$[ebp]
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 ?MakeDirectory@CFileUtil@@SA_NPBD@Z ; CFileUtil::MakeDirectory
  00042	83 c4 04	 add	 esp, 4

; 820  : 		pFile = _tfopen(pFilePath, _T("a+"));

  00045	8b f4		 mov	 esi, esp
  00047	68 00 00 00 00	 push	 OFFSET $SG86974
  0004c	8b 55 08	 mov	 edx, DWORD PTR _pFilePath$[ebp]
  0004f	52		 push	 edx
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00056	83 c4 08	 add	 esp, 8
  00059	3b f4		 cmp	 esi, esp
  0005b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00060	89 45 f8	 mov	 DWORD PTR _pFile$[ebp], eax

; 821  : 
; 822  : 		if (!pFile) {

  00063	83 7d f8 00	 cmp	 DWORD PTR _pFile$[ebp], 0
  00067	75 1c		 jne	 SHORT $LN5@add

; 823  : 			gs_cLogger.PutLogQueue(LEVEL_ERROR, _T("CDFSFile::add2 pFile open FAIL [%s]"), pFilePath);

  00069	8b 45 08	 mov	 eax, DWORD PTR _pFilePath$[ebp]
  0006c	50		 push	 eax
  0006d	68 00 00 00 00	 push	 OFFSET $SG86976
  00072	6a 05		 push	 5
  00074	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  00079	e8 00 00 00 00	 call	 ?PutLogQueue@CLogger@@QAAXHPBDZZ ; CLogger::PutLogQueue
  0007e	83 c4 10	 add	 esp, 16			; 00000010H

; 824  : 			return false;

  00081	32 c0		 xor	 al, al
  00083	eb 7f		 jmp	 SHORT $LN1@add
$LN5@add:

; 825  : 		}
; 826  : 	}
; 827  : 
; 828  : 	for (i = 0; i < nLoopCnt; i++) {

  00085	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0008c	eb 09		 jmp	 SHORT $LN4@add
$LN2@add:
  0008e	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00091	83 c1 01	 add	 ecx, 1
  00094	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$LN4@add:
  00097	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0009a	3b 55 0c	 cmp	 edx, DWORD PTR _nLoopCnt$[ebp]
  0009d	7d 37		 jge	 SHORT $LN3@add

; 829  : 		fwrite(pBuf[i].pBlock, g_nChSize, _tcslen(pBuf[i].pBlock), pFile);

  0009f	8b f4		 mov	 esi, esp
  000a1	8b 45 f8	 mov	 eax, DWORD PTR _pFile$[ebp]
  000a4	50		 push	 eax
  000a5	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000a8	8b 55 10	 mov	 edx, DWORD PTR _pBuf$[ebp]
  000ab	8b 04 ca	 mov	 eax, DWORD PTR [edx+ecx*8]
  000ae	50		 push	 eax
  000af	e8 00 00 00 00	 call	 _strlen
  000b4	83 c4 04	 add	 esp, 4
  000b7	50		 push	 eax
  000b8	6a 01		 push	 1
  000ba	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000bd	8b 55 10	 mov	 edx, DWORD PTR _pBuf$[ebp]
  000c0	8b 04 ca	 mov	 eax, DWORD PTR [edx+ecx*8]
  000c3	50		 push	 eax
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  000ca	83 c4 10	 add	 esp, 16			; 00000010H
  000cd	3b f4		 cmp	 esi, esp
  000cf	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 830  : 		//_ftprintf(pBackup, pBuf[i]);
; 831  : 	}

  000d4	eb b8		 jmp	 SHORT $LN2@add
$LN3@add:

; 832  : 	fflush(pFile);

  000d6	8b f4		 mov	 esi, esp
  000d8	8b 4d f8	 mov	 ecx, DWORD PTR _pFile$[ebp]
  000db	51		 push	 ecx
  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fflush
  000e2	83 c4 04	 add	 esp, 4
  000e5	3b f4		 cmp	 esi, esp
  000e7	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 833  : 	fclose(pFile);

  000ec	8b f4		 mov	 esi, esp
  000ee	8b 55 f8	 mov	 edx, DWORD PTR _pFile$[ebp]
  000f1	52		 push	 edx
  000f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  000f8	83 c4 04	 add	 esp, 4
  000fb	3b f4		 cmp	 esi, esp
  000fd	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 834  : 	return true;

  00102	b0 01		 mov	 al, 1
$LN1@add:

; 835  : 
; 836  : }

  00104	5e		 pop	 esi
  00105	83 c4 08	 add	 esp, 8
  00108	3b ec		 cmp	 ebp, esp
  0010a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0010f	8b e5		 mov	 esp, ebp
  00111	5d		 pop	 ebp
  00112	c3		 ret	 0
?add@CFileUtil@@SA_NPADHPAUSTFileMem@@@Z ENDP		; CFileUtil::add
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
_TEXT	SEGMENT
_pFile$ = -8						; size = 4
_i$ = -4						; size = 4
_pFilePath$ = 8						; size = 4
_nLoopCnt$ = 12						; size = 4
_pBuf$ = 16						; size = 4
?modify@CFileUtil@@SA_NPADHPAUSTFileMem@@@Z PROC	; CFileUtil::modify

; 789  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 790  : 	int i;
; 791  : 	FILE *pFile = _tfopen(pFilePath, _T("w"));

  00015	8b f4		 mov	 esi, esp
  00017	68 00 00 00 00	 push	 OFFSET $SG86957
  0001c	8b 45 08	 mov	 eax, DWORD PTR _pFilePath$[ebp]
  0001f	50		 push	 eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00026	83 c4 08	 add	 esp, 8
  00029	3b f4		 cmp	 esi, esp
  0002b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00030	89 45 f8	 mov	 DWORD PTR _pFile$[ebp], eax

; 792  : 
; 793  : 	if (!pFile) {

  00033	83 7d f8 00	 cmp	 DWORD PTR _pFile$[ebp], 0
  00037	75 4c		 jne	 SHORT $LN5@modify

; 794  : 
; 795  : 		CFileUtil::MakeDirectory(pFilePath);

  00039	8b 4d 08	 mov	 ecx, DWORD PTR _pFilePath$[ebp]
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 ?MakeDirectory@CFileUtil@@SA_NPBD@Z ; CFileUtil::MakeDirectory
  00042	83 c4 04	 add	 esp, 4

; 796  : 		pFile = _tfopen(pFilePath, _T("w"));

  00045	8b f4		 mov	 esi, esp
  00047	68 00 00 00 00	 push	 OFFSET $SG86959
  0004c	8b 55 08	 mov	 edx, DWORD PTR _pFilePath$[ebp]
  0004f	52		 push	 edx
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00056	83 c4 08	 add	 esp, 8
  00059	3b f4		 cmp	 esi, esp
  0005b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00060	89 45 f8	 mov	 DWORD PTR _pFile$[ebp], eax

; 797  : 
; 798  : 		if (!pFile) {

  00063	83 7d f8 00	 cmp	 DWORD PTR _pFile$[ebp], 0
  00067	75 1c		 jne	 SHORT $LN5@modify

; 799  : 			gs_cLogger.PutLogQueue(LEVEL_ERROR, _T("CDFSFile::modify pFile open FAIL [%s]"), pFilePath);

  00069	8b 45 08	 mov	 eax, DWORD PTR _pFilePath$[ebp]
  0006c	50		 push	 eax
  0006d	68 00 00 00 00	 push	 OFFSET $SG86961
  00072	6a 05		 push	 5
  00074	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  00079	e8 00 00 00 00	 call	 ?PutLogQueue@CLogger@@QAAXHPBDZZ ; CLogger::PutLogQueue
  0007e	83 c4 10	 add	 esp, 16			; 00000010H

; 800  : 			return false;

  00081	32 c0		 xor	 al, al
  00083	eb 7f		 jmp	 SHORT $LN1@modify
$LN5@modify:

; 801  : 		}
; 802  : 	}
; 803  : 
; 804  : 	for (i = 0; i < nLoopCnt; i++) {

  00085	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0008c	eb 09		 jmp	 SHORT $LN4@modify
$LN2@modify:
  0008e	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00091	83 c1 01	 add	 ecx, 1
  00094	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$LN4@modify:
  00097	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0009a	3b 55 0c	 cmp	 edx, DWORD PTR _nLoopCnt$[ebp]
  0009d	7d 37		 jge	 SHORT $LN3@modify

; 805  : 		fwrite(pBuf[i].pBlock, g_nChSize, _tcslen(pBuf[i].pBlock), pFile);

  0009f	8b f4		 mov	 esi, esp
  000a1	8b 45 f8	 mov	 eax, DWORD PTR _pFile$[ebp]
  000a4	50		 push	 eax
  000a5	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000a8	8b 55 10	 mov	 edx, DWORD PTR _pBuf$[ebp]
  000ab	8b 04 ca	 mov	 eax, DWORD PTR [edx+ecx*8]
  000ae	50		 push	 eax
  000af	e8 00 00 00 00	 call	 _strlen
  000b4	83 c4 04	 add	 esp, 4
  000b7	50		 push	 eax
  000b8	6a 01		 push	 1
  000ba	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000bd	8b 55 10	 mov	 edx, DWORD PTR _pBuf$[ebp]
  000c0	8b 04 ca	 mov	 eax, DWORD PTR [edx+ecx*8]
  000c3	50		 push	 eax
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  000ca	83 c4 10	 add	 esp, 16			; 00000010H
  000cd	3b f4		 cmp	 esi, esp
  000cf	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 806  : 		//_ftprintf(pBackup, pBuf[i]);
; 807  : 	}

  000d4	eb b8		 jmp	 SHORT $LN2@modify
$LN3@modify:

; 808  : 	fflush(pFile);

  000d6	8b f4		 mov	 esi, esp
  000d8	8b 4d f8	 mov	 ecx, DWORD PTR _pFile$[ebp]
  000db	51		 push	 ecx
  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fflush
  000e2	83 c4 04	 add	 esp, 4
  000e5	3b f4		 cmp	 esi, esp
  000e7	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 809  : 	fclose(pFile);

  000ec	8b f4		 mov	 esi, esp
  000ee	8b 55 f8	 mov	 edx, DWORD PTR _pFile$[ebp]
  000f1	52		 push	 edx
  000f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  000f8	83 c4 04	 add	 esp, 4
  000fb	3b f4		 cmp	 esi, esp
  000fd	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 810  : 	return true;

  00102	b0 01		 mov	 al, 1
$LN1@modify:

; 811  : }

  00104	5e		 pop	 esi
  00105	83 c4 08	 add	 esp, 8
  00108	3b ec		 cmp	 ebp, esp
  0010a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0010f	8b e5		 mov	 esp, ebp
  00111	5d		 pop	 ebp
  00112	c3		 ret	 0
?modify@CFileUtil@@SA_NPADHPAUSTFileMem@@@Z ENDP	; CFileUtil::modify
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
_TEXT	SEGMENT
_nSize$ = -8						; size = 4
_pFile$ = -4						; size = 4
_pFilePath$ = 8						; size = 4
_pBuf$ = 12						; size = 4
_nMaxBuf$ = 16						; size = 4
_nPos$ = 20						; size = 4
?nextRead@CFileUtil@@SAHPAD0HH@Z PROC			; CFileUtil::nextRead

; 772  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 773  : 	FILE *pFile = _tfopen(pFilePath, _T("rb"));

  00015	8b f4		 mov	 esi, esp
  00017	68 00 00 00 00	 push	 OFFSET $SG86944
  0001c	8b 45 08	 mov	 eax, DWORD PTR _pFilePath$[ebp]
  0001f	50		 push	 eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00026	83 c4 08	 add	 esp, 8
  00029	3b f4		 cmp	 esi, esp
  0002b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00030	89 45 fc	 mov	 DWORD PTR _pFile$[ebp], eax

; 774  : 	if (!pFile) {

  00033	83 7d fc 00	 cmp	 DWORD PTR _pFile$[ebp], 0
  00037	75 1c		 jne	 SHORT $LN2@nextRead

; 775  : 		gs_cLogger.PutLogQueue(LEVEL_ERROR, _T("CDFSFile::nextRead pFile open FAIL [%s]"), pFilePath);

  00039	8b 4d 08	 mov	 ecx, DWORD PTR _pFilePath$[ebp]
  0003c	51		 push	 ecx
  0003d	68 00 00 00 00	 push	 OFFSET $SG86946
  00042	6a 05		 push	 5
  00044	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  00049	e8 00 00 00 00	 call	 ?PutLogQueue@CLogger@@QAAXHPBDZZ ; CLogger::PutLogQueue
  0004e	83 c4 10	 add	 esp, 16			; 00000010H

; 776  : 		return 0;

  00051	33 c0		 xor	 eax, eax
  00053	eb 61		 jmp	 SHORT $LN1@nextRead
$LN2@nextRead:

; 777  : 	}
; 778  : 
; 779  : 	fseek(pFile, nPos*g_nChSize, SEEK_SET);

  00055	8b f4		 mov	 esi, esp
  00057	6a 00		 push	 0
  00059	8b 55 14	 mov	 edx, DWORD PTR _nPos$[ebp]
  0005c	52		 push	 edx
  0005d	8b 45 fc	 mov	 eax, DWORD PTR _pFile$[ebp]
  00060	50		 push	 eax
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006a	3b f4		 cmp	 esi, esp
  0006c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 780  : 
; 781  : 	int nSize = (int)fread(pBuf, g_nChSize, nMaxBuf, pFile);

  00071	8b f4		 mov	 esi, esp
  00073	8b 4d fc	 mov	 ecx, DWORD PTR _pFile$[ebp]
  00076	51		 push	 ecx
  00077	8b 55 10	 mov	 edx, DWORD PTR _nMaxBuf$[ebp]
  0007a	52		 push	 edx
  0007b	6a 01		 push	 1
  0007d	8b 45 0c	 mov	 eax, DWORD PTR _pBuf$[ebp]
  00080	50		 push	 eax
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  00087	83 c4 10	 add	 esp, 16			; 00000010H
  0008a	3b f4		 cmp	 esi, esp
  0008c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00091	89 45 f8	 mov	 DWORD PTR _nSize$[ebp], eax

; 782  : 	pBuf[nSize] = 0;

  00094	8b 4d 0c	 mov	 ecx, DWORD PTR _pBuf$[ebp]
  00097	03 4d f8	 add	 ecx, DWORD PTR _nSize$[ebp]
  0009a	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 783  : 	fclose(pFile);

  0009d	8b f4		 mov	 esi, esp
  0009f	8b 55 fc	 mov	 edx, DWORD PTR _pFile$[ebp]
  000a2	52		 push	 edx
  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  000a9	83 c4 04	 add	 esp, 4
  000ac	3b f4		 cmp	 esi, esp
  000ae	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 784  : 	return nSize;

  000b3	8b 45 f8	 mov	 eax, DWORD PTR _nSize$[ebp]
$LN1@nextRead:

; 785  : }

  000b6	5e		 pop	 esi
  000b7	83 c4 08	 add	 esp, 8
  000ba	3b ec		 cmp	 ebp, esp
  000bc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c3		 ret	 0
?nextRead@CFileUtil@@SAHPAD0HH@Z ENDP			; CFileUtil::nextRead
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
_TEXT	SEGMENT
_pFile$ = -20						; size = 4
_nReadSize$ = -16					; size = 4
_nEndSize$ = -12					; size = 4
_nTot$ = -8						; size = 4
_i$ = -4						; size = 4
_pFilePath$ = 8						; size = 4
_nLoopCnt$ = 12						; size = 4
_nMaxBuf$ = 16						; size = 4
_pMem$ = 20						; size = 4
_nPos$ = 24						; size = 4
_ntotSize$ = 28						; size = 4
?nextReadLoop@CFileUtil@@SAHPADHHPAUSTFileMem@@HH@Z PROC ; CFileUtil::nextReadLoop

; 733  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000f	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00012	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00015	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00018	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 734  : 	int i;
; 735  : 	int nTot = 0;

  0001b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _nTot$[ebp], 0

; 736  : 	int nEndSize;
; 737  : 	int nReadSize;
; 738  : 
; 739  : 	FILE *pFile;
; 740  : 	for (i = 0; i < 3; i++) {

  00022	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00029	eb 09		 jmp	 SHORT $LN4@nextReadLo
$LN2@nextReadLo:
  0002b	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0002e	83 c0 01	 add	 eax, 1
  00031	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@nextReadLo:
  00034	83 7d fc 03	 cmp	 DWORD PTR _i$[ebp], 3
  00038	7d 28		 jge	 SHORT $LN3@nextReadLo

; 741  : 		pFile = _tfopen(pFilePath, _T("rb"));

  0003a	8b f4		 mov	 esi, esp
  0003c	68 00 00 00 00	 push	 OFFSET $SG86929
  00041	8b 4d 08	 mov	 ecx, DWORD PTR _pFilePath$[ebp]
  00044	51		 push	 ecx
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  0004b	83 c4 08	 add	 esp, 8
  0004e	3b f4		 cmp	 esi, esp
  00050	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00055	89 45 ec	 mov	 DWORD PTR _pFile$[ebp], eax

; 742  : 		if (pFile) break;

  00058	83 7d ec 00	 cmp	 DWORD PTR _pFile$[ebp], 0
  0005c	74 02		 je	 SHORT $LN8@nextReadLo
  0005e	eb 02		 jmp	 SHORT $LN3@nextReadLo
$LN8@nextReadLo:

; 743  : 		//  
; 744  : 	}

  00060	eb c9		 jmp	 SHORT $LN2@nextReadLo
$LN3@nextReadLo:

; 745  : 	if (!pFile) {

  00062	83 7d ec 00	 cmp	 DWORD PTR _pFile$[ebp], 0
  00066	75 1f		 jne	 SHORT $LN9@nextReadLo

; 746  : 		gs_cLogger.PutLogQueue(LEVEL_ERROR, _T("CDFSFile::nextReadLoop pFile open FAIL [%s]"), pFilePath);

  00068	8b 55 08	 mov	 edx, DWORD PTR _pFilePath$[ebp]
  0006b	52		 push	 edx
  0006c	68 00 00 00 00	 push	 OFFSET $SG86932
  00071	6a 05		 push	 5
  00073	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  00078	e8 00 00 00 00	 call	 ?PutLogQueue@CLogger@@QAAXHPBDZZ ; CLogger::PutLogQueue
  0007d	83 c4 10	 add	 esp, 16			; 00000010H

; 747  : 		return 0;

  00080	33 c0		 xor	 eax, eax
  00082	e9 f5 00 00 00	 jmp	 $LN1@nextReadLo
$LN9@nextReadLo:

; 748  : 	}
; 749  : 
; 750  : 	fseek(pFile, nPos*g_nChSize, SEEK_SET);

  00087	8b f4		 mov	 esi, esp
  00089	6a 00		 push	 0
  0008b	8b 45 18	 mov	 eax, DWORD PTR _nPos$[ebp]
  0008e	50		 push	 eax
  0008f	8b 4d ec	 mov	 ecx, DWORD PTR _pFile$[ebp]
  00092	51		 push	 ecx
  00093	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  00099	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009c	3b f4		 cmp	 esi, esp
  0009e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 751  : 
; 752  : 	for (i = 0; i < nLoopCnt; i++) {

  000a3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000aa	eb 09		 jmp	 SHORT $LN7@nextReadLo
$LN5@nextReadLo:
  000ac	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000af	83 c2 01	 add	 edx, 1
  000b2	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$LN7@nextReadLo:
  000b5	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000b8	3b 45 0c	 cmp	 eax, DWORD PTR _nLoopCnt$[ebp]
  000bb	0f 8d a2 00 00
	00		 jge	 $LN6@nextReadLo

; 753  : 		if (i == nLoopCnt - 1) {

  000c1	8b 4d 0c	 mov	 ecx, DWORD PTR _nLoopCnt$[ebp]
  000c4	83 e9 01	 sub	 ecx, 1
  000c7	39 4d fc	 cmp	 DWORD PTR _i$[ebp], ecx
  000ca	75 4d		 jne	 SHORT $LN10@nextReadLo

; 754  : 			nEndSize = ntotSize - nTot;

  000cc	8b 55 1c	 mov	 edx, DWORD PTR _ntotSize$[ebp]
  000cf	2b 55 f8	 sub	 edx, DWORD PTR _nTot$[ebp]
  000d2	89 55 f4	 mov	 DWORD PTR _nEndSize$[ebp], edx

; 755  : 			nReadSize = (int)fread(pMem[i].pBlock, g_nChSize, nEndSize, pFile);

  000d5	8b f4		 mov	 esi, esp
  000d7	8b 45 ec	 mov	 eax, DWORD PTR _pFile$[ebp]
  000da	50		 push	 eax
  000db	8b 4d f4	 mov	 ecx, DWORD PTR _nEndSize$[ebp]
  000de	51		 push	 ecx
  000df	6a 01		 push	 1
  000e1	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000e4	8b 45 14	 mov	 eax, DWORD PTR _pMem$[ebp]
  000e7	8b 0c d0	 mov	 ecx, DWORD PTR [eax+edx*8]
  000ea	51		 push	 ecx
  000eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  000f1	83 c4 10	 add	 esp, 16			; 00000010H
  000f4	3b f4		 cmp	 esi, esp
  000f6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000fb	89 45 f0	 mov	 DWORD PTR _nReadSize$[ebp], eax

; 756  : 			nTot += nReadSize;

  000fe	8b 55 f8	 mov	 edx, DWORD PTR _nTot$[ebp]
  00101	03 55 f0	 add	 edx, DWORD PTR _nReadSize$[ebp]
  00104	89 55 f8	 mov	 DWORD PTR _nTot$[ebp], edx

; 757  : 			pMem[i].pBlock[nReadSize] = 0;

  00107	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0010a	8b 4d 14	 mov	 ecx, DWORD PTR _pMem$[ebp]
  0010d	8b 14 c1	 mov	 edx, DWORD PTR [ecx+eax*8]
  00110	8b 45 f0	 mov	 eax, DWORD PTR _nReadSize$[ebp]
  00113	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0

; 758  : 		}
; 759  : 		else {

  00117	eb 45		 jmp	 SHORT $LN11@nextReadLo
$LN10@nextReadLo:

; 760  : 			nReadSize = (int)fread(pMem[i].pBlock, g_nChSize, nMaxBuf - 1, pFile);

  00119	8b f4		 mov	 esi, esp
  0011b	8b 4d ec	 mov	 ecx, DWORD PTR _pFile$[ebp]
  0011e	51		 push	 ecx
  0011f	8b 55 10	 mov	 edx, DWORD PTR _nMaxBuf$[ebp]
  00122	83 ea 01	 sub	 edx, 1
  00125	52		 push	 edx
  00126	6a 01		 push	 1
  00128	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0012b	8b 4d 14	 mov	 ecx, DWORD PTR _pMem$[ebp]
  0012e	8b 14 c1	 mov	 edx, DWORD PTR [ecx+eax*8]
  00131	52		 push	 edx
  00132	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  00138	83 c4 10	 add	 esp, 16			; 00000010H
  0013b	3b f4		 cmp	 esi, esp
  0013d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00142	89 45 f0	 mov	 DWORD PTR _nReadSize$[ebp], eax

; 761  : 			nTot += nReadSize;

  00145	8b 45 f8	 mov	 eax, DWORD PTR _nTot$[ebp]
  00148	03 45 f0	 add	 eax, DWORD PTR _nReadSize$[ebp]
  0014b	89 45 f8	 mov	 DWORD PTR _nTot$[ebp], eax

; 762  : 			pMem[i].pBlock[nReadSize] = 0;

  0014e	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00151	8b 55 14	 mov	 edx, DWORD PTR _pMem$[ebp]
  00154	8b 04 ca	 mov	 eax, DWORD PTR [edx+ecx*8]
  00157	8b 4d f0	 mov	 ecx, DWORD PTR _nReadSize$[ebp]
  0015a	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0
$LN11@nextReadLo:

; 763  : 		}
; 764  : 	}

  0015e	e9 49 ff ff ff	 jmp	 $LN5@nextReadLo
$LN6@nextReadLo:

; 765  : 	fclose(pFile);

  00163	8b f4		 mov	 esi, esp
  00165	8b 55 ec	 mov	 edx, DWORD PTR _pFile$[ebp]
  00168	52		 push	 edx
  00169	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  0016f	83 c4 04	 add	 esp, 4
  00172	3b f4		 cmp	 esi, esp
  00174	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 766  : 
; 767  : 	return nTot;

  00179	8b 45 f8	 mov	 eax, DWORD PTR _nTot$[ebp]
$LN1@nextReadLo:

; 768  : }

  0017c	5e		 pop	 esi
  0017d	83 c4 14	 add	 esp, 20			; 00000014H
  00180	3b ec		 cmp	 ebp, esp
  00182	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00187	8b e5		 mov	 esp, ebp
  00189	5d		 pop	 ebp
  0018a	c3		 ret	 0
?nextReadLoop@CFileUtil@@SAHPADHHPAUSTFileMem@@HH@Z ENDP ; CFileUtil::nextReadLoop
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
_TEXT	SEGMENT
_pFile$ = -20						; size = 4
_nReadSize$ = -16					; size = 4
_nEndSize$ = -12					; size = 4
_nTot$ = -8						; size = 4
_i$ = -4						; size = 4
_pFilePath$ = 8						; size = 4
_nLoopCnt$ = 12						; size = 4
_nMaxBuf$ = 16						; size = 4
_pMem$ = 20						; size = 4
_ntotSize$ = 24						; size = 4
?readLoop@CFileUtil@@SAHPADHHPAUSTFileMem@@H@Z PROC	; CFileUtil::readLoop

; 703  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000f	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00012	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00015	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00018	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 704  : 	int i;
; 705  : 	int nTot = 0, nEndSize;

  0001b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _nTot$[ebp], 0

; 706  : 	int nReadSize;
; 707  : 
; 708  : 	FILE *pFile;
; 709  : 	pFile = _tfopen(pFilePath, _T("rb"));

  00022	8b f4		 mov	 esi, esp
  00024	68 00 00 00 00	 push	 OFFSET $SG86903
  00029	8b 45 08	 mov	 eax, DWORD PTR _pFilePath$[ebp]
  0002c	50		 push	 eax
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00033	83 c4 08	 add	 esp, 8
  00036	3b f4		 cmp	 esi, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	89 45 ec	 mov	 DWORD PTR _pFile$[ebp], eax

; 710  : 	if (!pFile) {

  00040	83 7d ec 00	 cmp	 DWORD PTR _pFile$[ebp], 0
  00044	75 1f		 jne	 SHORT $LN5@readLoop

; 711  : 		gs_cLogger.PutLogQueue(LEVEL_ERROR, _T("CDFSFile::readLoop pFile open FAIL [%s]"), pFilePath);

  00046	8b 4d 08	 mov	 ecx, DWORD PTR _pFilePath$[ebp]
  00049	51		 push	 ecx
  0004a	68 00 00 00 00	 push	 OFFSET $SG86905
  0004f	6a 05		 push	 5
  00051	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  00056	e8 00 00 00 00	 call	 ?PutLogQueue@CLogger@@QAAXHPBDZZ ; CLogger::PutLogQueue
  0005b	83 c4 10	 add	 esp, 16			; 00000010H

; 712  : 		return 0;

  0005e	33 c0		 xor	 eax, eax
  00060	e9 d9 00 00 00	 jmp	 $LN1@readLoop
$LN5@readLoop:

; 713  : 	}
; 714  : 
; 715  : 	for (i = 0; i < nLoopCnt; i++) {

  00065	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0006c	eb 09		 jmp	 SHORT $LN4@readLoop
$LN2@readLoop:
  0006e	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00071	83 c2 01	 add	 edx, 1
  00074	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$LN4@readLoop:
  00077	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0007a	3b 45 0c	 cmp	 eax, DWORD PTR _nLoopCnt$[ebp]
  0007d	0f 8d a2 00 00
	00		 jge	 $LN3@readLoop

; 716  : 		if (i == nLoopCnt - 1) {

  00083	8b 4d 0c	 mov	 ecx, DWORD PTR _nLoopCnt$[ebp]
  00086	83 e9 01	 sub	 ecx, 1
  00089	39 4d fc	 cmp	 DWORD PTR _i$[ebp], ecx
  0008c	75 4d		 jne	 SHORT $LN6@readLoop

; 717  : 			nEndSize = ntotSize - nTot;

  0008e	8b 55 18	 mov	 edx, DWORD PTR _ntotSize$[ebp]
  00091	2b 55 f8	 sub	 edx, DWORD PTR _nTot$[ebp]
  00094	89 55 f4	 mov	 DWORD PTR _nEndSize$[ebp], edx

; 718  : 			nReadSize = (int)fread(pMem[i].pBlock, g_nChSize, nEndSize, pFile);

  00097	8b f4		 mov	 esi, esp
  00099	8b 45 ec	 mov	 eax, DWORD PTR _pFile$[ebp]
  0009c	50		 push	 eax
  0009d	8b 4d f4	 mov	 ecx, DWORD PTR _nEndSize$[ebp]
  000a0	51		 push	 ecx
  000a1	6a 01		 push	 1
  000a3	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000a6	8b 45 14	 mov	 eax, DWORD PTR _pMem$[ebp]
  000a9	8b 0c d0	 mov	 ecx, DWORD PTR [eax+edx*8]
  000ac	51		 push	 ecx
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  000b3	83 c4 10	 add	 esp, 16			; 00000010H
  000b6	3b f4		 cmp	 esi, esp
  000b8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bd	89 45 f0	 mov	 DWORD PTR _nReadSize$[ebp], eax

; 719  : 			nTot += nReadSize;

  000c0	8b 55 f8	 mov	 edx, DWORD PTR _nTot$[ebp]
  000c3	03 55 f0	 add	 edx, DWORD PTR _nReadSize$[ebp]
  000c6	89 55 f8	 mov	 DWORD PTR _nTot$[ebp], edx

; 720  : 			pMem[i].pBlock[nReadSize] = 0;

  000c9	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000cc	8b 4d 14	 mov	 ecx, DWORD PTR _pMem$[ebp]
  000cf	8b 14 c1	 mov	 edx, DWORD PTR [ecx+eax*8]
  000d2	8b 45 f0	 mov	 eax, DWORD PTR _nReadSize$[ebp]
  000d5	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0

; 721  : 		}
; 722  : 		else {

  000d9	eb 45		 jmp	 SHORT $LN7@readLoop
$LN6@readLoop:

; 723  : 			nReadSize = (int)fread(pMem[i].pBlock, g_nChSize, nMaxBuf - 1, pFile);

  000db	8b f4		 mov	 esi, esp
  000dd	8b 4d ec	 mov	 ecx, DWORD PTR _pFile$[ebp]
  000e0	51		 push	 ecx
  000e1	8b 55 10	 mov	 edx, DWORD PTR _nMaxBuf$[ebp]
  000e4	83 ea 01	 sub	 edx, 1
  000e7	52		 push	 edx
  000e8	6a 01		 push	 1
  000ea	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000ed	8b 4d 14	 mov	 ecx, DWORD PTR _pMem$[ebp]
  000f0	8b 14 c1	 mov	 edx, DWORD PTR [ecx+eax*8]
  000f3	52		 push	 edx
  000f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  000fa	83 c4 10	 add	 esp, 16			; 00000010H
  000fd	3b f4		 cmp	 esi, esp
  000ff	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00104	89 45 f0	 mov	 DWORD PTR _nReadSize$[ebp], eax

; 724  : 			nTot += nReadSize;

  00107	8b 45 f8	 mov	 eax, DWORD PTR _nTot$[ebp]
  0010a	03 45 f0	 add	 eax, DWORD PTR _nReadSize$[ebp]
  0010d	89 45 f8	 mov	 DWORD PTR _nTot$[ebp], eax

; 725  : 			pMem[i].pBlock[nReadSize] = 0;

  00110	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00113	8b 55 14	 mov	 edx, DWORD PTR _pMem$[ebp]
  00116	8b 04 ca	 mov	 eax, DWORD PTR [edx+ecx*8]
  00119	8b 4d f0	 mov	 ecx, DWORD PTR _nReadSize$[ebp]
  0011c	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0
$LN7@readLoop:

; 726  : 		}
; 727  : 	}

  00120	e9 49 ff ff ff	 jmp	 $LN2@readLoop
$LN3@readLoop:

; 728  : 	fclose(pFile);

  00125	8b f4		 mov	 esi, esp
  00127	8b 55 ec	 mov	 edx, DWORD PTR _pFile$[ebp]
  0012a	52		 push	 edx
  0012b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00131	83 c4 04	 add	 esp, 4
  00134	3b f4		 cmp	 esi, esp
  00136	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 729  : 	return nTot;

  0013b	8b 45 f8	 mov	 eax, DWORD PTR _nTot$[ebp]
$LN1@readLoop:

; 730  : }

  0013e	5e		 pop	 esi
  0013f	83 c4 14	 add	 esp, 20			; 00000014H
  00142	3b ec		 cmp	 ebp, esp
  00144	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00149	8b e5		 mov	 esp, ebp
  0014b	5d		 pop	 ebp
  0014c	c3		 ret	 0
?readLoop@CFileUtil@@SAHPADHHPAUSTFileMem@@H@Z ENDP	; CFileUtil::readLoop
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
_TEXT	SEGMENT
_pFile$ = -12						; size = 4
_nTotSize$ = -8						; size = 4
_i$ = -4						; size = 4
_pFilePath$ = 8						; size = 4
_nMaxBuf$ = 12						; size = 4
_pLoopLen$ = 16						; size = 4
_nPos$ = 20						; size = 4
?getFileSize2@CFileUtil@@SAHPADHPAHH@Z PROC		; CFileUtil::getFileSize2

; 676  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000e	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00015	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 677  : 	int i = 0;

  0001c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 678  : 	int nTotSize;
; 679  : 	FILE *pFile;
; 680  : 
; 681  : 	pFile = _tfopen(pFilePath, _T("r"));

  00023	8b f4		 mov	 esi, esp
  00025	68 00 00 00 00	 push	 OFFSET $SG86883
  0002a	8b 45 08	 mov	 eax, DWORD PTR _pFilePath$[ebp]
  0002d	50		 push	 eax
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00034	83 c4 08	 add	 esp, 8
  00037	3b f4		 cmp	 esi, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	89 45 f4	 mov	 DWORD PTR _pFile$[ebp], eax

; 682  : 	if (!pFile) {

  00041	83 7d f4 00	 cmp	 DWORD PTR _pFile$[ebp], 0
  00045	75 04		 jne	 SHORT $LN2@getFileSiz

; 683  : 		return 0;

  00047	33 c0		 xor	 eax, eax
  00049	eb 7c		 jmp	 SHORT $LN1@getFileSiz
$LN2@getFileSiz:

; 684  : 	}
; 685  : 
; 686  : 	fseek(pFile, 0, SEEK_END);

  0004b	8b f4		 mov	 esi, esp
  0004d	6a 02		 push	 2
  0004f	6a 00		 push	 0
  00051	8b 4d f4	 mov	 ecx, DWORD PTR _pFile$[ebp]
  00054	51		 push	 ecx
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005e	3b f4		 cmp	 esi, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 687  : 	nTotSize = ftell(pFile);

  00065	8b f4		 mov	 esi, esp
  00067	8b 55 f4	 mov	 edx, DWORD PTR _pFile$[ebp]
  0006a	52		 push	 edx
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ftell
  00071	83 c4 04	 add	 esp, 4
  00074	3b f4		 cmp	 esi, esp
  00076	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007b	89 45 f8	 mov	 DWORD PTR _nTotSize$[ebp], eax

; 688  : 	fclose(pFile);

  0007e	8b f4		 mov	 esi, esp
  00080	8b 45 f4	 mov	 eax, DWORD PTR _pFile$[ebp]
  00083	50		 push	 eax
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  0008a	83 c4 04	 add	 esp, 4
  0008d	3b f4		 cmp	 esi, esp
  0008f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 689  : 
; 690  : 	//if(!nMaxBuf) return nTotSize; 
; 691  : 
; 692  : 	nTotSize = nTotSize / g_nChSize - nPos;

  00094	8b 4d f8	 mov	 ecx, DWORD PTR _nTotSize$[ebp]
  00097	2b 4d 14	 sub	 ecx, DWORD PTR _nPos$[ebp]
  0009a	89 4d f8	 mov	 DWORD PTR _nTotSize$[ebp], ecx

; 693  : 
; 694  : 	*pLoopLen = (int)(nTotSize / nMaxBuf);

  0009d	8b 45 f8	 mov	 eax, DWORD PTR _nTotSize$[ebp]
  000a0	99		 cdq
  000a1	f7 7d 0c	 idiv	 DWORD PTR _nMaxBuf$[ebp]
  000a4	8b 55 10	 mov	 edx, DWORD PTR _pLoopLen$[ebp]
  000a7	89 02		 mov	 DWORD PTR [edx], eax

; 695  : 	if (*pLoopLen * nMaxBuf < nTotSize) {

  000a9	8b 45 10	 mov	 eax, DWORD PTR _pLoopLen$[ebp]
  000ac	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ae	0f af 4d 0c	 imul	 ecx, DWORD PTR _nMaxBuf$[ebp]
  000b2	3b 4d f8	 cmp	 ecx, DWORD PTR _nTotSize$[ebp]
  000b5	7d 0d		 jge	 SHORT $LN3@getFileSiz

; 696  : 		*pLoopLen += 1;

  000b7	8b 55 10	 mov	 edx, DWORD PTR _pLoopLen$[ebp]
  000ba	8b 02		 mov	 eax, DWORD PTR [edx]
  000bc	83 c0 01	 add	 eax, 1
  000bf	8b 4d 10	 mov	 ecx, DWORD PTR _pLoopLen$[ebp]
  000c2	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@getFileSiz:

; 697  : 	}
; 698  : 	return nTotSize;

  000c4	8b 45 f8	 mov	 eax, DWORD PTR _nTotSize$[ebp]
$LN1@getFileSiz:

; 699  : }

  000c7	5e		 pop	 esi
  000c8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000cb	3b ec		 cmp	 ebp, esp
  000cd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d2	8b e5		 mov	 esp, ebp
  000d4	5d		 pop	 ebp
  000d5	c3		 ret	 0
?getFileSize2@CFileUtil@@SAHPADHPAHH@Z ENDP		; CFileUtil::getFileSize2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
_TEXT	SEGMENT
_pFile$ = -4						; size = 4
_pFilePath$ = 8						; size = 4
_nSize$ = 12						; size = 4
_pBuf$ = 16						; size = 4
?modify@CFileUtil@@SA_NPADH0@Z PROC			; CFileUtil::modify

; 653  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 654  : 	FILE *pFile = _tfopen(pFilePath, _T("w"));

  0000c	8b f4		 mov	 esi, esp
  0000e	68 00 00 00 00	 push	 OFFSET $SG86868
  00013	8b 45 08	 mov	 eax, DWORD PTR _pFilePath$[ebp]
  00016	50		 push	 eax
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  0001d	83 c4 08	 add	 esp, 8
  00020	3b f4		 cmp	 esi, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00027	89 45 fc	 mov	 DWORD PTR _pFile$[ebp], eax

; 655  : 
; 656  : 	if (!pFile) {

  0002a	83 7d fc 00	 cmp	 DWORD PTR _pFile$[ebp], 0
  0002e	75 4c		 jne	 SHORT $LN2@modify

; 657  : 
; 658  : 		CFileUtil::MakeDirectory(pFilePath);

  00030	8b 4d 08	 mov	 ecx, DWORD PTR _pFilePath$[ebp]
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 ?MakeDirectory@CFileUtil@@SA_NPBD@Z ; CFileUtil::MakeDirectory
  00039	83 c4 04	 add	 esp, 4

; 659  : 		pFile = _tfopen(pFilePath, _T("w"));

  0003c	8b f4		 mov	 esi, esp
  0003e	68 00 00 00 00	 push	 OFFSET $SG86870
  00043	8b 55 08	 mov	 edx, DWORD PTR _pFilePath$[ebp]
  00046	52		 push	 edx
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  0004d	83 c4 08	 add	 esp, 8
  00050	3b f4		 cmp	 esi, esp
  00052	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00057	89 45 fc	 mov	 DWORD PTR _pFile$[ebp], eax

; 660  : 
; 661  : 		if (!pFile) {

  0005a	83 7d fc 00	 cmp	 DWORD PTR _pFile$[ebp], 0
  0005e	75 1c		 jne	 SHORT $LN2@modify

; 662  : 			gs_cLogger.PutLogQueue(LEVEL_ERROR, _T("CFileUtil::modify pFile open FAIL [%s]"), pFilePath);

  00060	8b 45 08	 mov	 eax, DWORD PTR _pFilePath$[ebp]
  00063	50		 push	 eax
  00064	68 00 00 00 00	 push	 OFFSET $SG86872
  00069	6a 05		 push	 5
  0006b	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  00070	e8 00 00 00 00	 call	 ?PutLogQueue@CLogger@@QAAXHPBDZZ ; CLogger::PutLogQueue
  00075	83 c4 10	 add	 esp, 16			; 00000010H

; 663  : 			return false;

  00078	32 c0		 xor	 al, al
  0007a	eb 4e		 jmp	 SHORT $LN1@modify
$LN2@modify:

; 664  : 		}
; 665  : 	}
; 666  : 
; 667  : 	fwrite(pBuf, g_nChSize, nSize, pFile);

  0007c	8b f4		 mov	 esi, esp
  0007e	8b 4d fc	 mov	 ecx, DWORD PTR _pFile$[ebp]
  00081	51		 push	 ecx
  00082	8b 55 0c	 mov	 edx, DWORD PTR _nSize$[ebp]
  00085	52		 push	 edx
  00086	6a 01		 push	 1
  00088	8b 45 10	 mov	 eax, DWORD PTR _pBuf$[ebp]
  0008b	50		 push	 eax
  0008c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  00092	83 c4 10	 add	 esp, 16			; 00000010H
  00095	3b f4		 cmp	 esi, esp
  00097	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 668  : 	fflush(pFile);

  0009c	8b f4		 mov	 esi, esp
  0009e	8b 4d fc	 mov	 ecx, DWORD PTR _pFile$[ebp]
  000a1	51		 push	 ecx
  000a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fflush
  000a8	83 c4 04	 add	 esp, 4
  000ab	3b f4		 cmp	 esi, esp
  000ad	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 669  : 	fclose(pFile);

  000b2	8b f4		 mov	 esi, esp
  000b4	8b 55 fc	 mov	 edx, DWORD PTR _pFile$[ebp]
  000b7	52		 push	 edx
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  000be	83 c4 04	 add	 esp, 4
  000c1	3b f4		 cmp	 esi, esp
  000c3	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 670  : 	return true;

  000c8	b0 01		 mov	 al, 1
$LN1@modify:

; 671  : }

  000ca	5e		 pop	 esi
  000cb	83 c4 04	 add	 esp, 4
  000ce	3b ec		 cmp	 ebp, esp
  000d0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c3		 ret	 0
?modify@CFileUtil@@SA_NPADH0@Z ENDP			; CFileUtil::modify
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
_TEXT	SEGMENT
_pFile$ = -12						; size = 4
_res$ = -8						; size = 4
_i$ = -4						; size = 4
_tryCnt$ = 8						; size = 4
_pFilePath$ = 12					; size = 4
_pMode$ = 16						; size = 4
_pSize$ = 20						; size = 4
?tryopen@CFileUtil@@SAPAU_iobuf@@HPADPBDPAH@Z PROC	; CFileUtil::tryopen

; 637  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000e	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00015	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 638  : 	int i, res;
; 639  : 	FILE *pFile;
; 640  : 	for (i = 0; i < tryCnt; i++) {

  0001c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00023	eb 09		 jmp	 SHORT $LN4@tryopen
$LN2@tryopen:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00028	83 c0 01	 add	 eax, 1
  0002b	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@tryopen:
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00031	3b 4d 08	 cmp	 ecx, DWORD PTR _tryCnt$[ebp]
  00034	7d 62		 jge	 SHORT $LN3@tryopen

; 641  : 		pFile = _tfopen(pFilePath, pMode);

  00036	8b f4		 mov	 esi, esp
  00038	8b 55 10	 mov	 edx, DWORD PTR _pMode$[ebp]
  0003b	52		 push	 edx
  0003c	8b 45 0c	 mov	 eax, DWORD PTR _pFilePath$[ebp]
  0003f	50		 push	 eax
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00046	83 c4 08	 add	 esp, 8
  00049	3b f4		 cmp	 esi, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00050	89 45 f4	 mov	 DWORD PTR _pFile$[ebp], eax

; 642  : 		if (pFile) {

  00053	83 7d f4 00	 cmp	 DWORD PTR _pFile$[ebp], 0
  00057	74 3d		 je	 SHORT $LN5@tryopen

; 643  : 			res = fseek(pFile, 0, SEEK_END);

  00059	8b f4		 mov	 esi, esp
  0005b	6a 02		 push	 2
  0005d	6a 00		 push	 0
  0005f	8b 4d f4	 mov	 ecx, DWORD PTR _pFile$[ebp]
  00062	51		 push	 ecx
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006c	3b f4		 cmp	 esi, esp
  0006e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00073	89 45 f8	 mov	 DWORD PTR _res$[ebp], eax

; 644  : 			*pSize = ftell(pFile);

  00076	8b f4		 mov	 esi, esp
  00078	8b 55 f4	 mov	 edx, DWORD PTR _pFile$[ebp]
  0007b	52		 push	 edx
  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ftell
  00082	83 c4 04	 add	 esp, 4
  00085	3b f4		 cmp	 esi, esp
  00087	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008c	8b 4d 14	 mov	 ecx, DWORD PTR _pSize$[ebp]
  0008f	89 01		 mov	 DWORD PTR [ecx], eax

; 645  : 			return pFile;

  00091	8b 45 f4	 mov	 eax, DWORD PTR _pFile$[ebp]
  00094	eb 18		 jmp	 SHORT $LN1@tryopen
$LN5@tryopen:

; 646  : 		}
; 647  : 		//  
; 648  : 	}

  00096	eb 8d		 jmp	 SHORT $LN2@tryopen
$LN3@tryopen:

; 649  : 	gs_cLogger.PutLogQueue(LEVEL_ERROR, _T("CFileUtil::tryopen pFile open FAIL"));

  00098	68 00 00 00 00	 push	 OFFSET $SG86861
  0009d	6a 05		 push	 5
  0009f	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  000a4	e8 00 00 00 00	 call	 ?PutLogQueue@CLogger@@QAAXHPBDZZ ; CLogger::PutLogQueue
  000a9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 650  : 	return NULL;

  000ac	33 c0		 xor	 eax, eax
$LN1@tryopen:

; 651  : }

  000ae	5e		 pop	 esi
  000af	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b2	3b ec		 cmp	 ebp, esp
  000b4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c3		 ret	 0
?tryopen@CFileUtil@@SAPAU_iobuf@@HPADPBDPAH@Z ENDP	; CFileUtil::tryopen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
_TEXT	SEGMENT
_pFile$ = -8						; size = 4
_nTotSize$ = -4						; size = 4
_pFilePath$ = 8						; size = 4
?getFileSize@CFileUtil@@SAHPAD@Z PROC			; CFileUtil::getFileSize

; 621  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 622  : 	int nTotSize;
; 623  : 	FILE *pFile;
; 624  : 
; 625  : 	pFile = _tfopen(pFilePath, _T("r"));

  00015	8b f4		 mov	 esi, esp
  00017	68 00 00 00 00	 push	 OFFSET $SG86846
  0001c	8b 45 08	 mov	 eax, DWORD PTR _pFilePath$[ebp]
  0001f	50		 push	 eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00026	83 c4 08	 add	 esp, 8
  00029	3b f4		 cmp	 esi, esp
  0002b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00030	89 45 f8	 mov	 DWORD PTR _pFile$[ebp], eax

; 626  : 	if (!pFile) {

  00033	83 7d f8 00	 cmp	 DWORD PTR _pFile$[ebp], 0
  00037	75 04		 jne	 SHORT $LN2@getFileSiz

; 627  : 		return 0;

  00039	33 c0		 xor	 eax, eax
  0003b	eb 4c		 jmp	 SHORT $LN1@getFileSiz
$LN2@getFileSiz:

; 628  : 	}
; 629  : 
; 630  : 	fseek(pFile, 0, SEEK_END);

  0003d	8b f4		 mov	 esi, esp
  0003f	6a 02		 push	 2
  00041	6a 00		 push	 0
  00043	8b 4d f8	 mov	 ecx, DWORD PTR _pFile$[ebp]
  00046	51		 push	 ecx
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  0004d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00050	3b f4		 cmp	 esi, esp
  00052	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 631  : 	nTotSize = ftell(pFile);

  00057	8b f4		 mov	 esi, esp
  00059	8b 55 f8	 mov	 edx, DWORD PTR _pFile$[ebp]
  0005c	52		 push	 edx
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ftell
  00063	83 c4 04	 add	 esp, 4
  00066	3b f4		 cmp	 esi, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006d	89 45 fc	 mov	 DWORD PTR _nTotSize$[ebp], eax

; 632  : 	fclose(pFile);

  00070	8b f4		 mov	 esi, esp
  00072	8b 45 f8	 mov	 eax, DWORD PTR _pFile$[ebp]
  00075	50		 push	 eax
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  0007c	83 c4 04	 add	 esp, 4
  0007f	3b f4		 cmp	 esi, esp
  00081	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 633  : 
; 634  : 	return nTotSize;

  00086	8b 45 fc	 mov	 eax, DWORD PTR _nTotSize$[ebp]
$LN1@getFileSiz:

; 635  : }

  00089	5e		 pop	 esi
  0008a	83 c4 08	 add	 esp, 8
  0008d	3b ec		 cmp	 ebp, esp
  0008f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c3		 ret	 0
?getFileSize@CFileUtil@@SAHPAD@Z ENDP			; CFileUtil::getFileSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
_TEXT	SEGMENT
_error$1 = -8						; size = 4
_nRes$2 = -4						; size = 4
_pOldFileName$ = 8					; size = 4
_pNewFileName$ = 12					; size = 4
?renameFile@CFileUtil@@SA_NPBD0@Z PROC			; CFileUtil::renameFile

; 591  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 592  : 	//TCHAR pNameBackup[255];
; 593  : 	//_stprintf(pNameBackup, _T("%s.BAK"), pFilePath);
; 594  : 
; 595  : 	if (com_isFile(pOldFileName))

  00015	8b 45 08	 mov	 eax, DWORD PTR _pOldFileName$[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ?com_isFile@@YA_NPBD@Z	; com_isFile
  0001e	83 c4 04	 add	 esp, 4
  00021	0f b6 c8	 movzx	 ecx, al
  00024	85 c9		 test	 ecx, ecx
  00026	74 4e		 je	 SHORT $LN2@renameFile

; 596  : 	{
; 597  : 		//if (com_isFile(pOldFileName)) {
; 598  : 		//	if (!DeleteFile(pOldFileName)) {
; 599  : 		//		gs_cLogger.DebugLog(LEVEL_ERROR, _T("CDFSFile::renameFile DeleteFile error code[%d]"), GetLastError());
; 600  : 		//		return false;
; 601  : 		//	}
; 602  : 		//}
; 603  : 
; 604  : 		int nRes = FILEMOVE(pOldFileName, pNewFileName);

  00028	8b f4		 mov	 esi, esp
  0002a	8b 55 0c	 mov	 edx, DWORD PTR _pNewFileName$[ebp]
  0002d	52		 push	 edx
  0002e	8b 45 08	 mov	 eax, DWORD PTR _pOldFileName$[ebp]
  00031	50		 push	 eax
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MoveFileA@8
  00038	3b f4		 cmp	 esi, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	89 45 fc	 mov	 DWORD PTR _nRes$2[ebp], eax

; 605  : #ifdef WIN32
; 606  : 		if(!nRes)

  00042	83 7d fc 00	 cmp	 DWORD PTR _nRes$2[ebp], 0
  00046	75 2e		 jne	 SHORT $LN2@renameFile

; 607  : #else
; 608  : 		if (nRes)
; 609  : #endif
; 610  : 
; 611  : 		{
; 612  : 			DWORD error = GetLastError();

  00048	8b f4		 mov	 esi, esp
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00050	3b f4		 cmp	 esi, esp
  00052	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00057	89 45 f8	 mov	 DWORD PTR _error$1[ebp], eax

; 613  : 			gs_cLogger.PutLogQueue(LEVEL_ERROR, _T("FILEMOVE error code[%d]"), error);

  0005a	8b 4d f8	 mov	 ecx, DWORD PTR _error$1[ebp]
  0005d	51		 push	 ecx
  0005e	68 00 00 00 00	 push	 OFFSET $SG86840
  00063	6a 05		 push	 5
  00065	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  0006a	e8 00 00 00 00	 call	 ?PutLogQueue@CLogger@@QAAXHPBDZZ ; CLogger::PutLogQueue
  0006f	83 c4 10	 add	 esp, 16			; 00000010H

; 614  : 			return false;

  00072	32 c0		 xor	 al, al
  00074	eb 02		 jmp	 SHORT $LN1@renameFile
$LN2@renameFile:

; 615  : 		}
; 616  : 	}
; 617  : 	return true;

  00076	b0 01		 mov	 al, 1
$LN1@renameFile:

; 618  : }

  00078	5e		 pop	 esi
  00079	83 c4 08	 add	 esp, 8
  0007c	3b ec		 cmp	 ebp, esp
  0007e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c3		 ret	 0
?renameFile@CFileUtil@@SA_NPBD0@Z ENDP			; CFileUtil::renameFile
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
_TEXT	SEGMENT
_nLen$ = -8						; size = 4
_pPos$ = -4						; size = 4
_pTarget$ = 8						; size = 4
_pOriPath$ = 12						; size = 4
_pChangeStr$ = 16					; size = 4
?getReFileName@CFileUtil@@SA_NPADPBD1@Z PROC		; CFileUtil::getReFileName

; 583  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 584  : 	const TCHAR *pPos = _tcsrchr(pOriPath, _T('.'));

  00014	6a 2e		 push	 46			; 0000002eH
  00016	8b 45 0c	 mov	 eax, DWORD PTR _pOriPath$[ebp]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 __tcsrchr
  0001f	83 c4 08	 add	 esp, 8
  00022	89 45 fc	 mov	 DWORD PTR _pPos$[ebp], eax

; 585  : 	size_t nLen = pPos - pOriPath;

  00025	8b 4d fc	 mov	 ecx, DWORD PTR _pPos$[ebp]
  00028	2b 4d 0c	 sub	 ecx, DWORD PTR _pOriPath$[ebp]
  0002b	89 4d f8	 mov	 DWORD PTR _nLen$[ebp], ecx

; 586  : 	_tcsncpy(pTarget, pOriPath, nLen);

  0002e	8b 55 f8	 mov	 edx, DWORD PTR _nLen$[ebp]
  00031	52		 push	 edx
  00032	8b 45 0c	 mov	 eax, DWORD PTR _pOriPath$[ebp]
  00035	50		 push	 eax
  00036	8b 4d 08	 mov	 ecx, DWORD PTR _pTarget$[ebp]
  00039	51		 push	 ecx
  0003a	e8 00 00 00 00	 call	 __tcsncpy
  0003f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 587  : 	_tcscpy(&pTarget[nLen], pChangeStr);

  00042	8b 55 10	 mov	 edx, DWORD PTR _pChangeStr$[ebp]
  00045	52		 push	 edx
  00046	8b 45 08	 mov	 eax, DWORD PTR _pTarget$[ebp]
  00049	03 45 f8	 add	 eax, DWORD PTR _nLen$[ebp]
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 _strcpy
  00052	83 c4 08	 add	 esp, 8

; 588  : 	return true;

  00055	b0 01		 mov	 al, 1

; 589  : }

  00057	83 c4 08	 add	 esp, 8
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
?getReFileName@CFileUtil@@SA_NPADPBD1@Z ENDP		; CFileUtil::getReFileName
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
_TEXT	SEGMENT
_pFile$ = -4						; size = 4
_pFilePath$ = 8						; size = 4
_pBuf$ = 12						; size = 4
?add@CFileUtil@@SA_NPAD0@Z PROC				; CFileUtil::add

; 564  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 565  : 	// File copy
; 566  : 	FILE * pFile;
; 567  : 	pFile = _tfopen(pFilePath, _T("a+"));

  0000c	8b f4		 mov	 esi, esp
  0000e	68 00 00 00 00	 push	 OFFSET $SG86820
  00013	8b 45 08	 mov	 eax, DWORD PTR _pFilePath$[ebp]
  00016	50		 push	 eax
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  0001d	83 c4 08	 add	 esp, 8
  00020	3b f4		 cmp	 esi, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00027	89 45 fc	 mov	 DWORD PTR _pFile$[ebp], eax

; 568  : 	if (!pFile) {

  0002a	83 7d fc 00	 cmp	 DWORD PTR _pFile$[ebp], 0
  0002e	75 50		 jne	 SHORT $LN2@add

; 569  : 		CFileUtil::MakeDirectory(pFilePath);

  00030	8b 4d 08	 mov	 ecx, DWORD PTR _pFilePath$[ebp]
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 ?MakeDirectory@CFileUtil@@SA_NPBD@Z ; CFileUtil::MakeDirectory
  00039	83 c4 04	 add	 esp, 4

; 570  : 		pFile = _tfopen(pFilePath, _T("a+"));

  0003c	8b f4		 mov	 esi, esp
  0003e	68 00 00 00 00	 push	 OFFSET $SG86822
  00043	8b 55 08	 mov	 edx, DWORD PTR _pFilePath$[ebp]
  00046	52		 push	 edx
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  0004d	83 c4 08	 add	 esp, 8
  00050	3b f4		 cmp	 esi, esp
  00052	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00057	89 45 fc	 mov	 DWORD PTR _pFile$[ebp], eax

; 571  : 		if (!pFile) {

  0005a	83 7d fc 00	 cmp	 DWORD PTR _pFile$[ebp], 0
  0005e	75 1c		 jne	 SHORT $LN3@add

; 572  : 			gs_cLogger.PutLogQueue(LEVEL_ERROR, _T("CDFSFile::add pFile open FAIL [%s]"), pFilePath);

  00060	8b 45 08	 mov	 eax, DWORD PTR _pFilePath$[ebp]
  00063	50		 push	 eax
  00064	68 00 00 00 00	 push	 OFFSET $SG86824
  00069	6a 05		 push	 5
  0006b	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  00070	e8 00 00 00 00	 call	 ?PutLogQueue@CLogger@@QAAXHPBDZZ ; CLogger::PutLogQueue
  00075	83 c4 10	 add	 esp, 16			; 00000010H

; 573  : 			return false;

  00078	32 c0		 xor	 al, al
  0007a	eb 5b		 jmp	 SHORT $LN1@add
$LN3@add:

; 574  : 		}
; 575  : 		return false;

  0007c	32 c0		 xor	 al, al
  0007e	eb 57		 jmp	 SHORT $LN1@add
$LN2@add:

; 576  : 	}
; 577  : 	fwrite(pBuf, sizeof(TCHAR), _tcslen(pBuf), pFile);

  00080	8b f4		 mov	 esi, esp
  00082	8b 4d fc	 mov	 ecx, DWORD PTR _pFile$[ebp]
  00085	51		 push	 ecx
  00086	8b 55 0c	 mov	 edx, DWORD PTR _pBuf$[ebp]
  00089	52		 push	 edx
  0008a	e8 00 00 00 00	 call	 _strlen
  0008f	83 c4 04	 add	 esp, 4
  00092	50		 push	 eax
  00093	6a 01		 push	 1
  00095	8b 45 0c	 mov	 eax, DWORD PTR _pBuf$[ebp]
  00098	50		 push	 eax
  00099	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  0009f	83 c4 10	 add	 esp, 16			; 00000010H
  000a2	3b f4		 cmp	 esi, esp
  000a4	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 578  : 	fflush(pFile);

  000a9	8b f4		 mov	 esi, esp
  000ab	8b 4d fc	 mov	 ecx, DWORD PTR _pFile$[ebp]
  000ae	51		 push	 ecx
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fflush
  000b5	83 c4 04	 add	 esp, 4
  000b8	3b f4		 cmp	 esi, esp
  000ba	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 579  : 	fclose(pFile);

  000bf	8b f4		 mov	 esi, esp
  000c1	8b 55 fc	 mov	 edx, DWORD PTR _pFile$[ebp]
  000c4	52		 push	 edx
  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  000cb	83 c4 04	 add	 esp, 4
  000ce	3b f4		 cmp	 esi, esp
  000d0	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 580  : 	return true;

  000d5	b0 01		 mov	 al, 1
$LN1@add:

; 581  : }

  000d7	5e		 pop	 esi
  000d8	83 c4 04	 add	 esp, 4
  000db	3b ec		 cmp	 ebp, esp
  000dd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e2	8b e5		 mov	 esp, ebp
  000e4	5d		 pop	 ebp
  000e5	c3		 ret	 0
?add@CFileUtil@@SA_NPAD0@Z ENDP				; CFileUtil::add
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
_TEXT	SEGMENT
tv164 = -104						; size = 4
tv91 = -100						; size = 4
$T2 = -96						; size = 4
$T3 = -92						; size = 4
$T4 = -88						; size = 4
$T5 = -84						; size = 4
_idx$6 = -76						; size = 4
_stInfo$ = -64						; size = 12
_bres$ = -45						; size = 1
_pList$ = -44						; size = 4
_fileSize$ = -36					; size = 4
_pFileBuf$ = -24					; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pFilePath$ = 8						; size = 4
_pLineList$ = 12					; size = 4
_ch$ = 16						; size = 1
?fileToFieldRecord@CFileUtil@@SA_NPADPAV?$CTList@VCStringList@@@@D@Z PROC ; CFileUtil::fileToFieldRecord

; 399  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?fileToFieldRecord@CFileUtil@@SA_NPADPAV?$CTList@VCStringList@@@@D@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00014	57		 push	 edi
  00015	8d 7d 98	 lea	 edi, DWORD PTR [ebp-104]
  00018	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  0001d	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00022	f3 ab		 rep stosd
  00024	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00029	33 c5		 xor	 eax, ebp
  0002b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002e	50		 push	 eax
  0002f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00032	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 400  : 	// FILE READ
; 401  : 	TCHAR *pFileBuf = NULL;

  00038	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _pFileBuf$[ebp], 0

; 402  : 	int fileSize = 0;

  0003f	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _fileSize$[ebp], 0

; 403  : 	CStringList *pList;
; 404  : 	bool bres;
; 405  : 	STStrInfo stInfo;
; 406  : 
; 407  : 	memset(&stInfo, 0, sizeof(STStrInfo));

  00046	6a 0c		 push	 12			; 0000000cH
  00048	6a 00		 push	 0
  0004a	8d 45 c0	 lea	 eax, DWORD PTR _stInfo$[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 _memset
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH

; 408  : 	fileSize = readNalloc(pFilePath, &pFileBuf, &fileSize);

  00056	8d 4d dc	 lea	 ecx, DWORD PTR _fileSize$[ebp]
  00059	51		 push	 ecx
  0005a	8d 55 e8	 lea	 edx, DWORD PTR _pFileBuf$[ebp]
  0005d	52		 push	 edx
  0005e	8b 45 08	 mov	 eax, DWORD PTR _pFilePath$[ebp]
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ?readNalloc@CFileUtil@@SAHPADPAPADPAH@Z ; CFileUtil::readNalloc
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006a	89 45 dc	 mov	 DWORD PTR _fileSize$[ebp], eax

; 409  : 
; 410  : 	if (!fileSize) {

  0006d	83 7d dc 00	 cmp	 DWORD PTR _fileSize$[ebp], 0
  00071	75 09		 jne	 SHORT $LN6@fileToFiel

; 411  : 		bres = false;

  00073	c6 45 d3 00	 mov	 BYTE PTR _bres$[ebp], 0

; 412  : 		goto END_PROC;

  00077	e9 a6 01 00 00	 jmp	 $END_PROC$35
$LN6@fileToFiel:

; 413  : 	}
; 414  : 
; 415  : 	stInfo.aBufSize = 4096;

  0007c	c7 45 c8 00 10
	00 00		 mov	 DWORD PTR _stInfo$[ebp+8], 4096 ; 00001000H

; 416  : 	stInfo.pSource = pFileBuf;

  00083	8b 4d e8	 mov	 ecx, DWORD PTR _pFileBuf$[ebp]
  00086	89 4d c0	 mov	 DWORD PTR _stInfo$[ebp], ecx

; 417  : 	stInfo.pTarget = gs_pMMgr->newBuf(4096);

  00089	68 00 10 00 00	 push	 4096			; 00001000H
  0008e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pMMgr@@3PAVCMemManager@@A ; gs_pMMgr
  00094	e8 00 00 00 00	 call	 ?newBuf@CMemManager@@QAEPADH@Z ; CMemManager::newBuf
  00099	89 45 c4	 mov	 DWORD PTR _stInfo$[ebp+4], eax

; 418  : 	if (!stInfo.pTarget) {

  0009c	83 7d c4 00	 cmp	 DWORD PTR _stInfo$[ebp+4], 0
  000a0	75 09		 jne	 SHORT $LN2@fileToFiel

; 419  : 		bres = false;

  000a2	c6 45 d3 00	 mov	 BYTE PTR _bres$[ebp], 0

; 420  : 		goto END_PROC;

  000a6	e9 77 01 00 00	 jmp	 $END_PROC$35
$LN2@fileToFiel:

; 421  : 	}
; 422  : 
; 423  : 	while(getNextLine(&stInfo))

  000ab	8d 55 c0	 lea	 edx, DWORD PTR _stInfo$[ebp]
  000ae	52		 push	 edx
  000af	e8 00 00 00 00	 call	 ?getNextLine@CFileUtil@@SAHPAUSTStrInfo@@@Z ; CFileUtil::getNextLine
  000b4	83 c4 04	 add	 esp, 4
  000b7	85 c0		 test	 eax, eax
  000b9	0f 84 f5 00 00
	00		 je	 $LN3@fileToFiel

; 424  : 	{
; 425  : 		pList = new (std::nothrow) CStringList();

  000bf	68 00 00 00 00	 push	 OFFSET ?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  000c4	6a 14		 push	 20			; 00000014H
  000c6	e8 00 00 00 00	 call	 ??2@YAPAXIABUnothrow_t@std@@@Z ; operator new
  000cb	83 c4 08	 add	 esp, 8
  000ce	89 45 a8	 mov	 DWORD PTR $T4[ebp], eax
  000d1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000d8	83 7d a8 00	 cmp	 DWORD PTR $T4[ebp], 0
  000dc	74 0d		 je	 SHORT $LN23@fileToFiel
  000de	8b 4d a8	 mov	 ecx, DWORD PTR $T4[ebp]
  000e1	e8 00 00 00 00	 call	 ??0CStringList@@QAE@XZ	; CStringList::CStringList
  000e6	89 45 9c	 mov	 DWORD PTR tv91[ebp], eax
  000e9	eb 07		 jmp	 SHORT $LN24@fileToFiel
$LN23@fileToFiel:
  000eb	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv91[ebp], 0
$LN24@fileToFiel:
  000f2	8b 45 9c	 mov	 eax, DWORD PTR tv91[ebp]
  000f5	89 45 ac	 mov	 DWORD PTR $T5[ebp], eax
  000f8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000ff	8b 4d ac	 mov	 ecx, DWORD PTR $T5[ebp]
  00102	89 4d d4	 mov	 DWORD PTR _pList$[ebp], ecx

; 426  : 		if (!pList) { gs_cLogger.DebugLog(LEVEL_ERROR, _T("new pList")); goto ERROR_PROC; }

  00105	83 7d d4 00	 cmp	 DWORD PTR _pList$[ebp], 0
  00109	75 23		 jne	 SHORT $LN10@fileToFiel
  0010b	68 00 00 00 00	 push	 OFFSET $SG86734
  00110	68 aa 01 00 00	 push	 426			; 000001aaH
  00115	68 00 00 00 00	 push	 OFFSET $SG86735
  0011a	6a 05		 push	 5
  0011c	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  00121	e8 00 00 00 00	 call	 ?__debugLog@CLogger@@QAAXHPBDH0ZZ ; CLogger::__debugLog
  00126	83 c4 14	 add	 esp, 20			; 00000014H
  00129	e9 8c 00 00 00	 jmp	 $ERROR_PROC$36
$LN10@fileToFiel:

; 427  : 		if (!pList->alloc(10)) { gs_cLogger.DebugLog(LEVEL_ERROR, _T("alloc pList")); goto ERROR_PROC; }

  0012e	6a 0a		 push	 10			; 0000000aH
  00130	8b 4d d4	 mov	 ecx, DWORD PTR _pList$[ebp]
  00133	e8 00 00 00 00	 call	 ?alloc@CStringList@@QAEHH@Z ; CStringList::alloc
  00138	85 c0		 test	 eax, eax
  0013a	75 20		 jne	 SHORT $LN12@fileToFiel
  0013c	68 00 00 00 00	 push	 OFFSET $SG86738
  00141	68 ab 01 00 00	 push	 427			; 000001abH
  00146	68 00 00 00 00	 push	 OFFSET $SG86739
  0014b	6a 05		 push	 5
  0014d	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  00152	e8 00 00 00 00	 call	 ?__debugLog@CLogger@@QAAXHPBDH0ZZ ; CLogger::__debugLog
  00157	83 c4 14	 add	 esp, 20			; 00000014H
  0015a	eb 5e		 jmp	 SHORT $ERROR_PROC$36
$LN12@fileToFiel:

; 428  : 		if (!getFieldList(stInfo.pTarget, ch, pList)) {

  0015c	8b 55 d4	 mov	 edx, DWORD PTR _pList$[ebp]
  0015f	52		 push	 edx
  00160	0f b6 45 10	 movzx	 eax, BYTE PTR _ch$[ebp]
  00164	50		 push	 eax
  00165	8b 4d c4	 mov	 ecx, DWORD PTR _stInfo$[ebp+4]
  00168	51		 push	 ecx
  00169	e8 00 00 00 00	 call	 ?getFieldList@CFileUtil@@SA_NPADDPAVCStringList@@@Z ; CFileUtil::getFieldList
  0016e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00171	0f b6 d0	 movzx	 edx, al
  00174	85 d2		 test	 edx, edx
  00176	75 02		 jne	 SHORT $LN14@fileToFiel

; 429  : 			goto ERROR_PROC;

  00178	eb 40		 jmp	 SHORT $ERROR_PROC$36
$LN14@fileToFiel:

; 430  : 		}
; 431  : 		if (!pLineList->push_back(pList)) { gs_cLogger.DebugLog(LEVEL_ERROR, _T("add pLineList")); goto ERROR_PROC; }

  0017a	6a 00		 push	 0
  0017c	8b 45 d4	 mov	 eax, DWORD PTR _pList$[ebp]
  0017f	50		 push	 eax
  00180	8b 4d 0c	 mov	 ecx, DWORD PTR _pLineList$[ebp]
  00183	e8 00 00 00 00	 call	 ?push_back@?$CTList@VCStringList@@@@QAE_NPAVCStringList@@PAH@Z ; CTList<CStringList>::push_back
  00188	0f b6 c8	 movzx	 ecx, al
  0018b	85 c9		 test	 ecx, ecx
  0018d	75 20		 jne	 SHORT $LN16@fileToFiel
  0018f	68 00 00 00 00	 push	 OFFSET $SG86744
  00194	68 af 01 00 00	 push	 431			; 000001afH
  00199	68 00 00 00 00	 push	 OFFSET $SG86745
  0019e	6a 05		 push	 5
  001a0	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  001a5	e8 00 00 00 00	 call	 ?__debugLog@CLogger@@QAAXHPBDH0ZZ ; CLogger::__debugLog
  001aa	83 c4 14	 add	 esp, 20			; 00000014H
  001ad	eb 0b		 jmp	 SHORT $ERROR_PROC$36
$LN16@fileToFiel:

; 432  : 	}

  001af	e9 f7 fe ff ff	 jmp	 $LN2@fileToFiel
$LN3@fileToFiel:

; 433  : 	bres = true;

  001b4	c6 45 d3 01	 mov	 BYTE PTR _bres$[ebp], 1

; 434  : 	goto END_PROC;

  001b8	eb 68		 jmp	 SHORT $END_PROC$35
$ERROR_PROC$36:

; 435  : ERROR_PROC:
; 436  : 	if (pLineList) {

  001ba	83 7d 0c 00	 cmp	 DWORD PTR _pLineList$[ebp], 0
  001be	74 5e		 je	 SHORT $LN19@fileToFiel

; 437  : 		int idx = 0;

  001c0	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _idx$6[ebp], 0

; 438  : 		pList = pLineList->getNext(&idx);

  001c7	8d 55 b4	 lea	 edx, DWORD PTR _idx$6[ebp]
  001ca	52		 push	 edx
  001cb	8b 4d 0c	 mov	 ecx, DWORD PTR _pLineList$[ebp]
  001ce	e8 00 00 00 00	 call	 ?getNext@?$CTList@VCStringList@@@@QAEPAVCStringList@@PAH@Z ; CTList<CStringList>::getNext
  001d3	89 45 d4	 mov	 DWORD PTR _pList$[ebp], eax
$LN4@fileToFiel:

; 439  : 		while (pList) {

  001d6	83 7d d4 00	 cmp	 DWORD PTR _pList$[ebp], 0
  001da	74 42		 je	 SHORT $LN19@fileToFiel

; 440  : 			delete pList;

  001dc	8b 45 d4	 mov	 eax, DWORD PTR _pList$[ebp]
  001df	89 45 a0	 mov	 DWORD PTR $T2[ebp], eax
  001e2	8b 4d a0	 mov	 ecx, DWORD PTR $T2[ebp]
  001e5	89 4d a4	 mov	 DWORD PTR $T3[ebp], ecx
  001e8	83 7d a4 00	 cmp	 DWORD PTR $T3[ebp], 0
  001ec	74 0f		 je	 SHORT $LN25@fileToFiel
  001ee	6a 01		 push	 1
  001f0	8b 4d a4	 mov	 ecx, DWORD PTR $T3[ebp]
  001f3	e8 00 00 00 00	 call	 ??_GCStringList@@QAEPAXI@Z
  001f8	89 45 98	 mov	 DWORD PTR tv164[ebp], eax
  001fb	eb 07		 jmp	 SHORT $LN26@fileToFiel
$LN25@fileToFiel:
  001fd	c7 45 98 00 00
	00 00		 mov	 DWORD PTR tv164[ebp], 0
$LN26@fileToFiel:

; 441  : 			idx++;

  00204	8b 55 b4	 mov	 edx, DWORD PTR _idx$6[ebp]
  00207	83 c2 01	 add	 edx, 1
  0020a	89 55 b4	 mov	 DWORD PTR _idx$6[ebp], edx

; 442  : 			pList = pLineList->getNext(&idx);

  0020d	8d 45 b4	 lea	 eax, DWORD PTR _idx$6[ebp]
  00210	50		 push	 eax
  00211	8b 4d 0c	 mov	 ecx, DWORD PTR _pLineList$[ebp]
  00214	e8 00 00 00 00	 call	 ?getNext@?$CTList@VCStringList@@@@QAEPAVCStringList@@PAH@Z ; CTList<CStringList>::getNext
  00219	89 45 d4	 mov	 DWORD PTR _pList$[ebp], eax

; 443  : 		}

  0021c	eb b8		 jmp	 SHORT $LN4@fileToFiel
$LN19@fileToFiel:

; 444  : 	}
; 445  : 	bres = false;

  0021e	c6 45 d3 00	 mov	 BYTE PTR _bres$[ebp], 0
$END_PROC$35:

; 446  : END_PROC:
; 447  : 	if (pFileBuf) gs_pMMgr->delBuf(pFileBuf, fileSize);

  00222	83 7d e8 00	 cmp	 DWORD PTR _pFileBuf$[ebp], 0
  00226	74 13		 je	 SHORT $LN20@fileToFiel
  00228	8b 4d dc	 mov	 ecx, DWORD PTR _fileSize$[ebp]
  0022b	51		 push	 ecx
  0022c	8b 55 e8	 mov	 edx, DWORD PTR _pFileBuf$[ebp]
  0022f	52		 push	 edx
  00230	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pMMgr@@3PAVCMemManager@@A ; gs_pMMgr
  00236	e8 00 00 00 00	 call	 ?delBuf@CMemManager@@QAEXPADH@Z ; CMemManager::delBuf
$LN20@fileToFiel:

; 448  : 	if(stInfo.pTarget) gs_pMMgr->delBuf(stInfo.pTarget, stInfo.aBufSize);

  0023b	83 7d c4 00	 cmp	 DWORD PTR _stInfo$[ebp+4], 0
  0023f	74 13		 je	 SHORT $LN21@fileToFiel
  00241	8b 45 c8	 mov	 eax, DWORD PTR _stInfo$[ebp+8]
  00244	50		 push	 eax
  00245	8b 4d c4	 mov	 ecx, DWORD PTR _stInfo$[ebp+4]
  00248	51		 push	 ecx
  00249	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pMMgr@@3PAVCMemManager@@A ; gs_pMMgr
  0024f	e8 00 00 00 00	 call	 ?delBuf@CMemManager@@QAEXPADH@Z ; CMemManager::delBuf
$LN21@fileToFiel:

; 449  : 	return bres;

  00254	8a 45 d3	 mov	 al, BYTE PTR _bres$[ebp]

; 450  : }

  00257	52		 push	 edx
  00258	8b cd		 mov	 ecx, ebp
  0025a	50		 push	 eax
  0025b	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN34@fileToFiel
  00261	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00266	58		 pop	 eax
  00267	5a		 pop	 edx
  00268	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0026b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00272	59		 pop	 ecx
  00273	5f		 pop	 edi
  00274	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00277	33 cd		 xor	 ecx, ebp
  00279	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0027e	83 c4 68	 add	 esp, 104		; 00000068H
  00281	3b ec		 cmp	 ebp, esp
  00283	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00288	8b e5		 mov	 esp, ebp
  0028a	5d		 pop	 ebp
  0028b	c3		 ret	 0
$LN34@fileToFiel:
  0028c	04 00 00 00	 DD	 4
  00290	00 00 00 00	 DD	 $LN33@fileToFiel
$LN33@fileToFiel:
  00294	e8 ff ff ff	 DD	 -24			; ffffffe8H
  00298	04 00 00 00	 DD	 4
  0029c	00 00 00 00	 DD	 $LN28@fileToFiel
  002a0	dc ff ff ff	 DD	 -36			; ffffffdcH
  002a4	04 00 00 00	 DD	 4
  002a8	00 00 00 00	 DD	 $LN29@fileToFiel
  002ac	c0 ff ff ff	 DD	 -64			; ffffffc0H
  002b0	0c 00 00 00	 DD	 12			; 0000000cH
  002b4	00 00 00 00	 DD	 $LN30@fileToFiel
  002b8	b4 ff ff ff	 DD	 -76			; ffffffb4H
  002bc	04 00 00 00	 DD	 4
  002c0	00 00 00 00	 DD	 $LN31@fileToFiel
$LN31@fileToFiel:
  002c4	69		 DB	 105			; 00000069H
  002c5	64		 DB	 100			; 00000064H
  002c6	78		 DB	 120			; 00000078H
  002c7	00		 DB	 0
$LN30@fileToFiel:
  002c8	73		 DB	 115			; 00000073H
  002c9	74		 DB	 116			; 00000074H
  002ca	49		 DB	 73			; 00000049H
  002cb	6e		 DB	 110			; 0000006eH
  002cc	66		 DB	 102			; 00000066H
  002cd	6f		 DB	 111			; 0000006fH
  002ce	00		 DB	 0
$LN29@fileToFiel:
  002cf	66		 DB	 102			; 00000066H
  002d0	69		 DB	 105			; 00000069H
  002d1	6c		 DB	 108			; 0000006cH
  002d2	65		 DB	 101			; 00000065H
  002d3	53		 DB	 83			; 00000053H
  002d4	69		 DB	 105			; 00000069H
  002d5	7a		 DB	 122			; 0000007aH
  002d6	65		 DB	 101			; 00000065H
  002d7	00		 DB	 0
$LN28@fileToFiel:
  002d8	70		 DB	 112			; 00000070H
  002d9	46		 DB	 70			; 00000046H
  002da	69		 DB	 105			; 00000069H
  002db	6c		 DB	 108			; 0000006cH
  002dc	65		 DB	 101			; 00000065H
  002dd	42		 DB	 66			; 00000042H
  002de	75		 DB	 117			; 00000075H
  002df	66		 DB	 102			; 00000066H
  002e0	00		 DB	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?fileToFieldRecord@CFileUtil@@SA_NPADPAV?$CTList@VCStringList@@@@D@Z$7:
  00000	68 00 00 00 00	 push	 OFFSET ?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00005	8b 45 a8	 mov	 eax, DWORD PTR $T4[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ??3@YAXPAXABUnothrow_t@std@@@Z ; operator delete
  0000e	83 c4 08	 add	 esp, 8
  00011	c3		 ret	 0
__ehhandler$?fileToFieldRecord@CFileUtil@@SA_NPADPAV?$CTList@VCStringList@@@@D@Z:
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 4a 9c	 mov	 ecx, DWORD PTR [edx-100]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?fileToFieldRecord@CFileUtil@@SA_NPADPAV?$CTList@VCStringList@@@@D@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?fileToFieldRecord@CFileUtil@@SA_NPADPAV?$CTList@VCStringList@@@@D@Z ENDP ; CFileUtil::fileToFieldRecord
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
_TEXT	SEGMENT
$T1 = -540						; size = 4
_bEnd$ = -533						; size = 1
_word$ = -528						; size = 512
_pNext$ = -12						; size = 4
_nLen$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_pRecord$ = 8						; size = 4
_cSeparator$ = 12					; size = 1
_pList$ = 16						; size = 4
?getFieldList@CFileUtil@@SA_NPADDPAVCStringList@@@Z PROC ; CFileUtil::getFieldList

; 453  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 1c 02 00
	00		 sub	 esp, 540		; 0000021cH
  00009	57		 push	 edi
  0000a	8d bd e4 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-540]
  00010	b9 87 00 00 00	 mov	 ecx, 135		; 00000087H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 454  : 	int nLen; 
; 455  : 	TCHAR *pNext, word[512];
; 456  : 	bool bEnd=false;

  00026	c6 85 eb fd ff
	ff 00		 mov	 BYTE PTR _bEnd$[ebp], 0

; 457  : 
; 458  : 	if (!cSeparator) {

  0002d	0f be 45 0c	 movsx	 eax, BYTE PTR _cSeparator$[ebp]
  00031	85 c0		 test	 eax, eax
  00033	75 1e		 jne	 SHORT $LN2@getFieldLi

; 459  : 		if (pList->push_back(pRecord)) {

  00035	8b 4d 08	 mov	 ecx, DWORD PTR _pRecord$[ebp]
  00038	51		 push	 ecx
  00039	8b 4d 10	 mov	 ecx, DWORD PTR _pList$[ebp]
  0003c	e8 00 00 00 00	 call	 ?push_back@CStringList@@QAEPAVCmString@@PAD@Z ; CStringList::push_back
  00041	85 c0		 test	 eax, eax
  00043	74 07		 je	 SHORT $LN7@getFieldLi

; 460  : 			return true;

  00045	b0 01		 mov	 al, 1
  00047	e9 12 01 00 00	 jmp	 $LN15@getFieldLi
$LN7@getFieldLi:

; 461  : 		}
; 462  : 		return false;

  0004c	32 c0		 xor	 al, al
  0004e	e9 0b 01 00 00	 jmp	 $LN15@getFieldLi
$LN2@getFieldLi:

; 463  : 	}
; 464  : 
; 465  : 	while (*pRecord)

  00053	8b 55 08	 mov	 edx, DWORD PTR _pRecord$[ebp]
  00056	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00059	85 c0		 test	 eax, eax
  0005b	0f 84 fb 00 00
	00		 je	 $LN3@getFieldLi
$LN4@getFieldLi:

; 466  : 	{
; 467  : 		while (*pRecord == CH_SPC || *pRecord == CH_TAB) pRecord++;

  00061	8b 4d 08	 mov	 ecx, DWORD PTR _pRecord$[ebp]
  00064	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00067	83 fa 20	 cmp	 edx, 32			; 00000020H
  0006a	74 0b		 je	 SHORT $LN8@getFieldLi
  0006c	8b 45 08	 mov	 eax, DWORD PTR _pRecord$[ebp]
  0006f	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00072	83 f9 09	 cmp	 ecx, 9
  00075	75 0b		 jne	 SHORT $LN5@getFieldLi
$LN8@getFieldLi:
  00077	8b 55 08	 mov	 edx, DWORD PTR _pRecord$[ebp]
  0007a	83 c2 01	 add	 edx, 1
  0007d	89 55 08	 mov	 DWORD PTR _pRecord$[ebp], edx
  00080	eb df		 jmp	 SHORT $LN4@getFieldLi
$LN5@getFieldLi:

; 468  : 		pNext = strchr(pRecord, cSeparator);

  00082	0f be 45 0c	 movsx	 eax, BYTE PTR _cSeparator$[ebp]
  00086	50		 push	 eax
  00087	8b 4d 08	 mov	 ecx, DWORD PTR _pRecord$[ebp]
  0008a	51		 push	 ecx
  0008b	e8 00 00 00 00	 call	 ?strchr@@YAPADQADH@Z	; strchr
  00090	83 c4 08	 add	 esp, 8
  00093	89 45 f4	 mov	 DWORD PTR _pNext$[ebp], eax

; 469  : 		if (!pNext) {

  00096	83 7d f4 00	 cmp	 DWORD PTR _pNext$[ebp], 0
  0009a	75 42		 jne	 SHORT $LN9@getFieldLi

; 470  : 			if (!pNext) pNext = strchr(pRecord, 0);

  0009c	83 7d f4 00	 cmp	 DWORD PTR _pNext$[ebp], 0
  000a0	75 11		 jne	 SHORT $LN10@getFieldLi
  000a2	6a 00		 push	 0
  000a4	8b 55 08	 mov	 edx, DWORD PTR _pRecord$[ebp]
  000a7	52		 push	 edx
  000a8	e8 00 00 00 00	 call	 ?strchr@@YAPADQADH@Z	; strchr
  000ad	83 c4 08	 add	 esp, 8
  000b0	89 45 f4	 mov	 DWORD PTR _pNext$[ebp], eax
$LN10@getFieldLi:

; 471  : 			if (!pNext) pNext = strchr(pRecord, g_rc);

  000b3	83 7d f4 00	 cmp	 DWORD PTR _pNext$[ebp], 0
  000b7	75 11		 jne	 SHORT $LN11@getFieldLi
  000b9	6a 0a		 push	 10			; 0000000aH
  000bb	8b 45 08	 mov	 eax, DWORD PTR _pRecord$[ebp]
  000be	50		 push	 eax
  000bf	e8 00 00 00 00	 call	 ?strchr@@YAPADQADH@Z	; strchr
  000c4	83 c4 08	 add	 esp, 8
  000c7	89 45 f4	 mov	 DWORD PTR _pNext$[ebp], eax
$LN11@getFieldLi:

; 472  : 			if (!pNext) return false;

  000ca	83 7d f4 00	 cmp	 DWORD PTR _pNext$[ebp], 0
  000ce	75 07		 jne	 SHORT $LN12@getFieldLi
  000d0	32 c0		 xor	 al, al
  000d2	e9 87 00 00 00	 jmp	 $LN15@getFieldLi
$LN12@getFieldLi:

; 473  : 			bEnd = true;

  000d7	c6 85 eb fd ff
	ff 01		 mov	 BYTE PTR _bEnd$[ebp], 1
$LN9@getFieldLi:

; 474  : 		}
; 475  : 		nLen = (int)(pNext - pRecord);

  000de	8b 4d f4	 mov	 ecx, DWORD PTR _pNext$[ebp]
  000e1	2b 4d 08	 sub	 ecx, DWORD PTR _pRecord$[ebp]
  000e4	89 4d f8	 mov	 DWORD PTR _nLen$[ebp], ecx

; 476  : 		_tcsncpy(word, pRecord, nLen); word[nLen] = 0;

  000e7	8b 55 f8	 mov	 edx, DWORD PTR _nLen$[ebp]
  000ea	52		 push	 edx
  000eb	8b 45 08	 mov	 eax, DWORD PTR _pRecord$[ebp]
  000ee	50		 push	 eax
  000ef	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR _word$[ebp]
  000f5	51		 push	 ecx
  000f6	e8 00 00 00 00	 call	 __tcsncpy
  000fb	83 c4 0c	 add	 esp, 12			; 0000000cH
  000fe	8b 55 f8	 mov	 edx, DWORD PTR _nLen$[ebp]
  00101	89 95 e4 fd ff
	ff		 mov	 DWORD PTR $T1[ebp], edx
  00107	81 bd e4 fd ff
	ff 00 02 00 00	 cmp	 DWORD PTR $T1[ebp], 512	; 00000200H
  00111	73 02		 jae	 SHORT $LN16@getFieldLi
  00113	eb 05		 jmp	 SHORT $LN17@getFieldLi
$LN16@getFieldLi:
  00115	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN17@getFieldLi:
  0011a	8b 85 e4 fd ff
	ff		 mov	 eax, DWORD PTR $T1[ebp]
  00120	c6 84 05 f0 fd
	ff ff 00	 mov	 BYTE PTR _word$[ebp+eax], 0

; 477  : 		if (!pList->push_back(word)) {

  00128	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR _word$[ebp]
  0012e	51		 push	 ecx
  0012f	8b 4d 10	 mov	 ecx, DWORD PTR _pList$[ebp]
  00132	e8 00 00 00 00	 call	 ?push_back@CStringList@@QAEPAVCmString@@PAD@Z ; CStringList::push_back
  00137	85 c0		 test	 eax, eax
  00139	75 04		 jne	 SHORT $LN13@getFieldLi

; 478  : 			return false;

  0013b	32 c0		 xor	 al, al
  0013d	eb 1f		 jmp	 SHORT $LN15@getFieldLi
$LN13@getFieldLi:

; 479  : 		}
; 480  : 		if (bEnd) return true;

  0013f	0f b6 95 eb fd
	ff ff		 movzx	 edx, BYTE PTR _bEnd$[ebp]
  00146	85 d2		 test	 edx, edx
  00148	74 04		 je	 SHORT $LN14@getFieldLi
  0014a	b0 01		 mov	 al, 1
  0014c	eb 10		 jmp	 SHORT $LN15@getFieldLi
$LN14@getFieldLi:

; 481  : 		pRecord = pNext + 1;

  0014e	8b 45 f4	 mov	 eax, DWORD PTR _pNext$[ebp]
  00151	83 c0 01	 add	 eax, 1
  00154	89 45 08	 mov	 DWORD PTR _pRecord$[ebp], eax

; 482  : 	}

  00157	e9 f7 fe ff ff	 jmp	 $LN2@getFieldLi
$LN3@getFieldLi:

; 483  : 	return true;

  0015c	b0 01		 mov	 al, 1
$LN15@getFieldLi:

; 484  : }

  0015e	52		 push	 edx
  0015f	8b cd		 mov	 ecx, ebp
  00161	50		 push	 eax
  00162	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN20@getFieldLi
  00168	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0016d	58		 pop	 eax
  0016e	5a		 pop	 edx
  0016f	5f		 pop	 edi
  00170	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00173	33 cd		 xor	 ecx, ebp
  00175	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017a	81 c4 1c 02 00
	00		 add	 esp, 540		; 0000021cH
  00180	3b ec		 cmp	 ebp, esp
  00182	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00187	8b e5		 mov	 esp, ebp
  00189	5d		 pop	 ebp
  0018a	c3		 ret	 0
  0018b	90		 npad	 1
$LN20@getFieldLi:
  0018c	01 00 00 00	 DD	 1
  00190	00 00 00 00	 DD	 $LN19@getFieldLi
$LN19@getFieldLi:
  00194	f0 fd ff ff	 DD	 -528			; fffffdf0H
  00198	00 02 00 00	 DD	 512			; 00000200H
  0019c	00 00 00 00	 DD	 $LN18@getFieldLi
$LN18@getFieldLi:
  001a0	77		 DB	 119			; 00000077H
  001a1	6f		 DB	 111			; 0000006fH
  001a2	72		 DB	 114			; 00000072H
  001a3	64		 DB	 100			; 00000064H
  001a4	00		 DB	 0
?getFieldList@CFileUtil@@SA_NPADDPAVCStringList@@@Z ENDP ; CFileUtil::getFieldList
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
_TEXT	SEGMENT
_bEnd$ = -13						; size = 1
_pNextLine$ = -12					; size = 4
_nBufSize$ = -8						; size = 4
_nSize$ = -4						; size = 4
_pInfo$ = 8						; size = 4
?getNextLine@CFileUtil@@SAHPAUSTStrInfo@@@Z PROC	; CFileUtil::getNextLine

; 526  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 527  : 	int nSize = 0, nBufSize;  //g_nChSize

  00017	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _nSize$[ebp], 0

; 528  : 	TCHAR *pNextLine = _tcschr(pInfo->pSource, g_rc);

  0001e	6a 0a		 push	 10			; 0000000aH
  00020	8b 45 08	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00023	8b 08		 mov	 ecx, DWORD PTR [eax]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ?_tcschr@@YAPADPADI@Z	; _tcschr
  0002b	83 c4 08	 add	 esp, 8
  0002e	89 45 f4	 mov	 DWORD PTR _pNextLine$[ebp], eax

; 529  : 	bool bEnd = false;

  00031	c6 45 f3 00	 mov	 BYTE PTR _bEnd$[ebp], 0

; 530  : 
; 531  : 	if (pNextLine) {

  00035	83 7d f4 00	 cmp	 DWORD PTR _pNextLine$[ebp], 0
  00039	74 10		 je	 SHORT $LN2@getNextLin

; 532  : 		nSize = (int)(pNextLine - pInfo->pSource) + 1;

  0003b	8b 55 08	 mov	 edx, DWORD PTR _pInfo$[ebp]
  0003e	8b 45 f4	 mov	 eax, DWORD PTR _pNextLine$[ebp]
  00041	2b 02		 sub	 eax, DWORD PTR [edx]
  00043	83 c0 01	 add	 eax, 1
  00046	89 45 fc	 mov	 DWORD PTR _nSize$[ebp], eax

; 533  : 	}
; 534  : 	else {

  00049	eb 2f		 jmp	 SHORT $LN3@getNextLin
$LN2@getNextLin:

; 535  : 		pNextLine = _tcschr(pInfo->pSource, 0);

  0004b	6a 00		 push	 0
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR _pInfo$[ebp]
  00050	8b 11		 mov	 edx, DWORD PTR [ecx]
  00052	52		 push	 edx
  00053	e8 00 00 00 00	 call	 ?_tcschr@@YAPADPADI@Z	; _tcschr
  00058	83 c4 08	 add	 esp, 8
  0005b	89 45 f4	 mov	 DWORD PTR _pNextLine$[ebp], eax

; 536  : 		if(!pNextLine) return 0;

  0005e	83 7d f4 00	 cmp	 DWORD PTR _pNextLine$[ebp], 0
  00062	75 07		 jne	 SHORT $LN4@getNextLin
  00064	33 c0		 xor	 eax, eax
  00066	e9 d2 00 00 00	 jmp	 $LN1@getNextLin
$LN4@getNextLin:

; 537  : 		nSize = (int)(pNextLine - pInfo->pSource);

  0006b	8b 45 08	 mov	 eax, DWORD PTR _pInfo$[ebp]
  0006e	8b 4d f4	 mov	 ecx, DWORD PTR _pNextLine$[ebp]
  00071	2b 08		 sub	 ecx, DWORD PTR [eax]
  00073	89 4d fc	 mov	 DWORD PTR _nSize$[ebp], ecx

; 538  : 		bEnd = true;

  00076	c6 45 f3 01	 mov	 BYTE PTR _bEnd$[ebp], 1
$LN3@getNextLin:

; 539  : 	}
; 540  : 
; 541  : 	*pNextLine = 0;

  0007a	8b 55 f4	 mov	 edx, DWORD PTR _pNextLine$[ebp]
  0007d	c6 02 00	 mov	 BYTE PTR [edx], 0

; 542  : 	nBufSize = nSize * g_nChSize;

  00080	8b 45 fc	 mov	 eax, DWORD PTR _nSize$[ebp]
  00083	89 45 f8	 mov	 DWORD PTR _nBufSize$[ebp], eax

; 543  : 	if (pInfo->aBufSize < nBufSize) {

  00086	8b 4d 08	 mov	 ecx, DWORD PTR _pInfo$[ebp]
  00089	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0008c	3b 55 f8	 cmp	 edx, DWORD PTR _nBufSize$[ebp]
  0008f	7d 7b		 jge	 SHORT $LN5@getNextLin

; 544  : 		if (pInfo->aBufSize) {

  00091	8b 45 08	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00094	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00098	74 19		 je	 SHORT $LN6@getNextLin

; 545  : 			gs_pMMgr->delBuf(pInfo->pTarget, pInfo->aBufSize);

  0009a	8b 4d 08	 mov	 ecx, DWORD PTR _pInfo$[ebp]
  0009d	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000a0	52		 push	 edx
  000a1	8b 45 08	 mov	 eax, DWORD PTR _pInfo$[ebp]
  000a4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000a7	51		 push	 ecx
  000a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pMMgr@@3PAVCMemManager@@A ; gs_pMMgr
  000ae	e8 00 00 00 00	 call	 ?delBuf@CMemManager@@QAEXPADH@Z ; CMemManager::delBuf
$LN6@getNextLin:

; 546  : 		}
; 547  : 		nBufSize += 1024; // Allocating enough space

  000b3	8b 55 f8	 mov	 edx, DWORD PTR _nBufSize$[ebp]
  000b6	81 c2 00 04 00
	00		 add	 edx, 1024		; 00000400H
  000bc	89 55 f8	 mov	 DWORD PTR _nBufSize$[ebp], edx

; 548  : 		pInfo->pTarget = gs_pMMgr->newBuf(nBufSize);

  000bf	8b 45 f8	 mov	 eax, DWORD PTR _nBufSize$[ebp]
  000c2	50		 push	 eax
  000c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pMMgr@@3PAVCMemManager@@A ; gs_pMMgr
  000c9	e8 00 00 00 00	 call	 ?newBuf@CMemManager@@QAEPADH@Z ; CMemManager::newBuf
  000ce	8b 4d 08	 mov	 ecx, DWORD PTR _pInfo$[ebp]
  000d1	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 549  : 		if (!pInfo->pTarget) {

  000d4	8b 55 08	 mov	 edx, DWORD PTR _pInfo$[ebp]
  000d7	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  000db	75 26		 jne	 SHORT $LN7@getNextLin

; 550  : 			pInfo->aBufSize = 0;

  000dd	8b 45 08	 mov	 eax, DWORD PTR _pInfo$[ebp]
  000e0	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 551  : 			gs_cLogger.PutLogQueue(LEVEL_ERROR, _T("CFileUtil::getNextLine gs_pMMgr->newBuf error! size[%ld]"), nBufSize);

  000e7	8b 4d f8	 mov	 ecx, DWORD PTR _nBufSize$[ebp]
  000ea	51		 push	 ecx
  000eb	68 00 00 00 00	 push	 OFFSET $SG86812
  000f0	6a 05		 push	 5
  000f2	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  000f7	e8 00 00 00 00	 call	 ?PutLogQueue@CLogger@@QAAXHPBDZZ ; CLogger::PutLogQueue
  000fc	83 c4 10	 add	 esp, 16			; 00000010H

; 552  : 			return 0;

  000ff	33 c0		 xor	 eax, eax
  00101	eb 3a		 jmp	 SHORT $LN1@getNextLin
$LN7@getNextLin:

; 553  : 		}
; 554  : 		pInfo->aBufSize = nBufSize;

  00103	8b 55 08	 mov	 edx, DWORD PTR _pInfo$[ebp]
  00106	8b 45 f8	 mov	 eax, DWORD PTR _nBufSize$[ebp]
  00109	89 42 08	 mov	 DWORD PTR [edx+8], eax
$LN5@getNextLin:

; 555  : 	}
; 556  : 
; 557  : 	_tcscpy(pInfo->pTarget, pInfo->pSource);

  0010c	8b 4d 08	 mov	 ecx, DWORD PTR _pInfo$[ebp]
  0010f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00111	52		 push	 edx
  00112	8b 45 08	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00115	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00118	51		 push	 ecx
  00119	e8 00 00 00 00	 call	 _strcpy
  0011e	83 c4 08	 add	 esp, 8

; 558  : 	if (bEnd) return 0;

  00121	0f b6 55 f3	 movzx	 edx, BYTE PTR _bEnd$[ebp]
  00125	85 d2		 test	 edx, edx
  00127	74 04		 je	 SHORT $LN8@getNextLin
  00129	33 c0		 xor	 eax, eax
  0012b	eb 10		 jmp	 SHORT $LN1@getNextLin
$LN8@getNextLin:

; 559  : 	pInfo->pSource += nSize;

  0012d	8b 45 08	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00130	8b 08		 mov	 ecx, DWORD PTR [eax]
  00132	03 4d fc	 add	 ecx, DWORD PTR _nSize$[ebp]
  00135	8b 55 08	 mov	 edx, DWORD PTR _pInfo$[ebp]
  00138	89 0a		 mov	 DWORD PTR [edx], ecx

; 560  : 	return nSize;

  0013a	8b 45 fc	 mov	 eax, DWORD PTR _nSize$[ebp]
$LN1@getNextLin:

; 561  : }

  0013d	83 c4 10	 add	 esp, 16			; 00000010H
  00140	3b ec		 cmp	 ebp, esp
  00142	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00147	8b e5		 mov	 esp, ebp
  00149	5d		 pop	 ebp
  0014a	c3		 ret	 0
?getNextLine@CFileUtil@@SAHPAUSTStrInfo@@@Z ENDP	; CFileUtil::getNextLine
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
_TEXT	SEGMENT
_nBufSize$ = -20					; size = 4
_nPos$ = -16						; size = 4
_nRead$ = -12						; size = 4
_nSize$ = -8						; size = 4
_pFile$ = -4						; size = 4
_pFilePath$ = 8						; size = 4
_pBuf$ = 12						; size = 4
_aBufSize$ = 16						; size = 4
?readNalloc@CFileUtil@@SAHPADPAPADPAH@Z PROC		; CFileUtil::readNalloc

; 487  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000f	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00012	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00015	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00018	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 488  : 	FILE *pFile = _tfopen(pFilePath, _T("rb"));

  0001b	8b f4		 mov	 esi, esp
  0001d	68 00 00 00 00	 push	 OFFSET $SG86788
  00022	8b 45 08	 mov	 eax, DWORD PTR _pFilePath$[ebp]
  00025	50		 push	 eax
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  0002c	83 c4 08	 add	 esp, 8
  0002f	3b f4		 cmp	 esi, esp
  00031	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00036	89 45 fc	 mov	 DWORD PTR _pFile$[ebp], eax

; 489  : 	int nSize = 0, nRead, nPos=0, nBufSize;

  00039	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _nSize$[ebp], 0
  00040	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _nPos$[ebp], 0

; 490  : 
; 491  : 	if (!pFile) {

  00047	83 7d fc 00	 cmp	 DWORD PTR _pFile$[ebp], 0
  0004b	75 1f		 jne	 SHORT $LN4@readNalloc

; 492  : 		gs_cLogger.PutLogQueue(LEVEL_ERROR, _T("CDFSFile::read pFile open FAIL [%s]"), pFilePath);

  0004d	8b 4d 08	 mov	 ecx, DWORD PTR _pFilePath$[ebp]
  00050	51		 push	 ecx
  00051	68 00 00 00 00	 push	 OFFSET $SG86790
  00056	6a 05		 push	 5
  00058	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  0005d	e8 00 00 00 00	 call	 ?PutLogQueue@CLogger@@QAAXHPBDZZ ; CLogger::PutLogQueue
  00062	83 c4 10	 add	 esp, 16			; 00000010H

; 493  : 		return 0;

  00065	33 c0		 xor	 eax, eax
  00067	e9 48 01 00 00	 jmp	 $LN1@readNalloc
$LN4@readNalloc:

; 494  : 	}
; 495  : 	fseek(pFile, 0, SEEK_END);

  0006c	8b f4		 mov	 esi, esp
  0006e	6a 02		 push	 2
  00070	6a 00		 push	 0
  00072	8b 55 fc	 mov	 edx, DWORD PTR _pFile$[ebp]
  00075	52		 push	 edx
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007f	3b f4		 cmp	 esi, esp
  00081	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 496  : 	nSize = ftell(pFile);

  00086	8b f4		 mov	 esi, esp
  00088	8b 45 fc	 mov	 eax, DWORD PTR _pFile$[ebp]
  0008b	50		 push	 eax
  0008c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ftell
  00092	83 c4 04	 add	 esp, 4
  00095	3b f4		 cmp	 esi, esp
  00097	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009c	89 45 f8	 mov	 DWORD PTR _nSize$[ebp], eax

; 497  : 	fseek(pFile, 0, SEEK_SET);

  0009f	8b f4		 mov	 esi, esp
  000a1	6a 00		 push	 0
  000a3	6a 00		 push	 0
  000a5	8b 4d fc	 mov	 ecx, DWORD PTR _pFile$[ebp]
  000a8	51		 push	 ecx
  000a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  000af	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b2	3b f4		 cmp	 esi, esp
  000b4	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 498  : 
; 499  : 	nBufSize = nSize + 1;

  000b9	8b 55 f8	 mov	 edx, DWORD PTR _nSize$[ebp]
  000bc	83 c2 01	 add	 edx, 1
  000bf	89 55 ec	 mov	 DWORD PTR _nBufSize$[ebp], edx

; 500  : 	if (*aBufSize < nBufSize) {

  000c2	8b 45 10	 mov	 eax, DWORD PTR _aBufSize$[ebp]
  000c5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c7	3b 4d ec	 cmp	 ecx, DWORD PTR _nBufSize$[ebp]
  000ca	7d 62		 jge	 SHORT $LN2@readNalloc

; 501  : 		if (*aBufSize) {

  000cc	8b 55 10	 mov	 edx, DWORD PTR _aBufSize$[ebp]
  000cf	83 3a 00	 cmp	 DWORD PTR [edx], 0
  000d2	74 17		 je	 SHORT $LN6@readNalloc

; 502  : 			gs_pMMgr->delBuf(*pBuf, *aBufSize);

  000d4	8b 45 10	 mov	 eax, DWORD PTR _aBufSize$[ebp]
  000d7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d9	51		 push	 ecx
  000da	8b 55 0c	 mov	 edx, DWORD PTR _pBuf$[ebp]
  000dd	8b 02		 mov	 eax, DWORD PTR [edx]
  000df	50		 push	 eax
  000e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pMMgr@@3PAVCMemManager@@A ; gs_pMMgr
  000e6	e8 00 00 00 00	 call	 ?delBuf@CMemManager@@QAEXPADH@Z ; CMemManager::delBuf
$LN6@readNalloc:

; 503  : 		}
; 504  : 		*pBuf = gs_pMMgr->newBuf(nBufSize);

  000eb	8b 4d ec	 mov	 ecx, DWORD PTR _nBufSize$[ebp]
  000ee	51		 push	 ecx
  000ef	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pMMgr@@3PAVCMemManager@@A ; gs_pMMgr
  000f5	e8 00 00 00 00	 call	 ?newBuf@CMemManager@@QAEPADH@Z ; CMemManager::newBuf
  000fa	8b 55 0c	 mov	 edx, DWORD PTR _pBuf$[ebp]
  000fd	89 02		 mov	 DWORD PTR [edx], eax

; 505  : 		if (!*pBuf) {

  000ff	8b 45 0c	 mov	 eax, DWORD PTR _pBuf$[ebp]
  00102	83 38 00	 cmp	 DWORD PTR [eax], 0
  00105	75 1f		 jne	 SHORT $LN7@readNalloc

; 506  : 			gs_cLogger.PutLogQueue(LEVEL_ERROR, _T("CFileUtil::readNalloc malloc error! size[%ld]"), nBufSize);

  00107	8b 4d ec	 mov	 ecx, DWORD PTR _nBufSize$[ebp]
  0010a	51		 push	 ecx
  0010b	68 00 00 00 00	 push	 OFFSET $SG86794
  00110	6a 05		 push	 5
  00112	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  00117	e8 00 00 00 00	 call	 ?PutLogQueue@CLogger@@QAAXHPBDZZ ; CLogger::PutLogQueue
  0011c	83 c4 10	 add	 esp, 16			; 00000010H

; 507  : 			return 0;

  0011f	33 c0		 xor	 eax, eax
  00121	e9 8e 00 00 00	 jmp	 $LN1@readNalloc
$LN7@readNalloc:

; 508  : 		}
; 509  : 		*aBufSize = nBufSize;

  00126	8b 55 10	 mov	 edx, DWORD PTR _aBufSize$[ebp]
  00129	8b 45 ec	 mov	 eax, DWORD PTR _nBufSize$[ebp]
  0012c	89 02		 mov	 DWORD PTR [edx], eax
$LN2@readNalloc:

; 510  : 	}
; 511  : 
; 512  : 	while ((nRead = (int)fread(*pBuf + nPos, 1, nSize - nPos, pFile)) > 0)

  0012e	8b f4		 mov	 esi, esp
  00130	8b 4d fc	 mov	 ecx, DWORD PTR _pFile$[ebp]
  00133	51		 push	 ecx
  00134	8b 55 f8	 mov	 edx, DWORD PTR _nSize$[ebp]
  00137	2b 55 f0	 sub	 edx, DWORD PTR _nPos$[ebp]
  0013a	52		 push	 edx
  0013b	6a 01		 push	 1
  0013d	8b 45 0c	 mov	 eax, DWORD PTR _pBuf$[ebp]
  00140	8b 08		 mov	 ecx, DWORD PTR [eax]
  00142	03 4d f0	 add	 ecx, DWORD PTR _nPos$[ebp]
  00145	51		 push	 ecx
  00146	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  0014c	83 c4 10	 add	 esp, 16			; 00000010H
  0014f	3b f4		 cmp	 esi, esp
  00151	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00156	89 45 f4	 mov	 DWORD PTR _nRead$[ebp], eax
  00159	83 7d f4 00	 cmp	 DWORD PTR _nRead$[ebp], 0
  0015d	7e 0b		 jle	 SHORT $LN3@readNalloc

; 513  : 	{
; 514  : 		nPos += nRead;

  0015f	8b 55 f0	 mov	 edx, DWORD PTR _nPos$[ebp]
  00162	03 55 f4	 add	 edx, DWORD PTR _nRead$[ebp]
  00165	89 55 f0	 mov	 DWORD PTR _nPos$[ebp], edx

; 515  : 	}

  00168	eb c4		 jmp	 SHORT $LN2@readNalloc
$LN3@readNalloc:

; 516  : 
; 517  : 	if (!nPos) {

  0016a	83 7d f0 00	 cmp	 DWORD PTR _nPos$[ebp], 0
  0016e	75 1f		 jne	 SHORT $LN8@readNalloc

; 518  : 		printf("fread errno[%d]\n", errno);

  00170	8b f4		 mov	 esi, esp
  00172	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  00178	3b f4		 cmp	 esi, esp
  0017a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0017f	8b 00		 mov	 eax, DWORD PTR [eax]
  00181	50		 push	 eax
  00182	68 00 00 00 00	 push	 OFFSET $SG86796
  00187	e8 00 00 00 00	 call	 _printf
  0018c	83 c4 08	 add	 esp, 8
$LN8@readNalloc:

; 519  : 	}
; 520  : 	(*pBuf)[nPos] = 0;

  0018f	8b 4d 0c	 mov	 ecx, DWORD PTR _pBuf$[ebp]
  00192	8b 11		 mov	 edx, DWORD PTR [ecx]
  00194	8b 45 f0	 mov	 eax, DWORD PTR _nPos$[ebp]
  00197	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0

; 521  : 	fclose(pFile);

  0019b	8b f4		 mov	 esi, esp
  0019d	8b 4d fc	 mov	 ecx, DWORD PTR _pFile$[ebp]
  001a0	51		 push	 ecx
  001a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  001a7	83 c4 04	 add	 esp, 4
  001aa	3b f4		 cmp	 esi, esp
  001ac	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 522  : 	return nSize;

  001b1	8b 45 f8	 mov	 eax, DWORD PTR _nSize$[ebp]
$LN1@readNalloc:

; 523  : }

  001b4	5e		 pop	 esi
  001b5	83 c4 14	 add	 esp, 20			; 00000014H
  001b8	3b ec		 cmp	 ebp, esp
  001ba	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001bf	8b e5		 mov	 esp, ebp
  001c1	5d		 pop	 ebp
  001c2	c3		 ret	 0
?readNalloc@CFileUtil@@SAHPADPAPADPAH@Z ENDP		; CFileUtil::readNalloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
_TEXT	SEGMENT
_nSize$ = -8						; size = 4
_pFile$ = -4						; size = 4
_pFilePath$ = 8						; size = 4
_pBuf$ = 12						; size = 4
_nFileSize$ = 16					; size = 4
?read@CFileUtil@@SAHPAD0H@Z PROC			; CFileUtil::read

; 384  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 385  : 	FILE *pFile = _tfopen(pFilePath, _T("rb"));

  00015	8b f4		 mov	 esi, esp
  00017	68 00 00 00 00	 push	 OFFSET $SG86643
  0001c	8b 45 08	 mov	 eax, DWORD PTR _pFilePath$[ebp]
  0001f	50		 push	 eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00026	83 c4 08	 add	 esp, 8
  00029	3b f4		 cmp	 esi, esp
  0002b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00030	89 45 fc	 mov	 DWORD PTR _pFile$[ebp], eax

; 386  : 	int nSize = 0;

  00033	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _nSize$[ebp], 0

; 387  : 
; 388  : 	if (!pFile) {

  0003a	83 7d fc 00	 cmp	 DWORD PTR _pFile$[ebp], 0
  0003e	75 1c		 jne	 SHORT $LN2@read

; 389  : 		gs_cLogger.PutLogQueue(LEVEL_ERROR, _T("CDFSFile::read pFile open FAIL [%s]"), pFilePath);

  00040	8b 4d 08	 mov	 ecx, DWORD PTR _pFilePath$[ebp]
  00043	51		 push	 ecx
  00044	68 00 00 00 00	 push	 OFFSET $SG86645
  00049	6a 05		 push	 5
  0004b	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  00050	e8 00 00 00 00	 call	 ?PutLogQueue@CLogger@@QAAXHPBDZZ ; CLogger::PutLogQueue
  00055	83 c4 10	 add	 esp, 16			; 00000010H

; 390  : 		return 0;

  00058	33 c0		 xor	 eax, eax
  0005a	eb 45		 jmp	 SHORT $LN1@read
$LN2@read:

; 391  : 	}
; 392  : 	nSize = (int)fread(pBuf, g_nChSize, nFileSize, pFile);

  0005c	8b f4		 mov	 esi, esp
  0005e	8b 55 fc	 mov	 edx, DWORD PTR _pFile$[ebp]
  00061	52		 push	 edx
  00062	8b 45 10	 mov	 eax, DWORD PTR _nFileSize$[ebp]
  00065	50		 push	 eax
  00066	6a 01		 push	 1
  00068	8b 4d 0c	 mov	 ecx, DWORD PTR _pBuf$[ebp]
  0006b	51		 push	 ecx
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  00072	83 c4 10	 add	 esp, 16			; 00000010H
  00075	3b f4		 cmp	 esi, esp
  00077	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007c	89 45 f8	 mov	 DWORD PTR _nSize$[ebp], eax

; 393  : 	pBuf[nSize] = 0;

  0007f	8b 55 0c	 mov	 edx, DWORD PTR _pBuf$[ebp]
  00082	03 55 f8	 add	 edx, DWORD PTR _nSize$[ebp]
  00085	c6 02 00	 mov	 BYTE PTR [edx], 0

; 394  : 	fclose(pFile);

  00088	8b f4		 mov	 esi, esp
  0008a	8b 45 fc	 mov	 eax, DWORD PTR _pFile$[ebp]
  0008d	50		 push	 eax
  0008e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00094	83 c4 04	 add	 esp, 4
  00097	3b f4		 cmp	 esi, esp
  00099	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 395  : 	return nSize;

  0009e	8b 45 f8	 mov	 eax, DWORD PTR _nSize$[ebp]
$LN1@read:

; 396  : }

  000a1	5e		 pop	 esi
  000a2	83 c4 08	 add	 esp, 8
  000a5	3b ec		 cmp	 ebp, esp
  000a7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c3		 ret	 0
?read@CFileUtil@@SAHPAD0H@Z ENDP			; CFileUtil::read
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
_TEXT	SEGMENT
_pOriDir$ = 8						; size = 4
_pNewDir$ = 12						; size = 4
?changeDirName@CFileUtil@@SA_NPAD0@Z PROC		; CFileUtil::changeDirName

; 374  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 375  : 	MakeDirectory(pNewDir);

  00004	8b 45 0c	 mov	 eax, DWORD PTR _pNewDir$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?MakeDirectory@CFileUtil@@SA_NPBD@Z ; CFileUtil::MakeDirectory
  0000d	83 c4 04	 add	 esp, 4

; 376  : 	if ( _trename(pOriDir, pNewDir) != 0 ) {

  00010	8b f4		 mov	 esi, esp
  00012	8b 4d 0c	 mov	 ecx, DWORD PTR _pNewDir$[ebp]
  00015	51		 push	 ecx
  00016	8b 55 08	 mov	 edx, DWORD PTR _pOriDir$[ebp]
  00019	52		 push	 edx
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__rename
  00020	83 c4 08	 add	 esp, 8
  00023	3b f4		 cmp	 esi, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	85 c0		 test	 eax, eax
  0002c	74 04		 je	 SHORT $LN2@changeDirN

; 377  : 		return false;

  0002e	32 c0		 xor	 al, al
  00030	eb 02		 jmp	 SHORT $LN1@changeDirN
$LN2@changeDirN:

; 378  : 	}
; 379  : 	return true;

  00032	b0 01		 mov	 al, 1
$LN1@changeDirN:

; 380  : }

  00034	5e		 pop	 esi
  00035	3b ec		 cmp	 ebp, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?changeDirName@CFileUtil@@SA_NPAD0@Z ENDP		; CFileUtil::changeDirName
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
_TEXT	SEGMENT
_i$ = -12						; size = 4
_pRear$ = -8						; size = 4
_nLen$ = -4						; size = 4
_pDir$ = 8						; size = 4
_upCount$ = 12						; size = 4
?setDirectory@CFileUtil@@SA_NPADH@Z PROC		; CFileUtil::setDirectory

; 251  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 252  : 	if (!pDir) {

  0001b	83 7d 08 00	 cmp	 DWORD PTR _pDir$[ebp], 0
  0001f	75 07		 jne	 SHORT $LN5@setDirecto

; 253  : 		return false;

  00021	32 c0		 xor	 al, al
  00023	e9 84 00 00 00	 jmp	 $LN1@setDirecto
$LN5@setDirecto:

; 254  : 	}
; 255  : 	size_t	nLen = (int)_tcslen(pDir);

  00028	8b 45 08	 mov	 eax, DWORD PTR _pDir$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _strlen
  00031	83 c4 04	 add	 esp, 4
  00034	89 45 fc	 mov	 DWORD PTR _nLen$[ebp], eax

; 256  : 	char *pRear = pDir;

  00037	8b 4d 08	 mov	 ecx, DWORD PTR _pDir$[ebp]
  0003a	89 4d f8	 mov	 DWORD PTR _pRear$[ebp], ecx

; 257  : 
; 258  : 	int i;
; 259  : 	for (i = 0; i < upCount; i++) {

  0003d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00044	eb 09		 jmp	 SHORT $LN4@setDirecto
$LN2@setDirecto:
  00046	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  00049	83 c2 01	 add	 edx, 1
  0004c	89 55 f4	 mov	 DWORD PTR _i$[ebp], edx
$LN4@setDirecto:
  0004f	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00052	3b 45 0c	 cmp	 eax, DWORD PTR _upCount$[ebp]
  00055	7d 19		 jge	 SHORT $LN3@setDirecto

; 260  : 		pRear = _tcsrchr((TCHAR *)pDir, g_s);

  00057	6a 5c		 push	 92			; 0000005cH
  00059	8b 4d 08	 mov	 ecx, DWORD PTR _pDir$[ebp]
  0005c	51		 push	 ecx
  0005d	e8 00 00 00 00	 call	 ?_tcsrchr@@YAPADPADI@Z	; _tcsrchr
  00062	83 c4 08	 add	 esp, 8
  00065	89 45 f8	 mov	 DWORD PTR _pRear$[ebp], eax

; 261  : 		*pRear = 0;

  00068	8b 55 f8	 mov	 edx, DWORD PTR _pRear$[ebp]
  0006b	c6 02 00	 mov	 BYTE PTR [edx], 0

; 262  : 	}

  0006e	eb d6		 jmp	 SHORT $LN2@setDirecto
$LN3@setDirecto:

; 263  : 
; 264  : 	pRear = _tcsrchr((TCHAR *)pDir, g_s);

  00070	6a 5c		 push	 92			; 0000005cH
  00072	8b 45 08	 mov	 eax, DWORD PTR _pDir$[ebp]
  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 ?_tcsrchr@@YAPADPADI@Z	; _tcsrchr
  0007b	83 c4 08	 add	 esp, 8
  0007e	89 45 f8	 mov	 DWORD PTR _pRear$[ebp], eax

; 265  : 	nLen = pRear - pDir + 1;

  00081	8b 4d f8	 mov	 ecx, DWORD PTR _pRear$[ebp]
  00084	2b 4d 08	 sub	 ecx, DWORD PTR _pDir$[ebp]
  00087	83 c1 01	 add	 ecx, 1
  0008a	89 4d fc	 mov	 DWORD PTR _nLen$[ebp], ecx

; 266  : 
; 267  : 	_tcsncpy(pDir, pDir, nLen); pDir[nLen] = 0;

  0008d	8b 55 fc	 mov	 edx, DWORD PTR _nLen$[ebp]
  00090	52		 push	 edx
  00091	8b 45 08	 mov	 eax, DWORD PTR _pDir$[ebp]
  00094	50		 push	 eax
  00095	8b 4d 08	 mov	 ecx, DWORD PTR _pDir$[ebp]
  00098	51		 push	 ecx
  00099	e8 00 00 00 00	 call	 __tcsncpy
  0009e	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a1	8b 55 08	 mov	 edx, DWORD PTR _pDir$[ebp]
  000a4	03 55 fc	 add	 edx, DWORD PTR _nLen$[ebp]
  000a7	c6 02 00	 mov	 BYTE PTR [edx], 0

; 268  : 	return true;

  000aa	b0 01		 mov	 al, 1
$LN1@setDirecto:

; 269  : }

  000ac	83 c4 0c	 add	 esp, 12			; 0000000cH
  000af	3b ec		 cmp	 ebp, esp
  000b1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
?setDirectory@CFileUtil@@SA_NPADH@Z ENDP		; CFileUtil::setDirectory
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
_TEXT	SEGMENT
_pPath$ = 8						; size = 4
?IsAbsolutePath@CFileUtil@@SA_NPBD@Z PROC		; CFileUtil::IsAbsolutePath

; 329  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 330  : 	if (!pPath)

  00003	83 7d 08 00	 cmp	 DWORD PTR _pPath$[ebp], 0
  00007	75 04		 jne	 SHORT $LN2@IsAbsolute

; 331  : 		return false;

  00009	32 c0		 xor	 al, al
  0000b	eb 44		 jmp	 SHORT $LN1@IsAbsolute
$LN2@IsAbsolute:

; 332  : 
; 333  : 	if (pPath[1] == ':' || pPath[0] == '\\' || pPath[0] == '/')

  0000d	b8 01 00 00 00	 mov	 eax, 1
  00012	c1 e0 00	 shl	 eax, 0
  00015	8b 4d 08	 mov	 ecx, DWORD PTR _pPath$[ebp]
  00018	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  0001c	83 fa 3a	 cmp	 edx, 58			; 0000003aH
  0001f	74 28		 je	 SHORT $LN5@IsAbsolute
  00021	b8 01 00 00 00	 mov	 eax, 1
  00026	6b c8 00	 imul	 ecx, eax, 0
  00029	8b 55 08	 mov	 edx, DWORD PTR _pPath$[ebp]
  0002c	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00030	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  00033	74 14		 je	 SHORT $LN5@IsAbsolute
  00035	b9 01 00 00 00	 mov	 ecx, 1
  0003a	6b d1 00	 imul	 edx, ecx, 0
  0003d	8b 45 08	 mov	 eax, DWORD PTR _pPath$[ebp]
  00040	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  00044	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  00047	75 06		 jne	 SHORT $LN3@IsAbsolute
$LN5@IsAbsolute:

; 334  : 		return true;

  00049	b0 01		 mov	 al, 1
  0004b	eb 04		 jmp	 SHORT $LN1@IsAbsolute

; 335  : 	else

  0004d	eb 02		 jmp	 SHORT $LN1@IsAbsolute
$LN3@IsAbsolute:

; 336  : 		return false;

  0004f	32 c0		 xor	 al, al
$LN1@IsAbsolute:

; 337  : }

  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
?IsAbsolutePath@CFileUtil@@SA_NPBD@Z ENDP		; CFileUtil::IsAbsolutePath
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
_TEXT	SEGMENT
_outFp$ = -8216						; size = 4
_inFp$ = -8212						; size = 4
_nLen$ = -8208						; size = 4
_szBuf$ = -8200						; size = 8192
__$ArrayPad$ = -4					; size = 4
_szSrc$ = 8						; size = 4
_szDest$ = 12						; size = 4
?FileCopy@CFileUtil@@SA_NPBD0@Z PROC			; CFileUtil::FileCopy

; 341  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 18 20 00 00	 mov	 eax, 8216		; 00002018H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	8d bd e8 df ff
	ff		 lea	 edi, DWORD PTR [ebp-8216]
  00015	b9 06 08 00 00	 mov	 ecx, 2054		; 00000806H
  0001a	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001f	f3 ab		 rep stosd
  00021	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00026	33 c5		 xor	 eax, ebp
  00028	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 342  : 
; 343  : 	TCHAR	szBuf[8192];
; 344  : 	size_t	nLen;
; 345  : 	FILE *inFp=NULL, *outFp=NULL;

  0002b	c7 85 ec df ff
	ff 00 00 00 00	 mov	 DWORD PTR _inFp$[ebp], 0
  00035	c7 85 e8 df ff
	ff 00 00 00 00	 mov	 DWORD PTR _outFp$[ebp], 0

; 346  : 
; 347  : 	inFp = _tfopen(szSrc, _T("rb"));

  0003f	8b f4		 mov	 esi, esp
  00041	68 00 00 00 00	 push	 OFFSET $SG86625
  00046	8b 45 08	 mov	 eax, DWORD PTR _szSrc$[ebp]
  00049	50		 push	 eax
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00050	83 c4 08	 add	 esp, 8
  00053	3b f4		 cmp	 esi, esp
  00055	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005a	89 85 ec df ff
	ff		 mov	 DWORD PTR _inFp$[ebp], eax

; 348  : 	if(!inFp) {

  00060	83 bd ec df ff
	ff 00		 cmp	 DWORD PTR _inFp$[ebp], 0
  00067	75 07		 jne	 SHORT $LN4@FileCopy

; 349  : 		return false;

  00069	32 c0		 xor	 al, al
  0006b	e9 1a 01 00 00	 jmp	 $LN1@FileCopy
$LN4@FileCopy:

; 350  : 	}
; 351  : 
; 352  : 	outFp = _tfopen(szDest, _T("wb+"));

  00070	8b f4		 mov	 esi, esp
  00072	68 00 00 00 00	 push	 OFFSET $SG86627
  00077	8b 4d 0c	 mov	 ecx, DWORD PTR _szDest$[ebp]
  0007a	51		 push	 ecx
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00081	83 c4 08	 add	 esp, 8
  00084	3b f4		 cmp	 esi, esp
  00086	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008b	89 85 e8 df ff
	ff		 mov	 DWORD PTR _outFp$[ebp], eax

; 353  : 	if(!outFp) {

  00091	83 bd e8 df ff
	ff 00		 cmp	 DWORD PTR _outFp$[ebp], 0
  00098	75 20		 jne	 SHORT $LN5@FileCopy

; 354  : 		fclose(inFp);

  0009a	8b f4		 mov	 esi, esp
  0009c	8b 95 ec df ff
	ff		 mov	 edx, DWORD PTR _inFp$[ebp]
  000a2	52		 push	 edx
  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  000a9	83 c4 04	 add	 esp, 4
  000ac	3b f4		 cmp	 esi, esp
  000ae	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 355  : 		return false;

  000b3	32 c0		 xor	 al, al
  000b5	e9 d0 00 00 00	 jmp	 $LN1@FileCopy
$LN5@FileCopy:

; 356  : 	}
; 357  : 
; 358  : 	nLen = fread(szBuf, g_nChSize, sizeof(szBuf), inFp);

  000ba	8b f4		 mov	 esi, esp
  000bc	8b 85 ec df ff
	ff		 mov	 eax, DWORD PTR _inFp$[ebp]
  000c2	50		 push	 eax
  000c3	68 00 20 00 00	 push	 8192			; 00002000H
  000c8	6a 01		 push	 1
  000ca	8d 8d f8 df ff
	ff		 lea	 ecx, DWORD PTR _szBuf$[ebp]
  000d0	51		 push	 ecx
  000d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  000d7	83 c4 10	 add	 esp, 16			; 00000010H
  000da	3b f4		 cmp	 esi, esp
  000dc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e1	89 85 f0 df ff
	ff		 mov	 DWORD PTR _nLen$[ebp], eax
$LN2@FileCopy:

; 359  : 	while (0 < nLen) 

  000e7	83 bd f0 df ff
	ff 00		 cmp	 DWORD PTR _nLen$[ebp], 0
  000ee	76 66		 jbe	 SHORT $LN3@FileCopy

; 360  :     {
; 361  : 		fwrite(szBuf, g_nChSize, nLen, outFp);

  000f0	8b f4		 mov	 esi, esp
  000f2	8b 95 e8 df ff
	ff		 mov	 edx, DWORD PTR _outFp$[ebp]
  000f8	52		 push	 edx
  000f9	8b 85 f0 df ff
	ff		 mov	 eax, DWORD PTR _nLen$[ebp]
  000ff	50		 push	 eax
  00100	6a 01		 push	 1
  00102	8d 8d f8 df ff
	ff		 lea	 ecx, DWORD PTR _szBuf$[ebp]
  00108	51		 push	 ecx
  00109	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  0010f	83 c4 10	 add	 esp, 16			; 00000010H
  00112	3b f4		 cmp	 esi, esp
  00114	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 362  : 		if (nLen < sizeof(szBuf))

  00119	81 bd f0 df ff
	ff 00 20 00 00	 cmp	 DWORD PTR _nLen$[ebp], 8192 ; 00002000H
  00123	73 02		 jae	 SHORT $LN6@FileCopy

; 363  : 			break;

  00125	eb 2f		 jmp	 SHORT $LN3@FileCopy
$LN6@FileCopy:

; 364  : 
; 365  :         nLen = fread(szBuf, g_nChSize, sizeof(szBuf), inFp);

  00127	8b f4		 mov	 esi, esp
  00129	8b 95 ec df ff
	ff		 mov	 edx, DWORD PTR _inFp$[ebp]
  0012f	52		 push	 edx
  00130	68 00 20 00 00	 push	 8192			; 00002000H
  00135	6a 01		 push	 1
  00137	8d 85 f8 df ff
	ff		 lea	 eax, DWORD PTR _szBuf$[ebp]
  0013d	50		 push	 eax
  0013e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  00144	83 c4 10	 add	 esp, 16			; 00000010H
  00147	3b f4		 cmp	 esi, esp
  00149	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0014e	89 85 f0 df ff
	ff		 mov	 DWORD PTR _nLen$[ebp], eax

; 366  : 	}

  00154	eb 91		 jmp	 SHORT $LN2@FileCopy
$LN3@FileCopy:

; 367  : 
; 368  : 	fclose(inFp);

  00156	8b f4		 mov	 esi, esp
  00158	8b 8d ec df ff
	ff		 mov	 ecx, DWORD PTR _inFp$[ebp]
  0015e	51		 push	 ecx
  0015f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00165	83 c4 04	 add	 esp, 4
  00168	3b f4		 cmp	 esi, esp
  0016a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 369  : 	fclose(outFp);

  0016f	8b f4		 mov	 esi, esp
  00171	8b 95 e8 df ff
	ff		 mov	 edx, DWORD PTR _outFp$[ebp]
  00177	52		 push	 edx
  00178	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  0017e	83 c4 04	 add	 esp, 4
  00181	3b f4		 cmp	 esi, esp
  00183	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 370  : 	return true;

  00188	b0 01		 mov	 al, 1
$LN1@FileCopy:

; 371  : }

  0018a	52		 push	 edx
  0018b	8b cd		 mov	 ecx, ebp
  0018d	50		 push	 eax
  0018e	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN10@FileCopy
  00194	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00199	58		 pop	 eax
  0019a	5a		 pop	 edx
  0019b	5f		 pop	 edi
  0019c	5e		 pop	 esi
  0019d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a0	33 cd		 xor	 ecx, ebp
  001a2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a7	81 c4 18 20 00
	00		 add	 esp, 8216		; 00002018H
  001ad	3b ec		 cmp	 ebp, esp
  001af	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001b4	8b e5		 mov	 esp, ebp
  001b6	5d		 pop	 ebp
  001b7	c3		 ret	 0
$LN10@FileCopy:
  001b8	01 00 00 00	 DD	 1
  001bc	00 00 00 00	 DD	 $LN9@FileCopy
$LN9@FileCopy:
  001c0	f8 df ff ff	 DD	 -8200			; ffffdff8H
  001c4	00 20 00 00	 DD	 8192			; 00002000H
  001c8	00 00 00 00	 DD	 $LN8@FileCopy
$LN8@FileCopy:
  001cc	73		 DB	 115			; 00000073H
  001cd	7a		 DB	 122			; 0000007aH
  001ce	42		 DB	 66			; 00000042H
  001cf	75		 DB	 117			; 00000075H
  001d0	66		 DB	 102			; 00000066H
  001d1	00		 DB	 0
?FileCopy@CFileUtil@@SA_NPBD0@Z ENDP			; CFileUtil::FileCopy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
_TEXT	SEGMENT
$T1 = -304						; size = 4
_szTmp$ = -296						; size = 10
_len$ = -280						; size = 4
_dptr$ = -276						; size = 4
_ptr$ = -272						; size = 4
_tmpBuf$ = -264						; size = 256
__$ArrayPad$ = -4					; size = 4
_dirName$ = 8						; size = 4
?MakeDirectory@CFileUtil@@SA_NPBD@Z PROC		; CFileUtil::MakeDirectory

; 298  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 30 01 00
	00		 sub	 esp, 304		; 00000130H
  00009	57		 push	 edi
  0000a	8d bd d0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-304]
  00010	b9 4c 00 00 00	 mov	 ecx, 76			; 0000004cH
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 299  : 	TCHAR	tmpBuf[MAX_PATH_LEN];
; 300  : 	TCHAR	*ptr, *dptr = (TCHAR *)dirName;

  00026	8b 45 08	 mov	 eax, DWORD PTR _dirName$[ebp]
  00029	89 85 ec fe ff
	ff		 mov	 DWORD PTR _dptr$[ebp], eax

; 301  : 	int	len;	
; 302  : 	CheckDirName((TCHAR*)dirName);

  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _dirName$[ebp]
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 ?CheckDirName@@YAXPAD@Z	; CheckDirName
  00038	83 c4 04	 add	 esp, 4

; 303  : #ifndef WIN32
; 304  : 	TCHAR szTmp[2][5] = {_T("./"), _T("../")};
; 305  : #else
; 306  : 	TCHAR szTmp[2][5] = {_T(".\\"), _T("..\\")};

  0003b	66 8b 15 00 00
	00 00		 mov	 dx, WORD PTR $SG86598
  00042	66 89 95 d8 fe
	ff ff		 mov	 WORD PTR _szTmp$[ebp], dx
  00049	a0 02 00 00 00	 mov	 al, BYTE PTR $SG86598+2
  0004e	88 85 da fe ff
	ff		 mov	 BYTE PTR _szTmp$[ebp+2], al
  00054	33 c9		 xor	 ecx, ecx
  00056	66 89 8d db fe
	ff ff		 mov	 WORD PTR _szTmp$[ebp+3], cx
  0005d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR $SG86599
  00063	89 95 dd fe ff
	ff		 mov	 DWORD PTR _szTmp$[ebp+5], edx
  00069	33 c0		 xor	 eax, eax
  0006b	88 85 e1 fe ff
	ff		 mov	 BYTE PTR _szTmp$[ebp+9], al
$LN2@MakeDirect:

; 307  : #endif
; 308  : 	while (dptr && (ptr = _tcschr(dptr, g_s)))

  00071	83 bd ec fe ff
	ff 00		 cmp	 DWORD PTR _dptr$[ebp], 0
  00078	0f 84 0d 01 00
	00		 je	 $LN3@MakeDirect
  0007e	6a 5c		 push	 92			; 0000005cH
  00080	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _dptr$[ebp]
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 ?_tcschr@@YAPADPADI@Z	; _tcschr
  0008c	83 c4 08	 add	 esp, 8
  0008f	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _ptr$[ebp], eax
  00095	83 bd f0 fe ff
	ff 00		 cmp	 DWORD PTR _ptr$[ebp], 0
  0009c	0f 84 e9 00 00
	00		 je	 $LN3@MakeDirect

; 309  : 	{
; 310  : 		len = (int)(ptr - dirName) + 1;

  000a2	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR _ptr$[ebp]
  000a8	2b 55 08	 sub	 edx, DWORD PTR _dirName$[ebp]
  000ab	83 c2 01	 add	 edx, 1
  000ae	89 95 e8 fe ff
	ff		 mov	 DWORD PTR _len$[ebp], edx

; 311  : 		_tcsncpy(tmpBuf, dirName, len);

  000b4	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _len$[ebp]
  000ba	50		 push	 eax
  000bb	8b 4d 08	 mov	 ecx, DWORD PTR _dirName$[ebp]
  000be	51		 push	 ecx
  000bf	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _tmpBuf$[ebp]
  000c5	52		 push	 edx
  000c6	e8 00 00 00 00	 call	 __tcsncpy
  000cb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 312  : 		tmpBuf[len] = 0;

  000ce	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _len$[ebp]
  000d4	89 85 d0 fe ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  000da	81 bd d0 fe ff
	ff 00 01 00 00	 cmp	 DWORD PTR $T1[ebp], 256	; 00000100H
  000e4	73 02		 jae	 SHORT $LN11@MakeDirect
  000e6	eb 05		 jmp	 SHORT $LN12@MakeDirect
$LN11@MakeDirect:
  000e8	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN12@MakeDirect:
  000ed	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR $T1[ebp]
  000f3	c6 84 0d f8 fe
	ff ff 00	 mov	 BYTE PTR _tmpBuf$[ebp+ecx], 0

; 313  : 
; 314  : 		if (strcmp(tmpBuf, szTmp[0]) && strcmp(tmpBuf, szTmp[1])) {

  000fb	ba 05 00 00 00	 mov	 edx, 5
  00100	6b c2 00	 imul	 eax, edx, 0
  00103	8d 8c 05 d8 fe
	ff ff		 lea	 ecx, DWORD PTR _szTmp$[ebp+eax]
  0010a	51		 push	 ecx
  0010b	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _tmpBuf$[ebp]
  00111	52		 push	 edx
  00112	e8 00 00 00 00	 call	 _strcmp
  00117	83 c4 08	 add	 esp, 8
  0011a	85 c0		 test	 eax, eax
  0011c	74 55		 je	 SHORT $LN4@MakeDirect
  0011e	b8 05 00 00 00	 mov	 eax, 5
  00123	c1 e0 00	 shl	 eax, 0
  00126	8d 8c 05 d8 fe
	ff ff		 lea	 ecx, DWORD PTR _szTmp$[ebp+eax]
  0012d	51		 push	 ecx
  0012e	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _tmpBuf$[ebp]
  00134	52		 push	 edx
  00135	e8 00 00 00 00	 call	 _strcmp
  0013a	83 c4 08	 add	 esp, 8
  0013d	85 c0		 test	 eax, eax
  0013f	74 32		 je	 SHORT $LN4@MakeDirect

; 315  : 			if (com_isInvalid(tmpBuf)) {

  00141	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _tmpBuf$[ebp]
  00147	50		 push	 eax
  00148	e8 00 00 00 00	 call	 ?com_isInvalid@@YA_NPBD@Z ; com_isInvalid
  0014d	83 c4 04	 add	 esp, 4
  00150	0f b6 c8	 movzx	 ecx, al
  00153	85 c9		 test	 ecx, ecx
  00155	74 1a		 je	 SHORT $LN6@MakeDirect

; 316  : 				if (!com_mkdir(tmpBuf)) goto MDIR_ERROR;

  00157	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _tmpBuf$[ebp]
  0015d	52		 push	 edx
  0015e	e8 00 00 00 00	 call	 ?com_mkdir@@YA_NPBD@Z	; com_mkdir
  00163	83 c4 04	 add	 esp, 4
  00166	0f b6 c0	 movzx	 eax, al
  00169	85 c0		 test	 eax, eax
  0016b	75 04		 jne	 SHORT $LN6@MakeDirect
  0016d	eb 20		 jmp	 SHORT $MDIR_ERROR$17
  0016f	eb 1e		 jmp	 SHORT $MDIR_ERROR$17
$LN6@MakeDirect:

; 317  : 			}
; 318  : 		}
; 319  : 		else goto MDIR_ERROR;

  00171	eb 04		 jmp	 SHORT $LN5@MakeDirect
$LN4@MakeDirect:
  00173	eb 1a		 jmp	 SHORT $MDIR_ERROR$17
  00175	eb 18		 jmp	 SHORT $MDIR_ERROR$17
$LN5@MakeDirect:

; 320  : 		dptr = ptr + 1;

  00177	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR _ptr$[ebp]
  0017d	83 c1 01	 add	 ecx, 1
  00180	89 8d ec fe ff
	ff		 mov	 DWORD PTR _dptr$[ebp], ecx

; 321  : 	}

  00186	e9 e6 fe ff ff	 jmp	 $LN2@MakeDirect
$LN3@MakeDirect:

; 322  : 	return true;

  0018b	b0 01		 mov	 al, 1
  0018d	eb 27		 jmp	 SHORT $LN10@MakeDirect
$MDIR_ERROR$17:

; 323  : MDIR_ERROR:
; 324  : 	gs_cLogger.DebugLog(LEVEL_ERROR, "com_mkdir has Failed! [%s]", tmpBuf);

  0018f	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _tmpBuf$[ebp]
  00195	52		 push	 edx
  00196	68 00 00 00 00	 push	 OFFSET $SG86606
  0019b	68 44 01 00 00	 push	 324			; 00000144H
  001a0	68 00 00 00 00	 push	 OFFSET $SG86607
  001a5	6a 05		 push	 5
  001a7	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  001ac	e8 00 00 00 00	 call	 ?__debugLog@CLogger@@QAAXHPBDH0ZZ ; CLogger::__debugLog
  001b1	83 c4 18	 add	 esp, 24			; 00000018H

; 325  : 	return false;

  001b4	32 c0		 xor	 al, al
$LN10@MakeDirect:

; 326  : }

  001b6	52		 push	 edx
  001b7	8b cd		 mov	 ecx, ebp
  001b9	50		 push	 eax
  001ba	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN16@MakeDirect
  001c0	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001c5	58		 pop	 eax
  001c6	5a		 pop	 edx
  001c7	5f		 pop	 edi
  001c8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001cb	33 cd		 xor	 ecx, ebp
  001cd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001d2	81 c4 30 01 00
	00		 add	 esp, 304		; 00000130H
  001d8	3b ec		 cmp	 ebp, esp
  001da	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001df	8b e5		 mov	 esp, ebp
  001e1	5d		 pop	 ebp
  001e2	c3		 ret	 0
  001e3	90		 npad	 1
$LN16@MakeDirect:
  001e4	02 00 00 00	 DD	 2
  001e8	00 00 00 00	 DD	 $LN15@MakeDirect
$LN15@MakeDirect:
  001ec	f8 fe ff ff	 DD	 -264			; fffffef8H
  001f0	00 01 00 00	 DD	 256			; 00000100H
  001f4	00 00 00 00	 DD	 $LN13@MakeDirect
  001f8	d8 fe ff ff	 DD	 -296			; fffffed8H
  001fc	0a 00 00 00	 DD	 10			; 0000000aH
  00200	00 00 00 00	 DD	 $LN14@MakeDirect
$LN14@MakeDirect:
  00204	73		 DB	 115			; 00000073H
  00205	7a		 DB	 122			; 0000007aH
  00206	54		 DB	 84			; 00000054H
  00207	6d		 DB	 109			; 0000006dH
  00208	70		 DB	 112			; 00000070H
  00209	00		 DB	 0
$LN13@MakeDirect:
  0020a	74		 DB	 116			; 00000074H
  0020b	6d		 DB	 109			; 0000006dH
  0020c	70		 DB	 112			; 00000070H
  0020d	42		 DB	 66			; 00000042H
  0020e	75		 DB	 117			; 00000075H
  0020f	66		 DB	 102			; 00000066H
  00210	00		 DB	 0
?MakeDirectory@CFileUtil@@SA_NPBD@Z ENDP		; CFileUtil::MakeDirectory
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
_TEXT	SEGMENT
tv193 = -980						; size = 4
$T2 = -976						; size = 4
$T3 = -972						; size = 4
$T4 = -968						; size = 4
$T5 = -964						; size = 4
$T6 = -960						; size = 4
$T7 = -956						; size = 4
_filterList$ = -952					; size = 4
_pRes$ = -948						; size = 4
_stSubDir$ = -940					; size = 12
_cFTime$ = -920						; size = 8
_bDirectory$ = -905					; size = 1
_nResult$ = -904					; size = 4
_nCount$ = -900						; size = 4
_szSubDir$ = -892					; size = 128
_szDir$ = -756						; size = 128
_filePath$ = -620					; size = 256
_fname$ = -356						; size = 4
_file$ = -344						; size = 320
_dir$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pData$ = 8						; size = 4
_filter$ = 12						; size = 4
?delDirectory@CFileUtil@@SAHPAUSTDelInfo@@PAUSTFilterData@@@Z PROC ; CFileUtil::delDirectory

; 149  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?delDirectory@CFileUtil@@SAHPAUSTDelInfo@@PAUSTFilterData@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec c8 03 00
	00		 sub	 esp, 968		; 000003c8H
  00017	56		 push	 esi
  00018	57		 push	 edi
  00019	8d bd 2c fc ff
	ff		 lea	 edi, DWORD PTR [ebp-980]
  0001f	b9 f2 00 00 00	 mov	 ecx, 242		; 000000f2H
  00024	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00029	f3 ab		 rep stosd
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 150  : 	JPDIR dir;
; 151  : 	JFILEDATA  file;
; 152  : 	TCHAR	*fname = NULL, filePath[256], szDir[128], szSubDir[128];

  0003f	c7 85 9c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _fname$[ebp], 0

; 153  : 	int nCount = 0, nResult;

  00049	c7 85 7c fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _nCount$[ebp], 0

; 154  : 	bool bDirectory = false;

  00053	c6 85 77 fc ff
	ff 00		 mov	 BYTE PTR _bDirectory$[ebp], 0

; 155  : 	CFileTime cFTime;

  0005a	8d 8d 68 fc ff
	ff		 lea	 ecx, DWORD PTR _cFTime$[ebp]
  00060	e8 00 00 00 00	 call	 ??0CFileTime@@QAE@XZ	; CFileTime::CFileTime
  00065	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 156  : 	STDelInfo stSubDir;
; 157  : 	void *pRes = NULL;

  0006c	c7 85 4c fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _pRes$[ebp], 0

; 158  : 	CStringList *filterList = NULL;

  00076	c7 85 48 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _filterList$[ebp], 0

; 159  : 
; 160  : #ifndef WIN32
; 161  : 	struct  stat st;
; 162  : #endif
; 163  : 
; 164  : 	if (!pData->root) {

  00080	8b 45 08	 mov	 eax, DWORD PTR _pData$[ebp]
  00083	83 38 00	 cmp	 DWORD PTR [eax], 0
  00086	75 27		 jne	 SHORT $LN4@delDirecto

; 165  : 		// TODO LOG
; 166  : 		return 0;

  00088	c7 85 44 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp], 0
  00092	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00099	8d 8d 68 fc ff
	ff		 lea	 ecx, DWORD PTR _cFTime$[ebp]
  0009f	e8 00 00 00 00	 call	 ??1CFileTime@@QAE@XZ	; CFileTime::~CFileTime
  000a4	8b 85 44 fc ff
	ff		 mov	 eax, DWORD PTR $T7[ebp]
  000aa	e9 e5 03 00 00	 jmp	 $LN1@delDirecto
$LN4@delDirecto:

; 167  : 	}
; 168  : 	_tcscpy(szDir, pData->root);

  000af	8b 4d 08	 mov	 ecx, DWORD PTR _pData$[ebp]
  000b2	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b4	52		 push	 edx
  000b5	8d 85 0c fd ff
	ff		 lea	 eax, DWORD PTR _szDir$[ebp]
  000bb	50		 push	 eax
  000bc	e8 00 00 00 00	 call	 _strcpy
  000c1	83 c4 08	 add	 esp, 8

; 169  : 
; 170  : 	if (!IsExistDirectory(szDir)) return 0;

  000c4	8d 8d 0c fd ff
	ff		 lea	 ecx, DWORD PTR _szDir$[ebp]
  000ca	51		 push	 ecx
  000cb	e8 00 00 00 00	 call	 ?IsExistDirectory@CFileUtil@@SA_NPAD@Z ; CFileUtil::IsExistDirectory
  000d0	83 c4 04	 add	 esp, 4
  000d3	0f b6 d0	 movzx	 edx, al
  000d6	85 d2		 test	 edx, edx
  000d8	75 27		 jne	 SHORT $LN5@delDirecto
  000da	c7 85 40 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp], 0
  000e4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000eb	8d 8d 68 fc ff
	ff		 lea	 ecx, DWORD PTR _cFTime$[ebp]
  000f1	e8 00 00 00 00	 call	 ??1CFileTime@@QAE@XZ	; CFileTime::~CFileTime
  000f6	8b 85 40 fc ff
	ff		 mov	 eax, DWORD PTR $T6[ebp]
  000fc	e9 93 03 00 00	 jmp	 $LN1@delDirecto
$LN5@delDirecto:

; 171  : 
; 172  : 
; 173  : 	dir = com_findFirstFile(szDir, &file);

  00101	8d 85 a8 fe ff
	ff		 lea	 eax, DWORD PTR _file$[ebp]
  00107	50		 push	 eax
  00108	8d 8d 0c fd ff
	ff		 lea	 ecx, DWORD PTR _szDir$[ebp]
  0010e	51		 push	 ecx
  0010f	e8 00 00 00 00	 call	 ?com_findFirstFile@@YAPAXPBDPAU_WIN32_FIND_DATAA@@@Z ; com_findFirstFile
  00114	83 c4 08	 add	 esp, 8
  00117	89 45 ec	 mov	 DWORD PTR _dir$[ebp], eax

; 174  : 	if (0 >= dir) return 0;

  0011a	83 7d ec 00	 cmp	 DWORD PTR _dir$[ebp], 0
  0011e	77 27		 ja	 SHORT $LN2@delDirecto
  00120	c7 85 3c fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp], 0
  0012a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00131	8d 8d 68 fc ff
	ff		 lea	 ecx, DWORD PTR _cFTime$[ebp]
  00137	e8 00 00 00 00	 call	 ??1CFileTime@@QAE@XZ	; CFileTime::~CFileTime
  0013c	8b 85 3c fc ff
	ff		 mov	 eax, DWORD PTR $T5[ebp]
  00142	e9 4d 03 00 00	 jmp	 $LN1@delDirecto
$LN2@delDirecto:

; 175  : 	while (com_nextFile(dir, &file))

  00147	8d 95 a8 fe ff
	ff		 lea	 edx, DWORD PTR _file$[ebp]
  0014d	52		 push	 edx
  0014e	8b 45 ec	 mov	 eax, DWORD PTR _dir$[ebp]
  00151	50		 push	 eax
  00152	e8 00 00 00 00	 call	 ?com_nextFile@@YA_NPAXPAU_WIN32_FIND_DATAA@@@Z ; com_nextFile
  00157	83 c4 08	 add	 esp, 8
  0015a	0f b6 c8	 movzx	 ecx, al
  0015d	85 c9		 test	 ecx, ecx
  0015f	0f 84 41 02 00
	00		 je	 $LN3@delDirecto

; 176  : 	{
; 177  : 		com_getFileName(&fname, &file);

  00165	8d 95 a8 fe ff
	ff		 lea	 edx, DWORD PTR _file$[ebp]
  0016b	52		 push	 edx
  0016c	8d 85 9c fe ff
	ff		 lea	 eax, DWORD PTR _fname$[ebp]
  00172	50		 push	 eax
  00173	e8 00 00 00 00	 call	 ?com_getFileName@@YAXPAPADPAU_WIN32_FIND_DATAA@@@Z ; com_getFileName
  00178	83 c4 08	 add	 esp, 8

; 178  : 		if (_tcscmp(fname, _T(".")) == 0
; 179  : 			|| _tcscmp(fname, _T("..")) == 0)

  0017b	68 00 00 00 00	 push	 OFFSET $SG86453
  00180	8b 8d 9c fe ff
	ff		 mov	 ecx, DWORD PTR _fname$[ebp]
  00186	51		 push	 ecx
  00187	e8 00 00 00 00	 call	 __tcscmp
  0018c	83 c4 08	 add	 esp, 8
  0018f	85 c0		 test	 eax, eax
  00191	74 18		 je	 SHORT $LN8@delDirecto
  00193	68 00 00 00 00	 push	 OFFSET $SG86454
  00198	8b 95 9c fe ff
	ff		 mov	 edx, DWORD PTR _fname$[ebp]
  0019e	52		 push	 edx
  0019f	e8 00 00 00 00	 call	 __tcscmp
  001a4	83 c4 08	 add	 esp, 8
  001a7	85 c0		 test	 eax, eax
  001a9	75 02		 jne	 SHORT $LN7@delDirecto
$LN8@delDirecto:

; 180  : 			continue;

  001ab	eb 9a		 jmp	 SHORT $LN2@delDirecto
$LN7@delDirecto:

; 181  : 
; 182  : 		_stprintf(filePath, _T("%s%s"), pData->root, fname);

  001ad	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR _fname$[ebp]
  001b3	50		 push	 eax
  001b4	8b 4d 08	 mov	 ecx, DWORD PTR _pData$[ebp]
  001b7	8b 11		 mov	 edx, DWORD PTR [ecx]
  001b9	52		 push	 edx
  001ba	68 00 00 00 00	 push	 OFFSET $SG86455
  001bf	8d 85 94 fd ff
	ff		 lea	 eax, DWORD PTR _filePath$[ebp]
  001c5	50		 push	 eax
  001c6	e8 00 00 00 00	 call	 _sprintf
  001cb	83 c4 10	 add	 esp, 16			; 00000010H

; 183  : #ifndef WIN32 // -- only unix
; 184  : 		stat(filePath, &st);
; 185  : 		if (com_ISDIR(&st)) bDirectory = true;
; 186  : 		if (filter) {
; 187  : 			if (filter->pFunc == filter_dateTimeCompare) { cFTime.setFileTime(st.st_mtime); pRes = &cFTime; }
; 188  : 			else if (filter->pFunc == filter_stringCompare) { pRes = filterList; }
; 189  : 		}
; 190  : #else
; 191  : 		cFTime.setFileTime(&file.ftLastWriteTime);

  001ce	8d 8d bc fe ff
	ff		 lea	 ecx, DWORD PTR _file$[ebp+20]
  001d4	51		 push	 ecx
  001d5	8d 8d 68 fc ff
	ff		 lea	 ecx, DWORD PTR _cFTime$[ebp]
  001db	e8 00 00 00 00	 call	 ?setFileTime@CFileTime@@QAEHPAU_FILETIME@@@Z ; CFileTime::setFileTime

; 192  : 		// windows
; 193  : 		if (com_ISDIR(&file)) bDirectory = true;

  001e0	8d 95 a8 fe ff
	ff		 lea	 edx, DWORD PTR _file$[ebp]
  001e6	52		 push	 edx
  001e7	e8 00 00 00 00	 call	 ?jISDIR@@YA_NPAU_WIN32_FIND_DATAA@@@Z ; jISDIR
  001ec	83 c4 04	 add	 esp, 4
  001ef	0f b6 c0	 movzx	 eax, al
  001f2	85 c0		 test	 eax, eax
  001f4	74 07		 je	 SHORT $LN9@delDirecto
  001f6	c6 85 77 fc ff
	ff 01		 mov	 BYTE PTR _bDirectory$[ebp], 1
$LN9@delDirecto:

; 194  : 		if (filter) {

  001fd	83 7d 0c 00	 cmp	 DWORD PTR _filter$[ebp], 0
  00201	74 30		 je	 SHORT $LN10@delDirecto

; 195  : 			if (filter->pFunc == filter_dateTimeCompare) { 

  00203	8b 4d 0c	 mov	 ecx, DWORD PTR _filter$[ebp]
  00206	81 39 00 00 00
	00		 cmp	 DWORD PTR [ecx], OFFSET ?filter_dateTimeCompare@@YA_NPADPAX1@Z ; filter_dateTimeCompare
  0020c	75 0e		 jne	 SHORT $LN11@delDirecto

; 196  : 				//cFTime.setFileTime(filePath); 
; 197  : 				pRes = &cFTime; 

  0020e	8d 95 68 fc ff
	ff		 lea	 edx, DWORD PTR _cFTime$[ebp]
  00214	89 95 4c fc ff
	ff		 mov	 DWORD PTR _pRes$[ebp], edx
  0021a	eb 17		 jmp	 SHORT $LN10@delDirecto
$LN11@delDirecto:

; 198  : 			}
; 199  : 			else if (filter->pFunc == filter_stringCompare) { pRes = filterList; }

  0021c	8b 45 0c	 mov	 eax, DWORD PTR _filter$[ebp]
  0021f	81 38 00 00 00
	00		 cmp	 DWORD PTR [eax], OFFSET ?filter_stringCompare@@YA_NPADPAX1@Z ; filter_stringCompare
  00225	75 0c		 jne	 SHORT $LN10@delDirecto
  00227	8b 8d 48 fc ff
	ff		 mov	 ecx, DWORD PTR _filterList$[ebp]
  0022d	89 8d 4c fc ff
	ff		 mov	 DWORD PTR _pRes$[ebp], ecx
$LN10@delDirecto:

; 200  : 		}
; 201  : #endif
; 202  : 
; 203  : 		if (bDirectory) {

  00233	0f b6 95 77 fc
	ff ff		 movzx	 edx, BYTE PTR _bDirectory$[ebp]
  0023a	85 d2		 test	 edx, edx
  0023c	74 6e		 je	 SHORT $LN14@delDirecto

; 204  : 			if (pData->nFlag & DIR_RECURSIVE) {

  0023e	8b 45 08	 mov	 eax, DWORD PTR _pData$[ebp]
  00241	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00244	83 e1 01	 and	 ecx, 1
  00247	74 5e		 je	 SHORT $LN16@delDirecto

; 205  : 				_stprintf(szSubDir, _T("%s%s%c"), pData->root, fname, g_s);

  00249	6a 5c		 push	 92			; 0000005cH
  0024b	8b 95 9c fe ff
	ff		 mov	 edx, DWORD PTR _fname$[ebp]
  00251	52		 push	 edx
  00252	8b 45 08	 mov	 eax, DWORD PTR _pData$[ebp]
  00255	8b 08		 mov	 ecx, DWORD PTR [eax]
  00257	51		 push	 ecx
  00258	68 00 00 00 00	 push	 OFFSET $SG86464
  0025d	8d 95 84 fc ff
	ff		 lea	 edx, DWORD PTR _szSubDir$[ebp]
  00263	52		 push	 edx
  00264	e8 00 00 00 00	 call	 _sprintf
  00269	83 c4 14	 add	 esp, 20			; 00000014H

; 206  : 				memcpy(&stSubDir, pData, sizeof(STDelInfo));

  0026c	6a 0c		 push	 12			; 0000000cH
  0026e	8b 45 08	 mov	 eax, DWORD PTR _pData$[ebp]
  00271	50		 push	 eax
  00272	8d 8d 54 fc ff
	ff		 lea	 ecx, DWORD PTR _stSubDir$[ebp]
  00278	51		 push	 ecx
  00279	e8 00 00 00 00	 call	 _memcpy
  0027e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 207  : 				stSubDir.root = szSubDir;

  00281	8d 95 84 fc ff
	ff		 lea	 edx, DWORD PTR _szSubDir$[ebp]
  00287	89 95 54 fc ff
	ff		 mov	 DWORD PTR _stSubDir$[ebp], edx

; 208  : 				delDirectory(&stSubDir, filter);

  0028d	8b 45 0c	 mov	 eax, DWORD PTR _filter$[ebp]
  00290	50		 push	 eax
  00291	8d 8d 54 fc ff
	ff		 lea	 ecx, DWORD PTR _stSubDir$[ebp]
  00297	51		 push	 ecx
  00298	e8 00 00 00 00	 call	 ?delDirectory@CFileUtil@@SAHPAUSTDelInfo@@PAUSTFilterData@@@Z ; CFileUtil::delDirectory
  0029d	83 c4 08	 add	 esp, 8

; 209  : 				bDirectory = false;

  002a0	c6 85 77 fc ff
	ff 00		 mov	 BYTE PTR _bDirectory$[ebp], 0
$LN16@delDirecto:

; 210  : 			}
; 211  : 		}
; 212  : 		else {

  002a7	e9 f5 00 00 00	 jmp	 $LN15@delDirecto
$LN14@delDirecto:

; 213  : 			if (filter) {

  002ac	83 7d 0c 00	 cmp	 DWORD PTR _filter$[ebp], 0
  002b0	74 47		 je	 SHORT $LN17@delDirecto

; 214  : 				if (filter->pFunc(fname, filter->pData, pRes)) nResult = 1;

  002b2	8b f4		 mov	 esi, esp
  002b4	8b 95 4c fc ff
	ff		 mov	 edx, DWORD PTR _pRes$[ebp]
  002ba	52		 push	 edx
  002bb	8b 45 0c	 mov	 eax, DWORD PTR _filter$[ebp]
  002be	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002c1	51		 push	 ecx
  002c2	8b 95 9c fe ff
	ff		 mov	 edx, DWORD PTR _fname$[ebp]
  002c8	52		 push	 edx
  002c9	8b 45 0c	 mov	 eax, DWORD PTR _filter$[ebp]
  002cc	8b 08		 mov	 ecx, DWORD PTR [eax]
  002ce	ff d1		 call	 ecx
  002d0	83 c4 0c	 add	 esp, 12			; 0000000cH
  002d3	3b f4		 cmp	 esi, esp
  002d5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002da	0f b6 d0	 movzx	 edx, al
  002dd	85 d2		 test	 edx, edx
  002df	74 0c		 je	 SHORT $LN19@delDirecto
  002e1	c7 85 78 fc ff
	ff 01 00 00 00	 mov	 DWORD PTR _nResult$[ebp], 1
  002eb	eb 0a		 jmp	 SHORT $LN20@delDirecto
$LN19@delDirecto:

; 215  : 				else nResult = 0;

  002ed	c7 85 78 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _nResult$[ebp], 0
$LN20@delDirecto:
  002f7	eb 0a		 jmp	 SHORT $LN18@delDirecto
$LN17@delDirecto:

; 216  : 			}
; 217  : 			else nResult = 1;

  002f9	c7 85 78 fc ff
	ff 01 00 00 00	 mov	 DWORD PTR _nResult$[ebp], 1
$LN18@delDirecto:

; 218  : 
; 219  : 
; 220  : 			if (nResult) {

  00303	83 bd 78 fc ff
	ff 00		 cmp	 DWORD PTR _nResult$[ebp], 0
  0030a	0f 84 91 00 00
	00		 je	 $LN15@delDirecto

; 221  : 				nResult = _tremove(filePath);

  00310	8b f4		 mov	 esi, esp
  00312	8d 85 94 fd ff
	ff		 lea	 eax, DWORD PTR _filePath$[ebp]
  00318	50		 push	 eax
  00319	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__remove
  0031f	83 c4 04	 add	 esp, 4
  00322	3b f4		 cmp	 esi, esp
  00324	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00329	89 85 78 fc ff
	ff		 mov	 DWORD PTR _nResult$[ebp], eax

; 222  : 				if (nResult < 0) {

  0032f	83 bd 78 fc ff
	ff 00		 cmp	 DWORD PTR _nResult$[ebp], 0
  00336	7d 2e		 jge	 SHORT $LN22@delDirecto

; 223  : 					// TODO ERROR LOG
; 224  : 					gs_cLogger.DebugLog(LEVEL_WARN, _T("FAILED _tremove[%s] nResult[%d]"), filePath, nResult);

  00338	8b 8d 78 fc ff
	ff		 mov	 ecx, DWORD PTR _nResult$[ebp]
  0033e	51		 push	 ecx
  0033f	8d 95 94 fd ff
	ff		 lea	 edx, DWORD PTR _filePath$[ebp]
  00345	52		 push	 edx
  00346	68 00 00 00 00	 push	 OFFSET $SG86472
  0034b	68 e0 00 00 00	 push	 224			; 000000e0H
  00350	68 00 00 00 00	 push	 OFFSET $SG86473
  00355	6a 04		 push	 4
  00357	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  0035c	e8 00 00 00 00	 call	 ?__debugLog@CLogger@@QAAXHPBDH0ZZ ; CLogger::__debugLog
  00361	83 c4 1c	 add	 esp, 28			; 0000001cH

; 225  : 				}
; 226  : 				else {

  00364	eb 2c		 jmp	 SHORT $LN23@delDirecto
$LN22@delDirecto:

; 227  : 					gs_cLogger.DebugLog(LEVEL_INFO, _T("SUCCESS _tremove[%s] nResult[%d]"), filePath, nResult);

  00366	8b 85 78 fc ff
	ff		 mov	 eax, DWORD PTR _nResult$[ebp]
  0036c	50		 push	 eax
  0036d	8d 8d 94 fd ff
	ff		 lea	 ecx, DWORD PTR _filePath$[ebp]
  00373	51		 push	 ecx
  00374	68 00 00 00 00	 push	 OFFSET $SG86474
  00379	68 e3 00 00 00	 push	 227			; 000000e3H
  0037e	68 00 00 00 00	 push	 OFFSET $SG86475
  00383	6a 03		 push	 3
  00385	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  0038a	e8 00 00 00 00	 call	 ?__debugLog@CLogger@@QAAXHPBDH0ZZ ; CLogger::__debugLog
  0038f	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN23@delDirecto:

; 228  : 				}
; 229  : 				// TODO TRACE LOG
; 230  : 				nCount++;

  00392	8b 95 7c fc ff
	ff		 mov	 edx, DWORD PTR _nCount$[ebp]
  00398	83 c2 01	 add	 edx, 1
  0039b	89 95 7c fc ff
	ff		 mov	 DWORD PTR _nCount$[ebp], edx
$LN15@delDirecto:

; 231  : 			}
; 232  : 		}
; 233  : 	}

  003a1	e9 a1 fd ff ff	 jmp	 $LN2@delDirecto
$LN3@delDirecto:

; 234  : 	com_dirclose(dir);

  003a6	8b f4		 mov	 esi, esp
  003a8	8b 45 ec	 mov	 eax, DWORD PTR _dir$[ebp]
  003ab	50		 push	 eax
  003ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindClose@4
  003b2	3b f4		 cmp	 esi, esp
  003b4	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 235  : 	if (filterList) delete filterList;

  003b9	83 bd 48 fc ff
	ff 00		 cmp	 DWORD PTR _filterList$[ebp], 0
  003c0	74 40		 je	 SHORT $LN24@delDirecto
  003c2	8b 8d 48 fc ff
	ff		 mov	 ecx, DWORD PTR _filterList$[ebp]
  003c8	89 8d 34 fc ff
	ff		 mov	 DWORD PTR $T3[ebp], ecx
  003ce	8b 95 34 fc ff
	ff		 mov	 edx, DWORD PTR $T3[ebp]
  003d4	89 95 38 fc ff
	ff		 mov	 DWORD PTR $T4[ebp], edx
  003da	83 bd 38 fc ff
	ff 00		 cmp	 DWORD PTR $T4[ebp], 0
  003e1	74 15		 je	 SHORT $LN29@delDirecto
  003e3	6a 01		 push	 1
  003e5	8b 8d 38 fc ff
	ff		 mov	 ecx, DWORD PTR $T4[ebp]
  003eb	e8 00 00 00 00	 call	 ??_GCStringList@@QAEPAXI@Z
  003f0	89 85 2c fc ff
	ff		 mov	 DWORD PTR tv193[ebp], eax
  003f6	eb 0a		 jmp	 SHORT $LN24@delDirecto
$LN29@delDirecto:
  003f8	c7 85 2c fc ff
	ff 00 00 00 00	 mov	 DWORD PTR tv193[ebp], 0
$LN24@delDirecto:

; 236  : 	if (pData->nFlag & DEL_DIRECTORY) {

  00402	8b 45 08	 mov	 eax, DWORD PTR _pData$[ebp]
  00405	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00408	83 e1 02	 and	 ecx, 2
  0040b	74 63		 je	 SHORT $LN25@delDirecto

; 237  : 		if (com_rmdir(pData->root)) {

  0040d	8b f4		 mov	 esi, esp
  0040f	8b 55 08	 mov	 edx, DWORD PTR _pData$[ebp]
  00412	8b 02		 mov	 eax, DWORD PTR [edx]
  00414	50		 push	 eax
  00415	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RemoveDirectoryA@4
  0041b	3b f4		 cmp	 esi, esp
  0041d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00422	85 c0		 test	 eax, eax
  00424	74 26		 je	 SHORT $LN26@delDirecto

; 238  : 			gs_cLogger.DebugLog(LEVEL_INFO, _T("SUCCESS rmdir[%s]"), pData->root);

  00426	8b 4d 08	 mov	 ecx, DWORD PTR _pData$[ebp]
  00429	8b 11		 mov	 edx, DWORD PTR [ecx]
  0042b	52		 push	 edx
  0042c	68 00 00 00 00	 push	 OFFSET $SG86480
  00431	68 ee 00 00 00	 push	 238			; 000000eeH
  00436	68 00 00 00 00	 push	 OFFSET $SG86481
  0043b	6a 03		 push	 3
  0043d	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  00442	e8 00 00 00 00	 call	 ?__debugLog@CLogger@@QAAXHPBDH0ZZ ; CLogger::__debugLog
  00447	83 c4 18	 add	 esp, 24			; 00000018H

; 239  : 		}
; 240  : 		else {

  0044a	eb 24		 jmp	 SHORT $LN25@delDirecto
$LN26@delDirecto:

; 241  : 			gs_cLogger.DebugLog(LEVEL_WARN, _T("FAILED rmdir[%s]"), pData->root);

  0044c	8b 45 08	 mov	 eax, DWORD PTR _pData$[ebp]
  0044f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00451	51		 push	 ecx
  00452	68 00 00 00 00	 push	 OFFSET $SG86482
  00457	68 f1 00 00 00	 push	 241			; 000000f1H
  0045c	68 00 00 00 00	 push	 OFFSET $SG86483
  00461	6a 04		 push	 4
  00463	68 00 00 00 00	 push	 OFFSET ?gs_cLogger@@3VCLogger@@A ; gs_cLogger
  00468	e8 00 00 00 00	 call	 ?__debugLog@CLogger@@QAAXHPBDH0ZZ ; CLogger::__debugLog
  0046d	83 c4 18	 add	 esp, 24			; 00000018H
$LN25@delDirecto:

; 242  : 		}
; 243  : 	}
; 244  : 	return nCount;

  00470	8b 95 7c fc ff
	ff		 mov	 edx, DWORD PTR _nCount$[ebp]
  00476	89 95 30 fc ff
	ff		 mov	 DWORD PTR $T2[ebp], edx
  0047c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00483	8d 8d 68 fc ff
	ff		 lea	 ecx, DWORD PTR _cFTime$[ebp]
  00489	e8 00 00 00 00	 call	 ??1CFileTime@@QAE@XZ	; CFileTime::~CFileTime
  0048e	8b 85 30 fc ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]
$LN1@delDirecto:

; 245  : }

  00494	52		 push	 edx
  00495	8b cd		 mov	 ecx, ebp
  00497	50		 push	 eax
  00498	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN42@delDirecto
  0049e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  004a3	58		 pop	 eax
  004a4	5a		 pop	 edx
  004a5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  004a8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  004af	59		 pop	 ecx
  004b0	5f		 pop	 edi
  004b1	5e		 pop	 esi
  004b2	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004b5	33 cd		 xor	 ecx, ebp
  004b7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004bc	81 c4 d4 03 00
	00		 add	 esp, 980		; 000003d4H
  004c2	3b ec		 cmp	 ebp, esp
  004c4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  004c9	8b e5		 mov	 esp, ebp
  004cb	5d		 pop	 ebp
  004cc	c3		 ret	 0
  004cd	0f 1f 00	 npad	 3
$LN42@delDirecto:
  004d0	07 00 00 00	 DD	 7
  004d4	00 00 00 00	 DD	 $LN41@delDirecto
$LN41@delDirecto:
  004d8	a8 fe ff ff	 DD	 -344			; fffffea8H
  004dc	40 01 00 00	 DD	 320			; 00000140H
  004e0	00 00 00 00	 DD	 $LN33@delDirecto
  004e4	9c fe ff ff	 DD	 -356			; fffffe9cH
  004e8	04 00 00 00	 DD	 4
  004ec	00 00 00 00	 DD	 $LN34@delDirecto
  004f0	94 fd ff ff	 DD	 -620			; fffffd94H
  004f4	00 01 00 00	 DD	 256			; 00000100H
  004f8	00 00 00 00	 DD	 $LN35@delDirecto
  004fc	0c fd ff ff	 DD	 -756			; fffffd0cH
  00500	80 00 00 00	 DD	 128			; 00000080H
  00504	00 00 00 00	 DD	 $LN36@delDirecto
  00508	84 fc ff ff	 DD	 -892			; fffffc84H
  0050c	80 00 00 00	 DD	 128			; 00000080H
  00510	00 00 00 00	 DD	 $LN37@delDirecto
  00514	68 fc ff ff	 DD	 -920			; fffffc68H
  00518	08 00 00 00	 DD	 8
  0051c	00 00 00 00	 DD	 $LN38@delDirecto
  00520	54 fc ff ff	 DD	 -940			; fffffc54H
  00524	0c 00 00 00	 DD	 12			; 0000000cH
  00528	00 00 00 00	 DD	 $LN39@delDirecto
$LN39@delDirecto:
  0052c	73		 DB	 115			; 00000073H
  0052d	74		 DB	 116			; 00000074H
  0052e	53		 DB	 83			; 00000053H
  0052f	75		 DB	 117			; 00000075H
  00530	62		 DB	 98			; 00000062H
  00531	44		 DB	 68			; 00000044H
  00532	69		 DB	 105			; 00000069H
  00533	72		 DB	 114			; 00000072H
  00534	00		 DB	 0
$LN38@delDirecto:
  00535	63		 DB	 99			; 00000063H
  00536	46		 DB	 70			; 00000046H
  00537	54		 DB	 84			; 00000054H
  00538	69		 DB	 105			; 00000069H
  00539	6d		 DB	 109			; 0000006dH
  0053a	65		 DB	 101			; 00000065H
  0053b	00		 DB	 0
$LN37@delDirecto:
  0053c	73		 DB	 115			; 00000073H
  0053d	7a		 DB	 122			; 0000007aH
  0053e	53		 DB	 83			; 00000053H
  0053f	75		 DB	 117			; 00000075H
  00540	62		 DB	 98			; 00000062H
  00541	44		 DB	 68			; 00000044H
  00542	69		 DB	 105			; 00000069H
  00543	72		 DB	 114			; 00000072H
  00544	00		 DB	 0
$LN36@delDirecto:
  00545	73		 DB	 115			; 00000073H
  00546	7a		 DB	 122			; 0000007aH
  00547	44		 DB	 68			; 00000044H
  00548	69		 DB	 105			; 00000069H
  00549	72		 DB	 114			; 00000072H
  0054a	00		 DB	 0
$LN35@delDirecto:
  0054b	66		 DB	 102			; 00000066H
  0054c	69		 DB	 105			; 00000069H
  0054d	6c		 DB	 108			; 0000006cH
  0054e	65		 DB	 101			; 00000065H
  0054f	50		 DB	 80			; 00000050H
  00550	61		 DB	 97			; 00000061H
  00551	74		 DB	 116			; 00000074H
  00552	68		 DB	 104			; 00000068H
  00553	00		 DB	 0
$LN34@delDirecto:
  00554	66		 DB	 102			; 00000066H
  00555	6e		 DB	 110			; 0000006eH
  00556	61		 DB	 97			; 00000061H
  00557	6d		 DB	 109			; 0000006dH
  00558	65		 DB	 101			; 00000065H
  00559	00		 DB	 0
$LN33@delDirecto:
  0055a	66		 DB	 102			; 00000066H
  0055b	69		 DB	 105			; 00000069H
  0055c	6c		 DB	 108			; 0000006cH
  0055d	65		 DB	 101			; 00000065H
  0055e	00		 DB	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?delDirectory@CFileUtil@@SAHPAUSTDelInfo@@PAUSTFilterData@@@Z$0:
  00000	8d 8d 68 fc ff
	ff		 lea	 ecx, DWORD PTR _cFTime$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CFileTime@@QAE@XZ	; CFileTime::~CFileTime
__ehhandler$?delDirectory@CFileUtil@@SAHPAUSTDelInfo@@PAUSTFilterData@@@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a 2c fc ff
	ff		 mov	 ecx, DWORD PTR [edx-980]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?delDirectory@CFileUtil@@SAHPAUSTDelInfo@@PAUSTFilterData@@@Z
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?delDirectory@CFileUtil@@SAHPAUSTDelInfo@@PAUSTFilterData@@@Z ENDP ; CFileUtil::delDirectory
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
_TEXT	SEGMENT
tv152 = -508						; size = 4
$T1 = -504						; size = 4
$T2 = -500						; size = 4
_dirName$ = -492					; size = 128
_nCount$ = -360						; size = 4
_fList$ = -356						; size = 4
_fname$ = -348						; size = 4
_filterList$ = -340					; size = 4
_file$ = -332						; size = 320
_dir$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_pResult$ = 8						; size = 4
_pFilter$ = 12						; size = 4
?GetFileList@CFileUtil@@SA_NPAUSTFileList@@PAUSTFilterData@@@Z PROC ; CFileUtil::GetFileList

; 96   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec fc 01 00
	00		 sub	 esp, 508		; 000001fcH
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd 04 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-508]
  00011	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 97   : 	JPDIR dir;
; 98   : 	JFILEDATA  file;
; 99   : 
; 100  : 	CStringList *filterList = NULL;

  00027	c7 85 ac fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _filterList$[ebp], 0

; 101  : 	TCHAR	*fname= NULL;

  00031	c7 85 a4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _fname$[ebp], 0

; 102  : 	CTList<fileInfo> *fList = NULL;

  0003b	c7 85 9c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _fList$[ebp], 0

; 103  : 	int nCount = 0;

  00045	c7 85 98 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _nCount$[ebp], 0

; 104  : 	TCHAR dirName[128];
; 105  : 
; 106  : 	if (!pResult) return false;

  0004f	83 7d 08 00	 cmp	 DWORD PTR _pResult$[ebp], 0
  00053	75 07		 jne	 SHORT $LN5@GetFileLis
  00055	32 c0		 xor	 al, al
  00057	e9 b7 01 00 00	 jmp	 $LN1@GetFileLis
$LN5@GetFileLis:

; 107  : 	_tcscpy(dirName, pResult->root);

  0005c	8b 45 08	 mov	 eax, DWORD PTR _pResult$[ebp]
  0005f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00061	51		 push	 ecx
  00062	8d 95 14 fe ff
	ff		 lea	 edx, DWORD PTR _dirName$[ebp]
  00068	52		 push	 edx
  00069	e8 00 00 00 00	 call	 _strcpy
  0006e	83 c4 08	 add	 esp, 8

; 108  : 
; 109  : #ifndef WIN32
; 110  : 	struct  stat st;
; 111  : #endif
; 112  : 
; 113  : 	if (!IsExistDirectory(dirName)) return false;

  00071	8d 85 14 fe ff
	ff		 lea	 eax, DWORD PTR _dirName$[ebp]
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 ?IsExistDirectory@CFileUtil@@SA_NPAD@Z ; CFileUtil::IsExistDirectory
  0007d	83 c4 04	 add	 esp, 4
  00080	0f b6 c8	 movzx	 ecx, al
  00083	85 c9		 test	 ecx, ecx
  00085	75 07		 jne	 SHORT $LN6@GetFileLis
  00087	32 c0		 xor	 al, al
  00089	e9 85 01 00 00	 jmp	 $LN1@GetFileLis
$LN6@GetFileLis:

; 114  : 
; 115  : 	dir = com_findFirstFile(dirName, &file);

  0008e	8d 95 b4 fe ff
	ff		 lea	 edx, DWORD PTR _file$[ebp]
  00094	52		 push	 edx
  00095	8d 85 14 fe ff
	ff		 lea	 eax, DWORD PTR _dirName$[ebp]
  0009b	50		 push	 eax
  0009c	e8 00 00 00 00	 call	 ?com_findFirstFile@@YAPAXPBDPAU_WIN32_FIND_DATAA@@@Z ; com_findFirstFile
  000a1	83 c4 08	 add	 esp, 8
  000a4	89 45 f8	 mov	 DWORD PTR _dir$[ebp], eax

; 116  : 	if (0 >= dir) return false;

  000a7	83 7d f8 00	 cmp	 DWORD PTR _dir$[ebp], 0
  000ab	77 07		 ja	 SHORT $LN4@GetFileLis
  000ad	32 c0		 xor	 al, al
  000af	e9 5f 01 00 00	 jmp	 $LN1@GetFileLis
$LN4@GetFileLis:

; 117  : 
; 118  : 	do  {
; 119  : 		com_getFileName(&fname, &file);

  000b4	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR _file$[ebp]
  000ba	51		 push	 ecx
  000bb	8d 95 a4 fe ff
	ff		 lea	 edx, DWORD PTR _fname$[ebp]
  000c1	52		 push	 edx
  000c2	e8 00 00 00 00	 call	 ?com_getFileName@@YAXPAPADPAU_WIN32_FIND_DATAA@@@Z ; com_getFileName
  000c7	83 c4 08	 add	 esp, 8

; 120  : 
; 121  : 		if (_tcscmp(fname, _T(".")) == 0
; 122  : 			|| _tcscmp(fname, _T("..")) == 0)

  000ca	68 00 00 00 00	 push	 OFFSET $SG86412
  000cf	8b 85 a4 fe ff
	ff		 mov	 eax, DWORD PTR _fname$[ebp]
  000d5	50		 push	 eax
  000d6	e8 00 00 00 00	 call	 __tcscmp
  000db	83 c4 08	 add	 esp, 8
  000de	85 c0		 test	 eax, eax
  000e0	74 18		 je	 SHORT $LN9@GetFileLis
  000e2	68 00 00 00 00	 push	 OFFSET $SG86413
  000e7	8b 8d a4 fe ff
	ff		 mov	 ecx, DWORD PTR _fname$[ebp]
  000ed	51		 push	 ecx
  000ee	e8 00 00 00 00	 call	 __tcscmp
  000f3	83 c4 08	 add	 esp, 8
  000f6	85 c0		 test	 eax, eax
  000f8	75 05		 jne	 SHORT $LN8@GetFileLis
$LN9@GetFileLis:

; 123  : 			continue;

  000fa	e9 95 00 00 00	 jmp	 $LN2@GetFileLis
$LN8@GetFileLis:

; 124  : 
; 125  : #ifndef WIN32 // -- only unix
; 126  : 		_stprintf(filePath, _T("%s%s"), szDir, fname);
; 127  : 		stat(filePath, &st);
; 128  : 		if(com_ISDIR(&st)) { appendFileList(fList, fname, 'D');}
; 129  : 		else if(com_ISREG(&st)) {
; 130  : #else		
; 131  : 		if(com_ISDIR(&file)) { appendFileList(fList, fname, 'D'); }

  000ff	8d 95 b4 fe ff
	ff		 lea	 edx, DWORD PTR _file$[ebp]
  00105	52		 push	 edx
  00106	e8 00 00 00 00	 call	 ?jISDIR@@YA_NPAU_WIN32_FIND_DATAA@@@Z ; jISDIR
  0010b	83 c4 04	 add	 esp, 4
  0010e	0f b6 c0	 movzx	 eax, al
  00111	85 c0		 test	 eax, eax
  00113	74 1a		 je	 SHORT $LN10@GetFileLis
  00115	6a 44		 push	 68			; 00000044H
  00117	8b 8d a4 fe ff
	ff		 mov	 ecx, DWORD PTR _fname$[ebp]
  0011d	51		 push	 ecx
  0011e	8b 95 9c fe ff
	ff		 mov	 edx, DWORD PTR _fList$[ebp]
  00124	52		 push	 edx
  00125	e8 00 00 00 00	 call	 ?appendFileList@CFileUtil@@CA_NPAV?$CTList@UfileInfo@@@@PBDD@Z ; CFileUtil::appendFileList
  0012a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0012d	eb 65		 jmp	 SHORT $LN2@GetFileLis
$LN10@GetFileLis:

; 132  : 		else if(com_ISREG(&file)) {

  0012f	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _file$[ebp]
  00135	50		 push	 eax
  00136	e8 00 00 00 00	 call	 ?jISREG@@YA_NPAU_WIN32_FIND_DATAA@@@Z ; jISREG
  0013b	83 c4 04	 add	 esp, 4
  0013e	0f b6 c8	 movzx	 ecx, al
  00141	85 c9		 test	 ecx, ecx
  00143	74 4f		 je	 SHORT $LN2@GetFileLis

; 133  : #endif
; 134  : 			if (pFilter) {

  00145	83 7d 0c 00	 cmp	 DWORD PTR _pFilter$[ebp], 0
  00149	74 31		 je	 SHORT $LN13@GetFileLis

; 135  : 				if (!pFilter->pFunc(fname, pFilter->pData, filterList)) continue;

  0014b	8b f4		 mov	 esi, esp
  0014d	8b 95 ac fe ff
	ff		 mov	 edx, DWORD PTR _filterList$[ebp]
  00153	52		 push	 edx
  00154	8b 45 0c	 mov	 eax, DWORD PTR _pFilter$[ebp]
  00157	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0015a	51		 push	 ecx
  0015b	8b 95 a4 fe ff
	ff		 mov	 edx, DWORD PTR _fname$[ebp]
  00161	52		 push	 edx
  00162	8b 45 0c	 mov	 eax, DWORD PTR _pFilter$[ebp]
  00165	8b 08		 mov	 ecx, DWORD PTR [eax]
  00167	ff d1		 call	 ecx
  00169	83 c4 0c	 add	 esp, 12			; 0000000cH
  0016c	3b f4		 cmp	 esi, esp
  0016e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00173	0f b6 d0	 movzx	 edx, al
  00176	85 d2		 test	 edx, edx
  00178	75 02		 jne	 SHORT $LN13@GetFileLis
  0017a	eb 18		 jmp	 SHORT $LN2@GetFileLis
$LN13@GetFileLis:

; 136  : 			}
; 137  : 			appendFileList(fList, fname, 'F');

  0017c	6a 46		 push	 70			; 00000046H
  0017e	8b 85 a4 fe ff
	ff		 mov	 eax, DWORD PTR _fname$[ebp]
  00184	50		 push	 eax
  00185	8b 8d 9c fe ff
	ff		 mov	 ecx, DWORD PTR _fList$[ebp]
  0018b	51		 push	 ecx
  0018c	e8 00 00 00 00	 call	 ?appendFileList@CFileUtil@@CA_NPAV?$CTList@UfileInfo@@@@PBDD@Z ; CFileUtil::appendFileList
  00191	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@GetFileLis:

; 138  : 		}
; 139  : 	} while (com_nextFile(dir, &file));

  00194	8d 95 b4 fe ff
	ff		 lea	 edx, DWORD PTR _file$[ebp]
  0019a	52		 push	 edx
  0019b	8b 45 f8	 mov	 eax, DWORD PTR _dir$[ebp]
  0019e	50		 push	 eax
  0019f	e8 00 00 00 00	 call	 ?com_nextFile@@YA_NPAXPAU_WIN32_FIND_DATAA@@@Z ; com_nextFile
  001a4	83 c4 08	 add	 esp, 8
  001a7	0f b6 c8	 movzx	 ecx, al
  001aa	85 c9		 test	 ecx, ecx
  001ac	0f 85 02 ff ff
	ff		 jne	 $LN4@GetFileLis

; 140  : 
; 141  : 	com_dirclose(dir);

  001b2	8b f4		 mov	 esi, esp
  001b4	8b 55 f8	 mov	 edx, DWORD PTR _dir$[ebp]
  001b7	52		 push	 edx
  001b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindClose@4
  001be	3b f4		 cmp	 esi, esp
  001c0	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 142  : 	pResult->pList = fList;

  001c5	8b 45 08	 mov	 eax, DWORD PTR _pResult$[ebp]
  001c8	8b 8d 9c fe ff
	ff		 mov	 ecx, DWORD PTR _fList$[ebp]
  001ce	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 143  : 	delete filterList;

  001d1	8b 95 ac fe ff
	ff		 mov	 edx, DWORD PTR _filterList$[ebp]
  001d7	89 95 08 fe ff
	ff		 mov	 DWORD PTR $T1[ebp], edx
  001dd	8b 85 08 fe ff
	ff		 mov	 eax, DWORD PTR $T1[ebp]
  001e3	89 85 0c fe ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
  001e9	83 bd 0c fe ff
	ff 00		 cmp	 DWORD PTR $T2[ebp], 0
  001f0	74 15		 je	 SHORT $LN16@GetFileLis
  001f2	6a 01		 push	 1
  001f4	8b 8d 0c fe ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp]
  001fa	e8 00 00 00 00	 call	 ??_GCStringList@@QAEPAXI@Z
  001ff	89 85 04 fe ff
	ff		 mov	 DWORD PTR tv152[ebp], eax
  00205	eb 0a		 jmp	 SHORT $LN17@GetFileLis
$LN16@GetFileLis:
  00207	c7 85 04 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv152[ebp], 0
$LN17@GetFileLis:

; 144  : 	return true;

  00211	b0 01		 mov	 al, 1
$LN1@GetFileLis:

; 145  : }

  00213	52		 push	 edx
  00214	8b cd		 mov	 ecx, ebp
  00216	50		 push	 eax
  00217	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN22@GetFileLis
  0021d	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00222	58		 pop	 eax
  00223	5a		 pop	 edx
  00224	5f		 pop	 edi
  00225	5e		 pop	 esi
  00226	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00229	33 cd		 xor	 ecx, ebp
  0022b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00230	81 c4 fc 01 00
	00		 add	 esp, 508		; 000001fcH
  00236	3b ec		 cmp	 ebp, esp
  00238	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0023d	8b e5		 mov	 esp, ebp
  0023f	5d		 pop	 ebp
  00240	c3		 ret	 0
  00241	0f 1f 00	 npad	 3
$LN22@GetFileLis:
  00244	03 00 00 00	 DD	 3
  00248	00 00 00 00	 DD	 $LN21@GetFileLis
$LN21@GetFileLis:
  0024c	b4 fe ff ff	 DD	 -332			; fffffeb4H
  00250	40 01 00 00	 DD	 320			; 00000140H
  00254	00 00 00 00	 DD	 $LN18@GetFileLis
  00258	a4 fe ff ff	 DD	 -348			; fffffea4H
  0025c	04 00 00 00	 DD	 4
  00260	00 00 00 00	 DD	 $LN19@GetFileLis
  00264	14 fe ff ff	 DD	 -492			; fffffe14H
  00268	80 00 00 00	 DD	 128			; 00000080H
  0026c	00 00 00 00	 DD	 $LN20@GetFileLis
$LN20@GetFileLis:
  00270	64		 DB	 100			; 00000064H
  00271	69		 DB	 105			; 00000069H
  00272	72		 DB	 114			; 00000072H
  00273	4e		 DB	 78			; 0000004eH
  00274	61		 DB	 97			; 00000061H
  00275	6d		 DB	 109			; 0000006dH
  00276	65		 DB	 101			; 00000065H
  00277	00		 DB	 0
$LN19@GetFileLis:
  00278	66		 DB	 102			; 00000066H
  00279	6e		 DB	 110			; 0000006eH
  0027a	61		 DB	 97			; 00000061H
  0027b	6d		 DB	 109			; 0000006dH
  0027c	65		 DB	 101			; 00000065H
  0027d	00		 DB	 0
$LN18@GetFileLis:
  0027e	66		 DB	 102			; 00000066H
  0027f	69		 DB	 105			; 00000069H
  00280	6c		 DB	 108			; 0000006cH
  00281	65		 DB	 101			; 00000065H
  00282	00		 DB	 0
?GetFileList@CFileUtil@@SA_NPAUSTFileList@@PAUSTFilterData@@@Z ENDP ; CFileUtil::GetFileList
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
_TEXT	SEGMENT
_bRes$ = -1						; size = 1
_dirName$ = 8						; size = 4
?IsExistDirectory@CFileUtil@@SA_NPAD@Z PROC		; CFileUtil::IsExistDirectory

; 79   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 80   : 	bool bRes = false;

  0000b	c6 45 ff 00	 mov	 BYTE PTR _bRes$[ebp], 0

; 81   : 	if (com_isDirectory(dirName))

  0000f	8b 45 08	 mov	 eax, DWORD PTR _dirName$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?com_isDirectory@@YA_NPAD@Z ; com_isDirectory
  00018	83 c4 04	 add	 esp, 4
  0001b	0f b6 c8	 movzx	 ecx, al
  0001e	85 c9		 test	 ecx, ecx
  00020	74 19		 je	 SHORT $LN2@IsExistDir

; 82   : #ifndef WIN32 // -- only unix
; 83   : 	{
; 84   : 		bRes = true;
; 85   : 	}
; 86   : #else	
; 87   : 	{
; 88   : 		bRes = true;

  00022	c6 45 ff 01	 mov	 BYTE PTR _bRes$[ebp], 1

; 89   : 		_stprintf(dirName, _T("%s*.*"), dirName);

  00026	8b 55 08	 mov	 edx, DWORD PTR _dirName$[ebp]
  00029	52		 push	 edx
  0002a	68 00 00 00 00	 push	 OFFSET $SG86390
  0002f	8b 45 08	 mov	 eax, DWORD PTR _dirName$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 _sprintf
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@IsExistDir:

; 90   : 	}
; 91   : #endif
; 92   : 	return bRes;

  0003b	8a 45 ff	 mov	 al, BYTE PTR _bRes$[ebp]

; 93   : }

  0003e	83 c4 04	 add	 esp, 4
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
?IsExistDirectory@CFileUtil@@SA_NPAD@Z ENDP		; CFileUtil::IsExistDirectory
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
_TEXT	SEGMENT
_pComFileTime$ = -8					; size = 4
_pComperand$ = -4					; size = 4
_pFile$ = 8						; size = 4
_pData$ = 12						; size = 4
_pRes$ = 16						; size = 4
?filter_dateTimeCompare@@YA_NPADPAX1@Z PROC		; filter_dateTimeCompare

; 50   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 51   : 	CFileTime *pComperand = (CFileTime *)pData;

  00014	8b 45 0c	 mov	 eax, DWORD PTR _pData$[ebp]
  00017	89 45 fc	 mov	 DWORD PTR _pComperand$[ebp], eax

; 52   : 	CFileTime *pComFileTime = (CFileTime *)pRes;

  0001a	8b 4d 10	 mov	 ecx, DWORD PTR _pRes$[ebp]
  0001d	89 4d f8	 mov	 DWORD PTR _pComFileTime$[ebp], ecx

; 53   : 	if (pComFileTime->isCompare(pComperand, eOperator_LE)) // LE : less or Equal

  00020	6a 06		 push	 6
  00022	8b 55 fc	 mov	 edx, DWORD PTR _pComperand$[ebp]
  00025	52		 push	 edx
  00026	8b 4d f8	 mov	 ecx, DWORD PTR _pComFileTime$[ebp]
  00029	e8 00 00 00 00	 call	 ?isCompare@CFileTime@@QAE_NPAV1@W4E_OPERATOR@@@Z ; CFileTime::isCompare
  0002e	0f b6 c0	 movzx	 eax, al
  00031	85 c0		 test	 eax, eax
  00033	74 04		 je	 SHORT $LN2@filter_dat

; 54   : 	{
; 55   : 		return true;

  00035	b0 01		 mov	 al, 1
  00037	eb 02		 jmp	 SHORT $LN1@filter_dat
$LN2@filter_dat:

; 56   : 	}
; 57   : 	return false;

  00039	32 c0		 xor	 al, al
$LN1@filter_dat:

; 58   : }

  0003b	83 c4 08	 add	 esp, 8
  0003e	3b ec		 cmp	 ebp, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?filter_dateTimeCompare@@YA_NPADPAX1@Z ENDP		; filter_dateTimeCompare
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\comfileutil.cpp
_TEXT	SEGMENT
tv79 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
_filter$ = -40						; size = 4
_i$ = -32						; size = 4
_pFilter$4 = -24					; size = 4
_filterList$ = -20					; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pFile$ = 8						; size = 4
_pData$ = 12						; size = 4
_pRes$ = 16						; size = 4
?filter_stringCompare@@YA_NPADPAX1@Z PROC		; filter_stringCompare

; 27   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?filter_stringCompare@@YA_NPADPAX1@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 28	 sub	 esp, 40			; 00000028H
  00014	57		 push	 edi
  00015	8d 7d cc	 lea	 edi, DWORD PTR [ebp-52]
  00018	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  0001d	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00022	f3 ab		 rep stosd
  00024	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00029	33 c5		 xor	 eax, ebp
  0002b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002e	50		 push	 eax
  0002f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00032	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 28   : 	if (!pData) return true;

  00038	83 7d 0c 00	 cmp	 DWORD PTR _pData$[ebp], 0
  0003c	75 07		 jne	 SHORT $LN4@filter_str
  0003e	b0 01		 mov	 al, 1
  00040	e9 c5 00 00 00	 jmp	 $LN1@filter_str
$LN4@filter_str:

; 29   : 	CStringList *filterList = NULL;

  00045	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _filterList$[ebp], 0

; 30   : 	if (!pRes) {

  0004c	83 7d 10 00	 cmp	 DWORD PTR _pRes$[ebp], 0
  00050	75 6f		 jne	 SHORT $LN5@filter_str

; 31   : 		TCHAR *pFilter = (TCHAR *)pData;

  00052	8b 45 0c	 mov	 eax, DWORD PTR _pData$[ebp]
  00055	89 45 e8	 mov	 DWORD PTR _pFilter$4[ebp], eax

; 32   : 		filterList = new CStringList();

  00058	6a 14		 push	 20			; 00000014H
  0005a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0005f	83 c4 04	 add	 esp, 4
  00062	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
  00065	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0006c	83 7d d0 00	 cmp	 DWORD PTR $T2[ebp], 0
  00070	74 17		 je	 SHORT $LN9@filter_str
  00072	6a 14		 push	 20			; 00000014H
  00074	8b 4d d0	 mov	 ecx, DWORD PTR $T2[ebp]
  00077	e8 00 00 00 00	 call	 ?__autoclassinit2@CStringList@@QAEXI@Z
  0007c	8b 4d d0	 mov	 ecx, DWORD PTR $T2[ebp]
  0007f	e8 00 00 00 00	 call	 ??0CStringList@@QAE@XZ	; CStringList::CStringList
  00084	89 45 cc	 mov	 DWORD PTR tv79[ebp], eax
  00087	eb 07		 jmp	 SHORT $LN10@filter_str
$LN9@filter_str:
  00089	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR tv79[ebp], 0
$LN10@filter_str:
  00090	8b 4d cc	 mov	 ecx, DWORD PTR tv79[ebp]
  00093	89 4d d4	 mov	 DWORD PTR $T3[ebp], ecx
  00096	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0009d	8b 55 d4	 mov	 edx, DWORD PTR $T3[ebp]
  000a0	89 55 ec	 mov	 DWORD PTR _filterList$[ebp], edx

; 33   : 		filterList->alloc(4);

  000a3	6a 04		 push	 4
  000a5	8b 4d ec	 mov	 ecx, DWORD PTR _filterList$[ebp]
  000a8	e8 00 00 00 00	 call	 ?alloc@CStringList@@QAEHH@Z ; CStringList::alloc

; 34   : 		CFileUtil::getFieldList((char *)pFilter, CH_DELIMITER, filterList);

  000ad	8b 45 ec	 mov	 eax, DWORD PTR _filterList$[ebp]
  000b0	50		 push	 eax
  000b1	6a 3b		 push	 59			; 0000003bH
  000b3	8b 4d e8	 mov	 ecx, DWORD PTR _pFilter$4[ebp]
  000b6	51		 push	 ecx
  000b7	e8 00 00 00 00	 call	 ?getFieldList@CFileUtil@@SA_NPADDPAVCStringList@@@Z ; CFileUtil::getFieldList
  000bc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 35   : 	}
; 36   : 	else {

  000bf	eb 06		 jmp	 SHORT $LN6@filter_str
$LN5@filter_str:

; 37   : 		filterList = (CStringList *)pRes;

  000c1	8b 55 10	 mov	 edx, DWORD PTR _pRes$[ebp]
  000c4	89 55 ec	 mov	 DWORD PTR _filterList$[ebp], edx
$LN6@filter_str:

; 38   : 	}
; 39   : 	int i = 0;

  000c7	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 40   : 	CmString *filter = filterList->getNext(&i);

  000ce	8d 45 e0	 lea	 eax, DWORD PTR _i$[ebp]
  000d1	50		 push	 eax
  000d2	8b 4d ec	 mov	 ecx, DWORD PTR _filterList$[ebp]
  000d5	e8 00 00 00 00	 call	 ?getNext@CStringList@@QAEPAVCmString@@PAH@Z ; CStringList::getNext
  000da	89 45 d8	 mov	 DWORD PTR _filter$[ebp], eax
$LN2@filter_str:

; 41   : 	while (filter)

  000dd	83 7d d8 00	 cmp	 DWORD PTR _filter$[ebp], 0
  000e1	74 25		 je	 SHORT $LN3@filter_str

; 42   : 	{
; 43   : 		if (filter->compare(pFile)) return true;

  000e3	8b 4d 08	 mov	 ecx, DWORD PTR _pFile$[ebp]
  000e6	51		 push	 ecx
  000e7	8b 4d d8	 mov	 ecx, DWORD PTR _filter$[ebp]
  000ea	e8 00 00 00 00	 call	 ?compare@CmString@@QAEHPBD@Z ; CmString::compare
  000ef	85 c0		 test	 eax, eax
  000f1	74 04		 je	 SHORT $LN7@filter_str
  000f3	b0 01		 mov	 al, 1
  000f5	eb 13		 jmp	 SHORT $LN1@filter_str
$LN7@filter_str:

; 44   : 		filter = filterList->getNext(&i);

  000f7	8d 55 e0	 lea	 edx, DWORD PTR _i$[ebp]
  000fa	52		 push	 edx
  000fb	8b 4d ec	 mov	 ecx, DWORD PTR _filterList$[ebp]
  000fe	e8 00 00 00 00	 call	 ?getNext@CStringList@@QAEPAVCmString@@PAH@Z ; CStringList::getNext
  00103	89 45 d8	 mov	 DWORD PTR _filter$[ebp], eax

; 45   : 	}

  00106	eb d5		 jmp	 SHORT $LN2@filter_str
$LN3@filter_str:

; 46   : 	return false;

  00108	32 c0		 xor	 al, al
$LN1@filter_str:

; 47   : }

  0010a	52		 push	 edx
  0010b	8b cd		 mov	 ecx, ebp
  0010d	50		 push	 eax
  0010e	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN15@filter_str
  00114	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00119	58		 pop	 eax
  0011a	5a		 pop	 edx
  0011b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0011e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00125	59		 pop	 ecx
  00126	5f		 pop	 edi
  00127	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0012a	33 cd		 xor	 ecx, ebp
  0012c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00131	83 c4 34	 add	 esp, 52			; 00000034H
  00134	3b ec		 cmp	 ebp, esp
  00136	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0013b	8b e5		 mov	 esp, ebp
  0013d	5d		 pop	 ebp
  0013e	c3		 ret	 0
  0013f	90		 npad	 1
$LN15@filter_str:
  00140	01 00 00 00	 DD	 1
  00144	00 00 00 00	 DD	 $LN14@filter_str
$LN14@filter_str:
  00148	e0 ff ff ff	 DD	 -32			; ffffffe0H
  0014c	04 00 00 00	 DD	 4
  00150	00 00 00 00	 DD	 $LN12@filter_str
$LN12@filter_str:
  00154	69		 DB	 105			; 00000069H
  00155	00		 DB	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?filter_stringCompare@@YA_NPADPAX1@Z$0:
  00000	6a 14		 push	 20			; 00000014H
  00002	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
__ehhandler$?filter_stringCompare@@YA_NPADPAX1@Z:
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?filter_stringCompare@@YA_NPADPAX1@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?filter_stringCompare@@YA_NPADPAX1@Z ENDP		; filter_stringCompare
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_GCStringList@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCStringList@@QAEPAXI@Z PROC				; CStringList::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1CStringList@@QAE@XZ	; CStringList::~CStringList
  00016	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00019	83 e0 01	 and	 eax, 1
  0001c	74 0e		 je	 SHORT $LN2@scalar
  0001e	6a 14		 push	 20			; 00000014H
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00029	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b ec		 cmp	 ebp, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
??_GCStringList@@QAEPAXI@Z ENDP				; CStringList::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?__autoclassinit2@CStringList@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@CStringList@@QAEXI@Z PROC		; CStringList::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR _classSize$[ebp]
  00011	50		 push	 eax
  00012	6a 00		 push	 0
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 _memset
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00020	83 c4 04	 add	 esp, 4
  00023	3b ec		 cmp	 ebp, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?__autoclassinit2@CStringList@@QAEXI@Z ENDP		; CStringList::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\commstring.h
;	COMDAT ?__getNext@CStringList@@AAEPAVCmString@@PAH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?__getNext@CStringList@@AAEPAVCmString@@PAH@Z PROC	; CStringList::__getNext, COMDAT
; _this$ = ecx

; 105  : 	inline CmString *__getNext(int *i) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 106  : 		for (*i; *i < m_nListCnt; (*i)++) {

  0000e	eb 0d		 jmp	 SHORT $LN4@getNext
$LN2@getNext:
  00010	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00013	8b 08		 mov	 ecx, DWORD PTR [eax]
  00015	83 c1 01	 add	 ecx, 1
  00018	8b 55 08	 mov	 edx, DWORD PTR _i$[ebp]
  0001b	89 0a		 mov	 DWORD PTR [edx], ecx
$LN4@getNext:
  0001d	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 10		 mov	 edx, DWORD PTR [eax]
  00025	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00027	7d 23		 jge	 SHORT $LN3@getNext

; 107  : 			if (m_pList[*i]) { return m_pList[*i]; }

  00029	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  0002c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00031	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00034	83 3c 88 00	 cmp	 DWORD PTR [eax+ecx*4], 0
  00038	74 10		 je	 SHORT $LN5@getNext
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  0003d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00045	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  00048	eb 04		 jmp	 SHORT $LN1@getNext
$LN5@getNext:

; 108  : 		}

  0004a	eb c4		 jmp	 SHORT $LN2@getNext
$LN3@getNext:

; 109  : 		return NULL;

  0004c	33 c0		 xor	 eax, eax
$LN1@getNext:

; 110  : 	}

  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
?__getNext@CStringList@@AAEPAVCmString@@PAH@Z ENDP	; CStringList::__getNext
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\commstring.h
;	COMDAT ?getNext@CStringList@@QAEPAVCmString@@PAH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?getNext@CStringList@@QAEPAVCmString@@PAH@Z PROC	; CStringList::getNext, COMDAT
; _this$ = ecx

; 90   : 	inline CmString *getNext(int *i) { return __getNext(i);	}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?__getNext@CStringList@@AAEPAVCmString@@PAH@Z ; CStringList::__getNext
  0001a	83 c4 04	 add	 esp, 4
  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?getNext@CStringList@@QAEPAVCmString@@PAH@Z ENDP	; CStringList::getNext
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\commstring.h
;	COMDAT ?push_back@CStringList@@QAEPAVCmString@@PAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pString$ = 8						; size = 4
?push_back@CStringList@@QAEPAVCmString@@PAD@Z PROC	; CStringList::push_back, COMDAT
; _this$ = ecx

; 87   : 	CmString * CStringList::push_back(TCHAR* pString) {if (!m_pList[m_nLast]) return __add(pString, m_nLast);return __add(pString, newIdx());}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0001a	83 3c 88 00	 cmp	 DWORD PTR [eax+ecx*4], 0
  0001e	75 15		 jne	 SHORT $LN2@push_back
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00026	52		 push	 edx
  00027	8b 45 08	 mov	 eax, DWORD PTR _pString$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ?__add@CStringList@@AAEPAVCmString@@PADH@Z ; CStringList::__add
  00033	eb 15		 jmp	 SHORT $LN1@push_back
$LN2@push_back:
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ?newIdx@CStringList@@AAEHXZ ; CStringList::newIdx
  0003d	50		 push	 eax
  0003e	8b 4d 08	 mov	 ecx, DWORD PTR _pString$[ebp]
  00041	51		 push	 ecx
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ?__add@CStringList@@AAEPAVCmString@@PADH@Z ; CStringList::__add
$LN1@push_back:
  0004a	83 c4 04	 add	 esp, 4
  0004d	3b ec		 cmp	 ebp, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c2 04 00	 ret	 4
?push_back@CStringList@@QAEPAVCmString@@PAD@Z ENDP	; CStringList::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\commstring.h
;	COMDAT ?alloc@CStringList@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nMaxCount$ = 8						; size = 4
?alloc@CStringList@@QAEHH@Z PROC			; CStringList::alloc, COMDAT
; _this$ = ecx

; 85   : 	int alloc(int nMaxCount) { m_nListCnt = __alloc(nMaxCount); return m_nListCnt; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR _nMaxCount$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?__alloc@CStringList@@AAEHH@Z ; CStringList::__alloc
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	89 01		 mov	 DWORD PTR [ecx], eax
  0001f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00022	8b 02		 mov	 eax, DWORD PTR [edx]
  00024	83 c4 04	 add	 esp, 4
  00027	3b ec		 cmp	 ebp, esp
  00029	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
?alloc@CStringList@@QAEHH@Z ENDP			; CStringList::alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\commemmanager.h
;	COMDAT ?delBuf@CMemManager@@QAEXPADH@Z
_TEXT	SEGMENT
_nIdx$ = -8						; size = 4
_this$ = -4						; size = 4
_pBuf$ = 8						; size = 4
_nSize$ = 12						; size = 4
?delBuf@CMemManager@@QAEXPADH@Z PROC			; CMemManager::delBuf, COMDAT
; _this$ = ecx

; 38   : 	inline void delBuf(char *pBuf, int nSize) { int nIdx = getIndex(nSize); delBufByIndex(pBuf, nIdx); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00017	8b 45 0c	 mov	 eax, DWORD PTR _nSize$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ?getIndex@@YAHH@Z	; getIndex
  00020	83 c4 04	 add	 esp, 4
  00023	89 45 f8	 mov	 DWORD PTR _nIdx$[ebp], eax
  00026	8b 4d f8	 mov	 ecx, DWORD PTR _nIdx$[ebp]
  00029	51		 push	 ecx
  0002a	8b 55 08	 mov	 edx, DWORD PTR _pBuf$[ebp]
  0002d	52		 push	 edx
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ?delBufByIndex@CMemManager@@QAEXPADH@Z ; CMemManager::delBufByIndex
  00036	83 c4 08	 add	 esp, 8
  00039	3b ec		 cmp	 ebp, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8
?delBuf@CMemManager@@QAEXPADH@Z ENDP			; CMemManager::delBuf
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\commemmanager.h
;	COMDAT ?newBuf@CMemManager@@QAEPADHPAH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nSize$ = 8						; size = 4
_pIndex$ = 12						; size = 4
?newBuf@CMemManager@@QAEPADHPAH@Z PROC			; CMemManager::newBuf, COMDAT
; _this$ = ecx

; 35   : 	inline char *newBuf(int nSize, int *pIndex) { *pIndex = getIndex(nSize);  return __newBuf(*pIndex, nSize); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR _nSize$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ?getIndex@@YAHH@Z	; getIndex
  00017	83 c4 04	 add	 esp, 4
  0001a	8b 4d 0c	 mov	 ecx, DWORD PTR _pIndex$[ebp]
  0001d	89 01		 mov	 DWORD PTR [ecx], eax
  0001f	8b 55 08	 mov	 edx, DWORD PTR _nSize$[ebp]
  00022	52		 push	 edx
  00023	8b 45 0c	 mov	 eax, DWORD PTR _pIndex$[ebp]
  00026	8b 08		 mov	 ecx, DWORD PTR [eax]
  00028	51		 push	 ecx
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?__newBuf@CMemManager@@AAEPADHI@Z ; CMemManager::__newBuf
  00031	83 c4 04	 add	 esp, 4
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c2 08 00	 ret	 8
?newBuf@CMemManager@@QAEPADHPAH@Z ENDP			; CMemManager::newBuf
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\commemmanager.h
;	COMDAT ?newBuf@CMemManager@@QAEPADH@Z
_TEXT	SEGMENT
_nIdx$ = -8						; size = 4
_this$ = -4						; size = 4
_nSize$ = 8						; size = 4
?newBuf@CMemManager@@QAEPADH@Z PROC			; CMemManager::newBuf, COMDAT
; _this$ = ecx

; 34   : 	inline char *newBuf(int nSize) { int nIdx = getIndex(nSize);  return __newBuf(nIdx, nSize); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00017	8b 45 08	 mov	 eax, DWORD PTR _nSize$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ?getIndex@@YAHH@Z	; getIndex
  00020	83 c4 04	 add	 esp, 4
  00023	89 45 f8	 mov	 DWORD PTR _nIdx$[ebp], eax
  00026	8b 4d 08	 mov	 ecx, DWORD PTR _nSize$[ebp]
  00029	51		 push	 ecx
  0002a	8b 55 f8	 mov	 edx, DWORD PTR _nIdx$[ebp]
  0002d	52		 push	 edx
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ?__newBuf@CMemManager@@AAEPADHI@Z ; CMemManager::__newBuf
  00036	83 c4 08	 add	 esp, 8
  00039	3b ec		 cmp	 ebp, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 04 00	 ret	 4
?newBuf@CMemManager@@QAEPADH@Z ENDP			; CMemManager::newBuf
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\combufpool.h
;	COMDAT ?getIndex@@YAHH@Z
_TEXT	SEGMENT
tv73 = -24						; size = 4
_$S1$ = -16						; size = 8
_m$ = -4						; size = 4
_s$ = 8							; size = 4
?getIndex@@YAHH@Z PROC					; getIndex, COMDAT

; 51   : inline int getIndex(int s) { int m; union { double x; int b[2]; }; x = s; m = (b[1] >> 20) - 1023; return m + ((s&(s - (1 << m))) ? 1 : 0); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0000e	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00011	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00014	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00017	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001a	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001d	f2 0f 2a 45 08	 cvtsi2sd xmm0, DWORD PTR _s$[ebp]
  00022	f2 0f 11 45 f0	 movsd	 QWORD PTR _$S1$[ebp], xmm0
  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	c1 e0 00	 shl	 eax, 0
  0002f	8b 4c 05 f0	 mov	 ecx, DWORD PTR _$S1$[ebp+eax]
  00033	c1 f9 14	 sar	 ecx, 20			; 00000014H
  00036	81 e9 ff 03 00
	00		 sub	 ecx, 1023		; 000003ffH
  0003c	89 4d fc	 mov	 DWORD PTR _m$[ebp], ecx
  0003f	ba 01 00 00 00	 mov	 edx, 1
  00044	8b 4d fc	 mov	 ecx, DWORD PTR _m$[ebp]
  00047	d3 e2		 shl	 edx, cl
  00049	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0004c	2b c2		 sub	 eax, edx
  0004e	23 45 08	 and	 eax, DWORD PTR _s$[ebp]
  00051	74 09		 je	 SHORT $LN3@getIndex
  00053	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv73[ebp], 1
  0005a	eb 07		 jmp	 SHORT $LN4@getIndex
$LN3@getIndex:
  0005c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
$LN4@getIndex:
  00063	8b 45 fc	 mov	 eax, DWORD PTR _m$[ebp]
  00066	03 45 e8	 add	 eax, DWORD PTR tv73[ebp]
  00069	52		 push	 edx
  0006a	8b cd		 mov	 ecx, ebp
  0006c	50		 push	 eax
  0006d	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN7@getIndex
  00073	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00078	58		 pop	 eax
  00079	5a		 pop	 edx
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
  0007e	66 90		 npad	 2
$LN7@getIndex:
  00080	01 00 00 00	 DD	 1
  00084	00 00 00 00	 DD	 $LN6@getIndex
$LN6@getIndex:
  00088	f0 ff ff ff	 DD	 -16			; fffffff0H
  0008c	08 00 00 00	 DD	 8
  00090	00 00 00 00	 DD	 $LN5@getIndex
$LN5@getIndex:
  00094	24		 DB	 36			; 00000024H
  00095	53		 DB	 83			; 00000053H
  00096	31		 DB	 49			; 00000031H
  00097	00		 DB	 0
?getIndex@@YAHH@Z ENDP					; getIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\comfiletypes.h
;	COMDAT ?jISDIR@@YA_NPAU_WIN32_FIND_DATAA@@@Z
_TEXT	SEGMENT
tv67 = -1						; size = 1
_pFD$ = 8						; size = 4
?jISDIR@@YA_NPAU_WIN32_FIND_DATAA@@@Z PROC		; jISDIR, COMDAT

; 86   : inline bool jISDIR(LPJFILEDATA pFD)		{return (pFD->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)?true:false;} //directory?

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	8b 45 08	 mov	 eax, DWORD PTR _pFD$[ebp]
  0000e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00010	83 e1 10	 and	 ecx, 16			; 00000010H
  00013	74 06		 je	 SHORT $LN3@jISDIR
  00015	c6 45 ff 01	 mov	 BYTE PTR tv67[ebp], 1
  00019	eb 04		 jmp	 SHORT $LN4@jISDIR
$LN3@jISDIR:
  0001b	c6 45 ff 00	 mov	 BYTE PTR tv67[ebp], 0
$LN4@jISDIR:
  0001f	8a 45 ff	 mov	 al, BYTE PTR tv67[ebp]
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?jISDIR@@YA_NPAU_WIN32_FIND_DATAA@@@Z ENDP		; jISDIR
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\comfiletypes.h
;	COMDAT ?jISREG@@YA_NPAU_WIN32_FIND_DATAA@@@Z
_TEXT	SEGMENT
tv67 = -1						; size = 1
_pFD$ = 8						; size = 4
?jISREG@@YA_NPAU_WIN32_FIND_DATAA@@@Z PROC		; jISREG, COMDAT

; 85   : inline bool jISREG(LPJFILEDATA pFD)		{return (pFD->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)? false : true;} //regular file?

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	8b 45 08	 mov	 eax, DWORD PTR _pFD$[ebp]
  0000e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00010	83 e1 10	 and	 ecx, 16			; 00000010H
  00013	74 06		 je	 SHORT $LN3@jISREG
  00015	c6 45 ff 00	 mov	 BYTE PTR tv67[ebp], 0
  00019	eb 04		 jmp	 SHORT $LN4@jISREG
$LN3@jISREG:
  0001b	c6 45 ff 01	 mov	 BYTE PTR tv67[ebp], 1
$LN4@jISREG:
  0001f	8a 45 ff	 mov	 al, BYTE PTR tv67[ebp]
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?jISREG@@YA_NPAU_WIN32_FIND_DATAA@@@Z ENDP		; jISREG
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\comfiletypes.h
;	COMDAT ?com_getFileName@@YAXPAPADPAU_WIN32_FIND_DATAA@@@Z
_TEXT	SEGMENT
_pFileName$ = 8						; size = 4
_pFileData$ = 12					; size = 4
?com_getFileName@@YAXPAPADPAU_WIN32_FIND_DATAA@@@Z PROC	; com_getFileName, COMDAT

; 83   : inline void com_getFileName(TCHAR **pFileName, LPJFILEDATA pFileData) { *pFileName = pFileData->cFileName;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR _pFileData$[ebp]
  00006	83 c0 2c	 add	 eax, 44			; 0000002cH
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _pFileName$[ebp]
  0000c	89 01		 mov	 DWORD PTR [ecx], eax
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?com_getFileName@@YAXPAPADPAU_WIN32_FIND_DATAA@@@Z ENDP	; com_getFileName
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\comfiletypes.h
;	COMDAT ?com_nextFile@@YA_NPAXPAU_WIN32_FIND_DATAA@@@Z
_TEXT	SEGMENT
tv68 = -1						; size = 1
_dir$ = 8						; size = 4
_pFileData$ = 12					; size = 4
?com_nextFile@@YA_NPAXPAU_WIN32_FIND_DATAA@@@Z PROC	; com_nextFile, COMDAT

; 82   : inline bool com_nextFile(JPDIR dir, LPJFILEDATA pFileData) { return (FindNextFile(dir, pFileData))?true:false; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	8b f4		 mov	 esi, esp
  0000e	8b 45 0c	 mov	 eax, DWORD PTR _pFileData$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _dir$[ebp]
  00015	51		 push	 ecx
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindNextFileA@8
  0001c	3b f4		 cmp	 esi, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	85 c0		 test	 eax, eax
  00025	74 06		 je	 SHORT $LN3@com_nextFi
  00027	c6 45 ff 01	 mov	 BYTE PTR tv68[ebp], 1
  0002b	eb 04		 jmp	 SHORT $LN4@com_nextFi
$LN3@com_nextFi:
  0002d	c6 45 ff 00	 mov	 BYTE PTR tv68[ebp], 0
$LN4@com_nextFi:
  00031	8a 45 ff	 mov	 al, BYTE PTR tv68[ebp]
  00034	5e		 pop	 esi
  00035	83 c4 04	 add	 esp, 4
  00038	3b ec		 cmp	 ebp, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
?com_nextFile@@YA_NPAXPAU_WIN32_FIND_DATAA@@@Z ENDP	; com_nextFile
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\comfiletypes.h
;	COMDAT ?com_findFirstFile@@YAPAXPBDPAU_WIN32_FIND_DATAA@@@Z
_TEXT	SEGMENT
_pDirName$ = 8						; size = 4
_pFileData$ = 12					; size = 4
?com_findFirstFile@@YAPAXPBDPAU_WIN32_FIND_DATAA@@@Z PROC ; com_findFirstFile, COMDAT

; 81   : inline JPDIR com_findFirstFile(const TCHAR *pDirName, LPJFILEDATA pFileData) { return FindFirstFile(pDirName, pFileData); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f4		 mov	 esi, esp
  00006	8b 45 0c	 mov	 eax, DWORD PTR _pFileData$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _pDirName$[ebp]
  0000d	51		 push	 ecx
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindFirstFileA@8
  00014	3b f4		 cmp	 esi, esp
  00016	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001b	5e		 pop	 esi
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
?com_findFirstFile@@YAPAXPBDPAU_WIN32_FIND_DATAA@@@Z ENDP ; com_findFirstFile
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\comfiletypes.h
;	COMDAT ?com_isDirectory@@YA_NPAD@Z
_TEXT	SEGMENT
_res$ = -4						; size = 4
_dir$ = 8						; size = 4
?com_isDirectory@@YA_NPAD@Z PROC			; com_isDirectory, COMDAT

; 80   : inline bool com_isDirectory(TCHAR *dir) { int res = GetFileAttributes(dir); if (res == FILE_ATTRIBUTE_DIRECTORY)return true; return false; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	8b f4		 mov	 esi, esp
  0000e	8b 45 08	 mov	 eax, DWORD PTR _dir$[ebp]
  00011	50		 push	 eax
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileAttributesA@4
  00018	3b f4		 cmp	 esi, esp
  0001a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001f	89 45 fc	 mov	 DWORD PTR _res$[ebp], eax
  00022	83 7d fc 10	 cmp	 DWORD PTR _res$[ebp], 16 ; 00000010H
  00026	75 04		 jne	 SHORT $LN2@com_isDire
  00028	b0 01		 mov	 al, 1
  0002a	eb 02		 jmp	 SHORT $LN1@com_isDire
$LN2@com_isDire:
  0002c	32 c0		 xor	 al, al
$LN1@com_isDire:
  0002e	5e		 pop	 esi
  0002f	83 c4 04	 add	 esp, 4
  00032	3b ec		 cmp	 ebp, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
?com_isDirectory@@YA_NPAD@Z ENDP			; com_isDirectory
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\comfiletypes.h
;	COMDAT ?com_isFile@@YA_NPBD@Z
_TEXT	SEGMENT
_res$ = -4						; size = 4
_file$ = 8						; size = 4
?com_isFile@@YA_NPBD@Z PROC				; com_isFile, COMDAT

; 79   : inline bool com_isFile(const TCHAR *file) { int res = GetFileAttributes(file); if (res == INVALID_FILE_ATTRIBUTES || res == FILE_ATTRIBUTE_DIRECTORY)return false; return true; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	8b f4		 mov	 esi, esp
  0000e	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00011	50		 push	 eax
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileAttributesA@4
  00018	3b f4		 cmp	 esi, esp
  0001a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001f	89 45 fc	 mov	 DWORD PTR _res$[ebp], eax
  00022	83 7d fc ff	 cmp	 DWORD PTR _res$[ebp], -1
  00026	74 06		 je	 SHORT $LN3@com_isFile
  00028	83 7d fc 10	 cmp	 DWORD PTR _res$[ebp], 16 ; 00000010H
  0002c	75 04		 jne	 SHORT $LN2@com_isFile
$LN3@com_isFile:
  0002e	32 c0		 xor	 al, al
  00030	eb 02		 jmp	 SHORT $LN1@com_isFile
$LN2@com_isFile:
  00032	b0 01		 mov	 al, 1
$LN1@com_isFile:
  00034	5e		 pop	 esi
  00035	83 c4 04	 add	 esp, 4
  00038	3b ec		 cmp	 ebp, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
?com_isFile@@YA_NPBD@Z ENDP				; com_isFile
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\comfiletypes.h
;	COMDAT ?com_isInvalid@@YA_NPBD@Z
_TEXT	SEGMENT
_fath$ = 8						; size = 4
?com_isInvalid@@YA_NPBD@Z PROC				; com_isInvalid, COMDAT

; 78   : inline bool com_isInvalid(const TCHAR *fath) { if (GetFileAttributes(fath) == INVALID_FILE_ATTRIBUTES)return true; return false; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f4		 mov	 esi, esp
  00006	8b 45 08	 mov	 eax, DWORD PTR _fath$[ebp]
  00009	50		 push	 eax
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileAttributesA@4
  00010	3b f4		 cmp	 esi, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	83 f8 ff	 cmp	 eax, -1
  0001a	75 04		 jne	 SHORT $LN2@com_isInva
  0001c	b0 01		 mov	 al, 1
  0001e	eb 02		 jmp	 SHORT $LN1@com_isInva
$LN2@com_isInva:
  00020	32 c0		 xor	 al, al
$LN1@com_isInva:
  00022	5e		 pop	 esi
  00023	3b ec		 cmp	 ebp, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?com_isInvalid@@YA_NPBD@Z ENDP				; com_isInvalid
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\comfiletypes.h
;	COMDAT ?com_mkdir@@YA_NPBD@Z
_TEXT	SEGMENT
tv68 = -5						; size = 1
_res$ = -4						; size = 4
_path$ = 8						; size = 4
?com_mkdir@@YA_NPBD@Z PROC				; com_mkdir, COMDAT

; 75   : inline bool com_mkdir(const TCHAR *path)	{int res = CreateDirectory(path, NULL); return (res)?true:false; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00015	8b f4		 mov	 esi, esp
  00017	6a 00		 push	 0
  00019	8b 45 08	 mov	 eax, DWORD PTR _path$[ebp]
  0001c	50		 push	 eax
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDirectoryA@8
  00023	3b f4		 cmp	 esi, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	89 45 fc	 mov	 DWORD PTR _res$[ebp], eax
  0002d	83 7d fc 00	 cmp	 DWORD PTR _res$[ebp], 0
  00031	74 06		 je	 SHORT $LN3@com_mkdir
  00033	c6 45 fb 01	 mov	 BYTE PTR tv68[ebp], 1
  00037	eb 04		 jmp	 SHORT $LN4@com_mkdir
$LN3@com_mkdir:
  00039	c6 45 fb 00	 mov	 BYTE PTR tv68[ebp], 0
$LN4@com_mkdir:
  0003d	8a 45 fb	 mov	 al, BYTE PTR tv68[ebp]
  00040	5e		 pop	 esi
  00041	83 c4 08	 add	 esp, 8
  00044	3b ec		 cmp	 ebp, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
?com_mkdir@@YA_NPBD@Z ENDP				; com_mkdir
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
;	COMDAT ?_tcsrchr@@YAPADPADI@Z
_TEXT	SEGMENT
__S$ = 8						; size = 4
__C$ = 12						; size = 4
?_tcsrchr@@YAPADPADI@Z PROC				; _tcsrchr, COMDAT

; 2027 :         {return ((char *)_tcsrchr((const char *)_S, _C)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __C$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __S$[ebp]
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 __tcsrchr
  00010	83 c4 08	 add	 esp, 8
  00013	3b ec		 cmp	 ebp, esp
  00015	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?_tcsrchr@@YAPADPADI@Z ENDP				; _tcsrchr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
;	COMDAT ?_tcschr@@YAPADPADI@Z
_TEXT	SEGMENT
__S$ = 8						; size = 4
__C$ = 12						; size = 4
?_tcschr@@YAPADPADI@Z PROC				; _tcschr, COMDAT

; 2023 :         {return ((char *)_tcschr((const char *)_S, _C)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __C$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __S$[ebp]
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 __tcschr
  00010	83 c4 08	 add	 esp, 8
  00013	3b ec		 cmp	 ebp, esp
  00015	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?_tcschr@@YAPADPADI@Z ENDP				; _tcschr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
;	COMDAT __tcscmp
_TEXT	SEGMENT
__s1$ = 8						; size = 4
__s2$ = 12						; size = 4
__tcscmp PROC						; COMDAT

; 1669 : _Check_return_ __inline int _tcscmp(_In_ _CPC _s1,_In_ _CPC _s2) {return _mbscmp((_CPUC)_s1,(_CPUC)_s2);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f4		 mov	 esi, esp
  00006	8b 45 0c	 mov	 eax, DWORD PTR __s2$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __s1$[ebp]
  0000d	51		 push	 ecx
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mbscmp
  00014	83 c4 08	 add	 esp, 8
  00017	3b f4		 cmp	 esi, esp
  00019	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001e	5e		 pop	 esi
  0001f	3b ec		 cmp	 ebp, esp
  00021	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
__tcscmp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
;	COMDAT __tcsrchr
_TEXT	SEGMENT
__s1$ = 8						; size = 4
__c$ = 12						; size = 4
__tcsrchr PROC						; COMDAT

; 1569 : _Check_return_ __inline _CRPC _tcsrchr(_In_ _CPC _s1,_In_ _UI _c) {return (_CRPC)_mbsrchr((_CPUC)_s1,_c);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f4		 mov	 esi, esp
  00006	8b 45 0c	 mov	 eax, DWORD PTR __c$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __s1$[ebp]
  0000d	51		 push	 ecx
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mbsrchr
  00014	83 c4 08	 add	 esp, 8
  00017	3b f4		 cmp	 esi, esp
  00019	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001e	5e		 pop	 esi
  0001f	3b ec		 cmp	 ebp, esp
  00021	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
__tcsrchr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
;	COMDAT __tcsncpy
_TEXT	SEGMENT
__Dst$ = 8						; size = 4
__Source$ = 12						; size = 4
__Count$ = 16						; size = 4
__tcsncpy PROC						; COMDAT

; 1542 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1543 : #pragma warning(push)
; 1544 : #pragma warning(disable:4996)
; 1545 :     return (char *)_mbsnbcpy((unsigned char *)_Dst,(const unsigned char *)_Source,_Count);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Source$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 08	 mov	 edx, DWORD PTR __Dst$[ebp]
  00011	52		 push	 edx
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mbsnbcpy
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001b	3b f4		 cmp	 esi, esp
  0001d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1546 : #pragma warning(pop)
; 1547 : }

  00022	5e		 pop	 esi
  00023	3b ec		 cmp	 ebp, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
__tcsncpy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\tchar.h
;	COMDAT __tcschr
_TEXT	SEGMENT
__s1$ = 8						; size = 4
__c$ = 12						; size = 4
__tcschr PROC						; COMDAT

; 1497 : __inline _CRPC _tcschr(_In_ _CPC _s1,_In_ _UI _c) {return (_CRPC)_mbschr((_CPUC)_s1,_c);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f4		 mov	 esi, esp
  00006	8b 45 0c	 mov	 eax, DWORD PTR __c$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __s1$[ebp]
  0000d	51		 push	 ecx
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mbschr
  00014	83 c4 08	 add	 esp, 8
  00017	3b f4		 cmp	 esi, esp
  00019	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001e	5e		 pop	 esi
  0001f	3b ec		 cmp	 ebp, esp
  00021	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
__tcschr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\string.h
;	COMDAT ?strchr@@YAPADQADH@Z
_TEXT	SEGMENT
__String$ = 8						; size = 4
__Ch$ = 12						; size = 4
?strchr@@YAPADQADH@Z PROC				; strchr, COMDAT

; 518  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 519  :         return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Ch$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __String$[ebp]
  0000d	51		 push	 ecx
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strchr
  00014	83 c4 08	 add	 esp, 8
  00017	3b f4		 cmp	 esi, esp
  00019	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 520  :     }

  0001e	5e		 pop	 esi
  0001f	3b ec		 cmp	 ebp, esp
  00021	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?strchr@@YAPADQADH@Z ENDP				; strchr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

  00014	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
  00019	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0001c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __ArgList$[ebp]
  00022	51		 push	 ecx
  00023	6a 00		 push	 0
  00025	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00028	52		 push	 edx
  00029	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 __vsprintf_l
  00032	83 c4 10	 add	 esp, 16			; 00000010H
  00035	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

  00038	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1787 :     return _Result;

  0003f	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 1788 : }

  00042	83 c4 08	 add	 esp, 8
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00003	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  0000e	52		 push	 edx
  0000f	6a ff		 push	 -1
  00011	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 __vsnprintf_l
  0001a	83 c4 14	 add	 esp, 20			; 00000014H

; 1459 :     #pragma warning(pop)
; 1460 : }

  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00015	8b f4		 mov	 esi, esp
  00017	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00022	52		 push	 edx
  00023	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00030	8b 10		 mov	 edx, DWORD PTR [eax]
  00032	83 ca 01	 or	 edx, 1
  00035	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00038	50		 push	 eax
  00039	52		 push	 edx
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf
  00040	83 c4 1c	 add	 esp, 28			; 0000001cH
  00043	3b f4		 cmp	 esi, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  0004d	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  00051	7d 09		 jge	 SHORT $LN3@vsnprintf_
  00053	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  0005a	eb 06		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0005c	8b 4d fc	 mov	 ecx, DWORD PTR __Result$[ebp]
  0005f	89 4d f8	 mov	 DWORD PTR tv74[ebp], ecx
$LN4@vsnprintf_:
  00062	8b 45 f8	 mov	 eax, DWORD PTR tv74[ebp]

; 1391 : }

  00065	5e		 pop	 esi
  00066	83 c4 08	 add	 esp, 8
  00069	3b ec		 cmp	 ebp, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 950  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 951  :     int _Result;
; 952  :     va_list _ArgList;
; 953  :     __crt_va_start(_ArgList, _Format);

  00015	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
  0001a	8d 45 0c	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0001d	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 954  :     _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00020	8b 4d f8	 mov	 ecx, DWORD PTR __ArgList$[ebp]
  00023	51		 push	 ecx
  00024	6a 00		 push	 0
  00026	8b 55 08	 mov	 edx, DWORD PTR __Format$[ebp]
  00029	52		 push	 edx
  0002a	8b f4		 mov	 esi, esp
  0002c	6a 01		 push	 1
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  00034	83 c4 04	 add	 esp, 4
  00037	3b f4		 cmp	 esi, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 __vfprintf_l
  00044	83 c4 10	 add	 esp, 16			; 00000010H
  00047	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 955  :     __crt_va_end(_ArgList);

  0004a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 956  :     return _Result;

  00051	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 957  : }

  00054	5e		 pop	 esi
  00055	83 c4 08	 add	 esp, 8
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 144  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 638  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00011	52		 push	 edx
  00012	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0001b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001e	51		 push	 ecx
  0001f	8b 10		 mov	 edx, DWORD PTR [eax]
  00021	52		 push	 edx
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vfprintf
  00028	83 c4 18	 add	 esp, 24			; 00000018H
  0002b	3b f4		 cmp	 esi, esp
  0002d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 640  : }

  00032	5e		 pop	 esi
  00033	3b ec		 cmp	 ebp, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
