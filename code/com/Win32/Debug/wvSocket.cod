; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	E:\InfiniA-Library-3.0\com\src\wvSocket.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG84629 DB	'Socket select error', 00H
$SG84676 DB	'WVSocket::ConnectTo Socket create Error', 00H
$SG84678 DB	'WVSocket::ConnectTo Socket connect Error', 00H
	ORG $+3
$SG84688 DB	'WVSocket::ConnectTo Socket send Error', 00H
	ORG $+2
$SG84704 DB	'WVSocket::PutData Socket send Error', 00H
$SG84709 DB	'WVSocket::PutData Socket send Error - 2', 00H
$SG84711 DB	'WVSocket::PutData send timeout Error', 00H
	ORG $+3
$SG84729 DB	'WVSocket::GetData recv Error', 00H
	ORG $+3
$SG84747 DB	'WVSocket::RecvStringData length Reading Down!', 00H
	ORG $+2
$SG84749 DB	'WVSocket::RecvStringData length Reading Timeout!', 00H
	ORG $+3
$SG84769 DB	'%d.%d.%d.%d', 00H
CONST	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	?c_memcpy@@YAPAXPAXPBXH@Z			; c_memcpy
PUBLIC	??0WVSocket@@QAE@XZ				; WVSocket::WVSocket
PUBLIC	??0WVSocket@@QAE@PBDH@Z				; WVSocket::WVSocket
PUBLIC	??1WVSocket@@QAE@XZ				; WVSocket::~WVSocket
PUBLIC	?IsRecvData@WVSocket@@QAE_NXZ			; WVSocket::IsRecvData
PUBLIC	?SetOption@WVSocket@@QAEHHHPBXH@Z		; WVSocket::SetOption
PUBLIC	?GetOption@WVSocket@@QAEHHHPAXPAH@Z		; WVSocket::GetOption
PUBLIC	?GetData@WVSocket@@QAEHPADHJ@Z			; WVSocket::GetData
PUBLIC	?PutData@WVSocket@@QAEHPADHJ@Z			; WVSocket::PutData
PUBLIC	?SetAcceptedSocket@WVSocket@@QAEXH@Z		; WVSocket::SetAcceptedSocket
PUBLIC	?GetRecvData@WVSocket@@QAEHPADH@Z		; WVSocket::GetRecvData
PUBLIC	?ConnectTo@WVSocket@@QAEHPBDH@Z			; WVSocket::ConnectTo
PUBLIC	?SendNRecv@WVSocket@@QAEHPAHPADH@Z		; WVSocket::SendNRecv
PUBLIC	?RecvStringData@WVSocket@@QAEHPADH@Z		; WVSocket::RecvStringData
PUBLIC	?GetHostIP@WVSocket@@SAPBDXZ			; WVSocket::GetHostIP
PUBLIC	?ConnectWithTimeout@WVSocket@@QAEHPADHH@Z	; WVSocket::ConnectWithTimeout
PUBLIC	?onClose@WVSocket@@IAEXXZ			; WVSocket::onClose
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	_memset:PROC
EXTRN	_strcpy:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__atoi:PROC
EXTRN	___WSAFDIsSet@8:PROC
EXTRN	__imp__closesocket@4:PROC
EXTRN	__imp__connect@12:PROC
EXTRN	__imp__getsockopt@20:PROC
EXTRN	__imp__htons@4:PROC
EXTRN	__imp__inet_addr@4:PROC
EXTRN	__imp__recv@16:PROC
EXTRN	__imp__select@20:PROC
EXTRN	__imp__send@16:PROC
EXTRN	__imp__setsockopt@20:PROC
EXTRN	__imp__socket@12:PROC
EXTRN	__imp__gethostbyname@4:PROC
EXTRN	__imp__gethostname@8:PROC
EXTRN	__imp__WSAGetLastError@0:PROC
EXTRN	__imp___time64:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_UninitUse:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?_hostIP@?1??GetHostIP@WVSocket@@SAPBDXZ@4PADA
_BSS	SEGMENT
?_hostIP@?1??GetHostIP@WVSocket@@SAPBDXZ@4PADA DB 014H DUP (?) ; `WVSocket::GetHostIP'::`2'::_hostIP
_BSS	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
xdata$x	SEGMENT
__ehfuncinfo$??1WVSocket@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\wvsocket.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?onClose@WVSocket@@IAEXXZ PROC				; WVSocket::onClose
; _this$ = ecx

; 97   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 98   : 	SOCKETCLOSE(m_nSocket);

  0000f	8b f4		 mov	 esi, esp
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00017	51		 push	 ecx
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4
  0001e	3b f4		 cmp	 esi, esp
  00020	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 99   : 	m_nSocket = -1;

  00025	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00028	c7 42 04 ff ff
	ff ff		 mov	 DWORD PTR [edx+4], -1

; 100  : 	m_bConnected = false;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00032	c6 00 00	 mov	 BYTE PTR [eax], 0

; 101  : }

  00035	5e		 pop	 esi
  00036	83 c4 04	 add	 esp, 4
  00039	3b ec		 cmp	 ebp, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?onClose@WVSocket@@IAEXXZ ENDP				; WVSocket::onClose
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\wvsocket.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_szIP$ = 8						; size = 4
_nPort$ = 12						; size = 4
_nTimeout$ = 16						; size = 4
?ConnectWithTimeout@WVSocket@@QAEHPADHH@Z PROC		; WVSocket::ConnectWithTimeout
; _this$ = ecx

; 368  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 369  : #ifndef WIN32
; 370  : 	struct sockaddr_in sa;
; 371  : 	struct	timeval tmval;
; 372  : 	int nRet, flags, error;
; 373  : 	fd_set	wset, rset;
; 374  : 	
; 375  : 	strcpy(m_szIP, szIP);
; 376  : 	m_nPort = nPort;
; 377  : 	if (m_nSocket == -1) {
; 378  : 		m_nSocket = ::socket(SOCK_FLAG, SOCK_STREAM, 0);
; 379  : 		if (m_nSocket == -1) {
; 380  : 			return -1;
; 381  : 		}
; 382  : 	}
; 383  : 
; 384  : 	memset(&sa, 0x00, sizeof(sa));
; 385  : 	
; 386  : 	sa.sin_family = AF_INET;
; 387  : 	sa.sin_port = htons((short)nPort);
; 388  : 	sa.sin_addr.s_addr = inet_addr(szIP);
; 389  : 	
; 390  : 	if (!nTimeout) {
; 391  : 		if (m_cLogger)
; 392  : 			m_cLogger->LogPrint(LOG_DEBUG, "Normal connect\n");
; 393  : 		nRet = connect(m_nSocket, (struct sockaddr*)&sa, sizeof(sockaddr_in));
; 394  : 		if(nRet == -1) {
; 395  : 			onClose();
; 396  : 			return nRet;
; 397  : 		}
; 398  : 		else {
; 399  : 			m_bConnected = true;
; 400  : 			return 1;
; 401  : 		}
; 402  : 	}
; 403  : 
; 404  : 
; 405  : 	memset(&tmval, 0, sizeof(tmval));
; 406  : 	tmval.tv_sec = nTimeout;
; 407  : 
; 408  : 	flags = fcntl(m_nSocket, F_GETFL, 0);
; 409  : 	fcntl(m_nSocket, F_SETFL, flags | O_NONBLOCK);
; 410  : 
; 411  : 	error = 0;
; 412  : 
; 413  : 	nRet = connect(m_nSocket, (struct sockaddr*)&sa, sizeof(sockaddr_in));
; 414  : 	if (nRet < 0 && errno != EINPROGRESS) {
; 415  : 		onClose();
; 416  : 		return nRet;
; 417  : 	}
; 418  : 
; 419  : 	if (nRet == 0)
; 420  : 		goto done;
; 421  : 
; 422  : 	FD_ZERO(&rset);
; 423  : 	FD_SET(m_nSocket, &rset);
; 424  : 	wset = rset;
; 425  : 
; 426  : 	if (select(m_nSocket + 1, &rset, &wset, NULL, &tmval) == 0) {
; 427  : 		printf("TImeout Error\n");
; 428  : 		errno = ETIMEDOUT;
; 429  : 		return -1;
; 430  : 	}
; 431  : 
; 432  : 	if (FD_ISSET(m_nSocket, &rset) || FD_ISSET(m_nSocket, &wset)) {
; 433  : 		int len = sizeof(error);
; 434  : #if	defined(__ia64)
; 435  : 		if (getsockopt(m_nSocket, SOL_SOCKET, SO_ERROR, (void*)&error, &len) < 0) {
; 436  : #else
; 437  : 		if (getsockopt(m_nSocket, SOL_SOCKET, SO_ERROR, (void*)&error, (socklen_t *)&len) < 0) {
; 438  : #endif
; 439  : 			onClose();
; 440  : 			return -1;
; 441  : 		}
; 442  : 	}
; 443  : 	
; 444  : done:
; 445  : 	fcntl(m_nSocket, F_SETFL, flags);
; 446  : 	if (error != 0) {
; 447  : 		errno = error;
; 448  : 		onClose();
; 449  : 		return -1;
; 450  : 	}
; 451  : 	
; 452  : 	m_bConnected = true;
; 453  : #endif
; 454  : 	return 1;

  0000e	b8 01 00 00 00	 mov	 eax, 1

; 455  : }

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 0c 00	 ret	 12			; 0000000cH
?ConnectWithTimeout@WVSocket@@QAEHPADHH@Z ENDP		; WVSocket::ConnectWithTimeout
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\wvsocket.cpp
_TEXT	SEGMENT
_szHName$ = -140					; size = 128
_hEntry$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?GetHostIP@WVSocket@@SAPBDXZ PROC			; WVSocket::GetHostIP

; 347  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd 70 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-144]
  00011	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 348  : 	static	char _hostIP[20];
; 349  :     struct  hostent *hEntry;
; 350  : 	char    szHName[128];
; 351  : 
; 352  : 	if (gethostname(szHName, sizeof(szHName)) == 0) {

  00027	8b f4		 mov	 esi, esp
  00029	68 80 00 00 00	 push	 128			; 00000080H
  0002e	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _szHName$[ebp]
  00034	50		 push	 eax
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__gethostname@8
  0003b	3b f4		 cmp	 esi, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00042	85 c0		 test	 eax, eax
  00044	0f 85 d8 00 00
	00		 jne	 $LN2@GetHostIP

; 353  : 		hEntry = gethostbyname(szHName);

  0004a	8b f4		 mov	 esi, esp
  0004c	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _szHName$[ebp]
  00052	51		 push	 ecx
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__gethostbyname@4
  00059	3b f4		 cmp	 esi, esp
  0005b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00060	89 45 f8	 mov	 DWORD PTR _hEntry$[ebp], eax

; 354  : 		if (hEntry && hEntry->h_addr_list && hEntry->h_addr_list[0]) {

  00063	83 7d f8 00	 cmp	 DWORD PTR _hEntry$[ebp], 0
  00067	0f 84 b5 00 00
	00		 je	 $LN2@GetHostIP
  0006d	8b 55 f8	 mov	 edx, DWORD PTR _hEntry$[ebp]
  00070	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  00074	0f 84 a8 00 00
	00		 je	 $LN2@GetHostIP
  0007a	b8 04 00 00 00	 mov	 eax, 4
  0007f	6b c8 00	 imul	 ecx, eax, 0
  00082	8b 55 f8	 mov	 edx, DWORD PTR _hEntry$[ebp]
  00085	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00088	83 3c 01 00	 cmp	 DWORD PTR [ecx+eax], 0
  0008c	0f 84 90 00 00
	00		 je	 $LN2@GetHostIP

; 355  : 			sprintf(_hostIP, "%d.%d.%d.%d", 

  00092	b9 04 00 00 00	 mov	 ecx, 4
  00097	6b d1 00	 imul	 edx, ecx, 0
  0009a	8b 45 f8	 mov	 eax, DWORD PTR _hEntry$[ebp]
  0009d	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000a0	b8 01 00 00 00	 mov	 eax, 1
  000a5	6b c0 03	 imul	 eax, eax, 3
  000a8	8b 0c 11	 mov	 ecx, DWORD PTR [ecx+edx]
  000ab	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  000af	52		 push	 edx
  000b0	b8 04 00 00 00	 mov	 eax, 4
  000b5	6b c8 00	 imul	 ecx, eax, 0
  000b8	8b 55 f8	 mov	 edx, DWORD PTR _hEntry$[ebp]
  000bb	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000be	ba 01 00 00 00	 mov	 edx, 1
  000c3	d1 e2		 shl	 edx, 1
  000c5	8b 04 08	 mov	 eax, DWORD PTR [eax+ecx]
  000c8	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  000cc	51		 push	 ecx
  000cd	ba 04 00 00 00	 mov	 edx, 4
  000d2	6b c2 00	 imul	 eax, edx, 0
  000d5	8b 4d f8	 mov	 ecx, DWORD PTR _hEntry$[ebp]
  000d8	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000db	b9 01 00 00 00	 mov	 ecx, 1
  000e0	c1 e1 00	 shl	 ecx, 0
  000e3	8b 14 02	 mov	 edx, DWORD PTR [edx+eax]
  000e6	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  000ea	50		 push	 eax
  000eb	b9 04 00 00 00	 mov	 ecx, 4
  000f0	6b d1 00	 imul	 edx, ecx, 0
  000f3	8b 45 f8	 mov	 eax, DWORD PTR _hEntry$[ebp]
  000f6	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000f9	b8 01 00 00 00	 mov	 eax, 1
  000fe	6b c0 00	 imul	 eax, eax, 0
  00101	8b 0c 11	 mov	 ecx, DWORD PTR [ecx+edx]
  00104	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00108	52		 push	 edx
  00109	68 00 00 00 00	 push	 OFFSET $SG84769
  0010e	68 00 00 00 00	 push	 OFFSET ?_hostIP@?1??GetHostIP@WVSocket@@SAPBDXZ@4PADA
  00113	e8 00 00 00 00	 call	 _sprintf
  00118	83 c4 18	 add	 esp, 24			; 00000018H

; 356  : 				(unsigned char)hEntry->h_addr_list[0][0],
; 357  : 				(unsigned char)hEntry->h_addr_list[0][1],
; 358  : 				(unsigned char)hEntry->h_addr_list[0][2],
; 359  : 				(unsigned char)hEntry->h_addr_list[0][3]);
; 360  : 			return _hostIP;

  0011b	b8 00 00 00 00	 mov	 eax, OFFSET ?_hostIP@?1??GetHostIP@WVSocket@@SAPBDXZ@4PADA
  00120	eb 02		 jmp	 SHORT $LN1@GetHostIP
$LN2@GetHostIP:

; 361  : 		}
; 362  : 	}
; 363  : 	return NULL;

  00122	33 c0		 xor	 eax, eax
$LN1@GetHostIP:

; 364  : }

  00124	52		 push	 edx
  00125	8b cd		 mov	 ecx, ebp
  00127	50		 push	 eax
  00128	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN7@GetHostIP
  0012e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00133	58		 pop	 eax
  00134	5a		 pop	 edx
  00135	5f		 pop	 edi
  00136	5e		 pop	 esi
  00137	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0013a	33 cd		 xor	 ecx, ebp
  0013c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00141	81 c4 90 00 00
	00		 add	 esp, 144		; 00000090H
  00147	3b ec		 cmp	 ebp, esp
  00149	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0014e	8b e5		 mov	 esp, ebp
  00150	5d		 pop	 ebp
  00151	c3		 ret	 0
  00152	66 90		 npad	 2
$LN7@GetHostIP:
  00154	01 00 00 00	 DD	 1
  00158	00 00 00 00	 DD	 $LN6@GetHostIP
$LN6@GetHostIP:
  0015c	74 ff ff ff	 DD	 -140			; ffffff74H
  00160	80 00 00 00	 DD	 128			; 00000080H
  00164	00 00 00 00	 DD	 $LN5@GetHostIP
$LN5@GetHostIP:
  00168	73		 DB	 115			; 00000073H
  00169	7a		 DB	 122			; 0000007aH
  0016a	48		 DB	 72			; 00000048H
  0016b	4e		 DB	 78			; 0000004eH
  0016c	61		 DB	 97			; 00000061H
  0016d	6d		 DB	 109			; 0000006dH
  0016e	65		 DB	 101			; 00000065H
  0016f	00		 DB	 0
?GetHostIP@WVSocket@@SAPBDXZ ENDP			; WVSocket::GetHostIP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\wvsocket.cpp
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
_tmpBuf$ = -32						; size = 5
_nTmp$ = -20						; size = 4
_nPos$ = -16						; size = 4
_nSize$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_szBuffer$ = 8						; size = 4
_nBLen$ = 12						; size = 4
?RecvStringData@WVSocket@@QAEHPADH@Z PROC		; WVSocket::RecvStringData
; _this$ = ecx

; 293  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	51		 push	 ecx
  00009	8d 7d d4	 lea	 edi, DWORD PTR [ebp-44]
  0000c	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  00011	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00016	f3 ab		 rep stosd
  00018	59		 pop	 ecx
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00023	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 294  : 	int nSize = 0;

  00026	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _nSize$[ebp], 0

; 295  : 	int nPos = 0;

  0002d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _nPos$[ebp], 0

; 296  : 	int nTmp = 0;

  00034	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _nTmp$[ebp], 0

; 297  : 	char	tmpBuf[5];
; 298  : 
; 299  : 	nTmp = GetData(tmpBuf, 3, DEF_TIMEOUT);

  0003b	6a 03		 push	 3
  0003d	6a 03		 push	 3
  0003f	8d 45 e0	 lea	 eax, DWORD PTR _tmpBuf$[ebp]
  00042	50		 push	 eax
  00043	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?GetData@WVSocket@@QAEHPADHJ@Z ; WVSocket::GetData
  0004b	89 45 ec	 mov	 DWORD PTR _nTmp$[ebp], eax

; 300  : 	nPos += 3;

  0004e	8b 4d f0	 mov	 ecx, DWORD PTR _nPos$[ebp]
  00051	83 c1 03	 add	 ecx, 3
  00054	89 4d f0	 mov	 DWORD PTR _nPos$[ebp], ecx

; 301  : 
; 302  : 	if (nTmp == -1) {

  00057	83 7d ec ff	 cmp	 DWORD PTR _nTmp$[ebp], -1
  0005b	75 26		 jne	 SHORT $LN2@RecvString

; 303  : 		onClose();

  0005d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00060	e8 00 00 00 00	 call	 ?onClose@WVSocket@@IAEXXZ ; WVSocket::onClose

; 304  : 		strcpy(m_szErrMsg, "WVSocket::RecvStringData length Reading Down!");

  00065	68 00 00 00 00	 push	 OFFSET $SG84747
  0006a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0006d	83 c2 38	 add	 edx, 56			; 00000038H
  00070	52		 push	 edx
  00071	e8 00 00 00 00	 call	 _strcpy
  00076	83 c4 08	 add	 esp, 8

; 305  : 		return -1;

  00079	83 c8 ff	 or	 eax, -1
  0007c	e9 6e 01 00 00	 jmp	 $LN1@RecvString
  00081	eb 2a		 jmp	 SHORT $LN3@RecvString
$LN2@RecvString:

; 306  : 	}
; 307  : 	else if (nTmp == -2) {

  00083	83 7d ec fe	 cmp	 DWORD PTR _nTmp$[ebp], -2 ; fffffffeH
  00087	75 24		 jne	 SHORT $LN3@RecvString

; 308  : 		onClose();

  00089	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008c	e8 00 00 00 00	 call	 ?onClose@WVSocket@@IAEXXZ ; WVSocket::onClose

; 309  : 		strcpy(m_szErrMsg, "WVSocket::RecvStringData length Reading Timeout!");

  00091	68 00 00 00 00	 push	 OFFSET $SG84749
  00096	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00099	83 c0 38	 add	 eax, 56			; 00000038H
  0009c	50		 push	 eax
  0009d	e8 00 00 00 00	 call	 _strcpy
  000a2	83 c4 08	 add	 esp, 8

; 310  : 		return -1;

  000a5	83 c8 ff	 or	 eax, -1
  000a8	e9 42 01 00 00	 jmp	 $LN1@RecvString
$LN3@RecvString:

; 311  : 	}
; 312  : 	SLEEP(1);

  000ad	8b f4		 mov	 esi, esp
  000af	68 e8 03 00 00	 push	 1000			; 000003e8H
  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
  000ba	3b f4		 cmp	 esi, esp
  000bc	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 313  : 	//패킷 총 길이 계산하기
; 314  : 	nSize = atoi(tmpBuf);

  000c1	8b f4		 mov	 esi, esp
  000c3	8d 4d e0	 lea	 ecx, DWORD PTR _tmpBuf$[ebp]
  000c6	51		 push	 ecx
  000c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  000cd	83 c4 04	 add	 esp, 4
  000d0	3b f4		 cmp	 esi, esp
  000d2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d7	89 45 f4	 mov	 DWORD PTR _nSize$[ebp], eax

; 315  : 	if (m_nRecvBLen < nPos + nSize + 1) {

  000da	8b 55 f4	 mov	 edx, DWORD PTR _nSize$[ebp]
  000dd	8b 45 f0	 mov	 eax, DWORD PTR _nPos$[ebp]
  000e0	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  000e4	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000e7	39 4a 0c	 cmp	 DWORD PTR [edx+12], ecx
  000ea	7d 5a		 jge	 SHORT $LN5@RecvString

; 316  : 		if (m_szRecvData)

  000ec	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ef	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  000f3	74 15		 je	 SHORT $LN6@RecvString

; 317  : 			delete [] m_szRecvData;	//20100127

  000f5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000f8	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000fb	89 55 d8	 mov	 DWORD PTR $T2[ebp], edx
  000fe	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00101	50		 push	 eax
  00102	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00107	83 c4 04	 add	 esp, 4
$LN6@RecvString:

; 318  : 		m_nRecvBLen = nPos+nSize+1;

  0010a	8b 4d f4	 mov	 ecx, DWORD PTR _nSize$[ebp]
  0010d	8b 55 f0	 mov	 edx, DWORD PTR _nPos$[ebp]
  00110	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  00114	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00117	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 319  : 		m_szRecvData = new char[m_nRecvBLen];

  0011a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0011d	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00120	50		 push	 eax
  00121	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00126	83 c4 04	 add	 esp, 4
  00129	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
  0012c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0012f	8b 55 d4	 mov	 edx, DWORD PTR $T1[ebp]
  00132	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 320  : 		if (m_szRecvData == NULL)

  00135	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00138	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0013c	75 08		 jne	 SHORT $LN5@RecvString

; 321  : 			return -1;

  0013e	83 c8 ff	 or	 eax, -1
  00141	e9 a9 00 00 00	 jmp	 $LN1@RecvString
$LN5@RecvString:

; 322  : 	}
; 323  : 	memset(m_szRecvData, 0, m_nRecvBLen);

  00146	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00149	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0014c	52		 push	 edx
  0014d	6a 00		 push	 0
  0014f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00152	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00155	51		 push	 ecx
  00156	e8 00 00 00 00	 call	 _memset
  0015b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 324  : 	c_memcpy(m_szRecvData, tmpBuf, nPos);

  0015e	8b 55 f0	 mov	 edx, DWORD PTR _nPos$[ebp]
  00161	52		 push	 edx
  00162	8d 45 e0	 lea	 eax, DWORD PTR _tmpBuf$[ebp]
  00165	50		 push	 eax
  00166	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00169	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0016c	52		 push	 edx
  0016d	e8 00 00 00 00	 call	 ?c_memcpy@@YAPAXPAXPBXH@Z ; c_memcpy
  00172	83 c4 0c	 add	 esp, 12			; 0000000cH

; 325  : 	
; 326  : 	if((nTmp = GetData(m_szRecvData+nPos, nSize - nPos, DEF_TIMEOUT)) == -1) {

  00175	6a 03		 push	 3
  00177	8b 45 f4	 mov	 eax, DWORD PTR _nSize$[ebp]
  0017a	2b 45 f0	 sub	 eax, DWORD PTR _nPos$[ebp]
  0017d	50		 push	 eax
  0017e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00181	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00184	03 55 f0	 add	 edx, DWORD PTR _nPos$[ebp]
  00187	52		 push	 edx
  00188	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0018b	e8 00 00 00 00	 call	 ?GetData@WVSocket@@QAEHPADHJ@Z ; WVSocket::GetData
  00190	89 45 ec	 mov	 DWORD PTR _nTmp$[ebp], eax
  00193	83 7d ec ff	 cmp	 DWORD PTR _nTmp$[ebp], -1
  00197	75 0f		 jne	 SHORT $LN8@RecvString

; 327  : 		onClose();

  00199	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0019c	e8 00 00 00 00	 call	 ?onClose@WVSocket@@IAEXXZ ; WVSocket::onClose

; 328  : 		return -1;

  001a1	83 c8 ff	 or	 eax, -1
  001a4	eb 49		 jmp	 SHORT $LN1@RecvString
  001a6	eb 13		 jmp	 SHORT $LN9@RecvString
$LN8@RecvString:

; 329  : 	}
; 330  : 	else if (nTmp == -2) {

  001a8	83 7d ec fe	 cmp	 DWORD PTR _nTmp$[ebp], -2 ; fffffffeH
  001ac	75 0d		 jne	 SHORT $LN9@RecvString

; 331  : 		onClose();

  001ae	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001b1	e8 00 00 00 00	 call	 ?onClose@WVSocket@@IAEXXZ ; WVSocket::onClose

; 332  : 		return -1;

  001b6	83 c8 ff	 or	 eax, -1
  001b9	eb 34		 jmp	 SHORT $LN1@RecvString
$LN9@RecvString:

; 333  : 	}
; 334  : 
; 335  : 	nPos = nSize;

  001bb	8b 45 f4	 mov	 eax, DWORD PTR _nSize$[ebp]
  001be	89 45 f0	 mov	 DWORD PTR _nPos$[ebp], eax

; 336  : 	if (nBLen < nPos) {

  001c1	8b 4d 0c	 mov	 ecx, DWORD PTR _nBLen$[ebp]
  001c4	3b 4d f0	 cmp	 ecx, DWORD PTR _nPos$[ebp]
  001c7	7d 07		 jge	 SHORT $LN11@RecvString

; 337  : 		return -2;

  001c9	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  001ce	eb 1f		 jmp	 SHORT $LN1@RecvString
$LN11@RecvString:

; 338  : 	}
; 339  : 
; 340  : 	strcpy(szBuffer, m_szRecvData);

  001d0	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  001d3	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  001d6	50		 push	 eax
  001d7	8b 4d 08	 mov	 ecx, DWORD PTR _szBuffer$[ebp]
  001da	51		 push	 ecx
  001db	e8 00 00 00 00	 call	 _strcpy
  001e0	83 c4 08	 add	 esp, 8

; 341  : 	m_nRecvDLen = nPos;

  001e3	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  001e6	8b 45 f0	 mov	 eax, DWORD PTR _nPos$[ebp]
  001e9	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 342  : 	return nPos;

  001ec	8b 45 f0	 mov	 eax, DWORD PTR _nPos$[ebp]
$LN1@RecvString:

; 343  : }

  001ef	52		 push	 edx
  001f0	8b cd		 mov	 ecx, ebp
  001f2	50		 push	 eax
  001f3	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN15@RecvString
  001f9	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001fe	58		 pop	 eax
  001ff	5a		 pop	 edx
  00200	5f		 pop	 edi
  00201	5e		 pop	 esi
  00202	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00205	33 cd		 xor	 ecx, ebp
  00207	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0020c	83 c4 2c	 add	 esp, 44			; 0000002cH
  0020f	3b ec		 cmp	 ebp, esp
  00211	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00216	8b e5		 mov	 esp, ebp
  00218	5d		 pop	 ebp
  00219	c2 08 00	 ret	 8
$LN15@RecvString:
  0021c	01 00 00 00	 DD	 1
  00220	00 00 00 00	 DD	 $LN14@RecvString
$LN14@RecvString:
  00224	e0 ff ff ff	 DD	 -32			; ffffffe0H
  00228	05 00 00 00	 DD	 5
  0022c	00 00 00 00	 DD	 $LN13@RecvString
$LN13@RecvString:
  00230	74		 DB	 116			; 00000074H
  00231	6d		 DB	 109			; 0000006dH
  00232	70		 DB	 112			; 00000070H
  00233	42		 DB	 66			; 00000042H
  00234	75		 DB	 117			; 00000075H
  00235	66		 DB	 102			; 00000066H
  00236	00		 DB	 0
?RecvStringData@WVSocket@@QAEHPADH@Z ENDP		; WVSocket::RecvStringData
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\wvsocket.cpp
_TEXT	SEGMENT
tv83 = -12						; size = 4
_nSize$ = -8						; size = 4
_this$ = -4						; size = 4
_nLen$ = 8						; size = 4
_szBuffer$ = 12						; size = 4
_nBLen$ = 16						; size = 4
?SendNRecv@WVSocket@@QAEHPAHPADH@Z PROC			; WVSocket::SendNRecv
; _this$ = ecx

; 181  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000e	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00015	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 	if(m_nSocket < 0)	return -1;

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00026	73 08		 jae	 SHORT $LN2@SendNRecv
  00028	83 c8 ff	 or	 eax, -1
  0002b	e9 95 00 00 00	 jmp	 $LN1@SendNRecv
$LN2@SendNRecv:

; 183  : 
; 184  : 	int nSize = send(m_nSocket, szBuffer, *nLen, NODELAY);

  00030	8b f4		 mov	 esi, esp
  00032	6a 00		 push	 0
  00034	8b 4d 08	 mov	 ecx, DWORD PTR _nLen$[ebp]
  00037	8b 11		 mov	 edx, DWORD PTR [ecx]
  00039	52		 push	 edx
  0003a	8b 45 0c	 mov	 eax, DWORD PTR _szBuffer$[ebp]
  0003d	50		 push	 eax
  0003e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00044	52		 push	 edx
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__send@16
  0004b	3b f4		 cmp	 esi, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	89 45 f8	 mov	 DWORD PTR _nSize$[ebp], eax

; 185  : 	if(nSize != *nLen) {

  00055	8b 45 08	 mov	 eax, DWORD PTR _nLen$[ebp]
  00058	8b 4d f8	 mov	 ecx, DWORD PTR _nSize$[ebp]
  0005b	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0005d	74 21		 je	 SHORT $LN3@SendNRecv

; 186  : 		strcpy(m_szErrMsg, "WVSocket::ConnectTo Socket send Error");		

  0005f	68 00 00 00 00	 push	 OFFSET $SG84688
  00064	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00067	83 c2 38	 add	 edx, 56			; 00000038H
  0006a	52		 push	 edx
  0006b	e8 00 00 00 00	 call	 _strcpy
  00070	83 c4 08	 add	 esp, 8

; 187  : 		onClose();

  00073	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	e8 00 00 00 00	 call	 ?onClose@WVSocket@@IAEXXZ ; WVSocket::onClose

; 188  : 		return -1;

  0007b	83 c8 ff	 or	 eax, -1
  0007e	eb 45		 jmp	 SHORT $LN1@SendNRecv
$LN3@SendNRecv:

; 189  : 	}
; 190  : 	SLEEP(1);

  00080	8b f4		 mov	 esi, esp
  00082	68 e8 03 00 00	 push	 1000			; 000003e8H
  00087	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
  0008d	3b f4		 cmp	 esi, esp
  0008f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 191  : 	*nLen = RecvStringData(szBuffer, nBLen);

  00094	8b 45 10	 mov	 eax, DWORD PTR _nBLen$[ebp]
  00097	50		 push	 eax
  00098	8b 4d 0c	 mov	 ecx, DWORD PTR _szBuffer$[ebp]
  0009b	51		 push	 ecx
  0009c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009f	e8 00 00 00 00	 call	 ?RecvStringData@WVSocket@@QAEHPADH@Z ; WVSocket::RecvStringData
  000a4	8b 55 08	 mov	 edx, DWORD PTR _nLen$[ebp]
  000a7	89 02		 mov	 DWORD PTR [edx], eax

; 192  : 	return *nLen < 0 ? -1 : *nLen;

  000a9	8b 45 08	 mov	 eax, DWORD PTR _nLen$[ebp]
  000ac	83 38 00	 cmp	 DWORD PTR [eax], 0
  000af	7d 09		 jge	 SHORT $LN5@SendNRecv
  000b1	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR tv83[ebp], -1
  000b8	eb 08		 jmp	 SHORT $LN6@SendNRecv
$LN5@SendNRecv:
  000ba	8b 4d 08	 mov	 ecx, DWORD PTR _nLen$[ebp]
  000bd	8b 11		 mov	 edx, DWORD PTR [ecx]
  000bf	89 55 f4	 mov	 DWORD PTR tv83[ebp], edx
$LN6@SendNRecv:
  000c2	8b 45 f4	 mov	 eax, DWORD PTR tv83[ebp]
$LN1@SendNRecv:

; 193  : }

  000c5	5e		 pop	 esi
  000c6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c9	3b ec		 cmp	 ebp, esp
  000cb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d0	8b e5		 mov	 esp, ebp
  000d2	5d		 pop	 ebp
  000d3	c2 0c 00	 ret	 12			; 0000000cH
?SendNRecv@WVSocket@@QAEHPAHPADH@Z ENDP			; WVSocket::SendNRecv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\wvsocket.cpp
_TEXT	SEGMENT
_nRet$ = -36						; size = 4
_sa$ = -28						; size = 16
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_szIP$ = 8						; size = 4
_nPort$ = 12						; size = 4
?ConnectTo@WVSocket@@QAEHPBDH@Z PROC			; WVSocket::ConnectTo
; _this$ = ecx

; 151  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  0000f	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  00012	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00015	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00018	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0001b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0001e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00021	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00024	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00027	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002c	33 c5		 xor	 eax, ebp
  0002e	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00031	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 152  : 	struct sockaddr_in sa;
; 153  : 	
; 154  : 	strcpy(m_szIP, szIP);

  00034	8b 45 08	 mov	 eax, DWORD PTR _szIP$[ebp]
  00037	50		 push	 eax
  00038	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	83 c1 14	 add	 ecx, 20			; 00000014H
  0003e	51		 push	 ecx
  0003f	e8 00 00 00 00	 call	 _strcpy
  00044	83 c4 08	 add	 esp, 8

; 155  : 	m_nPort = nPort;

  00047	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0004a	8b 45 0c	 mov	 eax, DWORD PTR _nPort$[ebp]
  0004d	89 42 34	 mov	 DWORD PTR [edx+52], eax

; 156  : 	if (m_nSocket == -1) {

  00050	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	83 79 04 ff	 cmp	 DWORD PTR [ecx+4], -1
  00057	75 40		 jne	 SHORT $LN2@ConnectTo

; 157  : 		m_nSocket = ::socket(SOCK_FLAG, SOCK_STREAM, 0);

  00059	8b f4		 mov	 esi, esp
  0005b	6a 00		 push	 0
  0005d	6a 01		 push	 1
  0005f	6a 02		 push	 2
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__socket@12
  00067	3b f4		 cmp	 esi, esp
  00069	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00071	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 158  : 		if (m_nSocket == -1) {

  00074	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00077	83 78 04 ff	 cmp	 DWORD PTR [eax+4], -1
  0007b	75 1c		 jne	 SHORT $LN2@ConnectTo

; 159  : 			strcpy(m_szErrMsg, "WVSocket::ConnectTo Socket create Error");

  0007d	68 00 00 00 00	 push	 OFFSET $SG84676
  00082	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00085	83 c1 38	 add	 ecx, 56			; 00000038H
  00088	51		 push	 ecx
  00089	e8 00 00 00 00	 call	 _strcpy
  0008e	83 c4 08	 add	 esp, 8

; 160  : 			return -1;

  00091	83 c8 ff	 or	 eax, -1
  00094	e9 98 00 00 00	 jmp	 $LN1@ConnectTo
$LN2@ConnectTo:

; 161  : 		}
; 162  : 	}
; 163  : 
; 164  : 	memset(&sa, 0x00, sizeof(sa));

  00099	6a 10		 push	 16			; 00000010H
  0009b	6a 00		 push	 0
  0009d	8d 55 e4	 lea	 edx, DWORD PTR _sa$[ebp]
  000a0	52		 push	 edx
  000a1	e8 00 00 00 00	 call	 _memset
  000a6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 165  : 	
; 166  : 	sa.sin_family = AF_INET;

  000a9	b8 02 00 00 00	 mov	 eax, 2
  000ae	66 89 45 e4	 mov	 WORD PTR _sa$[ebp], ax

; 167  : 	sa.sin_port = htons((short)nPort);

  000b2	8b f4		 mov	 esi, esp
  000b4	0f b7 4d 0c	 movzx	 ecx, WORD PTR _nPort$[ebp]
  000b8	51		 push	 ecx
  000b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__htons@4
  000bf	3b f4		 cmp	 esi, esp
  000c1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c6	66 89 45 e6	 mov	 WORD PTR _sa$[ebp+2], ax

; 168  : 	sa.sin_addr.s_addr = inet_addr(szIP);

  000ca	8b f4		 mov	 esi, esp
  000cc	8b 55 08	 mov	 edx, DWORD PTR _szIP$[ebp]
  000cf	52		 push	 edx
  000d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__inet_addr@4
  000d6	3b f4		 cmp	 esi, esp
  000d8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000dd	89 45 e8	 mov	 DWORD PTR _sa$[ebp+4], eax

; 169  : 	
; 170  : 	int nRet = connect(m_nSocket, (struct sockaddr*)&sa, sizeof(sockaddr_in));

  000e0	8b f4		 mov	 esi, esp
  000e2	6a 10		 push	 16			; 00000010H
  000e4	8d 45 e4	 lea	 eax, DWORD PTR _sa$[ebp]
  000e7	50		 push	 eax
  000e8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000eb	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000ee	52		 push	 edx
  000ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__connect@12
  000f5	3b f4		 cmp	 esi, esp
  000f7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000fc	89 45 dc	 mov	 DWORD PTR _nRet$[ebp], eax

; 171  : 	if(nRet == -1) {

  000ff	83 7d dc ff	 cmp	 DWORD PTR _nRet$[ebp], -1
  00103	75 21		 jne	 SHORT $LN4@ConnectTo

; 172  : 		strcpy(m_szErrMsg, "WVSocket::ConnectTo Socket connect Error");		

  00105	68 00 00 00 00	 push	 OFFSET $SG84678
  0010a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0010d	83 c0 38	 add	 eax, 56			; 00000038H
  00110	50		 push	 eax
  00111	e8 00 00 00 00	 call	 _strcpy
  00116	83 c4 08	 add	 esp, 8

; 173  : 		onClose();

  00119	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0011c	e8 00 00 00 00	 call	 ?onClose@WVSocket@@IAEXXZ ; WVSocket::onClose

; 174  : 		return nRet;

  00121	8b 45 dc	 mov	 eax, DWORD PTR _nRet$[ebp]
  00124	eb 0b		 jmp	 SHORT $LN1@ConnectTo
$LN4@ConnectTo:

; 175  : 	}
; 176  : 	m_bConnected = true;

  00126	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00129	c6 01 01	 mov	 BYTE PTR [ecx], 1

; 177  : 	return 1;

  0012c	b8 01 00 00 00	 mov	 eax, 1
$LN1@ConnectTo:

; 178  : }

  00131	52		 push	 edx
  00132	8b cd		 mov	 ecx, ebp
  00134	50		 push	 eax
  00135	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@ConnectTo
  0013b	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00140	58		 pop	 eax
  00141	5a		 pop	 edx
  00142	5e		 pop	 esi
  00143	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00146	33 cd		 xor	 ecx, ebp
  00148	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0014d	83 c4 24	 add	 esp, 36			; 00000024H
  00150	3b ec		 cmp	 ebp, esp
  00152	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00157	8b e5		 mov	 esp, ebp
  00159	5d		 pop	 ebp
  0015a	c2 08 00	 ret	 8
  0015d	0f 1f 00	 npad	 3
$LN8@ConnectTo:
  00160	01 00 00 00	 DD	 1
  00164	00 00 00 00	 DD	 $LN7@ConnectTo
$LN7@ConnectTo:
  00168	e4 ff ff ff	 DD	 -28			; ffffffe4H
  0016c	10 00 00 00	 DD	 16			; 00000010H
  00170	00 00 00 00	 DD	 $LN6@ConnectTo
$LN6@ConnectTo:
  00174	73		 DB	 115			; 00000073H
  00175	61		 DB	 97			; 00000061H
  00176	00		 DB	 0
?ConnectTo@WVSocket@@QAEHPBDH@Z ENDP			; WVSocket::ConnectTo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\wvsocket.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pBuf$ = 8						; size = 4
_nBLen$ = 12						; size = 4
?GetRecvData@WVSocket@@QAEHPADH@Z PROC			; WVSocket::GetRecvData
; _this$ = ecx

; 112  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 113  : 	if (m_szRecvData && pBuf) {

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00015	74 4e		 je	 SHORT $LN2@GetRecvDat
  00017	83 7d 08 00	 cmp	 DWORD PTR _pBuf$[ebp], 0
  0001b	74 48		 je	 SHORT $LN2@GetRecvDat

; 114  : 		if (nBLen < m_nRecvDLen) {

  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	8b 55 0c	 mov	 edx, DWORD PTR _nBLen$[ebp]
  00023	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  00026	7d 1c		 jge	 SHORT $LN3@GetRecvDat

; 115  : 			c_memcpy(pBuf, m_szRecvData, nBLen);

  00028	8b 45 0c	 mov	 eax, DWORD PTR _nBLen$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00032	52		 push	 edx
  00033	8b 45 08	 mov	 eax, DWORD PTR _pBuf$[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ?c_memcpy@@YAPAXPAXPBXH@Z ; c_memcpy
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 116  : 			return -1;

  0003f	83 c8 ff	 or	 eax, -1
  00042	eb 23		 jmp	 SHORT $LN1@GetRecvDat
$LN3@GetRecvDat:

; 117  : 		}
; 118  : 		c_memcpy(pBuf, m_szRecvData, m_nRecvDLen);

  00044	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0004a	52		 push	 edx
  0004b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00051	51		 push	 ecx
  00052	8b 55 08	 mov	 edx, DWORD PTR _pBuf$[ebp]
  00055	52		 push	 edx
  00056	e8 00 00 00 00	 call	 ?c_memcpy@@YAPAXPAXPBXH@Z ; c_memcpy
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 119  : 		return 1;

  0005e	b8 01 00 00 00	 mov	 eax, 1
  00063	eb 02		 jmp	 SHORT $LN1@GetRecvDat
$LN2@GetRecvDat:

; 120  : 	}
; 121  : 	return 0;

  00065	33 c0		 xor	 eax, eax
$LN1@GetRecvDat:

; 122  : }

  00067	83 c4 04	 add	 esp, 4
  0006a	3b ec		 cmp	 ebp, esp
  0006c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c2 08 00	 ret	 8
?GetRecvData@WVSocket@@QAEHPADH@Z ENDP			; WVSocket::GetRecvData
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\wvsocket.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nSocket$ = 8						; size = 4
?SetAcceptedSocket@WVSocket@@QAEXH@Z PROC		; WVSocket::SetAcceptedSocket
; _this$ = ecx

; 104  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 105  : 	if (m_nSocket >= 0)

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00016	72 16		 jb	 SHORT $LN2@SetAccepte

; 106  : 		SOCKETCLOSE(m_nSocket);

  00018	8b f4		 mov	 esi, esp
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00020	52		 push	 edx
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4
  00027	3b f4		 cmp	 esi, esp
  00029	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@SetAccepte:

; 107  : 	m_nSocket = nSocket;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b 4d 08	 mov	 ecx, DWORD PTR _nSocket$[ebp]
  00034	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 108  : 	m_bConnected = true;

  00037	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003a	c6 02 01	 mov	 BYTE PTR [edx], 1

; 109  : }

  0003d	5e		 pop	 esi
  0003e	83 c4 04	 add	 esp, 4
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4
?SetAcceptedSocket@WVSocket@@QAEXH@Z ENDP		; WVSocket::SetAcceptedSocket
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\wvsocket.cpp
_TEXT	SEGMENT
tv193 = -44						; size = 8
tv190 = -36						; size = 8
_sPos$ = -28						; size = 4
_sLen$ = -24						; size = 4
_tmCur$ = -20						; size = 8
_tmIn$ = -12						; size = 8
_this$ = -4						; size = 4
_szBuf$ = 8						; size = 4
_nLen$ = 12						; size = 4
_ltimeOut$ = 16						; size = 4
?PutData@WVSocket@@QAEHPADHJ@Z PROC			; WVSocket::PutData
; _this$ = ecx

; 198  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	51		 push	 ecx
  00009	8d 7d d4	 lea	 edi, DWORD PTR [ebp-44]
  0000c	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  00011	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00016	f3 ab		 rep stosd
  00018	59		 pop	 ecx
  00019	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 199  : 	time_t	tmIn, tmCur;
; 200  : 	int	sLen, sPos;
; 201  : 
; 202  : 	if (m_nSocket < 0)

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00023	73 08		 jae	 SHORT $LN4@PutData

; 203  : 		return -1;

  00025	83 c8 ff	 or	 eax, -1
  00028	e9 78 01 00 00	 jmp	 $LN1@PutData
$LN4@PutData:

; 204  : 	
; 205  : 	if (ltimeOut == 0) {

  0002d	83 7d 10 00	 cmp	 DWORD PTR _ltimeOut$[ebp], 0
  00031	75 55		 jne	 SHORT $LN5@PutData

; 206  : 		sLen = send(m_nSocket, szBuf, nLen, 0);

  00033	8b f4		 mov	 esi, esp
  00035	6a 00		 push	 0
  00037	8b 4d 0c	 mov	 ecx, DWORD PTR _nLen$[ebp]
  0003a	51		 push	 ecx
  0003b	8b 55 08	 mov	 edx, DWORD PTR _szBuf$[ebp]
  0003e	52		 push	 edx
  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00045	51		 push	 ecx
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__send@16
  0004c	3b f4		 cmp	 esi, esp
  0004e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00053	89 45 e8	 mov	 DWORD PTR _sLen$[ebp], eax

; 207  : 		if (sLen < 0) 

  00056	83 7d e8 00	 cmp	 DWORD PTR _sLen$[ebp], 0
  0005a	7d 24		 jge	 SHORT $LN6@PutData

; 208  : 		{
; 209  : 			strcpy(m_szErrMsg, "WVSocket::PutData Socket send Error");	

  0005c	68 00 00 00 00	 push	 OFFSET $SG84704
  00061	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00064	83 c2 38	 add	 edx, 56			; 00000038H
  00067	52		 push	 edx
  00068	e8 00 00 00 00	 call	 _strcpy
  0006d	83 c4 08	 add	 esp, 8

; 210  : 			onClose();

  00070	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	e8 00 00 00 00	 call	 ?onClose@WVSocket@@IAEXXZ ; WVSocket::onClose

; 211  : 			return -1;

  00078	83 c8 ff	 or	 eax, -1
  0007b	e9 25 01 00 00	 jmp	 $LN1@PutData
$LN6@PutData:

; 212  : 		}
; 213  : 		return sLen;

  00080	8b 45 e8	 mov	 eax, DWORD PTR _sLen$[ebp]
  00083	e9 1d 01 00 00	 jmp	 $LN1@PutData
$LN5@PutData:

; 214  : 	}
; 215  : 
; 216  : 	sPos = sLen = 0;

  00088	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _sLen$[ebp], 0
  0008f	8b 45 e8	 mov	 eax, DWORD PTR _sLen$[ebp]
  00092	89 45 e4	 mov	 DWORD PTR _sPos$[ebp], eax

; 217  : 	tmIn = tmCur = time(NULL);

  00095	6a 00		 push	 0
  00097	e8 00 00 00 00	 call	 _time
  0009c	83 c4 04	 add	 esp, 4
  0009f	89 45 ec	 mov	 DWORD PTR _tmCur$[ebp], eax
  000a2	89 55 f0	 mov	 DWORD PTR _tmCur$[ebp+4], edx
  000a5	8b 4d ec	 mov	 ecx, DWORD PTR _tmCur$[ebp]
  000a8	89 4d f4	 mov	 DWORD PTR _tmIn$[ebp], ecx
  000ab	8b 55 f0	 mov	 edx, DWORD PTR _tmCur$[ebp+4]
  000ae	89 55 f8	 mov	 DWORD PTR _tmIn$[ebp+4], edx
$LN2@PutData:

; 218  : 	while (sPos < nLen) {

  000b1	8b 45 e4	 mov	 eax, DWORD PTR _sPos$[ebp]
  000b4	3b 45 0c	 cmp	 eax, DWORD PTR _nLen$[ebp]
  000b7	0f 8d e5 00 00
	00		 jge	 $LN3@PutData

; 219  : 		sLen = send(m_nSocket, szBuf + sPos, nLen - sPos, NODELAY);

  000bd	8b f4		 mov	 esi, esp
  000bf	6a 00		 push	 0
  000c1	8b 4d 0c	 mov	 ecx, DWORD PTR _nLen$[ebp]
  000c4	2b 4d e4	 sub	 ecx, DWORD PTR _sPos$[ebp]
  000c7	51		 push	 ecx
  000c8	8b 55 08	 mov	 edx, DWORD PTR _szBuf$[ebp]
  000cb	03 55 e4	 add	 edx, DWORD PTR _sPos$[ebp]
  000ce	52		 push	 edx
  000cf	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000d2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d5	51		 push	 ecx
  000d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__send@16
  000dc	3b f4		 cmp	 esi, esp
  000de	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e3	89 45 e8	 mov	 DWORD PTR _sLen$[ebp], eax

; 220  : 		if (sLen < 0) {

  000e6	83 7d e8 00	 cmp	 DWORD PTR _sLen$[ebp], 0
  000ea	7d 51		 jge	 SHORT $LN7@PutData

; 221  : #ifdef WIN32
; 222  : 			if (WSAGetLastError() == WSAEWOULDBLOCK) {

  000ec	8b f4		 mov	 esi, esp
  000ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  000f4	3b f4		 cmp	 esi, esp
  000f6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000fb	3d 33 27 00 00	 cmp	 eax, 10035		; 00002733H
  00100	75 18		 jne	 SHORT $LN9@PutData

; 223  : #else
; 224  : 			if (errno == EWOULDBLOCK) {
; 225  : #endif
; 226  : 				SLEEP(1);

  00102	8b f4		 mov	 esi, esp
  00104	68 e8 03 00 00	 push	 1000			; 000003e8H
  00109	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
  0010f	3b f4		 cmp	 esi, esp
  00111	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 227  : 				continue;

  00116	eb 99		 jmp	 SHORT $LN2@PutData

; 228  : 			}
; 229  : 			else {

  00118	eb 14		 jmp	 SHORT $LN10@PutData
$LN9@PutData:

; 230  : 				strcpy(m_szErrMsg, "WVSocket::PutData Socket send Error - 2");	

  0011a	68 00 00 00 00	 push	 OFFSET $SG84709
  0011f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00122	83 c2 38	 add	 edx, 56			; 00000038H
  00125	52		 push	 edx
  00126	e8 00 00 00 00	 call	 _strcpy
  0012b	83 c4 08	 add	 esp, 8
$LN10@PutData:

; 231  : 			}
; 232  : 			onClose();

  0012e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00131	e8 00 00 00 00	 call	 ?onClose@WVSocket@@IAEXXZ ; WVSocket::onClose

; 233  : 			return -1;

  00136	83 c8 ff	 or	 eax, -1
  00139	eb 6a		 jmp	 SHORT $LN1@PutData

; 234  : 
; 235  : 		}
; 236  : 		else

  0013b	eb 09		 jmp	 SHORT $LN8@PutData
$LN7@PutData:

; 237  : 			sPos += sLen;

  0013d	8b 45 e4	 mov	 eax, DWORD PTR _sPos$[ebp]
  00140	03 45 e8	 add	 eax, DWORD PTR _sLen$[ebp]
  00143	89 45 e4	 mov	 DWORD PTR _sPos$[ebp], eax
$LN8@PutData:

; 238  : 
; 239  : 		tmCur = time(NULL); // 20090420 rivo

  00146	6a 00		 push	 0
  00148	e8 00 00 00 00	 call	 _time
  0014d	83 c4 04	 add	 esp, 4
  00150	89 45 ec	 mov	 DWORD PTR _tmCur$[ebp], eax
  00153	89 55 f0	 mov	 DWORD PTR _tmCur$[ebp+4], edx

; 240  : 
; 241  : 		if (tmCur - tmIn > ltimeOut) {

  00156	8b 4d ec	 mov	 ecx, DWORD PTR _tmCur$[ebp]
  00159	2b 4d f4	 sub	 ecx, DWORD PTR _tmIn$[ebp]
  0015c	8b 75 f0	 mov	 esi, DWORD PTR _tmCur$[ebp+4]
  0015f	1b 75 f8	 sbb	 esi, DWORD PTR _tmIn$[ebp+4]
  00162	8b 45 10	 mov	 eax, DWORD PTR _ltimeOut$[ebp]
  00165	99		 cdq
  00166	89 4d dc	 mov	 DWORD PTR tv190[ebp], ecx
  00169	89 75 e0	 mov	 DWORD PTR tv190[ebp+4], esi
  0016c	89 45 d4	 mov	 DWORD PTR tv193[ebp], eax
  0016f	89 55 d8	 mov	 DWORD PTR tv193[ebp+4], edx
  00172	8b 55 e0	 mov	 edx, DWORD PTR tv190[ebp+4]
  00175	3b 55 d8	 cmp	 edx, DWORD PTR tv193[ebp+4]
  00178	7c 23		 jl	 SHORT $LN11@PutData
  0017a	7f 08		 jg	 SHORT $LN14@PutData
  0017c	8b 45 dc	 mov	 eax, DWORD PTR tv190[ebp]
  0017f	3b 45 d4	 cmp	 eax, DWORD PTR tv193[ebp]
  00182	76 19		 jbe	 SHORT $LN11@PutData
$LN14@PutData:

; 242  : 			strcpy(m_szErrMsg, "WVSocket::PutData send timeout Error");

  00184	68 00 00 00 00	 push	 OFFSET $SG84711
  00189	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0018c	83 c1 38	 add	 ecx, 56			; 00000038H
  0018f	51		 push	 ecx
  00190	e8 00 00 00 00	 call	 _strcpy
  00195	83 c4 08	 add	 esp, 8

; 243  : 			return sPos;

  00198	8b 45 e4	 mov	 eax, DWORD PTR _sPos$[ebp]
  0019b	eb 08		 jmp	 SHORT $LN1@PutData
$LN11@PutData:

; 244  : 		}
; 245  : 	}

  0019d	e9 0f ff ff ff	 jmp	 $LN2@PutData
$LN3@PutData:

; 246  : 
; 247  : 	return sPos;

  001a2	8b 45 e4	 mov	 eax, DWORD PTR _sPos$[ebp]
$LN1@PutData:

; 248  : }

  001a5	5f		 pop	 edi
  001a6	5e		 pop	 esi
  001a7	83 c4 2c	 add	 esp, 44			; 0000002cH
  001aa	3b ec		 cmp	 ebp, esp
  001ac	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001b1	8b e5		 mov	 esp, ebp
  001b3	5d		 pop	 ebp
  001b4	c2 0c 00	 ret	 12			; 0000000cH
?PutData@WVSocket@@QAEHPADHJ@Z ENDP			; WVSocket::PutData
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\wvsocket.cpp
_TEXT	SEGMENT
tv173 = -48						; size = 8
tv170 = -40						; size = 8
$T1 = -29						; size = 1
_curTm$ = -28						; size = 8
_stTm$ = -20						; size = 8
_nPos$ = -12						; size = 4
_nRet$ = -8						; size = 4
_this$ = -4						; size = 4
_szBuf$ = 8						; size = 4
_nLen$ = 12						; size = 4
_ltimeOut$ = 16						; size = 4
?GetData@WVSocket@@QAEHPADHJ@Z PROC			; WVSocket::GetData
; _this$ = ecx

; 251  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	51		 push	 ecx
  00009	8d 7d d0	 lea	 edi, DWORD PTR [ebp-48]
  0000c	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00011	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00016	f3 ab		 rep stosd
  00018	59		 pop	 ecx
  00019	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	c6 45 e3 00	 mov	 BYTE PTR $T1[ebp], 0

; 252  : 	int	nRet, nPos = 0;

  00020	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _nPos$[ebp], 0

; 253  : 	time_t	stTm, curTm;
; 254  : 
; 255  : 	if (m_nSocket < 0)

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0002e	73 08		 jae	 SHORT $LN4@GetData

; 256  : 		return -1;

  00030	83 c8 ff	 or	 eax, -1
  00033	e9 29 01 00 00	 jmp	 $LN1@GetData
$LN4@GetData:

; 257  : 
; 258  : 	if (ltimeOut)

  00038	83 7d 10 00	 cmp	 DWORD PTR _ltimeOut$[ebp], 0
  0003c	74 20		 je	 SHORT $LN2@GetData

; 259  : 		stTm = curTm = time(NULL);

  0003e	6a 00		 push	 0
  00040	e8 00 00 00 00	 call	 _time
  00045	83 c4 04	 add	 esp, 4
  00048	89 45 e4	 mov	 DWORD PTR _curTm$[ebp], eax
  0004b	89 55 e8	 mov	 DWORD PTR _curTm$[ebp+4], edx
  0004e	c6 45 e3 01	 mov	 BYTE PTR $T1[ebp], 1
  00052	8b 4d e4	 mov	 ecx, DWORD PTR _curTm$[ebp]
  00055	89 4d ec	 mov	 DWORD PTR _stTm$[ebp], ecx
  00058	8b 55 e8	 mov	 edx, DWORD PTR _curTm$[ebp+4]
  0005b	89 55 f0	 mov	 DWORD PTR _stTm$[ebp+4], edx
$LN2@GetData:

; 260  : 
; 261  : 	while (1) {

  0005e	b8 01 00 00 00	 mov	 eax, 1
  00063	85 c0		 test	 eax, eax
  00065	0f 84 f3 00 00
	00		 je	 $LN3@GetData

; 262  : 		nRet = recv(m_nSocket, szBuf+nPos, nLen-nPos, NODELAY);

  0006b	8b f4		 mov	 esi, esp
  0006d	6a 00		 push	 0
  0006f	8b 4d 0c	 mov	 ecx, DWORD PTR _nLen$[ebp]
  00072	2b 4d f4	 sub	 ecx, DWORD PTR _nPos$[ebp]
  00075	51		 push	 ecx
  00076	8b 55 08	 mov	 edx, DWORD PTR _szBuf$[ebp]
  00079	03 55 f4	 add	 edx, DWORD PTR _nPos$[ebp]
  0007c	52		 push	 edx
  0007d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00080	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00083	51		 push	 ecx
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__recv@16
  0008a	3b f4		 cmp	 esi, esp
  0008c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00091	89 45 f8	 mov	 DWORD PTR _nRet$[ebp], eax

; 263  : 		if (nRet <= 0) {

  00094	83 7d f8 00	 cmp	 DWORD PTR _nRet$[ebp], 0
  00098	7f 50		 jg	 SHORT $LN6@GetData

; 264  : #ifdef WIN32
; 265  : 			if (WSAGetLastError() != WSAEWOULDBLOCK) {

  0009a	8b f4		 mov	 esi, esp
  0009c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  000a2	3b f4		 cmp	 esi, esp
  000a4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a9	3d 33 27 00 00	 cmp	 eax, 10035		; 00002733H
  000ae	74 24		 je	 SHORT $LN8@GetData

; 266  : #else
; 267  : 			if (errno != EWOULDBLOCK) {
; 268  : #endif
; 269  : 				strcpy(m_szErrMsg, "WVSocket::GetData recv Error");

  000b0	68 00 00 00 00	 push	 OFFSET $SG84729
  000b5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000b8	83 c2 38	 add	 edx, 56			; 00000038H
  000bb	52		 push	 edx
  000bc	e8 00 00 00 00	 call	 _strcpy
  000c1	83 c4 08	 add	 esp, 8

; 270  : 				onClose();

  000c4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c7	e8 00 00 00 00	 call	 ?onClose@WVSocket@@IAEXXZ ; WVSocket::onClose

; 271  : 				return -1;

  000cc	83 c8 ff	 or	 eax, -1
  000cf	e9 8d 00 00 00	 jmp	 $LN1@GetData
$LN8@GetData:

; 272  : 			}
; 273  : 			SLEEP(1);

  000d4	8b f4		 mov	 esi, esp
  000d6	68 e8 03 00 00	 push	 1000			; 000003e8H
  000db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
  000e1	3b f4		 cmp	 esi, esp
  000e3	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 274  : 		}
; 275  : 		else

  000e8	eb 09		 jmp	 SHORT $LN7@GetData
$LN6@GetData:

; 276  : 			nPos += nRet;

  000ea	8b 45 f4	 mov	 eax, DWORD PTR _nPos$[ebp]
  000ed	03 45 f8	 add	 eax, DWORD PTR _nRet$[ebp]
  000f0	89 45 f4	 mov	 DWORD PTR _nPos$[ebp], eax
$LN7@GetData:

; 277  : 		if (nPos >= nLen)

  000f3	8b 4d f4	 mov	 ecx, DWORD PTR _nPos$[ebp]
  000f6	3b 4d 0c	 cmp	 ecx, DWORD PTR _nLen$[ebp]
  000f9	7c 02		 jl	 SHORT $LN9@GetData

; 278  : 			break;

  000fb	eb 61		 jmp	 SHORT $LN3@GetData
$LN9@GetData:

; 279  : 
; 280  : 		if (ltimeOut) {

  000fd	83 7d 10 00	 cmp	 DWORD PTR _ltimeOut$[ebp], 0
  00101	74 56		 je	 SHORT $LN10@GetData

; 281  : 			curTm = time(NULL);

  00103	6a 00		 push	 0
  00105	e8 00 00 00 00	 call	 _time
  0010a	83 c4 04	 add	 esp, 4
  0010d	89 45 e4	 mov	 DWORD PTR _curTm$[ebp], eax
  00110	89 55 e8	 mov	 DWORD PTR _curTm$[ebp+4], edx

; 282  : 
; 283  : 			if (curTm - stTm > ltimeOut)

  00113	80 7d e3 00	 cmp	 BYTE PTR $T1[ebp], 0
  00117	75 0d		 jne	 SHORT $LN13@GetData
  00119	68 00 00 00 00	 push	 OFFSET $LN14@GetData
  0011e	e8 00 00 00 00	 call	 __RTC_UninitUse
  00123	83 c4 04	 add	 esp, 4
$LN13@GetData:
  00126	8b 4d e4	 mov	 ecx, DWORD PTR _curTm$[ebp]
  00129	2b 4d ec	 sub	 ecx, DWORD PTR _stTm$[ebp]
  0012c	8b 75 e8	 mov	 esi, DWORD PTR _curTm$[ebp+4]
  0012f	1b 75 f0	 sbb	 esi, DWORD PTR _stTm$[ebp+4]
  00132	8b 45 10	 mov	 eax, DWORD PTR _ltimeOut$[ebp]
  00135	99		 cdq
  00136	89 4d d8	 mov	 DWORD PTR tv170[ebp], ecx
  00139	89 75 dc	 mov	 DWORD PTR tv170[ebp+4], esi
  0013c	89 45 d0	 mov	 DWORD PTR tv173[ebp], eax
  0013f	89 55 d4	 mov	 DWORD PTR tv173[ebp+4], edx
  00142	8b 55 dc	 mov	 edx, DWORD PTR tv170[ebp+4]
  00145	3b 55 d4	 cmp	 edx, DWORD PTR tv173[ebp+4]
  00148	7c 0f		 jl	 SHORT $LN10@GetData
  0014a	7f 08		 jg	 SHORT $LN15@GetData
  0014c	8b 45 d8	 mov	 eax, DWORD PTR tv170[ebp]
  0014f	3b 45 d0	 cmp	 eax, DWORD PTR tv173[ebp]
  00152	76 05		 jbe	 SHORT $LN10@GetData
$LN15@GetData:

; 284  : 				return nPos;

  00154	8b 45 f4	 mov	 eax, DWORD PTR _nPos$[ebp]
  00157	eb 08		 jmp	 SHORT $LN1@GetData
$LN10@GetData:

; 285  : 		}
; 286  : 	}

  00159	e9 00 ff ff ff	 jmp	 $LN2@GetData
$LN3@GetData:

; 287  : 	return nPos;

  0015e	8b 45 f4	 mov	 eax, DWORD PTR _nPos$[ebp]
$LN1@GetData:

; 288  : }

  00161	5f		 pop	 edi
  00162	5e		 pop	 esi
  00163	83 c4 30	 add	 esp, 48			; 00000030H
  00166	3b ec		 cmp	 ebp, esp
  00168	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0016d	8b e5		 mov	 esp, ebp
  0016f	5d		 pop	 ebp
  00170	c2 0c 00	 ret	 12			; 0000000cH
$LN16@GetData:
$LN14@GetData:
  00173	73		 DB	 115			; 00000073H
  00174	74		 DB	 116			; 00000074H
  00175	54		 DB	 84			; 00000054H
  00176	6d		 DB	 109			; 0000006dH
  00177	00		 DB	 0
?GetData@WVSocket@@QAEHPADHJ@Z ENDP			; WVSocket::GetData
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\wvsocket.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_level$ = 8						; size = 4
_optname$ = 12						; size = 4
_optval$ = 16						; size = 4
_optlen$ = 20						; size = 4
?GetOption@WVSocket@@QAEHHHPAXPAH@Z PROC		; WVSocket::GetOption
; _this$ = ecx

; 137  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 138  : 	if (m_nSocket < 0)

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00016	73 05		 jae	 SHORT $LN2@GetOption

; 139  : 		return -1;

  00018	83 c8 ff	 or	 eax, -1
  0001b	eb 26		 jmp	 SHORT $LN1@GetOption
$LN2@GetOption:

; 140  : 
; 141  : #ifdef WIN32
; 142  : 	return getsockopt(m_nSocket, level, optname, (char*)optval, optlen);

  0001d	8b f4		 mov	 esi, esp
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _optlen$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _optval$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _optname$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _level$[ebp]
  0002e	51		 push	 ecx
  0002f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00032	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00035	50		 push	 eax
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__getsockopt@20
  0003c	3b f4		 cmp	 esi, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@GetOption:

; 143  : #elif defined(__ia64)
; 144  : 	return getsockopt(m_nSocket, level, optname, optval, (int *)optlen);
; 145  : #else
; 146  : 	return getsockopt(m_nSocket, level, optname, optval, optlen);
; 147  : #endif
; 148  : }

  00043	5e		 pop	 esi
  00044	83 c4 04	 add	 esp, 4
  00047	3b ec		 cmp	 ebp, esp
  00049	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 10 00	 ret	 16			; 00000010H
?GetOption@WVSocket@@QAEHHHPAXPAH@Z ENDP		; WVSocket::GetOption
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\wvsocket.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_level$ = 8						; size = 4
_optname$ = 12						; size = 4
_optval$ = 16						; size = 4
_optlen$ = 20						; size = 4
?SetOption@WVSocket@@QAEHHHPBXH@Z PROC			; WVSocket::SetOption
; _this$ = ecx

; 125  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 126  : 	if (m_nSocket < 0)

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00016	73 05		 jae	 SHORT $LN2@SetOption

; 127  : 		return -1;

  00018	83 c8 ff	 or	 eax, -1
  0001b	eb 26		 jmp	 SHORT $LN1@SetOption
$LN2@SetOption:

; 128  : 
; 129  : #ifdef WIN32
; 130  : 	return setsockopt(m_nSocket, level, optname, (char*)optval, optlen);

  0001d	8b f4		 mov	 esi, esp
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _optlen$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _optval$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _optname$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _level$[ebp]
  0002e	51		 push	 ecx
  0002f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00032	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00035	50		 push	 eax
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__setsockopt@20
  0003c	3b f4		 cmp	 esi, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@SetOption:

; 131  : #else
; 132  : 	return setsockopt(m_nSocket, level, optname, optval, optlen);
; 133  : #endif
; 134  : }

  00043	5e		 pop	 esi
  00044	83 c4 04	 add	 esp, 4
  00047	3b ec		 cmp	 ebp, esp
  00049	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 10 00	 ret	 16			; 00000010H
?SetOption@WVSocket@@QAEHHHPBXH@Z ENDP			; WVSocket::SetOption
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\wvsocket.cpp
_TEXT	SEGMENT
___i$1 = -304						; size = 4
_nfds$ = -300						; size = 4
_nCount$ = -296						; size = 4
_stFds$ = -288						; size = 260
_tv$ = -20						; size = 8
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?IsRecvData@WVSocket@@QAE_NXZ PROC			; WVSocket::IsRecvData
; _this$ = ecx

; 67   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 30 01 00
	00		 sub	 esp, 304		; 00000130H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	51		 push	 ecx
  0000c	8d bd d0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-304]
  00012	b9 4c 00 00 00	 mov	 ecx, 76			; 0000004cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	59		 pop	 ecx
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c5		 xor	 eax, ebp
  00026	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00029	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 68   : 	struct timeval	tv;
; 69   : 	fd_set	stFds;
; 70   : 	int	nCount;
; 71   : 	int nfds;
; 72   : 
; 73   : 	if (m_nSocket < 0)

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00033	73 07		 jae	 SHORT $LN8@IsRecvData

; 74   : 		return false;

  00035	32 c0		 xor	 al, al
  00037	e9 17 01 00 00	 jmp	 $LN1@IsRecvData
$LN8@IsRecvData:

; 75   : 
; 76   : 	tv.tv_sec	= 0;

  0003c	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _tv$[ebp], 0

; 77   : 	tv.tv_usec	= 10000;

  00043	c7 45 f0 10 27
	00 00		 mov	 DWORD PTR _tv$[ebp+4], 10000 ; 00002710H

; 78   : 
; 79   : 	FD_ZERO(&stFds);

  0004a	c7 85 e0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _stFds$[ebp], 0
$LN4@IsRecvData:

; 80   : 
; 81   : 	FD_SET(m_nSocket, &stFds);

  00054	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR ___i$1[ebp], 0
  0005e	eb 0f		 jmp	 SHORT $LN7@IsRecvData
$LN5@IsRecvData:
  00060	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR ___i$1[ebp]
  00066	83 c1 01	 add	 ecx, 1
  00069	89 8d d0 fe ff
	ff		 mov	 DWORD PTR ___i$1[ebp], ecx
$LN7@IsRecvData:
  0006f	8b 95 d0 fe ff
	ff		 mov	 edx, DWORD PTR ___i$1[ebp]
  00075	3b 95 e0 fe ff
	ff		 cmp	 edx, DWORD PTR _stFds$[ebp]
  0007b	73 19		 jae	 SHORT $LN6@IsRecvData
  0007d	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR ___i$1[ebp]
  00083	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	8b 94 85 e4 fe
	ff ff		 mov	 edx, DWORD PTR _stFds$[ebp+eax*4+4]
  0008d	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00090	75 02		 jne	 SHORT $LN9@IsRecvData
  00092	eb 02		 jmp	 SHORT $LN6@IsRecvData
$LN9@IsRecvData:
  00094	eb ca		 jmp	 SHORT $LN5@IsRecvData
$LN6@IsRecvData:
  00096	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR ___i$1[ebp]
  0009c	3b 85 e0 fe ff
	ff		 cmp	 eax, DWORD PTR _stFds$[ebp]
  000a2	75 2b		 jne	 SHORT $LN2@IsRecvData
  000a4	83 bd e0 fe ff
	ff 40		 cmp	 DWORD PTR _stFds$[ebp], 64 ; 00000040H
  000ab	73 22		 jae	 SHORT $LN2@IsRecvData
  000ad	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR ___i$1[ebp]
  000b3	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000b6	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000b9	89 84 8d e4 fe
	ff ff		 mov	 DWORD PTR _stFds$[ebp+ecx*4+4], eax
  000c0	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _stFds$[ebp]
  000c6	83 c1 01	 add	 ecx, 1
  000c9	89 8d e0 fe ff
	ff		 mov	 DWORD PTR _stFds$[ebp], ecx
$LN2@IsRecvData:
  000cf	33 d2		 xor	 edx, edx
  000d1	75 81		 jne	 SHORT $LN4@IsRecvData

; 82   : 	nfds = (int)m_nSocket;

  000d3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000d6	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d9	89 8d d4 fe ff
	ff		 mov	 DWORD PTR _nfds$[ebp], ecx

; 83   : 	nCount =  select (nfds + 1, &stFds, NULL, NULL, &tv);

  000df	8b f4		 mov	 esi, esp
  000e1	8d 55 ec	 lea	 edx, DWORD PTR _tv$[ebp]
  000e4	52		 push	 edx
  000e5	6a 00		 push	 0
  000e7	6a 00		 push	 0
  000e9	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _stFds$[ebp]
  000ef	50		 push	 eax
  000f0	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _nfds$[ebp]
  000f6	83 c1 01	 add	 ecx, 1
  000f9	51		 push	 ecx
  000fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__select@20
  00100	3b f4		 cmp	 esi, esp
  00102	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00107	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _nCount$[ebp], eax

; 84   : 	if (nCount  == -1) {

  0010d	83 bd d8 fe ff
	ff ff		 cmp	 DWORD PTR _nCount$[ebp], -1
  00114	75 20		 jne	 SHORT $LN12@IsRecvData

; 85   : 		strcpy(m_szErrMsg, "Socket select error");

  00116	68 00 00 00 00	 push	 OFFSET $SG84629
  0011b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0011e	83 c2 38	 add	 edx, 56			; 00000038H
  00121	52		 push	 edx
  00122	e8 00 00 00 00	 call	 _strcpy
  00127	83 c4 08	 add	 esp, 8

; 86   : 		onClose();

  0012a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0012d	e8 00 00 00 00	 call	 ?onClose@WVSocket@@IAEXXZ ; WVSocket::onClose

; 87   : 		return false;

  00132	32 c0		 xor	 al, al
  00134	eb 1d		 jmp	 SHORT $LN1@IsRecvData
$LN12@IsRecvData:

; 88   : 	}
; 89   : 
; 90   : 	if (FD_ISSET(m_nSocket, &stFds))

  00136	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _stFds$[ebp]
  0013c	50		 push	 eax
  0013d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00140	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00143	52		 push	 edx
  00144	e8 00 00 00 00	 call	 ___WSAFDIsSet@8
  00149	85 c0		 test	 eax, eax
  0014b	74 04		 je	 SHORT $LN13@IsRecvData

; 91   : 		return true;

  0014d	b0 01		 mov	 al, 1
  0014f	eb 02		 jmp	 SHORT $LN1@IsRecvData
$LN13@IsRecvData:

; 92   : 
; 93   : 	return false;

  00151	32 c0		 xor	 al, al
$LN1@IsRecvData:

; 94   : }

  00153	52		 push	 edx
  00154	8b cd		 mov	 ecx, ebp
  00156	50		 push	 eax
  00157	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN18@IsRecvData
  0015d	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00162	58		 pop	 eax
  00163	5a		 pop	 edx
  00164	5f		 pop	 edi
  00165	5e		 pop	 esi
  00166	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00169	33 cd		 xor	 ecx, ebp
  0016b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00170	81 c4 30 01 00
	00		 add	 esp, 304		; 00000130H
  00176	3b ec		 cmp	 ebp, esp
  00178	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0017d	8b e5		 mov	 esp, ebp
  0017f	5d		 pop	 ebp
  00180	c3		 ret	 0
  00181	0f 1f 00	 npad	 3
$LN18@IsRecvData:
  00184	02 00 00 00	 DD	 2
  00188	00 00 00 00	 DD	 $LN17@IsRecvData
$LN17@IsRecvData:
  0018c	ec ff ff ff	 DD	 -20			; ffffffecH
  00190	08 00 00 00	 DD	 8
  00194	00 00 00 00	 DD	 $LN15@IsRecvData
  00198	e0 fe ff ff	 DD	 -288			; fffffee0H
  0019c	04 01 00 00	 DD	 260			; 00000104H
  001a0	00 00 00 00	 DD	 $LN16@IsRecvData
$LN16@IsRecvData:
  001a4	73		 DB	 115			; 00000073H
  001a5	74		 DB	 116			; 00000074H
  001a6	46		 DB	 70			; 00000046H
  001a7	64		 DB	 100			; 00000064H
  001a8	73		 DB	 115			; 00000073H
  001a9	00		 DB	 0
$LN15@IsRecvData:
  001aa	74		 DB	 116			; 00000074H
  001ab	76		 DB	 118			; 00000076H
  001ac	00		 DB	 0
?IsRecvData@WVSocket@@QAE_NXZ ENDP			; WVSocket::IsRecvData
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\wvsocket.cpp
_TEXT	SEGMENT
$T2 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1WVSocket@@QAE@XZ PROC				; WVSocket::~WVSocket
; _this$ = ecx

; 54   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1WVSocket@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  0001b	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	50		 push	 eax
  0002a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00033	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 55   : 	if (m_nSocket > 0) 

  00036	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00039	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0003d	76 08		 jbe	 SHORT $LN2@WVSocket

; 56   : 		onClose();

  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?onClose@WVSocket@@IAEXXZ ; WVSocket::onClose
$LN2@WVSocket:

; 57   : 
; 58   : 	if (m_szRecvData)

  00047	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  0004e	74 15		 je	 SHORT $LN3@WVSocket

; 59   : 		delete [] m_szRecvData;	//20100127

  00050	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00053	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00056	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
  00059	8b 4d ec	 mov	 ecx, DWORD PTR $T2[ebp]
  0005c	51		 push	 ecx
  0005d	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00062	83 c4 04	 add	 esp, 4
$LN3@WVSocket:

; 60   : 
; 61   : 	m_nRecvBLen = m_nRecvDLen = 0;

  00065	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00068	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], 0
  0006f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00072	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 62   : 
; 63   : }

  00079	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00083	59		 pop	 ecx
  00084	83 c4 14	 add	 esp, 20			; 00000014H
  00087	3b ec		 cmp	 ebp, esp
  00089	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
__ehhandler$??1WVSocket@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1WVSocket@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1WVSocket@@QAE@XZ ENDP				; WVSocket::~WVSocket
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\wvsocket.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_szIP$ = 8						; size = 4
_nPort$ = 12						; size = 4
??0WVSocket@@QAE@PBDH@Z PROC				; WVSocket::WVSocket
; _this$ = ecx

; 38   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 39   : 	m_bConnected = false;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	c6 00 00	 mov	 BYTE PTR [eax], 0

; 40   : 	m_nSocket = -1;

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	c7 41 04 ff ff
	ff ff		 mov	 DWORD PTR [ecx+4], -1

; 41   : 	m_szRecvData = NULL;

  0001e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00021	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 42   : 	m_nRecvDLen = 0;

  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 43   : 	m_nRecvBLen = 0;

  00032	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 44   : 
; 45   : 
; 46   : 	memset(m_szIP, 0, sizeof(m_szIP));

  0003c	6a 1e		 push	 30			; 0000001eH
  0003e	6a 00		 push	 0
  00040	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00043	83 c2 14	 add	 edx, 20			; 00000014H
  00046	52		 push	 edx
  00047	e8 00 00 00 00	 call	 _memset
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 47   : 	m_nPort = -1;

  0004f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00052	c7 40 34 ff ff
	ff ff		 mov	 DWORD PTR [eax+52], -1

; 48   : 
; 49   : 
; 50   : 	ConnectTo(szIP, nPort);

  00059	8b 4d 0c	 mov	 ecx, DWORD PTR _nPort$[ebp]
  0005c	51		 push	 ecx
  0005d	8b 55 08	 mov	 edx, DWORD PTR _szIP$[ebp]
  00060	52		 push	 edx
  00061	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	e8 00 00 00 00	 call	 ?ConnectTo@WVSocket@@QAEHPBDH@Z ; WVSocket::ConnectTo

; 51   : }

  00069	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	83 c4 04	 add	 esp, 4
  0006f	3b ec		 cmp	 ebp, esp
  00071	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c2 08 00	 ret	 8
??0WVSocket@@QAE@PBDH@Z ENDP				; WVSocket::WVSocket
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\src\wvsocket.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0WVSocket@@QAE@XZ PROC				; WVSocket::WVSocket
; _this$ = ecx

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 25   : 	m_bConnected = false;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c6 00 00	 mov	 BYTE PTR [eax], 0

; 26   : 	m_nSocket = -1;

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	c7 41 04 ff ff
	ff ff		 mov	 DWORD PTR [ecx+4], -1

; 27   : 	m_szRecvData = NULL;

  0001f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00022	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 28   : 	m_nRecvDLen = 0;

  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 29   : 	m_nRecvBLen = 0;

  00033	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 30   : 	memset(m_szIP, 0, sizeof(m_szIP));

  0003d	6a 1e		 push	 30			; 0000001eH
  0003f	6a 00		 push	 0
  00041	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00044	83 c2 14	 add	 edx, 20			; 00000014H
  00047	52		 push	 edx
  00048	e8 00 00 00 00	 call	 _memset
  0004d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 31   : 	m_nPort = -1;

  00050	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00053	c7 40 34 ff ff
	ff ff		 mov	 DWORD PTR [eax+52], -1

; 32   : 
; 33   : 	m_nSocket = ::socket(SOCK_FLAG, SOCK_STREAM, 0);

  0005a	8b f4		 mov	 esi, esp
  0005c	6a 00		 push	 0
  0005e	6a 01		 push	 1
  00060	6a 02		 push	 2
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__socket@12
  00068	3b f4		 cmp	 esi, esp
  0006a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 34   : 
; 35   : }

  00075	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00078	5e		 pop	 esi
  00079	83 c4 04	 add	 esp, 4
  0007c	3b ec		 cmp	 ebp, esp
  0007e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c3		 ret	 0
??0WVSocket@@QAE@XZ ENDP				; WVSocket::WVSocket
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\infinia-library-3.0\com\include\comtypes.h
;	COMDAT ?c_memcpy@@YAPAXPAXPBXH@Z
_TEXT	SEGMENT
tv65 = -12						; size = 4
_s$ = -8						; size = 4
_d$ = -4						; size = 4
_de$ = 8						; size = 4
_so$ = 12						; size = 4
_l$ = 16						; size = 4
?c_memcpy@@YAPAXPAXPBXH@Z PROC				; c_memcpy, COMDAT

; 309  : inline void *c_memcpy(void *de, const void *so, int l) { char *d = (char*)de; const char *s = (char*)so; while (l--) *d++ = *s++; return de;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	8b 45 08	 mov	 eax, DWORD PTR _de$[ebp]
  0001e	89 45 fc	 mov	 DWORD PTR _d$[ebp], eax
  00021	8b 4d 0c	 mov	 ecx, DWORD PTR _so$[ebp]
  00024	89 4d f8	 mov	 DWORD PTR _s$[ebp], ecx
$LN2@c_memcpy:
  00027	8b 55 10	 mov	 edx, DWORD PTR _l$[ebp]
  0002a	89 55 f4	 mov	 DWORD PTR tv65[ebp], edx
  0002d	8b 45 10	 mov	 eax, DWORD PTR _l$[ebp]
  00030	83 e8 01	 sub	 eax, 1
  00033	89 45 10	 mov	 DWORD PTR _l$[ebp], eax
  00036	83 7d f4 00	 cmp	 DWORD PTR tv65[ebp], 0
  0003a	74 1e		 je	 SHORT $LN3@c_memcpy
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _d$[ebp]
  0003f	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  00042	8a 02		 mov	 al, BYTE PTR [edx]
  00044	88 01		 mov	 BYTE PTR [ecx], al
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _d$[ebp]
  00049	83 c1 01	 add	 ecx, 1
  0004c	89 4d fc	 mov	 DWORD PTR _d$[ebp], ecx
  0004f	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  00052	83 c2 01	 add	 edx, 1
  00055	89 55 f8	 mov	 DWORD PTR _s$[ebp], edx
  00058	eb cd		 jmp	 SHORT $LN2@c_memcpy
$LN3@c_memcpy:
  0005a	8b 45 08	 mov	 eax, DWORD PTR _de$[ebp]
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
?c_memcpy@@YAPAXPAXPBXH@Z ENDP				; c_memcpy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

  00014	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
  00019	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0001c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __ArgList$[ebp]
  00022	51		 push	 ecx
  00023	6a 00		 push	 0
  00025	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00028	52		 push	 edx
  00029	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 __vsprintf_l
  00032	83 c4 10	 add	 esp, 16			; 00000010H
  00035	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

  00038	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1787 :     return _Result;

  0003f	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 1788 : }

  00042	83 c4 08	 add	 esp, 8
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00003	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  0000e	52		 push	 edx
  0000f	6a ff		 push	 -1
  00011	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 __vsnprintf_l
  0001a	83 c4 14	 add	 esp, 20			; 00000014H

; 1459 :     #pragma warning(pop)
; 1460 : }

  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00015	8b f4		 mov	 esi, esp
  00017	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00022	52		 push	 edx
  00023	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00030	8b 10		 mov	 edx, DWORD PTR [eax]
  00032	83 ca 01	 or	 edx, 1
  00035	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00038	50		 push	 eax
  00039	52		 push	 edx
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf
  00040	83 c4 1c	 add	 esp, 28			; 0000001cH
  00043	3b f4		 cmp	 esi, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  0004d	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  00051	7d 09		 jge	 SHORT $LN3@vsnprintf_
  00053	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  0005a	eb 06		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0005c	8b 4d fc	 mov	 ecx, DWORD PTR __Result$[ebp]
  0005f	89 4d f8	 mov	 DWORD PTR tv74[ebp], ecx
$LN4@vsnprintf_:
  00062	8b 45 f8	 mov	 eax, DWORD PTR tv74[ebp]

; 1391 : }

  00065	5e		 pop	 esi
  00066	83 c4 08	 add	 esp, 8
  00069	3b ec		 cmp	 ebp, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 144  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_time	PROC

; 534  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 535  :             return _time64(_Time);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 08	 mov	 eax, DWORD PTR __Time$[ebp]
  00009	50		 push	 eax
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___time64
  00010	83 c4 04	 add	 esp, 4
  00013	3b f4		 cmp	 esi, esp
  00015	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 536  :         }

  0001a	5e		 pop	 esi
  0001b	3b ec		 cmp	 ebp, esp
  0001d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
_time	ENDP
_TEXT	ENDS
END
